"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/onnxruntime-web";
exports.ids = ["vendor-chunks/onnxruntime-web"];
exports.modules = {

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort-web.node.js":
/*!***********************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-web.node.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var console = __webpack_require__(/*! ./node_modules/console-browserify/index.js */ \"(ssr)/./node_modules/console-browserify/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! ./node_modules/process/browser.js */ \"(ssr)/./node_modules/process/browser.js\");\n\n/*!\n* ONNX Runtime Web v1.16.3\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/ (()=>{\n    var __webpack_modules__ = {\n        5716: (e1, t1, n1)=>{\n            \"use strict\";\n            t1.R = void 0;\n            const r1 = n1(6027), o1 = n1(1723);\n            t1.R = new class {\n                async init() {}\n                async createSessionHandler(e1, t1) {\n                    const n1 = new r1.Session(t1);\n                    return await n1.loadModel(e1), new o1.OnnxjsSessionHandler(n1);\n                }\n            };\n        },\n        2818: (e1, t1, n1)=>{\n            \"use strict\";\n            t1.c8 = t1.rX = void 0;\n            const r1 = n1(6207), o1 = n1(9719), i1 = n1(9544), s1 = n1(6640);\n            t1.rX = ()=>{\n                if ((\"number\" != typeof r1.env.wasm.initTimeout || r1.env.wasm.initTimeout < 0) && (r1.env.wasm.initTimeout = 0), \"boolean\" != typeof r1.env.wasm.simd && (r1.env.wasm.simd = !0), \"boolean\" != typeof r1.env.wasm.proxy && (r1.env.wasm.proxy = !1), \"number\" != typeof r1.env.wasm.numThreads || !Number.isInteger(r1.env.wasm.numThreads) || r1.env.wasm.numThreads <= 0) {\n                    const e1 = \"undefined\" == typeof navigator ? (0, o1.cpus)().length : navigator.hardwareConcurrency;\n                    r1.env.wasm.numThreads = Math.min(4, Math.ceil((e1 || 1) / 2));\n                }\n            }, t1.c8 = new class {\n                async init() {\n                    (0, t1.rX)(), await (0, i1.initializeWebAssemblyInstance)();\n                }\n                async createSessionHandler(e1, t1) {\n                    const n1 = new s1.OnnxruntimeWebAssemblySessionHandler;\n                    return await n1.loadModel(e1, t1), Promise.resolve(n1);\n                }\n            };\n        },\n        1057: function(e1, t1, n1) {\n            \"use strict\";\n            var r1 = this && this.__createBinding || (Object.create ? function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1);\n                var o1 = Object.getOwnPropertyDescriptor(t1, n1);\n                o1 && !(\"get\" in o1 ? !t1.__esModule : o1.writable || o1.configurable) || (o1 = {\n                    enumerable: !0,\n                    get: function() {\n                        return t1[n1];\n                    }\n                }), Object.defineProperty(e1, r1, o1);\n            } : function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1), e1[r1] = t1[n1];\n            }), o1 = this && this.__exportStar || function(e1, t1) {\n                for(var n1 in e1)\"default\" === n1 || Object.prototype.hasOwnProperty.call(t1, n1) || r1(t1, e1, n1);\n            };\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), o1(n1(6207), t1);\n            const i1 = n1(6207), s1 = n1(8408);\n            {\n                const e1 = n1(5716).R;\n                (0, i1.registerBackend)(\"webgl\", e1, -10);\n            }\n            {\n                const e1 = n1(2818).c8;\n                (0, i1.registerBackend)(\"cpu\", e1, 10), (0, i1.registerBackend)(\"wasm\", e1, 10), (0, i1.registerBackend)(\"xnnpack\", e1, 9), (0, i1.registerBackend)(\"webnn\", e1, 9);\n            }\n            i1.env.versions.web = s1.version;\n        },\n        4910: (e1, t1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createAttributeWithCacheKey = void 0;\n            class n1 {\n                constructor(e1){\n                    Object.assign(this, e1);\n                }\n                get cacheKey() {\n                    return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((e1)=>`${this[e1]}`).join(\";\")), this._cacheKey;\n                }\n            }\n            t1.createAttributeWithCacheKey = (e1)=>new n1(e1);\n        },\n        6874: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.Attribute = void 0;\n            const r1 = n1(5127), o1 = n1(2446), i1 = n1(9240), s1 = n1(7273);\n            var a1 = r1.onnxruntime.experimental.fbs;\n            class u1 {\n                constructor(e1){\n                    if (this._attributes = new Map, null != e1) {\n                        for (const t1 of e1)t1 instanceof o1.onnx.AttributeProto ? this._attributes.set(t1.name, [\n                            u1.getValue(t1),\n                            u1.getType(t1)\n                        ]) : t1 instanceof a1.Attribute && this._attributes.set(t1.name(), [\n                            u1.getValue(t1),\n                            u1.getType(t1)\n                        ]);\n                        if (this._attributes.size < e1.length) throw new Error(\"duplicated attribute names\");\n                    }\n                }\n                set(e1, t1, n1) {\n                    this._attributes.set(e1, [\n                        n1,\n                        t1\n                    ]);\n                }\n                delete(e1) {\n                    this._attributes.delete(e1);\n                }\n                getFloat(e1, t1) {\n                    return this.get(e1, \"float\", t1);\n                }\n                getInt(e1, t1) {\n                    return this.get(e1, \"int\", t1);\n                }\n                getString(e1, t1) {\n                    return this.get(e1, \"string\", t1);\n                }\n                getTensor(e1, t1) {\n                    return this.get(e1, \"tensor\", t1);\n                }\n                getFloats(e1, t1) {\n                    return this.get(e1, \"floats\", t1);\n                }\n                getInts(e1, t1) {\n                    return this.get(e1, \"ints\", t1);\n                }\n                getStrings(e1, t1) {\n                    return this.get(e1, \"strings\", t1);\n                }\n                getTensors(e1, t1) {\n                    return this.get(e1, \"tensors\", t1);\n                }\n                get(e1, t1, n1) {\n                    const r1 = this._attributes.get(e1);\n                    if (void 0 === r1) {\n                        if (void 0 !== n1) return n1;\n                        throw new Error(`required attribute not found: ${e1}`);\n                    }\n                    if (r1[1] !== t1) throw new Error(`type mismatch: expected ${t1} but got ${r1[1]}`);\n                    return r1[0];\n                }\n                static getType(e1) {\n                    const t1 = e1 instanceof o1.onnx.AttributeProto ? e1.type : e1.type();\n                    switch(t1){\n                        case o1.onnx.AttributeProto.AttributeType.FLOAT:\n                            return \"float\";\n                        case o1.onnx.AttributeProto.AttributeType.INT:\n                            return \"int\";\n                        case o1.onnx.AttributeProto.AttributeType.STRING:\n                            return \"string\";\n                        case o1.onnx.AttributeProto.AttributeType.TENSOR:\n                            return \"tensor\";\n                        case o1.onnx.AttributeProto.AttributeType.FLOATS:\n                            return \"floats\";\n                        case o1.onnx.AttributeProto.AttributeType.INTS:\n                            return \"ints\";\n                        case o1.onnx.AttributeProto.AttributeType.STRINGS:\n                            return \"strings\";\n                        case o1.onnx.AttributeProto.AttributeType.TENSORS:\n                            return \"tensors\";\n                        default:\n                            throw new Error(`attribute type is not supported yet: ${o1.onnx.AttributeProto.AttributeType[t1]}`);\n                    }\n                }\n                static getValue(e1) {\n                    const t1 = e1 instanceof o1.onnx.AttributeProto ? e1.type : e1.type();\n                    if (t1 === o1.onnx.AttributeProto.AttributeType.GRAPH || t1 === o1.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error(\"graph attribute is not supported yet\");\n                    const n1 = this.getValueNoCheck(e1);\n                    if (t1 === o1.onnx.AttributeProto.AttributeType.INT && s1.LongUtil.isLong(n1)) return s1.LongUtil.longToNumber(n1);\n                    if (t1 === o1.onnx.AttributeProto.AttributeType.INTS) {\n                        const e1 = n1, t1 = new Array(e1.length);\n                        for(let n1 = 0; n1 < e1.length; n1++){\n                            const r1 = e1[n1];\n                            t1[n1] = s1.LongUtil.longToNumber(r1);\n                        }\n                        return t1;\n                    }\n                    if (t1 === o1.onnx.AttributeProto.AttributeType.TENSOR) return e1 instanceof o1.onnx.AttributeProto ? i1.Tensor.fromProto(n1) : i1.Tensor.fromOrtTensor(n1);\n                    if (t1 === o1.onnx.AttributeProto.AttributeType.TENSORS) {\n                        if (e1 instanceof o1.onnx.AttributeProto) return n1.map((e1)=>i1.Tensor.fromProto(e1));\n                        if (e1 instanceof a1.Attribute) return n1.map((e1)=>i1.Tensor.fromOrtTensor(e1));\n                    }\n                    if (t1 === o1.onnx.AttributeProto.AttributeType.STRING && e1 instanceof o1.onnx.AttributeProto) {\n                        const e1 = n1;\n                        return (0, s1.decodeUtf8String)(e1);\n                    }\n                    return t1 === o1.onnx.AttributeProto.AttributeType.STRINGS && e1 instanceof o1.onnx.AttributeProto ? n1.map(s1.decodeUtf8String) : n1;\n                }\n                static getValueNoCheck(e1) {\n                    return e1 instanceof o1.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(e1) : this.getValueNoCheckFromOrtFormat(e1);\n                }\n                static getValueNoCheckFromOnnxFormat(e1) {\n                    switch(e1.type){\n                        case o1.onnx.AttributeProto.AttributeType.FLOAT:\n                            return e1.f;\n                        case o1.onnx.AttributeProto.AttributeType.INT:\n                            return e1.i;\n                        case o1.onnx.AttributeProto.AttributeType.STRING:\n                            return e1.s;\n                        case o1.onnx.AttributeProto.AttributeType.TENSOR:\n                            return e1.t;\n                        case o1.onnx.AttributeProto.AttributeType.GRAPH:\n                            return e1.g;\n                        case o1.onnx.AttributeProto.AttributeType.FLOATS:\n                            return e1.floats;\n                        case o1.onnx.AttributeProto.AttributeType.INTS:\n                            return e1.ints;\n                        case o1.onnx.AttributeProto.AttributeType.STRINGS:\n                            return e1.strings;\n                        case o1.onnx.AttributeProto.AttributeType.TENSORS:\n                            return e1.tensors;\n                        case o1.onnx.AttributeProto.AttributeType.GRAPHS:\n                            return e1.graphs;\n                        default:\n                            throw new Error(`unsupported attribute type: ${o1.onnx.AttributeProto.AttributeType[e1.type]}`);\n                    }\n                }\n                static getValueNoCheckFromOrtFormat(e1) {\n                    switch(e1.type()){\n                        case a1.AttributeType.FLOAT:\n                            return e1.f();\n                        case a1.AttributeType.INT:\n                            return e1.i();\n                        case a1.AttributeType.STRING:\n                            return e1.s();\n                        case a1.AttributeType.TENSOR:\n                            return e1.t();\n                        case a1.AttributeType.GRAPH:\n                            return e1.g();\n                        case a1.AttributeType.FLOATS:\n                            return e1.floatsArray();\n                        case a1.AttributeType.INTS:\n                            {\n                                const t1 = [];\n                                for(let n1 = 0; n1 < e1.intsLength(); n1++)t1.push(e1.ints(n1));\n                                return t1;\n                            }\n                        case a1.AttributeType.STRINGS:\n                            {\n                                const t1 = [];\n                                for(let n1 = 0; n1 < e1.stringsLength(); n1++)t1.push(e1.strings(n1));\n                                return t1;\n                            }\n                        case a1.AttributeType.TENSORS:\n                            {\n                                const t1 = [];\n                                for(let n1 = 0; n1 < e1.tensorsLength(); n1++)t1.push(e1.tensors(n1));\n                                return t1;\n                            }\n                        default:\n                            throw new Error(`unsupported attribute type: ${a1.AttributeType[e1.type()]}`);\n                    }\n                }\n            }\n            t1.Attribute = u1;\n        },\n        1975: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.resolveBackend = t1.backend = void 0;\n            const r1 = n1(4418), o1 = new Map;\n            async function i1(e1) {\n                const n1 = t1.backend;\n                if (void 0 !== n1[e1] && function(e1) {\n                    const t1 = e1;\n                    return \"initialize\" in t1 && \"function\" == typeof t1.initialize && \"createSessionHandler\" in t1 && \"function\" == typeof t1.createSessionHandler && \"dispose\" in t1 && \"function\" == typeof t1.dispose;\n                }(n1[e1])) {\n                    const t1 = n1[e1];\n                    let r1 = t1.initialize();\n                    if (\"object\" == typeof r1 && \"then\" in r1 && (r1 = await r1), r1) return o1.set(e1, t1), t1;\n                }\n            }\n            t1.backend = {\n                webgl: new r1.WebGLBackend\n            }, t1.resolveBackend = async function e1(t1) {\n                if (!t1) return e1([\n                    \"webgl\"\n                ]);\n                {\n                    const e1 = \"string\" == typeof t1 ? [\n                        t1\n                    ] : t1;\n                    for (const t1 of e1){\n                        const e1 = o1.get(t1);\n                        if (e1) return e1;\n                        const n1 = await i1(t1);\n                        if (n1) return n1;\n                    }\n                }\n                throw new Error(\"no available backend to use\");\n            };\n        },\n        4418: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.WebGLBackend = void 0;\n            const r1 = n1(6207), o1 = n1(1315), i1 = n1(2171), s1 = n1(3389);\n            t1.WebGLBackend = class {\n                get contextId() {\n                    return r1.env.webgl.contextId;\n                }\n                set contextId(e1) {\n                    r1.env.webgl.contextId = e1;\n                }\n                get matmulMaxBatchSize() {\n                    return r1.env.webgl.matmulMaxBatchSize;\n                }\n                set matmulMaxBatchSize(e1) {\n                    r1.env.webgl.matmulMaxBatchSize = e1;\n                }\n                get textureCacheMode() {\n                    return r1.env.webgl.textureCacheMode;\n                }\n                set textureCacheMode(e1) {\n                    r1.env.webgl.textureCacheMode = e1;\n                }\n                get pack() {\n                    return r1.env.webgl.pack;\n                }\n                set pack(e1) {\n                    r1.env.webgl.pack = e1;\n                }\n                get async() {\n                    return r1.env.webgl.async;\n                }\n                set async(e1) {\n                    r1.env.webgl.async = e1;\n                }\n                initialize() {\n                    try {\n                        return this.glContext = (0, s1.createWebGLContext)(this.contextId), \"number\" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), \"string\" != typeof this.textureCacheMode && (this.textureCacheMode = \"full\"), \"boolean\" != typeof this.pack && (this.pack = !1), \"boolean\" != typeof this.async && (this.async = !1), o1.Logger.setWithEnv(r1.env), o1.Logger.verbose(\"WebGLBackend\", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), !0;\n                    } catch (e1) {\n                        return o1.Logger.warning(\"WebGLBackend\", `Unable to initialize WebGLBackend. ${e1}`), !1;\n                    }\n                }\n                createSessionHandler(e1) {\n                    return new i1.WebGLSessionHandler(this, e1);\n                }\n                dispose() {\n                    this.glContext.dispose();\n                }\n            };\n        },\n        6859: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.CoordsGlslLib = void 0;\n            const r1 = n1(7273), o1 = n1(1997), i1 = n1(6757), s1 = n1(7618), a1 = n1(432);\n            class u1 extends o1.GlslLib {\n                constructor(e1){\n                    super(e1);\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                offsetToCoords() {\n                    return {\n                        offsetToCoords: new o1.GlslLibRoutine(\"\\n      vec2 offsetToCoords(int offset, int width, int height) {\\n        int t = offset / width;\\n        int s = offset - t*width;\\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\\n        return coords;\\n      }\\n      \")\n                    };\n                }\n                coordsToOffset() {\n                    return {\n                        coordsToOffset: new o1.GlslLibRoutine(\"\\n      int coordsToOffset(vec2 coords, int width, int height) {\\n        float s = coords.s * float(width);\\n        float t = coords.t * float(height);\\n        int offset = int(t) * width + int(s);\\n        return offset;\\n      }\\n      \")\n                    };\n                }\n                getOutputSamplingSnippet() {\n                    const e1 = this.context.outputTextureLayout;\n                    return e1.isPacked ? this.getPackedOutputSamplingSnippet(e1) : this.getUnpackedOutputSamplingSnippet(e1);\n                }\n                getPackedOutputSamplingSnippet(e1) {\n                    const t1 = e1.unpackedShape, n1 = [\n                        e1.width,\n                        e1.height\n                    ], r1 = {}, s1 = \"getOutputCoords\";\n                    switch(t1.length){\n                        case 0:\n                            r1[s1] = this.getOutputScalarCoords();\n                            break;\n                        case 1:\n                            r1[s1] = this.getOutputPacked1DCoords(t1, n1);\n                            break;\n                        case 2:\n                            r1[s1] = this.getOutputPacked2DCoords(t1, n1);\n                            break;\n                        case 3:\n                            r1[s1] = this.getOutputPacked3DCoords(t1, n1);\n                            break;\n                        default:\n                            r1[s1] = this.getOutputPackedNDCoords(t1, n1);\n                    }\n                    const a1 = `\\n      void setOutput(vec4 val) {\\n        ${(0, i1.getGlsl)(this.context.glContext.version).output} = val;\\n      }\\n    `;\n                    return r1.floatTextureSetRGBA = new o1.GlslLibRoutine(a1), r1;\n                }\n                getUnpackedOutputSamplingSnippet(e1) {\n                    const t1 = e1.unpackedShape, n1 = [\n                        e1.width,\n                        e1.height\n                    ], r1 = {}, s1 = \"getOutputCoords\";\n                    switch(t1.length){\n                        case 0:\n                            r1[s1] = this.getOutputScalarCoords();\n                            break;\n                        case 1:\n                            r1[s1] = this.getOutputUnpacked1DCoords(t1, n1);\n                            break;\n                        case 2:\n                            r1[s1] = this.getOutputUnpacked2DCoords(t1, n1);\n                            break;\n                        case 3:\n                            r1[s1] = this.getOutputUnpacked3DCoords(t1, n1);\n                            break;\n                        case 4:\n                            r1[s1] = this.getOutputUnpacked4DCoords(t1, n1);\n                            break;\n                        case 5:\n                            r1[s1] = this.getOutputUnpacked5DCoords(t1, n1);\n                            break;\n                        case 6:\n                            r1[s1] = this.getOutputUnpacked6DCoords(t1, n1);\n                            break;\n                        default:\n                            throw new Error(`Unsupported output dimensionality: ${t1.length}`);\n                    }\n                    const a1 = `\\n        void setOutput(float val) {\\n          ${(0, i1.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\\n        }\\n    `;\n                    return r1.floatTextureSetR = new o1.GlslLibRoutine(a1), r1;\n                }\n                getOutputScalarCoords() {\n                    return new o1.GlslLibRoutine(\"\\n      int getOutputCoords() {\\n        return 0;\\n      }\\n    \");\n                }\n                getOutputPacked1DCoords(e1, t1) {\n                    const n1 = t1;\n                    let r1 = \"\";\n                    return 1 === n1[0] ? (r1 = `\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.y * ${n1[1]}.0);\\n          }\\n        `, new o1.GlslLibRoutine(r1)) : 1 === n1[1] ? (r1 = `\\n          int getOutputCoords() {\\n            return 2 * int(TexCoords.x * ${n1[0]}.0);\\n          }\\n        `, new o1.GlslLibRoutine(r1)) : (r1 = `\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                 vec2(${n1[0]}, ${n1[1]}));\\n          return 2 * (resTexRC.y * ${n1[0]} + resTexRC.x);\\n        }\\n      `, new o1.GlslLibRoutine(r1));\n                }\n                getOutputPacked2DCoords(e1, t1) {\n                    let n1 = \"\";\n                    if (r1.ArrayUtil.arraysEqual(e1, t1)) return n1 = `\\n        ivec2 getOutputCoords() {\\n          return 2 * ivec2(TexCoords.xy * vec2(${t1[0]}, ${t1[1]}));\\n        }\\n      `, new o1.GlslLibRoutine(n1);\n                    const i1 = t1, s1 = Math.ceil(e1[1] / 2);\n                    return n1 = `\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${i1[0]}, ${i1[1]}));\\n\\n          int index = resTexRC.y * ${i1[0]} + resTexRC.x;\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${s1}) * 2;\\n          int c = 2 * (index / ${s1});\\n\\n          return ivec2(r, c);\\n        }\\n      `, new o1.GlslLibRoutine(n1);\n                }\n                getOutputPacked3DCoords(e1, t1) {\n                    const n1 = [\n                        t1[0],\n                        t1[1]\n                    ], r1 = Math.ceil(e1[2] / 2), i1 = r1 * Math.ceil(e1[1] / 2), s1 = `\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${n1[0]}, ${n1[1]}));\\n          int index = resTexRC.y * ${n1[0]} + resTexRC.x;\\n\\n          int b = index / ${i1};\\n          index -= b * ${i1};\\n\\n          // reverse r and c order for packed texture\\n          int r = imod(index, ${r1}) * 2;\\n          int c = 2 * (index / ${r1});\\n\\n          return ivec3(b, r, c);\\n        }\\n      `;\n                    return new o1.GlslLibRoutine(s1);\n                }\n                getOutputPackedNDCoords(e1, t1) {\n                    const n1 = [\n                        t1[0],\n                        t1[1]\n                    ], r1 = Math.ceil(e1[e1.length - 1] / 2), i1 = r1 * Math.ceil(e1[e1.length - 2] / 2);\n                    let s1 = i1, a1 = \"\", u1 = \"b, r, c\";\n                    for(let t1 = 2; t1 < e1.length - 1; t1++)s1 *= e1[e1.length - t1 - 1], a1 = `\\n      int b${t1} = index / ${s1};\\n      index -= b${t1} * ${s1};\\n    ` + a1, u1 = `b${t1}, ` + u1;\n                    const l1 = `\\n      ivec${e1.length} getOutputCoords() {\\n        ivec2 resTexRC = ivec2(TexCoords.xy *\\n                              vec2(${n1[0]}, ${n1[1]}));\\n        int index = resTexRC.y * ${n1[0]} + resTexRC.x;\\n\\n        ${a1}\\n\\n        int b = index / ${i1};\\n        index -= b * ${i1};\\n\\n        // reverse r and c order for packed texture\\n        int r = imod(index, ${r1}) * 2;\\n        int c = 2 * (index / ${r1});\\n\\n        return ivec${e1.length}(${u1});\\n      }\\n    `;\n                    return new o1.GlslLibRoutine(l1);\n                }\n                getOutputUnpacked1DCoords(e1, t1) {\n                    const n1 = `\\n        int getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t1[0]}, ${t1[1]}));\\n          return resTexRC.y * ${t1[0]} + resTexRC.x;\\n        }\\n      `;\n                    return new o1.GlslLibRoutine(n1);\n                }\n                getOutputUnpacked2DCoords(e1, t1) {\n                    const n1 = `\\n        ivec2 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t1[0]}, ${t1[1]}));\\n          int index = resTexRC.y * ${t1[0]} + resTexRC.x;\\n          int r = index / ${e1[1]};\\n          int c = index - r * ${e1[1]};\\n          return ivec2(r, c);\\n        }\\n      `;\n                    return new o1.GlslLibRoutine(n1);\n                }\n                getOutputUnpacked3DCoords(e1, t1) {\n                    let n1 = \"\";\n                    const r1 = e1.length;\n                    let i1 = null;\n                    r1 < 2 && (i1 = []), i1 = new Array(r1 - 1), i1[r1 - 2] = e1[r1 - 1];\n                    for(let t1 = r1 - 3; t1 >= 0; --t1)i1[t1] = i1[t1 + 1] * e1[t1 + 1];\n                    const s1 = [\n                        \"r\",\n                        \"c\",\n                        \"d\"\n                    ], a1 = i1.map((e1, t1)=>`int ${s1[t1]} = index / ${e1}; ${t1 === i1.length - 1 ? `int ${s1[t1 + 1]} = index - ${s1[t1]} * ${e1}` : `index -= ${s1[t1]} * ${e1}`};`).join(\"\");\n                    return n1 = `\\n        ivec3 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t1[0]}, ${t1[1]}));\\n          int index = resTexRC.y * ${t1[0]} + resTexRC.x;\\n          ${a1}\\n          return ivec3(r, c, d);\\n        }\\n      `, new o1.GlslLibRoutine(n1);\n                }\n                getOutputUnpacked4DCoords(e1, t1) {\n                    let n1 = \"\";\n                    const r1 = e1.length;\n                    let i1 = null;\n                    r1 < 2 && (i1 = []), i1 = new Array(r1 - 1), i1[r1 - 2] = e1[r1 - 1];\n                    for(let t1 = r1 - 3; t1 >= 0; --t1)i1[t1] = i1[t1 + 1] * e1[t1 + 1];\n                    const s1 = [\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\"\n                    ], a1 = i1.map((e1, t1)=>`int ${s1[t1]} = index / ${e1}; ${t1 === i1.length - 1 ? `int ${s1[t1 + 1]} = index - ${s1[t1]} * ${e1}` : `index -= ${s1[t1]} * ${e1}`};`).join(\"\");\n                    return n1 = `\\n      ivec4 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t1[0]}, ${t1[1]}));\\n          int index = resTexRC.y * ${t1[0]} + resTexRC.x;\\n          ${a1}\\n          return ivec4(r, c, d, d2);\\n        }\\n      `, new o1.GlslLibRoutine(n1);\n                }\n                getOutputUnpacked5DCoords(e1, t1) {\n                    let n1 = \"\";\n                    const r1 = e1.length;\n                    let i1 = null;\n                    r1 < 2 && (i1 = []), i1 = new Array(r1 - 1), i1[r1 - 2] = e1[r1 - 1];\n                    for(let t1 = r1 - 3; t1 >= 0; --t1)i1[t1] = i1[t1 + 1] * e1[t1 + 1];\n                    const s1 = [\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\",\n                        \"d3\"\n                    ], a1 = i1.map((e1, t1)=>`int ${s1[t1]} = index / ${e1}; ${t1 === i1.length - 1 ? `int ${s1[t1 + 1]} = index - ${s1[t1]} * ${e1}` : `index -= ${s1[t1]} * ${e1}`};`).join(\"\");\n                    return n1 = `\\n      ivec5 getOutputCoords() {\\n          ivec2 resTexRC = ivec2(TexCoords.xy *\\n                                vec2(${t1[0]}, ${t1[1]}));\\n          int index = resTexRC.y * ${t1[0]} + resTexRC.x;\\n          ${a1}\\n          return ivec5(r, c, d, d2, d3);\\n        }\\n      `, new o1.GlslLibRoutine(n1);\n                }\n                getOutputUnpacked6DCoords(e1, t1) {\n                    let n1 = \"\";\n                    const r1 = e1.length;\n                    let i1 = null;\n                    r1 < 2 && (i1 = []), i1 = new Array(r1 - 1), i1[r1 - 2] = e1[r1 - 1];\n                    for(let t1 = r1 - 3; t1 >= 0; --t1)i1[t1] = i1[t1 + 1] * e1[t1 + 1];\n                    const s1 = [\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\",\n                        \"d3\",\n                        \"d4\"\n                    ], a1 = i1.map((e1, t1)=>`int ${s1[t1]} = index / ${e1}; ${t1 === i1.length - 1 ? `int ${s1[t1 + 1]} = index - ${s1[t1]} * ${e1}` : `index -= ${s1[t1]} * ${e1}`};`).join(\"\");\n                    return n1 = `\\n     ivec6 getOutputCoords() {\\n         ivec2 resTexRC = ivec2(TexCoords.xy *\\n                               vec2(${t1[0]}, ${t1[1]}));\\n         int index = resTexRC.y * ${t1[0]} + resTexRC.x;\\n         ${a1}\\n         return ivec6(r, c, d, d2, d3, d4);\\n       }\\n     `, new o1.GlslLibRoutine(n1);\n                }\n                getCommonUtilFuncs() {\n                    const e1 = {};\n                    let t1 = \"uvFromFlat\";\n                    e1[t1] = new o1.GlslLibRoutine(\"\\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n      int texC = index / texNumR;\\n      int texR = index - texC * texNumR;\\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\\n      //       v.\\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\\n    }\\n    \"), t1 = \"packedUVfrom1D\", e1[t1] = new o1.GlslLibRoutine(\"\\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n        int texelIndex = index / 2;\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), t1 = \"packedUVfrom2D\", e1[t1] = new o1.GlslLibRoutine(\"\\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = texelIndex / texNumC;\\n        int texC = texelIndex - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), t1 = \"packedUVfrom3D\", e1[t1] = new o1.GlslLibRoutine(\"\\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\\n          int texelsInBatch, int texelsInLogicalRow, int b,\\n          int row, int col) {\\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n        int texR = index / texNumC;\\n        int texC = index - texR * texNumC;\\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n      }\\n      \"), t1 = \"sampleTexture\";\n                    const n1 = (0, i1.getGlsl)(this.context.glContext.version);\n                    return e1[t1] = new o1.GlslLibRoutine(`\\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n            return ${n1.texture2D}(textureSampler, uv).r;\\n        }`), e1;\n                }\n                getInputsSamplingSnippets() {\n                    const e1 = {}, t1 = this.context.outputTextureLayout;\n                    return this.context.programInfo.inputNames.forEach((n1, r1)=>{\n                        const o1 = this.context.inputTextureLayouts[r1], i1 = (0, a1.generateShaderFuncNameFromInputSamplerName)(n1);\n                        o1.isPacked ? e1[i1] = this.getPackedSamplerFromInput(i1, n1, o1) : e1[i1] = this.getUnpackedSamplerFromInput(i1, n1, o1);\n                        const s1 = (0, a1.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n1);\n                        o1.unpackedShape.length <= t1.unpackedShape.length && (o1.isPacked ? e1[s1] = this.getPackedSamplerAtOutputCoords(s1, o1, t1, n1) : e1[s1] = this.getUnpackedSamplerAtOutputCoords(s1, o1, t1, n1));\n                    }), e1;\n                }\n                getPackedSamplerAtOutputCoords(e1, t1, n1, i1) {\n                    const s1 = t1.unpackedShape, u1 = n1.unpackedShape, l1 = i1, c1 = (0, a1.generateShaderFuncNameFromInputSamplerName)(l1), p1 = s1.length, d1 = u1.length, f1 = r1.BroadcastUtil.getBroadcastDims(s1, u1), h1 = (0, a1.getCoordsDataType)(d1), g1 = d1 - p1;\n                    let b1;\n                    const m1 = (0, a1.getGlChannels)();\n                    b1 = 0 === p1 ? \"\" : d1 < 2 && f1.length >= 1 ? \"coords = 0;\" : f1.map((e1)=>`coords.${m1[e1 + g1]} = 0;`).join(\"\\n\");\n                    let y1 = \"\";\n                    y1 = d1 < 2 && p1 > 0 ? \"coords\" : s1.map((e1, t1)=>`coords.${m1[t1 + g1]}`).join(\", \");\n                    let _1 = \"return outputValue;\";\n                    const v1 = 1 === r1.ShapeUtil.size(s1), T1 = 1 === r1.ShapeUtil.size(u1);\n                    if (1 !== p1 || v1 || T1) {\n                        if (v1 && !T1) _1 = 1 === d1 ? \"\\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\\n        \" : \"\\n          return vec4(outputValue.x);\\n        \";\n                        else if (f1.length) {\n                            const e1 = p1 - 2, t1 = p1 - 1;\n                            f1.indexOf(e1) > -1 && f1.indexOf(t1) > -1 ? _1 = \"return vec4(outputValue.x);\" : f1.indexOf(e1) > -1 ? _1 = \"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\" : f1.indexOf(t1) > -1 && (_1 = \"return vec4(outputValue.xx, outputValue.zz);\");\n                        }\n                    } else _1 = \"\\n        return vec4(outputValue.xy, outputValue.xy);\\n      \";\n                    const x1 = `\\n      vec4 ${e1}() {\\n        ${h1} coords = getOutputCoords();\\n        \\n        int lastDim = coords.${m1[d1 - 1]};\\n        coords.${m1[d1 - 1]} = coords.${m1[d1 - 2]};\\n        coords.${m1[d1 - 2]} = lastDim;\\n      \\n        ${b1}\\n        vec4 outputValue = ${c1}(${y1});\\n        ${_1}\\n      }\\n    `;\n                    return new o1.GlslLibRoutine(x1, [\n                        \"coordinates.getOutputCoords\"\n                    ]);\n                }\n                getUnpackedSamplerAtOutputCoords(e1, t1, n1, i1) {\n                    const s1 = [\n                        n1.width,\n                        n1.height\n                    ], u1 = [\n                        t1.width,\n                        t1.height\n                    ], l1 = t1.unpackedShape.length, c1 = n1.unpackedShape.length, p1 = t1.unpackedShape, d1 = n1.unpackedShape, f1 = (0, a1.generateShaderFuncNameFromInputSamplerName)(i1);\n                    if (l1 === c1 && r1.ArrayUtil.arraysEqual(u1, s1)) {\n                        const t1 = `\\n          float ${e1}() {\\n            return sampleTexture(${i1}, TexCoords);\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(t1, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const h1 = (0, a1.getCoordsDataType)(c1), g1 = r1.BroadcastUtil.getBroadcastDims(p1, d1), b1 = c1 - l1;\n                    let m1;\n                    const y1 = (0, a1.getGlChannels)();\n                    m1 = 0 === l1 ? \"\" : c1 < 2 && g1.length >= 1 ? \"coords = 0;\" : g1.map((e1)=>`coords.${y1[e1 + b1]} = 0;`).join(\"\\n\");\n                    let _1 = \"\";\n                    _1 = c1 < 2 && l1 > 0 ? \"coords\" : t1.unpackedShape.map((e1, t1)=>`coords.${y1[t1 + b1]}`).join(\", \");\n                    const v1 = `\\n        float ${e1}() {\\n          ${h1} coords = getOutputCoords();\\n          ${m1}\\n          return ${f1}(${_1});\\n        }\\n      `;\n                    return new o1.GlslLibRoutine(v1, [\n                        \"coordinates.getOutputCoords\"\n                    ]);\n                }\n                getPackedSamplerFromInput(e1, t1, n1) {\n                    switch(n1.unpackedShape.length){\n                        case 0:\n                            return this.getPackedSamplerScalar(e1, t1);\n                        case 1:\n                            return this.getPackedSampler1D(e1, t1, n1);\n                        case 2:\n                            return this.getPackedSampler2D(e1, t1, n1);\n                        case 3:\n                            return this.getPackedSampler3D(e1, t1, n1);\n                        default:\n                            return this.getPackedSamplerND(e1, t1, n1);\n                    }\n                }\n                getUnpackedSamplerFromInput(e1, t1, n1) {\n                    const r1 = n1.unpackedShape;\n                    switch(r1.length){\n                        case 0:\n                            return this.getUnpackedSamplerScalar(e1, t1, n1);\n                        case 1:\n                            return this.getUnpackedSampler1D(e1, t1, n1);\n                        case 2:\n                            return this.getUnpackedSampler2D(e1, t1, n1);\n                        case 3:\n                            return this.getUnpackedSampler3D(e1, t1, n1);\n                        case 4:\n                            return this.getUnpackedSampler4D(e1, t1, n1);\n                        case 5:\n                            return this.getUnpackedSampler5D(e1, t1, n1);\n                        case 6:\n                            return this.getUnpackedSampler6D(e1, t1, n1);\n                        default:\n                            throw new Error(`Unsupported dimension ${r1.length}-D`);\n                    }\n                }\n                getPackedSamplerScalar(e1, t1) {\n                    const n1 = `\\n          vec4 ${e1}() {\\n            return ${(0, i1.getGlsl)(this.context.glContext.version).texture2D}(${t1}, halfCR);\\n          }\\n        `;\n                    return new o1.GlslLibRoutine(n1);\n                }\n                getPackedSampler1D(e1, t1, n1) {\n                    const r1 = [\n                        n1.width,\n                        n1.height\n                    ], s1 = [\n                        r1[1],\n                        r1[0]\n                    ], a1 = (0, i1.getGlsl)(this.context.glContext.version), u1 = `vec4 ${e1}(int index) {\\n      vec2 uv = packedUVfrom1D(\\n      ${s1[0]}, ${s1[1]}, index);\\n      return ${a1.texture2D}(${t1}, uv);\\n    }`;\n                    return new o1.GlslLibRoutine(u1, [\n                        \"coordinates.packedUVfrom1D\"\n                    ]);\n                }\n                getPackedSampler2D(e1, t1, n1) {\n                    const s1 = n1.unpackedShape, a1 = [\n                        n1.width,\n                        n1.height\n                    ], u1 = (0, i1.getGlsl)(this.context.glContext.version), l1 = a1[0], c1 = a1[1];\n                    if (null != a1 && r1.ArrayUtil.arraysEqual(s1, a1)) {\n                        const n1 = `vec4 ${e1}(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c1}.0, ${l1}.0);\\n        return ${u1.texture2D}(${t1}, uv);\\n      }`;\n                        return new o1.GlslLibRoutine(n1);\n                    }\n                    const p1 = a1, d1 = Math.ceil(s1[1] / 2), f1 = `vec4 ${e1}(int row, int col) {\\n      vec2 uv = packedUVfrom2D(${p1[1]}, ${p1[0]}, ${d1}, row, col);\\n      return ${u1.texture2D}(${t1}, uv);\\n    }`;\n                    return new o1.GlslLibRoutine(f1, [\n                        \"coordinates.packedUVfrom2D\"\n                    ]);\n                }\n                getPackedSampler3D(e1, t1, n1) {\n                    const r1 = n1.unpackedShape, s1 = [\n                        n1.width,\n                        n1.height\n                    ], u1 = [\n                        s1[0],\n                        s1[1]\n                    ], l1 = (0, i1.getGlsl)(this.context.glContext.version);\n                    if (1 === r1[0]) {\n                        const i1 = r1.slice(1), s1 = [\n                            1,\n                            2\n                        ], u1 = (0, a1.squeezeInputShape)(r1, i1), l1 = [\n                            \"b\",\n                            \"row\",\n                            \"col\"\n                        ], c1 = JSON.parse(JSON.stringify(n1));\n                        c1.unpackedShape = u1;\n                        const p1 = this.getPackedSamplerFromInput(e1, t1, c1), d1 = `${p1.routineBody}\\n      vec4 ${e1}(int b, int row, int col) {\\n        return ${e1}(${(0, a1.getSqueezedParams)(l1, s1)});\\n      } `;\n                        return new o1.GlslLibRoutine(d1, p1.dependencies);\n                    }\n                    const c1 = u1[0], p1 = u1[1], d1 = Math.ceil(r1[2] / 2), f1 = `vec4 ${e1}(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        ${p1}, ${c1}, ${d1 * Math.ceil(r1[1] / 2)}, ${d1}, b, row, col);\\n      return ${l1.texture2D}(${t1}, uv);}`;\n                    return new o1.GlslLibRoutine(f1, [\n                        \"coordinates.packedUVfrom3D\"\n                    ]);\n                }\n                getPackedSamplerND(e1, t1, n1) {\n                    const r1 = n1.unpackedShape, s1 = r1.length, a1 = [\n                        n1.width,\n                        n1.height\n                    ], u1 = (0, i1.getGlsl)(this.context.glContext.version), l1 = [\n                        a1[0],\n                        a1[1]\n                    ], c1 = l1[1], p1 = l1[0], d1 = Math.ceil(r1[s1 - 1] / 2);\n                    let f1 = d1 * Math.ceil(r1[s1 - 2] / 2), h1 = \"int b, int row, int col\", g1 = `b * ${f1} + (row / 2) * ${d1} + (col / 2)`;\n                    for(let e1 = 2; e1 < s1 - 1; e1++)h1 = `int b${e1}, ` + h1, f1 *= r1[s1 - e1 - 1], g1 = `b${e1} * ${f1} + ` + g1;\n                    const b1 = `vec4 ${e1}(${h1}) {\\n      int index = ${g1};\\n      int texR = index / ${p1};\\n      int texC = index - texR * ${p1};\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p1}, ${c1});\\n      return ${u1.texture2D}(${t1}, uv);\\n    }`;\n                    return new o1.GlslLibRoutine(b1);\n                }\n                getUnpackedSamplerScalar(e1, t1, n1) {\n                    const [r1, i1] = [\n                        n1.width,\n                        n1.height\n                    ];\n                    if (1 === r1 && 1 === i1) {\n                        const n1 = `\\n          float ${e1}() {\\n            return sampleTexture(${t1}, halfCR);\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(n1, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const s1 = `\\n        float ${e1}() {\\n          int offset_${t1} = coordsToOffset(TexCoords, ${r1}, ${i1});\\n          vec2 uv = uvFromFlat(${r1}, ${i1}, offset_${t1});\\n          return sampleTexture(${t1}, uv);\\n        }\\n      `;\n                    return new o1.GlslLibRoutine(s1, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.coordsToOffset\"\n                    ]);\n                }\n                getUnpackedSampler1D(e1, t1, n1) {\n                    const r1 = n1.width, i1 = n1.height;\n                    if (1 === i1 && 1 === r1) {\n                        const n1 = `\\n        float ${e1}(int index) {\\n          return sampleTexture(${t1}, halfCR);\\n        }\\n      `;\n                        return new o1.GlslLibRoutine(n1, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    if (1 === i1) {\n                        const n1 = `\\n          float ${e1}(int index) {\\n            vec2 uv = vec2((float(index) + 0.5) / ${r1}.0, 0.5);\\n            return sampleTexture(${t1}, uv);\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(n1, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    if (1 === r1) {\n                        const n1 = `\\n          float ${e1}(int index) {\\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${i1}.0);\\n            return sampleTexture(${t1}, uv);\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(n1, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const s1 = `\\n        float ${e1}(int index) {\\n          vec2 uv = uvFromFlat(${r1}, ${i1}, index);\\n          return sampleTexture(${t1}, uv);\\n        }\\n      `;\n                    return new o1.GlslLibRoutine(s1, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\"\n                    ]);\n                }\n                getUnpackedSampler2D(e1, t1, n1) {\n                    const i1 = n1.unpackedShape, u1 = [\n                        n1.height,\n                        n1.width\n                    ];\n                    if (null != u1 && r1.ArrayUtil.arraysEqual(i1, u1)) {\n                        const n1 = `\\n          float ${e1}(int row, int col) {\\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u1[1]}.0, ${u1[0]}.0);\\n            return sampleTexture(${t1}, uv);\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(n1, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const { newShape: l1, keptDims: c1 } = (0, s1.squeezeShape)(i1), p1 = l1;\n                    if (p1.length < i1.length) {\n                        const r1 = (0, a1.squeezeInputShape)(i1, p1), s1 = JSON.parse(JSON.stringify(n1));\n                        s1.unpackedShape = r1;\n                        const u1 = [\n                            \"col\",\n                            \"row\"\n                        ], l1 = `\\n          ${this.getUnpackedSamplerFromInput(e1, t1, s1).routineBody}\\n          float ${e1}(int row, int col) {\\n            return ${e1}(${(0, a1.getSqueezedParams)(u1, c1)});\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(l1, [\n                            \"coordinates.sampleTexture\"\n                        ]);\n                    }\n                    const d1 = u1[1], f1 = u1[0];\n                    if (1 === f1) {\n                        const n1 = `\\n          float ${e1}(int row, int col) {\\n            int offset_${t1} = coordsToOffset(TexCoords, ${d1}, ${f1});\\n            float index = dot(vec3(row, col, offset_${t1}), vec3(${i1[1]}, 1, 1));\\n            vec2 uv = vec2(0.5, (index + 0.5) / ${d1}.0);\\n            return sampleTexture(${t1}, uv);\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(n1, [\n                            \"coordinates.sampleTexture\",\n                            \"coordinates.coordsToOffset\"\n                        ]);\n                    }\n                    if (1 === d1) {\n                        const n1 = `\\n          float ${e1}(int row, int col) {\\n            int offset_${t1} = coordsToOffset(TexCoords, ${d1}, ${f1});\\n            float index = dot(vec3(row, col, offset_${t1}), vec3(${i1[1]}, 1, 1));\\n            vec2 uv = vec2((index + 0.5) / ${f1}.0, 0.5);\\n            return sampleTexture(${t1}, uv);\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(n1, [\n                            \"coordinates.sampleTexture\",\n                            \"coordinates.coordsToOffset\"\n                        ]);\n                    }\n                    const h1 = `\\n        float ${e1}(int row, int col) {\\n          int index = col * ${i1[1]} + row;\\n          vec2 uv = uvFromFlat(${d1}, ${f1}, index);\\n          return sampleTexture(${t1}, uv);\\n        }\\n      `;\n                    return new o1.GlslLibRoutine(h1, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.coordsToOffset\"\n                    ]);\n                }\n                getUnpackedSampler3D(e1, t1, n1) {\n                    const r1 = n1.unpackedShape, i1 = r1[1] * r1[2], u1 = r1[2], { newShape: l1, keptDims: c1 } = (0, s1.squeezeShape)(r1), p1 = l1;\n                    if (p1.length < r1.length) {\n                        const i1 = (0, a1.squeezeInputShape)(r1, p1), s1 = [\n                            \"batch\",\n                            \"col\",\n                            \"row\"\n                        ], u1 = JSON.parse(JSON.stringify(n1));\n                        u1.unpackedShape = i1;\n                        const l1 = this.getUnpackedSamplerFromInput(e1, t1, u1), d1 = c1.reverse(), f1 = `\\n          ${l1.routineBody}\\n          float ${e1}(int batch, int row, int col) {\\n            return ${e1}(${(0, a1.getSqueezedParams)(s1, d1)});\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(f1, l1.dependencies);\n                    }\n                    const d1 = `\\n          float ${e1}(int depth, int row, int col) {\\n            // Explicitly use integer operations as dot() only works on floats.\\n            int index = depth * ${i1} + col * ${u1} + row;\\n            vec2 uv = uvFromFlat(${n1.width}, ${n1.height}, index);\\n            return sampleTexture(${t1}, uv);\\n          }\\n      `;\n                    return new o1.GlslLibRoutine(d1, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.coordsToOffset\"\n                    ]);\n                }\n                getUnpackedSampler4D(e1, t1, n1) {\n                    const r1 = n1.unpackedShape, i1 = r1[3], s1 = r1[2] * i1, a1 = `\\n        float ${e1}(int row, int col, int depth, int depth2) {\\n          int index = row * ${r1[1] * s1} + col * ${s1} +\\n              depth2 * ${i1} + depth;\\n          vec2 uv = uvFromFlat(${n1.width}, ${n1.height}, index);\\n          return sampleTexture(${t1}, uv);\\n        }\\n      `;\n                    return new o1.GlslLibRoutine(a1, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\"\n                    ]);\n                }\n                getUnpackedSampler5D(e1, t1, n1) {\n                    const r1 = n1.unpackedShape, i1 = r1[4], u1 = r1[3] * i1, l1 = r1[2] * u1, c1 = r1[1] * l1, { newShape: p1, keptDims: d1 } = (0, s1.squeezeShape)(r1);\n                    if (p1.length < r1.length) {\n                        const i1 = (0, a1.squeezeInputShape)(r1, p1), s1 = [\n                            \"row\",\n                            \"col\",\n                            \"depth\",\n                            \"depth2\",\n                            \"depth3\"\n                        ], u1 = JSON.parse(JSON.stringify(n1));\n                        u1.unpackedShape = i1;\n                        const l1 = `\\n          ${this.getUnpackedSamplerFromInput(e1, t1, u1).routineBody}\\n          float ${e1}(int row, int col, int depth, int depth2, int depth3) {\\n            return ${e1}(${(0, a1.getSqueezedParams)(s1, d1)});\\n          }\\n        `;\n                        return new o1.GlslLibRoutine(l1, [\n                            \"coordinates.sampleTexture\",\n                            \"coordinates.uvFromFlat\"\n                        ]);\n                    }\n                    const f1 = `\\n        float ${e1}(int row, int col, int depth, int depth2, int depth3) {\\n          int index = row * ${c1} + col * ${l1} + depth * ${u1} +\\n          depth3 * ${i1} + depth2;\\n          vec2 uv = uvFromFlat(${n1.width}, ${n1.height}, index);\\n          return sampleTexture(${t1}, uv);\\n        }\\n      `;\n                    return new o1.GlslLibRoutine(f1, [\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.uvFromFlat\"\n                    ]);\n                }\n                getUnpackedSampler6D(e1, t1, n1) {\n                    const r1 = n1.unpackedShape, i1 = r1[5], u1 = r1[4] * i1, l1 = r1[3] * u1, c1 = r1[2] * l1, p1 = r1[1] * c1, { newShape: d1, keptDims: f1 } = (0, s1.squeezeShape)(r1);\n                    if (d1.length < r1.length) {\n                        const i1 = (0, a1.squeezeInputShape)(r1, d1), s1 = [\n                            \"row\",\n                            \"col\",\n                            \"depth\",\n                            \"depth2\",\n                            \"depth3\",\n                            \"depth4\"\n                        ], u1 = JSON.parse(JSON.stringify(n1));\n                        u1.unpackedShape = i1;\n                        const l1 = `\\n            ${this.getUnpackedSamplerFromInput(e1, t1, u1).routineBody}\\n            float ${e1}(int row, int col, int depth,\\n              int depth2, int depth3, int depth4) {\\n              return ${e1}(${(0, a1.getSqueezedParams)(s1, f1)});\\n            }\\n          `;\n                        return new o1.GlslLibRoutine(l1, [\n                            \"coordinates.sampleTexture\",\n                            \"coordinates.uvFromFlat\"\n                        ]);\n                    }\n                    const h1 = `\\n          float ${e1}(int row, int col, int depth,\\n            int depth2, int depth3, int depth4) {\\n            int index = row * ${p1} + col * ${c1} + depth * ${l1} +\\n            depth2 * ${u1} + depth3 * ${i1} + depth4;\\n            vec2 uv = uvFromFlat(${n1.width}, ${n1.height}, index);\\n            return sampleTexture(${t1}, uv);\\n          }\\n        `;\n                    return new o1.GlslLibRoutine(h1, [\n                        \"coordinates.uvFromFlat\",\n                        \"coordinates.sampleTexture\",\n                        \"coordinates.coordsToOffset\"\n                    ]);\n                }\n                toVec() {\n                    const e1 = this.context.outputTextureLayout, t1 = e1.shape.length, n1 = e1.strides, r1 = e1.width, i1 = e1.height, s1 = [];\n                    for(let e1 = 0; e1 < t1 - 1; ++e1)s1.push(`\\n        c[${e1}] = offset / ${n1[e1]};`), s1.push(`\\n        offset -= c[${e1}] * ${n1[e1]};`);\n                    s1.push(`\\n        c[${t1 - 1}] = offset;`);\n                    const a1 = `\\n      void toVec(vec2 texCoords, out int c[${t1}]) {\\n        int offset = coordsToOffset(texCoords, ${r1}, ${i1});\\n        ${s1.join(\"\")}\\n      }\\n      void toVec(int offset, out int c[${t1}]) {\\n        ${s1.join(\"\")}\\n      }\\n    `;\n                    return {\n                        toVec: new o1.GlslLibRoutine(a1, [\n                            \"coordinates.coordsToOffset\"\n                        ])\n                    };\n                }\n                valueFrom() {\n                    const e1 = {};\n                    return this.context.programInfo.inputNames.forEach((t1, n1)=>{\n                        const r1 = this.context.inputTextureLayouts[n1], i1 = (r1.unpackedShape.length > 0 ? r1.unpackedShape : r1.shape).length;\n                        let s1 = `_${t1}`;\n                        e1[s1] = new o1.GlslLibRoutine(this.getValueFromSingle(t1, i1, r1.width, r1.height, !1), [\n                            `shapeUtils.indicesToOffset${s1}`,\n                            \"coordinates.offsetToCoords\",\n                            \"fragcolor.getColorAsFloat\"\n                        ]), s1 += \"_T\", e1[s1] = new o1.GlslLibRoutine(this.getValueFromSingle(t1, i1, r1.width, r1.height, !0), [\n                            `shapeUtils.indicesToOffset${s1}`,\n                            \"coordinates.offsetToCoords\",\n                            \"fragcolor.getColorAsFloat\"\n                        ]);\n                    }), e1;\n                }\n                getValueFromSingle(e1, t1, n1, r1, o1) {\n                    let s1 = `_${e1}`;\n                    return o1 && (s1 += \"_T\"), `\\n        float ${s1}(int m[${t1}]) {\\n          int offset = indicesToOffset${s1}(m);\\n          vec2 coords = offsetToCoords(offset, ${n1}, ${r1});\\n          float value = getColorAsFloat(${(0, i1.getGlsl)(this.context.glContext.version).texture2D}(${e1}, coords));\\n          return value;\\n        }\\n        `;\n                }\n                getPackedValueFrom(e1, t1, n1, r1, o1) {\n                    let s1 = `_${e1}_Pack`;\n                    return o1 && (s1 += \"_T\"), `\\n        vec4 ${s1}(int m[${t1}]) {\\n          int offset = indicesToOffset_${e1}(m);\\n          vec2 coords = offsetToCoords(offset, ${n1}, ${r1});\\n          return ${(0, i1.getGlsl)(this.context.glContext.version).texture2D}(${e1}, coords);\\n        }\\n        `;\n                }\n            }\n            t1.CoordsGlslLib = u1;\n        },\n        1997: (e1, t1)=>{\n            \"use strict\";\n            var n1;\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.TopologicalSortGlslRoutines = t1.GlslLibRoutineNode = t1.GlslLibRoutine = t1.GlslLib = t1.GlslContext = t1.FunctionType = void 0, (n1 = t1.FunctionType || (t1.FunctionType = {}))[n1.ValueBased = 0] = \"ValueBased\", n1[n1.Positional = 1] = \"Positional\", t1.GlslContext = class {\n                constructor(e1, t1, n1, r1){\n                    this.glContext = e1, this.programInfo = t1, this.inputTextureLayouts = n1, this.outputTextureLayout = r1;\n                }\n            }, t1.GlslLib = class {\n                constructor(e1){\n                    this.context = e1;\n                }\n            }, t1.GlslLibRoutine = class {\n                constructor(e1, t1){\n                    this.routineBody = e1, this.dependencies = t1;\n                }\n            }, t1.GlslLibRoutineNode = class {\n                constructor(e1, t1, n1){\n                    this.name = e1, this.dependencies = n1 || [], t1 && (this.routineBody = t1);\n                }\n                addDependency(e1) {\n                    e1 && this.dependencies.push(e1);\n                }\n            }, t1.TopologicalSortGlslRoutines = class {\n                static returnOrderedNodes(e1) {\n                    if (!e1 || 0 === e1.length) return [];\n                    if (1 === e1.length) return e1;\n                    const t1 = new Set, n1 = new Set, r1 = new Array;\n                    return this.createOrderedNodes(e1, t1, n1, r1), r1;\n                }\n                static createOrderedNodes(e1, t1, n1, r1) {\n                    for(let o1 = 0; o1 < e1.length; ++o1)this.dfsTraverse(e1[o1], t1, n1, r1);\n                }\n                static dfsTraverse(e1, t1, n1, r1) {\n                    if (!e1 || n1.has(e1.name)) return;\n                    if (t1.has(e1.name)) throw new Error(\"Cyclic dependency detected. Can't topologically sort routines needed for shader.\");\n                    t1.add(e1.name);\n                    const o1 = e1.dependencies;\n                    if (o1 && o1.length > 0) for(let e1 = 0; e1 < o1.length; ++e1)this.dfsTraverse(o1[e1], t1, n1, r1);\n                    r1.push(e1), n1.add(e1.name), t1.delete(e1.name);\n                }\n            };\n        },\n        1371: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.EncodingGlslLib = void 0;\n            const r1 = n1(1997);\n            class o1 extends r1.GlslLib {\n                constructor(e1){\n                    super(e1);\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                encodeFloat32() {\n                    return {\n                        encode: new r1.GlslLibRoutine(\"highp vec4 encode(highp float f) {\\n        return vec4(f, 0.0, 0.0, 0.0);\\n      }\\n        \")\n                    };\n                }\n                decodeFloat32() {\n                    return {\n                        decode: new r1.GlslLibRoutine(\"highp float decode(highp vec4 rgba) {\\n        return rgba.r;\\n      }\\n        \")\n                    };\n                }\n                encodeUint8() {\n                    const e1 = o1.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n                    return {\n                        encode: new r1.GlslLibRoutine(`\\n      highp vec4 encode(highp float f) {\\n        highp float F = abs(f);\\n        highp float Sign = step(0.0,-f);\\n        highp float Exponent = floor(log2(F));\\n        highp float Mantissa = (exp2(- Exponent) * F);\\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\\n        highp vec4 rgba;\\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\\n        ${e1}\\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\\n        return rgba;\\n    }\\n        `)\n                    };\n                }\n                decodeUint8() {\n                    const e1 = o1.isLittleEndian() ? \"rgba.rgba=rgba.abgr;\" : \"\";\n                    return {\n                        decode: new r1.GlslLibRoutine(`\\n        highp float decode(highp vec4 rgba) {\\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\\n          ${e1}\\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\\n          return Result;\\n      }\\n        `)\n                    };\n                }\n                static isLittleEndian() {\n                    const e1 = new ArrayBuffer(4), t1 = new Uint32Array(e1), n1 = new Uint8Array(e1);\n                    if (t1[0] = 3735928559, 239 === n1[0]) return !0;\n                    if (222 === n1[0]) return !1;\n                    throw new Error(\"unknown endianness\");\n                }\n            }\n            t1.EncodingGlslLib = o1;\n        },\n        2691: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.FragColorGlslLib = void 0;\n            const r1 = n1(1997), o1 = n1(6757);\n            class i1 extends r1.GlslLib {\n                constructor(e1){\n                    super(e1);\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                setFragColor() {\n                    const e1 = (0, o1.getGlsl)(this.context.glContext.version);\n                    return {\n                        setFragColor: new r1.GlslLibRoutine(`\\n        void setFragColor(float value) {\\n            ${e1.output} = encode(value);\\n        }\\n        `, [\n                            \"encoding.encode\"\n                        ])\n                    };\n                }\n                getColorAsFloat() {\n                    return {\n                        getColorAsFloat: new r1.GlslLibRoutine(\"\\n        float getColorAsFloat(vec4 color) {\\n            return decode(color);\\n        }\\n        \", [\n                            \"encoding.decode\"\n                        ])\n                    };\n                }\n            }\n            t1.FragColorGlslLib = i1;\n        },\n        3878: (e1, t1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.replaceInlines = void 0;\n            const n1 = /@inline[\\s\\n\\r]+(\\w+)[\\s\\n\\r]+([0-9a-zA-Z_]+)\\s*\\(([^)]*)\\)\\s*{(([^}]|[\\n\\r])*)}/gm;\n            t1.replaceInlines = function(e1) {\n                const t1 = {};\n                let r1;\n                for(; null !== (r1 = n1.exec(e1));){\n                    const e1 = r1[3].split(\",\").map((e1)=>{\n                        const t1 = e1.trim().split(\" \");\n                        return t1 && 2 === t1.length ? {\n                            type: t1[0],\n                            name: t1[1]\n                        } : null;\n                    }).filter((e1)=>null !== e1);\n                    t1[r1[2]] = {\n                        params: e1,\n                        body: r1[4]\n                    };\n                }\n                for(const n1 in t1){\n                    const o1 = \"(\\\\w+)?\\\\s+([_0-9a-zA-Z]+)\\\\s+=\\\\s+__FUNC__\\\\((.*)\\\\)\\\\s*;\".replace(\"__FUNC__\", n1), i1 = new RegExp(o1, \"gm\");\n                    for(; null !== (r1 = i1.exec(e1));){\n                        const o1 = r1[1], i1 = r1[2], s1 = r1[3].split(\",\"), a1 = o1 ? `${o1} ${i1};` : \"\";\n                        let u1 = t1[n1].body, l1 = \"\";\n                        t1[n1].params.forEach((e1, t1)=>{\n                            e1 && (l1 += `${e1.type} ${e1.name} = ${s1[t1]};\\n`);\n                        }), u1 = `${l1}\\n ${u1}`, u1 = u1.replace(\"return\", `${i1} = `);\n                        const c1 = `\\n      ${a1}\\n      {\\n        ${u1}\\n      }\\n      `;\n                        e1 = e1.replace(r1[0], c1);\n                    }\n                }\n                return e1.replace(n1, \"\");\n            };\n        },\n        8897: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.GlslPreprocessor = void 0;\n            const r1 = n1(1997), o1 = n1(3878), i1 = n1(1248), s1 = n1(6757);\n            t1.GlslPreprocessor = class {\n                constructor(e1, t1, n1, o1){\n                    this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r1.GlslContext(e1, t1, n1, o1), Object.keys(i1.glslRegistry).forEach((e1)=>{\n                        const t1 = new i1.glslRegistry[e1](this.context);\n                        this.libs[e1] = t1;\n                    });\n                    const s1 = this.glslLibRoutineDependencyGraph;\n                    for(const e1 in this.libs){\n                        const t1 = this.libs[e1].getFunctions();\n                        for(const n1 in t1){\n                            const o1 = e1 + \".\" + n1;\n                            let i1;\n                            s1[o1] ? (i1 = s1[o1], i1.routineBody = t1[n1].routineBody) : (i1 = new r1.GlslLibRoutineNode(o1, t1[n1].routineBody), s1[o1] = i1);\n                            const a1 = t1[n1].dependencies;\n                            if (a1) for(let e1 = 0; e1 < a1.length; ++e1)if (s1[a1[e1]]) i1.addDependency(s1[a1[e1]]);\n                            else {\n                                const t1 = new r1.GlslLibRoutineNode(a1[e1]);\n                                s1[a1[e1]] = t1, i1.addDependency(t1);\n                            }\n                        }\n                    }\n                }\n                preprocess() {\n                    const e1 = this.context.programInfo;\n                    let t1 = e1.shaderSource;\n                    return this.context.programInfo.hasMain || (t1 = `${t1}\\n      ${(0, s1.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), t1 = (0, o1.replaceInlines)(t1), `${(0, s1.getFragShaderPreamble)(this.context.glContext.version)}\\n    ${this.getUniforms(e1.inputNames, e1.variables)}\\n    ${this.getImports(t1)}\\n    ${t1}`;\n                }\n                getImports(e1) {\n                    const t1 = this.selectGlslLibRoutinesToBeIncluded(e1);\n                    if (0 === t1.length) return \"\";\n                    let n1 = \"\";\n                    for(let e1 = 0; e1 < t1.length; ++e1){\n                        if (!t1[e1].routineBody) throw new Error(`Missing body for the Glsl Library routine: ${t1[e1].name}`);\n                        n1 += t1[e1].routineBody + \"\\n\";\n                    }\n                    return n1;\n                }\n                selectGlslLibRoutinesToBeIncluded(e1) {\n                    const t1 = [];\n                    return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n1)=>{\n                        const r1 = n1.split(\".\")[1];\n                        -1 !== e1.indexOf(r1) && t1.push(this.glslLibRoutineDependencyGraph[n1]);\n                    }), r1.TopologicalSortGlslRoutines.returnOrderedNodes(t1);\n                }\n                getUniforms(e1, t1) {\n                    const n1 = [];\n                    if (e1) for (const t1 of e1)n1.push(`uniform sampler2D ${t1};`);\n                    if (t1) for (const e1 of t1)n1.push(`uniform ${e1.type} ${e1.name}${e1.arrayLength ? `[${e1.arrayLength}]` : \"\"};`);\n                    return n1.join(\"\\n\");\n                }\n            };\n        },\n        1248: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.glslRegistry = void 0;\n            const r1 = n1(6859), o1 = n1(1371), i1 = n1(2691), s1 = n1(9183), a1 = n1(9314);\n            t1.glslRegistry = {\n                encoding: o1.EncodingGlslLib,\n                fragcolor: i1.FragColorGlslLib,\n                vec: a1.VecGlslLib,\n                shapeUtils: s1.ShapeUtilsGlslLib,\n                coordinates: r1.CoordsGlslLib\n            };\n        },\n        9183: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.ShapeUtilsGlslLib = void 0;\n            const r1 = n1(1997);\n            class o1 extends r1.GlslLib {\n                constructor(e1){\n                    super(e1);\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                bcastIndex() {\n                    const e1 = this.context.outputTextureLayout.shape.length, t1 = {};\n                    return this.context.programInfo.inputNames.forEach((n1, o1)=>{\n                        const i1 = this.context.inputTextureLayouts[o1].unpackedShape;\n                        if (i1.length <= e1) {\n                            const o1 = i1.length, s1 = e1 - o1, a1 = `bcastIndices_${n1}`;\n                            let u1 = \"\";\n                            for(let e1 = 0; e1 < o1; ++e1)u1 += `\\n          realIndices[${e1}] = int( mod(float(bcastedIndices[${s1 + e1}]), ${i1[e1]}.0) );\\n          `;\n                            const l1 = `\\n        void ${a1} (int bcastedIndices[${e1}], out int realIndices[${o1}]) {\\n          ${u1}\\n        }\\n        `;\n                            t1[a1] = new r1.GlslLibRoutine(l1);\n                        }\n                    }), t1;\n                }\n                bcastMatmulIndex() {\n                    const e1 = this.context.outputTextureLayout.shape.length, t1 = {};\n                    return this.context.programInfo.inputNames.forEach((n1, o1)=>{\n                        const i1 = this.context.inputTextureLayouts[o1].shape;\n                        if (!(i1.length < 2 || i1.length > e1)) {\n                            const o1 = i1.length, s1 = e1 - o1, a1 = `bcastMatmulIndices_${n1}`;\n                            let u1 = \"\";\n                            for(let e1 = 0; e1 < o1 - 2; ++e1)u1 += `\\n          realIndices[${e1}] = int( mod(float(bcastedIndices[${s1 + e1}]), ${i1[e1]}.0) );\\n          `;\n                            const l1 = `\\n        void ${a1}(int bcastedIndices[${e1}], out int realIndices[${o1}]) {\\n          ${u1}\\n          realIndices[${o1 - 1}] = bcastedIndices[${e1 - 1}];\\n          realIndices[${o1 - 2}] = bcastedIndices[${e1 - 2}];\\n        }\\n        `;\n                            t1[a1] = new r1.GlslLibRoutine(l1);\n                        }\n                    }), t1;\n                }\n                indicesToOffset() {\n                    const e1 = {};\n                    return this.context.programInfo.inputNames.forEach((t1, n1)=>{\n                        const i1 = this.context.inputTextureLayouts[n1].shape, s1 = this.context.inputTextureLayouts[n1].strides, a1 = i1.length;\n                        let u1 = `indicesToOffset_${t1}`;\n                        e1[u1] = new r1.GlslLibRoutine(o1.indexToOffsetSingle(u1, a1, s1)), u1 = `indicesToOffset_${t1}_T`, e1[u1] = new r1.GlslLibRoutine(o1.indexToOffsetSingle(u1, a1, s1.slice().reverse()));\n                    }), e1;\n                }\n                static indexToOffsetSingle(e1, t1, n1) {\n                    let r1 = \"\";\n                    for(let e1 = t1 - 1; e1 >= 0; --e1)r1 += `\\n        offset += indices[${e1}] * ${n1[e1]};\\n        `;\n                    return `\\n      int ${e1}(int indices[${t1}]) {\\n        int offset = 0;\\n        ${r1}\\n        return offset;\\n      }\\n      `;\n                }\n                offsetToIndices() {\n                    const e1 = {};\n                    return this.context.programInfo.inputNames.forEach((t1, n1)=>{\n                        const i1 = this.context.inputTextureLayouts[n1].shape, s1 = this.context.inputTextureLayouts[n1].strides, a1 = i1.length;\n                        let u1 = `offsetToIndices_${t1}`;\n                        e1[u1] = new r1.GlslLibRoutine(o1.offsetToIndicesSingle(u1, a1, s1)), u1 = `offsetToIndices_${t1}_T`, e1[u1] = new r1.GlslLibRoutine(o1.offsetToIndicesSingle(u1, a1, s1.slice().reverse()));\n                    }), e1;\n                }\n                static offsetToIndicesSingle(e1, t1, n1) {\n                    const r1 = [];\n                    for(let e1 = 0; e1 < t1 - 1; ++e1)r1.push(`\\n      indices[${e1}] = offset / ${n1[e1]};`), r1.push(`\\n        offset -= indices[${e1}] * ${n1[e1]};`);\n                    return r1.push(`\\n      indices[${t1 - 1}] = offset;`), `\\n      void ${e1}(int offset, out int indices[${t1}]) {\\n        ${r1.join(\"\")}\\n      }\\n      `;\n                }\n                incrementIndices() {\n                    const e1 = {};\n                    return this.context.programInfo.inputNames.forEach((t1, n1)=>{\n                        const o1 = this.context.inputTextureLayouts[n1].shape, i1 = o1.length, s1 = `incrementIndices_${t1}`;\n                        let a1 = \"\";\n                        for(let e1 = 0; e1 < i1; ++e1)a1 += `\\n        shape[${e1}] = ${o1[e1]};`;\n                        const u1 = `\\n        void ${s1}(int axis, out int indices[${i1}]) {\\n          int shape[${i1}];\\n          ${a1};\\n          for(int i = ${i1} -1 ; i >= 0; --i) {\\n            if(i > axis) continue;\\n            indices[i] += 1;\\n            if(indices[i] < shape[i]) {\\n              break;\\n            }\\n            indices[i] = 0;\\n          }\\n        }\\n        `;\n                        e1[s1] = new r1.GlslLibRoutine(u1);\n                    }), e1;\n                }\n            }\n            t1.ShapeUtilsGlslLib = o1;\n        },\n        6757: (e1, t1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.getDefaultFragShaderMain = t1.getFragShaderPreamble = t1.getVertexShaderSource = t1.getGlsl = void 0;\n            const n1 = {\n                version: \"\",\n                attribute: \"attribute\",\n                varyingVertex: \"varying\",\n                varyingFrag: \"varying\",\n                texture2D: \"texture2D\",\n                output: \"gl_FragColor\",\n                outputDeclaration: \"\"\n            }, r1 = {\n                version: \"#version 300 es\",\n                attribute: \"in\",\n                varyingVertex: \"out\",\n                varyingFrag: \"in\",\n                texture2D: \"texture\",\n                output: \"outputColor\",\n                outputDeclaration: \"out vec4 outputColor;\"\n            };\n            function o1(e1) {\n                return 1 === e1 ? n1 : r1;\n            }\n            t1.getGlsl = o1, t1.getVertexShaderSource = function(e1) {\n                const t1 = o1(e1);\n                return `${t1.version}\\n      precision highp float;\\n      ${t1.attribute} vec3 position;\\n      ${t1.attribute} vec2 textureCoord;\\n\\n      ${t1.varyingVertex} vec2 TexCoords;\\n\\n      void main()\\n      {\\n          gl_Position = vec4(position, 1.0);\\n          TexCoords = textureCoord;\\n      }`;\n            }, t1.getFragShaderPreamble = function(e1) {\n                const t1 = o1(e1);\n                return `${t1.version}\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    ${t1.varyingFrag} vec2 TexCoords;\\n    ${t1.outputDeclaration}\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    // Custom vector types to handle higher dimenalities.\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    `;\n            }, t1.getDefaultFragShaderMain = function(e1, t1) {\n                return `\\n  void main() {\\n    int indices[${t1}];\\n    toVec(TexCoords, indices);\\n    vec4 result = vec4(process(indices));\\n    ${o1(e1).output} = result;\\n  }\\n  `;\n            };\n        },\n        9314: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.VecGlslLib = void 0;\n            const r1 = n1(1997);\n            class o1 extends r1.GlslLib {\n                constructor(e1){\n                    super(e1);\n                }\n                getCustomTypes() {\n                    return {};\n                }\n                getFunctions() {\n                    return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());\n                }\n                binaryVecFunctions() {\n                    const e1 = this.context.outputTextureLayout.shape.length, t1 = {\n                        add: \"+=\",\n                        sub: \"-=\",\n                        mul: \"*=\",\n                        div: \"/=\"\n                    }, n1 = {};\n                    for(const o1 in t1){\n                        const i1 = `${o1}Vec`;\n                        let s1 = \"\";\n                        for(let n1 = 0; n1 < e1; ++n1)s1 += `\\n          dest[${n1}] ${t1[o1]} src[${n1}];\\n          `;\n                        const a1 = `\\n        void ${i1}(int src[${e1}], out int dest[${e1}]) {\\n          ${s1}\\n        }\\n        `;\n                        n1[i1] = new r1.GlslLibRoutine(a1);\n                    }\n                    return n1;\n                }\n                copyVec() {\n                    const e1 = this.context.outputTextureLayout.shape.length;\n                    let t1 = \"\";\n                    for(let n1 = 0; n1 < e1; ++n1)t1 += `\\n        dest[${n1}] = src[${n1}];\\n        `;\n                    const n1 = `\\n      void copyVec(int src[${e1}], out int dest[${e1}]) {\\n        ${t1}\\n      }\\n      `;\n                    return {\n                        copyVec: new r1.GlslLibRoutine(n1)\n                    };\n                }\n                setVecItem() {\n                    const e1 = this.context.outputTextureLayout.shape.length;\n                    let t1 = `\\n        if(index < 0)\\n            index =${e1} + index;\\n        if (index == 0)\\n            m[0] = value;\\n        `;\n                    for(let n1 = 1; n1 < e1 - 1; ++n1)t1 += `\\n        else if (index == ${n1})\\n            m[${n1}] = value;\\n            `;\n                    t1 += `\\n        else\\n            m[${e1 - 1}] = value;\\n        `;\n                    const n1 = `\\n      void setVecItem(out int m[${e1}], int index, int value) {\\n        ${t1}\\n      }\\n        `;\n                    return {\n                        setVecItem: new r1.GlslLibRoutine(n1)\n                    };\n                }\n                getVecItem() {\n                    const e1 = this.context.outputTextureLayout.shape.length;\n                    let t1 = `\\n        if(index < 0)\\n            index = ${e1} + index;\\n        if (index == 0)\\n            return m[0];\\n      `;\n                    for(let n1 = 1; n1 < e1 - 1; ++n1)t1 += `\\n        else if (index == ${n1})\\n            return m[${n1}];\\n      `;\n                    t1 += `\\n        else\\n            return m[${e1 - 1}];\\n        `;\n                    const n1 = `\\n      int getVecItem(int m[${e1}], int index) {\\n        ${t1}\\n      }\\n    `;\n                    return {\n                        getVecItem: new r1.GlslLibRoutine(n1)\n                    };\n                }\n            }\n            t1.VecGlslLib = o1;\n        },\n        7860: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.WebGLInferenceHandler = void 0;\n            const r1 = n1(1315), o1 = n1(9240), i1 = n1(7273), s1 = n1(9), a1 = n1(7379), u1 = n1(2488), l1 = n1(540), c1 = n1(3314), p1 = n1(5639);\n            t1.WebGLInferenceHandler = class {\n                constructor(e1){\n                    this.session = e1, this.packedTextureDataCache = new Map, this.unpackedTextureDataCache = new Map;\n                }\n                calculateTextureWidthAndHeight(e1, t1) {\n                    return (0, c1.calculateTextureWidthAndHeight)(this.session.layoutStrategy, e1, t1);\n                }\n                executeProgram(e1, t1) {\n                    if (t1.length < e1.inputNames.length) throw new Error(`Input size mustn't be less than ${e1.inputNames.length}.`);\n                    if (e1.inputNames.length !== e1.inputTypes.length) throw new Error(\"input names size does not match input types\");\n                    const n1 = [];\n                    for(let r1 = 0; r1 < e1.inputNames.length; ++r1)n1[r1] = this.getOrCreateTextureData(t1[r1], e1.inputTypes[r1]);\n                    const r1 = ((e1, t1)=>{\n                        const n1 = t1.map((e1)=>`${e1.unpackedShape.join(\",\")};${e1.width}x${e1.height}`).join(\"_\");\n                        let r1 = e1.name;\n                        return e1.cacheHint && (r1 += \"[\" + e1.cacheHint + \"]\"), r1 += \":\" + n1, r1;\n                    })(e1, n1);\n                    let o1 = this.session.programManager.getArtifact(r1);\n                    const i1 = o1 ? o1.programInfo : \"function\" == typeof e1.get ? e1.get() : e1, s1 = (0, c1.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i1.output.dims, i1.output.textureType), a1 = this.createTextureData(s1, i1.output.type);\n                    return o1 || (o1 = this.session.programManager.build(i1, n1, a1), this.session.programManager.setArtifact(r1, o1)), this.runProgram(o1, n1, a1), a1;\n                }\n                run(e1, t1) {\n                    return this.executeProgram(e1, t1).tensor;\n                }\n                runProgram(e1, t1, n1) {\n                    for(let n1 = 0; n1 < t1.length; ++n1)if (!!t1[n1].isPacked != (e1.programInfo.inputTypes[n1] === p1.TextureType.packed)) throw new Error(`input[${n1}] property packed inconsistent`);\n                    if (!!n1.isPacked != (e1.programInfo.output.textureType === p1.TextureType.packed)) throw new Error(\"output property packed inconsistent\");\n                    this.session.programManager.run(e1, t1, n1);\n                }\n                getOrCreateTextureData(e1, t1) {\n                    let n1 = this.getTextureData(e1.dataId, t1 === p1.TextureType.packed);\n                    if (!n1 && (n1 = this.getTextureData(e1.dataId, t1 !== p1.TextureType.packed), n1)) return t1 === p1.TextureType.packed ? this.pack(n1) : this.unpack(n1);\n                    if (!n1) {\n                        const r1 = (0, c1.createTextureLayoutFromTextureType)(this.session.layoutStrategy, e1.dims, t1);\n                        if (t1 === p1.TextureType.packedLastDimension) {\n                            const n1 = 1, r1 = 4, o1 = e1.dims;\n                            if (4 === o1.length) {\n                                const i1 = [\n                                    o1[0],\n                                    Math.ceil(o1[1] * o1[2] * o1[3] / r1)\n                                ], s1 = (0, c1.createTextureLayoutFromTextureType)(this.session.layoutStrategy, i1, t1);\n                                let a1 = e1.numberData;\n                                if (o1[1] * o1[2] * o1[3] % r1 != 0) {\n                                    const t1 = o1[0], i1 = o1[1] * o1[2] * o1[3], s1 = Math.ceil(i1 * n1 / r1) * r1;\n                                    a1 = new Float32Array(t1 * s1);\n                                    for(let r1 = 0; r1 < t1; ++r1){\n                                        const t1 = r1 * i1, o1 = r1 * s1 + r1 % n1 * i1;\n                                        a1.set(e1.numberData.subarray(t1, t1 + i1), o1);\n                                    }\n                                }\n                                return this.createTextureData(s1, e1.type, a1, e1, 1);\n                            }\n                        }\n                        if (t1 === p1.TextureType.packed) {\n                            const t1 = (0, c1.createTextureLayoutFromShape)(this.session.layoutStrategy, e1.dims, 1, [], {\n                                reverseWH: !0\n                            }), r1 = this.createTextureData(t1, e1.type, e1.numberData, e1, 1);\n                            n1 = this.pack(r1);\n                        } else n1 = this.createTextureData(r1, e1.type, e1.numberData, e1, 1);\n                    }\n                    return n1;\n                }\n                createTextureDataFromLayoutBindTensor(e1, t1, n1, r1) {\n                    return this.createTextureData(e1, t1, n1, r1, 1);\n                }\n                createTextureData(e1, t1, n1, o1, i1) {\n                    r1.Logger.verbose(\"InferenceHandler\", `Creating TextureData: layout:[${JSON.stringify(e1)}]`);\n                    const s1 = this.session.textureManager.createTextureFromLayout(t1, e1, n1, i1);\n                    return this.createTextureDataFromTexture(e1, t1, s1, o1);\n                }\n                reshapeUnpacked(e1, t1) {\n                    const n1 = this.getOrCreateTextureData(e1, p1.TextureType.unpacked), r1 = {\n                        channels: n1.channels,\n                        height: n1.height,\n                        width: n1.width,\n                        shape: 0 !== t1.length ? t1 : [\n                            1\n                        ],\n                        strides: i1.ShapeUtil.computeStrides(t1),\n                        unpackedShape: t1\n                    };\n                    return this.createTextureDataFromTexture(r1, e1.type, n1.texture).tensor;\n                }\n                reshapePacked(e1, t1) {\n                    const n1 = this.getOrCreateTextureData(e1, p1.TextureType.packed);\n                    if ((0, a1.isReshapeCheap)(e1.dims, t1)) {\n                        const r1 = {\n                            channels: n1.channels,\n                            height: n1.height,\n                            width: n1.width,\n                            shape: 0 !== t1.length ? t1 : [\n                                1\n                            ],\n                            strides: i1.ShapeUtil.computeStrides(t1),\n                            unpackedShape: t1,\n                            isPacked: !0\n                        };\n                        return this.createTextureDataFromTexture(r1, e1.type, n1.texture).tensor;\n                    }\n                    const r1 = (0, a1.processDims3D)(e1.dims), o1 = (0, a1.processDims3D)(t1), s1 = this.reshapePacked(e1, r1), u1 = this.run((0, a1.createPackedReshape3DProgramInfoLoader)(this, s1, o1), [\n                        s1\n                    ]);\n                    return this.reshapePacked(u1, t1);\n                }\n                cast(e1, t1) {\n                    const n1 = this.getOrCreateTextureData(e1, p1.TextureType.unpacked);\n                    return this.createTextureDataFromTexture(n1, t1, n1.texture).tensor;\n                }\n                createTextureDataFromTexture(e1, t1, n1, r1, i1) {\n                    const s1 = Object.assign(Object.assign({}, e1), {\n                        tensor: r1 || new o1.Tensor(e1.unpackedShape, t1, (e1)=>this.readTexture(s1), async (e1)=>this.readTextureAsync(s1), void 0, i1),\n                        texture: n1\n                    });\n                    return this.setTextureData(s1.tensor.dataId, s1, e1.isPacked), s1;\n                }\n                getTextureData(e1, t1 = !1) {\n                    return this.session.isInitializer(e1) ? this.session.getTextureData(e1, t1) : t1 ? this.packedTextureDataCache.get(e1) : this.unpackedTextureDataCache.get(e1);\n                }\n                setTextureData(e1, t1, n1 = !1) {\n                    this.session.isInitializer(e1) ? this.session.setTextureData(e1, t1, n1) : (n1 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(e1, t1);\n                }\n                isTextureLayoutCached(e1, t1 = !1) {\n                    return !!this.getTextureData(e1.dataId, t1);\n                }\n                dispose() {\n                    this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e1)=>this.session.textureManager.releaseTexture(e1)), this.packedTextureDataCache = new Map, this.unpackedTextureDataCache.forEach((e1)=>this.session.textureManager.releaseTexture(e1)), this.unpackedTextureDataCache = new Map;\n                }\n                readTexture(e1) {\n                    return e1.isPacked ? this.readTexture(this.unpack(e1)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(e1, e1.tensor.type, e1.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u1.encodeAsUint8)(this, e1));\n                }\n                async readTextureAsync(e1) {\n                    return e1.isPacked ? this.readTextureAsync(this.unpack(e1)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(e1, e1.tensor.type, e1.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u1.encodeAsUint8)(this, e1));\n                }\n                pack(e1) {\n                    return this.executeProgram((0, s1.createPackProgramInfoLoader)(this, e1.tensor), [\n                        e1.tensor\n                    ]);\n                }\n                unpack(e1) {\n                    return this.executeProgram((0, l1.createUnpackProgramInfoLoader)(this, e1.tensor), [\n                        e1.tensor\n                    ]);\n                }\n            };\n        },\n        4110: function(e1, t1, n1) {\n            \"use strict\";\n            var r1 = this && this.__createBinding || (Object.create ? function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1);\n                var o1 = Object.getOwnPropertyDescriptor(t1, n1);\n                o1 && !(\"get\" in o1 ? !t1.__esModule : o1.writable || o1.configurable) || (o1 = {\n                    enumerable: !0,\n                    get: function() {\n                        return t1[n1];\n                    }\n                }), Object.defineProperty(e1, r1, o1);\n            } : function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1), e1[r1] = t1[n1];\n            }), o1 = this && this.__setModuleDefault || (Object.create ? function(e1, t1) {\n                Object.defineProperty(e1, \"default\", {\n                    enumerable: !0,\n                    value: t1\n                });\n            } : function(e1, t1) {\n                e1.default = t1;\n            }), i1 = this && this.__importStar || function(e1) {\n                if (e1 && e1.__esModule) return e1;\n                var t1 = {};\n                if (null != e1) for(var n1 in e1)\"default\" !== n1 && Object.prototype.hasOwnProperty.call(e1, n1) && r1(t1, e1, n1);\n                return o1(t1, e1), t1;\n            };\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.WEBGL_OP_RESOLVE_RULES = void 0;\n            const s1 = n1(8817), a1 = i1(n1(5194)), u1 = n1(4752), l1 = n1(6668), c1 = n1(9754), p1 = n1(5042), d1 = n1(6742), f1 = n1(4125), h1 = n1(6149), g1 = n1(5378), b1 = n1(6981), m1 = n1(7413), y1 = n1(7006), _1 = n1(8276), v1 = n1(5565), T1 = n1(2834), x1 = n1(1010), w1 = n1(8126), O1 = n1(2801), S1 = n1(565), A1 = n1(2444), P1 = n1(815), I1 = n1(564), E1 = n1(5416), D1 = n1(1240), $1 = n1(5944), k1 = n1(5707), F1 = i1(n1(9087)), N1 = n1(7862), L1 = n1(3980);\n            t1.WEBGL_OP_RESOLVE_RULES = [\n                [\n                    \"Abs\",\n                    \"\",\n                    \"6+\",\n                    F1.abs\n                ],\n                [\n                    \"Acos\",\n                    \"\",\n                    \"7+\",\n                    F1.acos\n                ],\n                [\n                    \"Add\",\n                    \"\",\n                    \"7+\",\n                    a1.add\n                ],\n                [\n                    \"And\",\n                    \"\",\n                    \"7+\",\n                    a1.and\n                ],\n                [\n                    \"Asin\",\n                    \"\",\n                    \"7+\",\n                    F1.asin\n                ],\n                [\n                    \"Atan\",\n                    \"\",\n                    \"7+\",\n                    F1.atan\n                ],\n                [\n                    \"AveragePool\",\n                    \"\",\n                    \"7+\",\n                    T1.averagePool,\n                    T1.parseAveragePoolAttributes\n                ],\n                [\n                    \"BatchNormalization\",\n                    \"\",\n                    \"7+\",\n                    s1.batchNormalization,\n                    s1.parseBatchNormalizationAttributes\n                ],\n                [\n                    \"Cast\",\n                    \"\",\n                    \"6+\",\n                    u1.cast,\n                    u1.parseCastAttributes\n                ],\n                [\n                    \"Ceil\",\n                    \"\",\n                    \"6+\",\n                    F1.ceil\n                ],\n                [\n                    \"Clip\",\n                    \"\",\n                    \"6-10\",\n                    F1.clip,\n                    F1.parseClipAttributes\n                ],\n                [\n                    \"Clip\",\n                    \"\",\n                    \"11+\",\n                    F1.clipV11\n                ],\n                [\n                    \"Concat\",\n                    \"\",\n                    \"4+\",\n                    l1.concat,\n                    l1.parseConcatAttributes\n                ],\n                [\n                    \"Conv\",\n                    \"\",\n                    \"1+\",\n                    c1.conv,\n                    c1.parseConvAttributes\n                ],\n                [\n                    \"ConvTranspose\",\n                    \"\",\n                    \"1+\",\n                    p1.convTranspose,\n                    p1.parseConvTransposeAttributes\n                ],\n                [\n                    \"Cos\",\n                    \"\",\n                    \"7+\",\n                    F1.cos\n                ],\n                [\n                    \"Div\",\n                    \"\",\n                    \"7+\",\n                    a1.div\n                ],\n                [\n                    \"Dropout\",\n                    \"\",\n                    \"7+\",\n                    F1.identity\n                ],\n                [\n                    \"DepthToSpace\",\n                    \"\",\n                    \"1+\",\n                    d1.depthToSpace,\n                    d1.parseDepthToSpaceAttributes\n                ],\n                [\n                    \"Equal\",\n                    \"\",\n                    \"7+\",\n                    a1.equal\n                ],\n                [\n                    \"Elu\",\n                    \"\",\n                    \"6+\",\n                    F1.elu,\n                    F1.parseEluAttributes\n                ],\n                [\n                    \"Exp\",\n                    \"\",\n                    \"6+\",\n                    F1.exp\n                ],\n                [\n                    \"Flatten\",\n                    \"\",\n                    \"1+\",\n                    f1.flatten,\n                    f1.parseFlattenAttributes\n                ],\n                [\n                    \"Floor\",\n                    \"\",\n                    \"6+\",\n                    F1.floor\n                ],\n                [\n                    \"FusedConv\",\n                    \"com.microsoft\",\n                    \"1+\",\n                    c1.conv,\n                    c1.parseConvAttributes\n                ],\n                [\n                    \"Gather\",\n                    \"\",\n                    \"1+\",\n                    h1.gather,\n                    h1.parseGatherAttributes\n                ],\n                [\n                    \"Gemm\",\n                    \"\",\n                    \"7-10\",\n                    g1.gemm,\n                    g1.parseGemmAttributesV7\n                ],\n                [\n                    \"Gemm\",\n                    \"\",\n                    \"11+\",\n                    g1.gemm,\n                    g1.parseGemmAttributesV11\n                ],\n                [\n                    \"GlobalAveragePool\",\n                    \"\",\n                    \"1+\",\n                    T1.globalAveragePool,\n                    T1.parseGlobalAveragePoolAttributes\n                ],\n                [\n                    \"GlobalMaxPool\",\n                    \"\",\n                    \"1+\",\n                    T1.globalMaxPool\n                ],\n                [\n                    \"Greater\",\n                    \"\",\n                    \"7+\",\n                    a1.greater\n                ],\n                [\n                    \"Identity\",\n                    \"\",\n                    \"1+\",\n                    F1.identity\n                ],\n                [\n                    \"ImageScaler\",\n                    \"\",\n                    \"1+\",\n                    b1.imageScaler,\n                    b1.parseImageScalerAttributes\n                ],\n                [\n                    \"InstanceNormalization\",\n                    \"\",\n                    \"6+\",\n                    m1.instanceNormalization,\n                    m1.parseInstanceNormalizationAttributes\n                ],\n                [\n                    \"LeakyRelu\",\n                    \"\",\n                    \"6+\",\n                    F1.leakyRelu,\n                    F1.parseLeakyReluAttributes\n                ],\n                [\n                    \"Less\",\n                    \"\",\n                    \"7+\",\n                    a1.less\n                ],\n                [\n                    \"LRN\",\n                    \"\",\n                    \"1+\",\n                    y1.lrn,\n                    y1.parseLrnAttributes\n                ],\n                [\n                    \"Log\",\n                    \"\",\n                    \"6+\",\n                    F1.log\n                ],\n                [\n                    \"MatMul\",\n                    \"\",\n                    \"1+\",\n                    _1.matMul,\n                    _1.parseMatMulAttributes\n                ],\n                [\n                    \"MaxPool\",\n                    \"\",\n                    \"1+\",\n                    T1.maxPool,\n                    T1.parseMaxPoolAttributes\n                ],\n                [\n                    \"Mul\",\n                    \"\",\n                    \"7+\",\n                    a1.mul\n                ],\n                [\n                    \"Neg\",\n                    \"\",\n                    \"6+\",\n                    F1.neg\n                ],\n                [\n                    \"Not\",\n                    \"\",\n                    \"1+\",\n                    F1.not\n                ],\n                [\n                    \"Or\",\n                    \"\",\n                    \"7+\",\n                    a1.or\n                ],\n                [\n                    \"Pad\",\n                    \"\",\n                    \"2-10\",\n                    v1.padV2,\n                    v1.parsePadAttributesV2\n                ],\n                [\n                    \"Pad\",\n                    \"\",\n                    \"11+\",\n                    v1.padV11,\n                    v1.parsePadAttributesV11\n                ],\n                [\n                    \"Pow\",\n                    \"\",\n                    \"7+\",\n                    a1.pow\n                ],\n                [\n                    \"PRelu\",\n                    \"\",\n                    \"7+\",\n                    a1.pRelu\n                ],\n                [\n                    \"ReduceLogSum\",\n                    \"\",\n                    \"1+\",\n                    x1.reduceLogSum,\n                    x1.parseReduceAttributes\n                ],\n                [\n                    \"ReduceMax\",\n                    \"\",\n                    \"1+\",\n                    x1.reduceMax,\n                    x1.parseReduceAttributes\n                ],\n                [\n                    \"ReduceMean\",\n                    \"\",\n                    \"1+\",\n                    x1.reduceMean,\n                    x1.parseReduceAttributes\n                ],\n                [\n                    \"ReduceMin\",\n                    \"\",\n                    \"1+\",\n                    x1.reduceMin,\n                    x1.parseReduceAttributes\n                ],\n                [\n                    \"ReduceProd\",\n                    \"\",\n                    \"1+\",\n                    x1.reduceProd,\n                    x1.parseReduceAttributes\n                ],\n                [\n                    \"ReduceSum\",\n                    \"\",\n                    \"1-12\",\n                    x1.reduceSum,\n                    x1.parseReduceAttributes\n                ],\n                [\n                    \"ReduceSumSquare\",\n                    \"\",\n                    \"1+\",\n                    x1.reduceLogSumSquare,\n                    x1.parseReduceAttributes\n                ],\n                [\n                    \"Relu\",\n                    \"\",\n                    \"6+\",\n                    F1.relu\n                ],\n                [\n                    \"Reshape\",\n                    \"\",\n                    \"5+\",\n                    w1.reshape\n                ],\n                [\n                    \"Resize\",\n                    \"\",\n                    \"10\",\n                    O1.resize,\n                    O1.parseResizeAttributesV10\n                ],\n                [\n                    \"Resize\",\n                    \"\",\n                    \"11+\",\n                    O1.resize,\n                    O1.parseResizeAttributesV11\n                ],\n                [\n                    \"Shape\",\n                    \"\",\n                    \"1+\",\n                    S1.shape\n                ],\n                [\n                    \"Sigmoid\",\n                    \"\",\n                    \"6+\",\n                    F1.sigmoid\n                ],\n                [\n                    \"Sin\",\n                    \"\",\n                    \"7+\",\n                    F1.sin\n                ],\n                [\n                    \"Slice\",\n                    \"\",\n                    \"10+\",\n                    A1.sliceV10\n                ],\n                [\n                    \"Slice\",\n                    \"\",\n                    \"1-9\",\n                    A1.slice,\n                    A1.parseSliceAttributes\n                ],\n                [\n                    \"Softmax\",\n                    \"\",\n                    \"1-12\",\n                    P1.softmax,\n                    P1.parseSoftmaxAttributes\n                ],\n                [\n                    \"Softmax\",\n                    \"\",\n                    \"13+\",\n                    P1.softmaxV13,\n                    P1.parseSoftmaxAttributesV13\n                ],\n                [\n                    \"Split\",\n                    \"\",\n                    \"2-12\",\n                    I1.split,\n                    I1.parseSplitAttributes\n                ],\n                [\n                    \"Sqrt\",\n                    \"\",\n                    \"6+\",\n                    F1.sqrt\n                ],\n                [\n                    \"Squeeze\",\n                    \"\",\n                    \"1-12\",\n                    E1.squeeze,\n                    E1.parseSqueezeAttributes\n                ],\n                [\n                    \"Squeeze\",\n                    \"\",\n                    \"13+\",\n                    E1.squeezeV13\n                ],\n                [\n                    \"Sub\",\n                    \"\",\n                    \"7+\",\n                    a1.sub\n                ],\n                [\n                    \"Sum\",\n                    \"\",\n                    \"6+\",\n                    D1.sum\n                ],\n                [\n                    \"Tan\",\n                    \"\",\n                    \"7+\",\n                    F1.tan\n                ],\n                [\n                    \"Tanh\",\n                    \"\",\n                    \"6+\",\n                    F1.tanh\n                ],\n                [\n                    \"Tile\",\n                    \"\",\n                    \"6+\",\n                    $1.tile\n                ],\n                [\n                    \"Transpose\",\n                    \"\",\n                    \"1+\",\n                    k1.transpose,\n                    k1.parseTransposeAttributes\n                ],\n                [\n                    \"Upsample\",\n                    \"\",\n                    \"7-8\",\n                    L1.upsample,\n                    L1.parseUpsampleAttributesV7\n                ],\n                [\n                    \"Upsample\",\n                    \"\",\n                    \"9\",\n                    L1.upsample,\n                    L1.parseUpsampleAttributesV9\n                ],\n                [\n                    \"Unsqueeze\",\n                    \"\",\n                    \"1-12\",\n                    N1.unsqueeze,\n                    N1.parseUnsqueezeAttributes\n                ],\n                [\n                    \"Unsqueeze\",\n                    \"\",\n                    \"13+\",\n                    N1.unsqueezeV13\n                ],\n                [\n                    \"Xor\",\n                    \"\",\n                    \"7+\",\n                    a1.xor\n                ]\n            ];\n        },\n        8817: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseBatchNormalizationAttributes = t1.batchNormalization = void 0;\n            const r1 = n1(4910), o1 = n1(6757), i1 = n1(5639), s1 = {\n                name: \"BatchNormalization\",\n                inputNames: [\n                    \"A\",\n                    \"Scale\",\n                    \"B\",\n                    \"Mean\",\n                    \"Variance\"\n                ],\n                inputTypes: [\n                    i1.TextureType.unpacked,\n                    i1.TextureType.unpacked,\n                    i1.TextureType.unpacked,\n                    i1.TextureType.unpacked,\n                    i1.TextureType.unpacked\n                ]\n            };\n            t1.batchNormalization = (e1, t1, n1)=>(u1(t1), [\n                    e1.run(Object.assign(Object.assign({}, s1), {\n                        cacheHint: n1.cacheKey,\n                        get: ()=>a1(e1, t1, n1)\n                    }), t1)\n                ]), t1.parseBatchNormalizationAttributes = (e1)=>{\n                const t1 = e1.attributes.getFloat(\"epsilon\", 1e-5), n1 = e1.attributes.getFloat(\"momentum\", .9), o1 = e1.attributes.getInt(\"spatial\", 1);\n                return (0, r1.createAttributeWithCacheKey)({\n                    epsilon: t1,\n                    momentum: n1,\n                    spatial: o1\n                });\n            };\n            const a1 = (e1, t1, n1)=>{\n                const r1 = (0, o1.getGlsl)(e1.session.backend.glContext.version), a1 = t1[0].dims.length, [u1, l1] = e1.calculateTextureWidthAndHeight(t1[1].dims, i1.TextureType.unpacked), c1 = `\\n  float process(int[${a1}] indices) {\\n    vec2 position = offsetToCoords(indices[1], ${u1}, ${l1});\\n    float scale = getColorAsFloat(${r1.texture2D}(Scale, position));\\n    float mean = getColorAsFloat(${r1.texture2D}(Mean, position));\\n    float variance = getColorAsFloat(${r1.texture2D}(Variance, position));\\n    float b = getColorAsFloat(${r1.texture2D}(B, position));\\n\\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n1.epsilon})) ) + b;\\n  }`;\n                return Object.assign(Object.assign({}, s1), {\n                    output: {\n                        dims: t1[0].dims,\n                        type: t1[0].type,\n                        textureType: i1.TextureType.unpacked\n                    },\n                    shaderSource: c1\n                });\n            }, u1 = (e1)=>{\n                if (!e1 || 5 !== e1.length) throw new Error(\"BatchNormalization requires 5 inputs.\");\n                const t1 = e1[0], n1 = e1[1], r1 = e1[2], o1 = e1[3], i1 = e1[4];\n                if (t1.dims.length < 3 || 1 !== n1.dims.length || 1 !== r1.dims.length || 1 !== o1.dims.length || 1 !== i1.dims.length) throw new Error(\"invalid input shape.\");\n                if (n1.dims[0] !== t1.dims[1] || r1.dims[0] !== t1.dims[1] || o1.dims[0] !== t1.dims[1] || i1.dims[0] !== t1.dims[1]) throw new Error(\"invalid input shape.\");\n                if (\"float32\" !== t1.type && \"float64\" !== t1.type || \"float32\" !== n1.type && \"float64\" !== n1.type || \"float32\" !== r1.type && \"float64\" !== r1.type || \"float32\" !== o1.type && \"float64\" !== o1.type || \"float32\" !== i1.type && \"float64\" !== i1.type) throw new Error(\"invalid input tensor types.\");\n            };\n        },\n        5194: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.xor = t1.sub = t1.pRelu = t1.pow = t1.or = t1.mul = t1.less = t1.greater = t1.equal = t1.div = t1.and = t1.add = t1.glslPRelu = t1.glslPow = t1.glslXor = t1.glslOr = t1.glslAnd = t1.glslLess = t1.glslGreater = t1.glslEqual = t1.glslSub = t1.glslMul = t1.glslDiv = t1.glslAdd = void 0;\n            const r1 = n1(7273), o1 = n1(1997), i1 = n1(6757), s1 = n1(5639);\n            function a1() {\n                const e1 = \"add_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return a + b;\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    return v1 + v2;\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function u1() {\n                const e1 = \"div_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return a / b;\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    return v1 / v2;\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function l1() {\n                const e1 = \"mul_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return a * b;\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    return v1 * v2;\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function c1() {\n                const e1 = \"sub_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return a - b;\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    return v1 - v2;\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function p1() {\n                const e1 = \"equal_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return float(a == b);\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    return vec4(equal(v1, v2));\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function d1() {\n                const e1 = \"greater_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return float(a > b);\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r > v2.r ,\\n      v1.g > v2.g,\\n      v1.b > v2.b,\\n      v1.a > v2.a );\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function f1() {\n                const e1 = \"less_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return float(a < b);\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    return vec4( v1.r < v2.r ,\\n                v1.g < v2.g,\\n                v1.b < v2.b,\\n                v1.a < v2.a );\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function h1() {\n                const e1 = \"and_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return float( bool(a) && bool(b) );\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r && b2.r ,\\n                b1.g && b2.g,\\n                b1.b && b2.b,\\n                b1.a && b2.a );\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function g1() {\n                const e1 = \"or_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return float( bool(a) || bool(b) );\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r || b2.r ,\\n                b1.g || b2.g,\\n                b1.b || b2.b,\\n                b1.a || b2.a );\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function b1() {\n                const e1 = \"xor_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return float( bool(a) ^^ bool(b) );\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    bvec4 b1 = bvec4(v1);\\n    bvec4 b2 = bvec4(v2);\\n    return vec4( b1.r ^^ b2.r ,\\n                b1.g ^^ b2.g,\\n                b1.b ^^ b2.b,\\n                b1.a ^^ b2.a );\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            function m1() {\n                return function(e1) {\n                    const t1 = `${e1}_`;\n                    return {\n                        body: `\\n  float ${t1}(float a, float b) {\\n    return ${e1}(a, b);\\n  }\\n  vec4 ${t1}(vec4 v1, vec4 v2) {\\n    return ${e1}(v1, v2);\\n  }\\n  `,\n                        name: t1,\n                        type: o1.FunctionType.ValueBased\n                    };\n                }(\"pow\");\n            }\n            function y1() {\n                const e1 = \"prelu_\";\n                return {\n                    body: `\\n  float ${e1}(float a, float b) {\\n    return a < 0.0 ? a * b: a;\\n  }\\n  vec4 ${e1}(vec4 v1, vec4 v2) {\\n    return vec4(\\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\\n      );\\n  }\\n  `,\n                    name: e1,\n                    type: o1.FunctionType.ValueBased\n                };\n            }\n            t1.glslAdd = a1, t1.glslDiv = u1, t1.glslMul = l1, t1.glslSub = c1, t1.glslEqual = p1, t1.glslGreater = d1, t1.glslLess = f1, t1.glslAnd = h1, t1.glslOr = g1, t1.glslXor = b1, t1.glslPow = m1, t1.glslPRelu = y1;\n            const _1 = (e1, t1, n1, r1 = t1[0].type, o1)=>{\n                const i1 = e1.session.pack ? s1.TextureType.packed : s1.TextureType.unpacked;\n                return {\n                    name: n1.name,\n                    inputNames: [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: [\n                        i1,\n                        i1\n                    ],\n                    cacheHint: o1,\n                    get: ()=>v1(e1, t1, n1, r1)\n                };\n            }, v1 = (e1, t1, n1, o1 = t1[0].type)=>{\n                const a1 = e1.session.pack ? s1.TextureType.packed : s1.TextureType.unpacked, u1 = !r1.ShapeUtil.areEqual(t1[0].dims, t1[1].dims);\n                let l1 = t1[0].dims;\n                const c1 = e1.session.pack;\n                if (u1) {\n                    const s1 = r1.BroadcastUtil.calcShape(t1[0].dims, t1[1].dims, !1);\n                    if (!s1) throw new Error(\"Can't perform binary op on the given tensors\");\n                    l1 = s1;\n                    const u1 = l1.length, p1 = 0 !== t1[0].dims.length ? t1[0].dims.length : 1, d1 = 0 !== t1[1].dims.length ? t1[1].dims.length : 1, f1 = 0 !== t1[0].dims.length ? \"bcastIndices_A(indices, aindices);\" : \"aindices[0] = 0;\", h1 = 0 !== t1[1].dims.length ? \"bcastIndices_B(indices, bindices);\" : \"bindices[0] = 0;\", g1 = (0, i1.getGlsl)(e1.session.backend.glContext.version), b1 = c1 ? `\\n      ${n1.body}\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n        vec4 result = ${n1.name}(a, b);\\n        ${g1.output} = result;\\n      }` : `\\n      ${n1.body}\\n      float process(int indices[${u1}]) {\\n        int aindices[${p1}];\\n        int bindices[${d1}];\\n        ${f1}\\n        ${h1}\\n        return ${n1.name}(_A(aindices), _B(bindices));\\n      }`;\n                    return {\n                        name: n1.name,\n                        inputNames: [\n                            \"A\",\n                            \"B\"\n                        ],\n                        inputTypes: [\n                            a1,\n                            a1\n                        ],\n                        output: {\n                            dims: l1,\n                            type: o1,\n                            textureType: a1\n                        },\n                        shaderSource: b1,\n                        hasMain: c1\n                    };\n                }\n                const p1 = (0, i1.getGlsl)(e1.session.backend.glContext.version), d1 = `\\n    ${n1.body}\\n    void main() {\\n      vec4 v1 = ${p1.texture2D}(A, TexCoords);\\n      vec4 v2 = ${p1.texture2D}(B, TexCoords);\\n      vec4 result = ${n1.name}(v1, v2);\\n      ${p1.output} = result;\\n    }\\n    `;\n                return {\n                    name: n1.name,\n                    inputNames: [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: [\n                        a1,\n                        a1\n                    ],\n                    output: {\n                        dims: t1[0].dims,\n                        type: o1,\n                        textureType: a1\n                    },\n                    shaderSource: d1,\n                    hasMain: !0\n                };\n            };\n            t1.add = (e1, t1)=>[\n                    e1.run(_1(e1, t1, a1()), t1)\n                ], t1.and = (e1, t1)=>[\n                    e1.run(_1(e1, t1, h1(), \"bool\"), t1)\n                ], t1.div = (e1, t1)=>[\n                    e1.run(_1(e1, t1, u1()), t1)\n                ], t1.equal = (e1, t1)=>[\n                    e1.run(_1(e1, t1, p1(), \"bool\"), t1)\n                ], t1.greater = (e1, t1)=>[\n                    e1.run(_1(e1, t1, d1(), \"bool\"), t1)\n                ], t1.less = (e1, t1)=>[\n                    e1.run(_1(e1, t1, f1(), \"bool\"), t1)\n                ], t1.mul = (e1, t1)=>[\n                    e1.run(_1(e1, t1, l1()), t1)\n                ], t1.or = (e1, t1)=>[\n                    e1.run(_1(e1, t1, g1(), \"bool\"), t1)\n                ], t1.pow = (e1, t1)=>[\n                    e1.run(_1(e1, t1, m1()), t1)\n                ], t1.pRelu = (e1, t1)=>[\n                    e1.run(_1(e1, t1, y1()), t1)\n                ], t1.sub = (e1, t1)=>[\n                    e1.run(_1(e1, t1, c1()), t1)\n                ], t1.xor = (e1, t1)=>[\n                    e1.run(_1(e1, t1, b1(), \"bool\"), t1)\n                ];\n        },\n        4752: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseCastAttributes = t1.cast = void 0;\n            const r1 = n1(7273);\n            t1.cast = (e1, t1, n1)=>(o1(t1), [\n                    e1.cast(t1[0], n1)\n                ]), t1.parseCastAttributes = (e1)=>r1.ProtoUtil.tensorDataTypeFromProto(e1.attributes.getInt(\"to\"));\n            const o1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Cast requires 1 input.\");\n                if (\"string\" === e1[0].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        4595: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createPackedConcatProgramInfoLoader = void 0;\n            const r1 = n1(6757), o1 = n1(5639), i1 = n1(432), s1 = n1(5614);\n            t1.createPackedConcatProgramInfoLoader = (e1, t1, n1)=>{\n                const u1 = (l1 = t1.length, c1 = n1.cacheKey, {\n                    name: \"Concat (packed)\",\n                    inputNames: Array.from({\n                        length: l1\n                    }, (e1, t1)=>`X${t1}`),\n                    inputTypes: Array(l1).fill(o1.TextureType.packed),\n                    cacheHint: c1\n                });\n                var l1, c1;\n                return Object.assign(Object.assign({}, u1), {\n                    get: ()=>((e1, t1, n1, u1)=>{\n                            const l1 = n1[0].dims.slice();\n                            if (u1 >= l1.length || u1 < -1 * l1.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n                            u1 < 0 && (u1 = l1.length + u1);\n                            const c1 = l1.slice(0);\n                            for(let e1 = 1; e1 < n1.length; e1++){\n                                const t1 = n1[e1].dims.slice();\n                                for(let e1 = 0; e1 < l1.length; e1++)if (e1 === u1) c1[u1] += t1[e1];\n                                else if (l1[e1] !== t1[e1]) throw new Error(\"non concat dimensions must match\");\n                            }\n                            const p1 = c1.length, d1 = (0, s1.getChannels)(\"coords\", p1), f1 = (0, i1.getCoordsDataType)(p1), h1 = (0, s1.unpackFromChannel)(), g1 = n1.map((e1)=>e1.dims), b1 = (0, i1.getGlChannels)(p1), m1 = new Array(g1.length - 1);\n                            m1[0] = g1[0][u1];\n                            for(let e1 = 1; e1 < m1.length; e1++)m1[e1] = m1[e1 - 1] + g1[e1][u1];\n                            const y1 = b1[u1], _1 = b1.slice(-2), v1 = b1.join();\n                            let T1 = `if (${y1} < ${m1[0]}) {\\n        return getChannel(\\n            getX0(${v1}), vec2(${_1.join()}));\\n        }`;\n                            for(let e1 = 1; e1 < m1.length; e1++){\n                                const t1 = m1[e1 - 1];\n                                T1 += `\\n            if (${y1} < ${m1[e1]}  && ${y1} >= ${m1[e1 - 1]}) {\\n              return getChannel(\\n                getX${e1}(${a1(b1, y1, t1)}),\\n                vec2(${a1(_1, y1, t1)}));\\n            }`;\n                            }\n                            const x1 = m1.length, w1 = m1[m1.length - 1];\n                            T1 += `\\n            return getChannel(\\n              getX${x1}(${a1(b1, y1, w1)}),\\n              vec2(${a1(_1, y1, w1)}));`;\n                            const O1 = (0, r1.getGlsl)(e1.session.backend.glContext.version), S1 = `\\n          ${h1}\\n          float getValue(${b1.map((e1)=>\"int \" + e1)}) {\\n            ${T1}\\n          }\\n\\n          void main() {\\n            ${f1} coords = getOutputCoords();\\n            int lastDim = coords.${b1[p1 - 1]};\\n            coords.${b1[p1 - 1]} = coords.${b1[p1 - 2]};\\n            coords.${b1[p1 - 2]} = lastDim;\\n\\n            vec4 result = vec4(getValue(${d1}), 0., 0., 0.);\\n\\n            ${d1[p1 - 1]} = ${d1[p1 - 1]} + 1;\\n            if (${d1[p1 - 1]} < ${c1[p1 - 1]}) {\\n              result.g = getValue(${d1});\\n            }\\n\\n            ${d1[p1 - 2]} = ${d1[p1 - 2]} + 1;\\n            if (${d1[p1 - 2]} < ${c1[p1 - 2]}) {\\n              result.a = getValue(${d1});\\n            }\\n\\n            ${d1[p1 - 1]} = ${d1[p1 - 1]} - 1;\\n            if (${d1[p1 - 2]} < ${c1[p1 - 2]} &&\\n                ${d1[p1 - 1]} < ${c1[p1 - 1]}) {\\n              result.b = getValue(${d1});\\n            }\\n            ${O1.output} = result;\\n          }\\n        `;\n                            return Object.assign(Object.assign({}, t1), {\n                                output: {\n                                    dims: c1,\n                                    type: n1[0].type,\n                                    textureType: o1.TextureType.packed\n                                },\n                                shaderSource: S1,\n                                hasMain: !0\n                            });\n                        })(e1, u1, t1, n1.axis)\n                });\n            };\n            const a1 = (e1, t1, n1)=>{\n                const r1 = e1.indexOf(t1);\n                return e1.map((e1, t1)=>t1 === r1 ? `${e1} - ${n1}` : e1).join();\n            };\n        },\n        6668: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseConcatAttributes = t1.concat = void 0;\n            const r1 = n1(4910), o1 = n1(5639), i1 = n1(4595);\n            t1.concat = (e1, t1, n1)=>(p1(t1), e1.session.pack && t1[0].dims.length > 1 ? [\n                    e1.run((0, i1.createPackedConcatProgramInfoLoader)(e1, t1, n1), t1)\n                ] : [\n                    e1.run(s1(e1, t1, n1), t1)\n                ]);\n            const s1 = (e1, t1, n1)=>{\n                const r1 = (i1 = t1.length, s1 = n1.cacheKey, {\n                    name: \"Concat\",\n                    inputNames: Array.from({\n                        length: i1\n                    }, (e1, t1)=>`X${t1}`),\n                    inputTypes: Array(i1).fill(o1.TextureType.unpacked),\n                    cacheHint: s1\n                });\n                var i1, s1;\n                return Object.assign(Object.assign({}, r1), {\n                    get: ()=>((e1, t1, n1, r1)=>{\n                            const i1 = n1[0].dims.slice();\n                            if (r1 >= i1.length || r1 < -1 * i1.length) throw new Error(\"axis specified for concat doesn't match input dimensionality\");\n                            r1 < 0 && (r1 = i1.length + r1);\n                            const s1 = i1.slice(0);\n                            for(let e1 = 1; e1 < n1.length; e1++){\n                                const t1 = n1[e1].dims.slice();\n                                for(let e1 = 0; e1 < i1.length; e1++)if (e1 === r1) s1[r1] += t1[e1];\n                                else if (i1[e1] !== t1[e1]) throw new Error(\"non concat dimensions must match\");\n                            }\n                            const p1 = s1.length, d1 = new Array(n1.length);\n                            let f1 = 0;\n                            for(let e1 = 0; e1 < d1.length; ++e1)f1 += n1[e1].dims[r1], d1[e1] = f1;\n                            let h1 = \"\";\n                            h1 = n1.length < 5 ? a1(d1) : u1(d1);\n                            const g1 = `\\n        ${l1(n1.length, p1)}\\n        ${c1(d1)}\\n        ${h1}\\n        float process(int indices[${p1}]) {\\n          int textureIndex = getTextureWhereDataResides (indices[${r1}]);\\n\\n          if(textureIndex != 0) {\\n            indices[${r1}] = indices[${r1}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\\n          }\\n\\n          return fetchDataFromCorrectTexture(textureIndex, indices);\\n        }`;\n                            return Object.assign(Object.assign({}, t1), {\n                                output: {\n                                    dims: s1,\n                                    type: n1[0].type,\n                                    textureType: o1.TextureType.unpacked\n                                },\n                                shaderSource: g1\n                            });\n                        })(0, r1, t1, n1.axis)\n                });\n            }, a1 = (e1)=>{\n                const t1 = e1.map((e1, t1)=>`if(index<${e1}) {return ${t1};}\\n`);\n                return `int getTextureWhereDataResides(int index) {\\n      ${t1.join(\"\")}\\n    }`;\n            }, u1 = (e1)=>a1(e1), l1 = (e1, t1)=>{\n                const n1 = [\n                    `float fetchDataFromCorrectTexture(int textureIndex, int indices[${t1}]) {`\n                ];\n                for(let t1 = 0; t1 < e1; ++t1)0 === t1 ? n1.push(`\\tif (textureIndex == ${t1}) { return _X${t1}(indices); }`) : t1 === e1 - 1 ? n1.push(`\\telse { return _X${t1}(indices); }`) : n1.push(`\\telse if (textureIndex == ${t1}) { return _X${t1}(indices); }`);\n                return n1.push(\"\t}\"), n1.join(\"\\n\");\n            }, c1 = (e1)=>{\n                const t1 = [\n                    \"int getSizeInConcatAxisValueFromIndex(int index) {\"\n                ];\n                for(let n1 = 0; n1 < e1.length; ++n1)0 === n1 ? t1.push(`\\tif (index == ${n1}) { return ${e1[n1]}; }`) : n1 === e1.length - 1 ? t1.push(`\\telse { return ${e1[n1]}; }`) : t1.push(`\\telse if (index == ${n1}) { return ${e1[n1]}; }`);\n                return t1.push(\"\t}\"), t1.join(\"\\n\");\n            };\n            t1.parseConcatAttributes = (e1)=>(0, r1.createAttributeWithCacheKey)({\n                    axis: e1.attributes.getInt(\"axis\")\n                });\n            const p1 = (e1)=>{\n                if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n                const t1 = e1[0].type, n1 = e1[0].dims.length;\n                if (\"string\" === t1) throw new Error(\"string tensor is not supported yet\");\n                for (const r1 of e1){\n                    if (r1.type !== t1) throw new Error(\"input tensors should be one type\");\n                    if (r1.dims.length !== n1) throw new Error(\"input tensors should have the same shape\");\n                }\n            };\n        },\n        7825: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createUnpackedGroupedConvProgramInfoLoader = void 0;\n            const r1 = n1(1315), o1 = n1(6757), i1 = n1(5639), s1 = n1(9754), a1 = n1(2150);\n            t1.createUnpackedGroupedConvProgramInfoLoader = (e1, t1, n1)=>{\n                const u1 = (l1 = t1.length > 2, c1 = n1.cacheKey, {\n                    name: \"GroupedConv\",\n                    inputNames: l1 ? [\n                        \"X\",\n                        \"W\",\n                        \"Bias\"\n                    ] : [\n                        \"X\",\n                        \"W\"\n                    ],\n                    inputTypes: l1 ? [\n                        i1.TextureType.unpacked,\n                        i1.TextureType.unpacked,\n                        i1.TextureType.unpacked\n                    ] : [\n                        i1.TextureType.unpacked,\n                        i1.TextureType.unpacked\n                    ],\n                    cacheHint: c1\n                });\n                var l1, c1;\n                return Object.assign(Object.assign({}, u1), {\n                    get: ()=>((e1, t1, n1, u1)=>{\n                            const l1 = t1.length > 2 ? \"value += getBias(output_channel);\" : \"\", c1 = t1[0].dims.slice(), p1 = t1[1].dims.slice(), d1 = p1[0] / u1.group;\n                            r1.Logger.verbose(\"GroupedConv\", `autpPad:${u1.autoPad}, dilations:${u1.dilations}, group:${u1.group}, kernelShape:${u1.kernelShape}, pads:${u1.pads}, strides:${u1.strides}`);\n                            const f1 = (0, s1.calculateOutputShape)(c1, p1, u1.dilations, u1.pads, u1.strides), h1 = (0, o1.getGlsl)(e1.session.backend.glContext.version), { activationFunction: g1, applyActivation: b1 } = (0, a1.getActivationSnippet)(u1), m1 = `\\n  const ivec2 strides = ivec2(${u1.strides[0]}, ${u1.strides[1]});\\n  const ivec2 pads = ivec2(${u1.pads[0]}, ${u1.pads[1]});\\n  ${g1}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n    ivec2 xRCCorner = coords.zw * strides - pads;\\n    int group_id = output_channel / ${d1};\\n\\n    float value = 0.0;\\n    for (int wInChannel = 0; wInChannel < ${p1[1]}; wInChannel++) {\\n      int input_channel = group_id * ${p1[1]} + wInChannel;\\n      for (int wHeight = 0; wHeight < ${p1[2]}; wHeight++) {\\n        int xHeight = xRCCorner.x + wHeight * ${u1.dilations[0]};\\n\\n        if (xHeight < 0 || xHeight >= ${c1[2]}) {\\n          continue;\\n        }\\n\\n        for (int wWidth = 0; wWidth < ${p1[3]}; wWidth++) {\\n          int xWidth = xRCCorner.y + wWidth * ${u1.dilations[1]};\\n          if (xWidth < 0 || xWidth >= ${c1[3]}) {\\n            continue;\\n          }\\n\\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\\n          value += xVal*wVal;\\n        }\\n      }\\n    }\\n    ${l1}\\n    ${b1}\\n    ${h1.output} = vec4(value, .0, .0, .0);\\n  }\\n`;\n                            return Object.assign(Object.assign({}, n1), {\n                                output: {\n                                    dims: f1,\n                                    type: t1[0].type,\n                                    textureType: i1.TextureType.unpacked\n                                },\n                                shaderSource: m1,\n                                hasMain: !0\n                            });\n                        })(e1, t1, u1, n1)\n                });\n            };\n        },\n        7708: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.conv2DPacked = t1.conv2DPackedPointwise = void 0;\n            const r1 = n1(9754), o1 = n1(5950), i1 = n1(5632);\n            t1.conv2DPackedPointwise = (e1, t1, n1)=>{\n                const o1 = t1[0].dims, s1 = t1[1].dims, a1 = (0, r1.calculateOutputShape)(o1, s1, n1.dilations, n1.pads, n1.strides), u1 = e1.reshapePacked(t1[0], [\n                    o1[1],\n                    o1[2] * o1[3]\n                ]), l1 = e1.reshapePacked(t1[1], [\n                    s1[0],\n                    s1[1]\n                ]), c1 = t1.length > 2 ? [\n                    l1,\n                    u1,\n                    t1[2]\n                ] : [\n                    l1,\n                    u1\n                ], p1 = e1.run((0, i1.createPackedMatmulProgramInfoLoader)(e1, c1, n1), c1);\n                return e1.reshapePacked(p1, a1);\n            }, t1.conv2DPacked = (e1, t1, n1)=>{\n                const s1 = t1[0].dims, a1 = t1[1].dims, u1 = (0, r1.calculateOutputShape)(s1, a1, n1.dilations, n1.pads, n1.strides), l1 = e1.run((0, o1.createPackedIm2ColProgramInfoLoader)(e1, t1[0], t1[1], u1, n1), [\n                    t1[0]\n                ]), c1 = e1.reshapePacked(t1[1], [\n                    a1[0],\n                    a1[1] * a1[2] * a1[3]\n                ]), p1 = 3 === t1.length ? [\n                    c1,\n                    l1,\n                    t1[2]\n                ] : [\n                    c1,\n                    l1\n                ], d1 = e1.run((0, i1.createPackedMatmulProgramInfoLoader)(e1, p1, n1), p1);\n                return e1.reshapePacked(d1, u1);\n            };\n        },\n        5042: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseConvTransposeAttributes = t1.convTranspose = void 0;\n            const r1 = n1(4910), o1 = n1(6757), i1 = n1(5639), s1 = n1(2150), a1 = (e1, t1, n1, r1, o1, i1)=>(e1 - 1) * t1 + n1 + (r1 - 1) * o1 + 1 - i1, u1 = (e1, t1, n1, r1, o1)=>{\n                const i1 = Math.floor(e1 / 2);\n                \"SAME_UPPER\" === t1 ? (n1[r1] = i1, n1[o1] = e1 - i1) : \"SAME_LOWER\" === t1 && (n1[r1] = e1 - i1, n1[o1] = i1);\n            };\n            t1.convTranspose = (e1, t1, n1)=>(d1(t1, n1), l1(e1, t1, n1));\n            const l1 = (e1, t1, n1)=>{\n                const r1 = p1(n1, t1);\n                return [\n                    c1(e1, t1, r1)\n                ];\n            }, c1 = (e1, t1, n1)=>e1.run(((e1, t1, n1)=>{\n                    const r1 = (a1 = t1.length > 2, u1 = n1.cacheKey, {\n                        name: \"ConvTranspose\",\n                        inputNames: a1 ? [\n                            \"X\",\n                            \"W\",\n                            \"B\"\n                        ] : [\n                            \"X\",\n                            \"W\"\n                        ],\n                        inputTypes: a1 ? [\n                            i1.TextureType.unpacked,\n                            i1.TextureType.unpacked,\n                            i1.TextureType.unpacked\n                        ] : [\n                            i1.TextureType.unpacked,\n                            i1.TextureType.unpacked\n                        ],\n                        cacheHint: u1\n                    });\n                    var a1, u1;\n                    return Object.assign(Object.assign({}, r1), {\n                        get: ()=>((e1, t1, n1, r1)=>{\n                                const a1 = t1.length > 2 ? \"getB(output_channel)\" : \"0.0\", u1 = t1[0].dims, l1 = t1[1].dims, c1 = l1[1], p1 = l1[0] / r1.group, d1 = [\n                                    t1[0].dims[0],\n                                    t1[1].dims[1] * r1.group,\n                                    ...r1.outputShape\n                                ], f1 = (0, o1.getGlsl)(e1.session.backend.glContext.version), { activationFunction: h1, applyActivation: g1 } = (0, s1.getActivationSnippet)(r1), b1 = `\\n  const ivec2 strides = ivec2(${r1.strides[0]}, ${r1.strides[1]});\\n  const ivec2 pads = ivec2(${r1.pads[0]}, ${r1.pads[1]});\\n  ${h1}\\n  void main() {\\n    ivec4 coords = getOutputCoords();\\n    int batch = coords.x;\\n    int output_channel = coords.y;\\n\\n    ivec2 loc = coords.zw + pads;\\n\\n    int group_id = output_channel / ${c1};\\n    int wOutChannel = output_channel - group_id * ${c1};\\n\\n    float value = ${a1};\\n    for (int inChannelOffset = 0; inChannelOffset < ${p1}; inChannelOffset++) {\\n      int input_channel = group_id * ${p1} + inChannelOffset;\\n      for (int wWOff = 0; wWOff < ${l1[2]}; wWOff++) {\\n        for (int wHOff = 0; wHOff < ${l1[3]}; wHOff++) {\\n          ivec2 wOff = ivec2(wWOff * ${r1.dilations[0]}, wHOff * ${r1.dilations[1]});\\n          ivec2 wLoc = loc - wOff;\\n          ivec2 wLocIn = wLoc / strides;\\n          if (\\n            wLocIn * strides == wLoc &&\\n            wLocIn.x >= 0 && wLocIn.x < ${u1[2]} &&\\n            wLocIn.y >= 0 && wLocIn.y < ${u1[3]}\\n          ) {\\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n    }\\n    ${g1}\\n    ${f1.output} = vec4(value, .0, .0, .0);\\n  }\\n`;\n                                return Object.assign(Object.assign({}, n1), {\n                                    output: {\n                                        dims: d1,\n                                        type: t1[0].type,\n                                        textureType: i1.TextureType.unpacked\n                                    },\n                                    shaderSource: b1,\n                                    hasMain: !0\n                                });\n                            })(e1, t1, r1, n1)\n                    });\n                })(e1, t1, n1), t1), p1 = (e1, t1)=>{\n                const n1 = e1.kernelShape.slice();\n                if (0 === e1.kernelShape.length) for(let e1 = 2; e1 < t1[1].dims.length; ++e1)n1.push(t1[1].dims[e1]);\n                const r1 = e1.pads.slice(), o1 = e1.outputShape.slice();\n                ((e1, t1, n1, r1, o1, i1, s1, l1)=>{\n                    const c1 = e1.length - 2, p1 = 0 === l1.length;\n                    for(let d1 = 0; d1 < c1; ++d1){\n                        const f1 = p1 ? e1[d1 + 2] * i1[d1] : l1[d1], h1 = a1(e1[d1 + 2], i1[d1], o1[d1], t1[d1], n1[d1], f1);\n                        u1(h1, r1, o1, d1, d1 + c1), p1 && l1.push(i1[d1] * (e1[d1 + 2] - 1) + s1[d1] + (t1[d1] - 1) * n1[d1] + 1 - o1[d1] - o1[d1 + c1]);\n                    }\n                })(t1[0].dims, n1, e1.dilations, e1.autoPad, r1, e1.strides, e1.outputPadding, o1);\n                const i1 = Object.assign({}, e1);\n                return Object.assign(i1, {\n                    kernelShape: n1,\n                    pads: r1,\n                    outputShape: o1,\n                    cacheKey: e1.cacheKey\n                }), i1;\n            };\n            t1.parseConvTransposeAttributes = (e1)=>{\n                const t1 = e1.attributes, n1 = (0, s1.parseInternalActivationAttributes)(t1), o1 = t1.getString(\"auto_pad\", \"NOTSET\"), i1 = t1.getInts(\"dilations\", [\n                    1,\n                    1\n                ]), a1 = t1.getInt(\"group\", 1), u1 = t1.getInts(\"kernel_shape\", []), l1 = t1.getInts(\"output_padding\", [\n                    0,\n                    0\n                ]), c1 = t1.getInts(\"output_shape\", []), p1 = t1.getInts(\"pads\", [\n                    0,\n                    0,\n                    0,\n                    0\n                ]), d1 = t1.getInts(\"strides\", [\n                    1,\n                    1\n                ]);\n                return (0, r1.createAttributeWithCacheKey)(Object.assign({\n                    autoPad: o1,\n                    dilations: i1,\n                    group: a1,\n                    kernelShape: u1,\n                    outputPadding: l1,\n                    outputShape: c1,\n                    pads: p1,\n                    strides: d1\n                }, n1));\n            };\n            const d1 = (e1, t1)=>{\n                if (!e1 || 2 !== e1.length && 3 !== e1.length) throw new Error(\"Conv requires 2 or 3 inputs\");\n                if (4 !== e1[0].dims.length || 4 !== e1[1].dims.length) throw new Error(\"currently only support 2-dimensional conv\");\n                if (e1[0].dims[1] !== e1[1].dims[0]) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n                const n1 = e1[1].dims[1] * t1.group;\n                if (3 === e1.length && (1 !== e1[2].dims.length || e1[2].dims[0] !== n1)) throw new Error(\"invalid bias\");\n                const r1 = e1[0].dims.length - 2;\n                if (t1.dilations.length !== r1) throw new Error(`dilations should be ${r1}D`);\n                if (t1.strides.length !== r1) throw new Error(`strides should be ${r1}D`);\n                if (t1.pads.length !== 2 * r1) throw new Error(`pads should be ${2 * r1}D`);\n                if (t1.outputPadding.length !== r1) throw new Error(`output_padding should be ${r1}D`);\n                if (0 !== t1.kernelShape.length && t1.kernelShape.length !== e1[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n                if (0 !== t1.outputShape.length && t1.outputShape.length !== e1[0].dims.length - 2) throw new Error(\"invalid output shape\");\n                if (\"float32\" !== e1[0].type || \"float32\" !== e1[1].type) throw new Error(\"ConvTranspose input(X,W) should be float tensor\");\n                if (3 === e1.length && \"float32\" !== e1[2].type) throw new Error(\"ConvTranspose input(bias) should be float tensor\");\n            };\n        },\n        9754: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseConvAttributes = t1.conv = t1.calculateOutputShape = void 0;\n            const r1 = n1(4910), o1 = n1(7273), i1 = n1(7825), s1 = n1(7708), a1 = n1(3281), u1 = n1(2150), l1 = n1(1625), c1 = n1(8276);\n            t1.calculateOutputShape = (e1, t1, n1, r1, o1)=>{\n                const i1 = e1[0], s1 = e1.slice(2), a1 = s1.length, u1 = t1[0], l1 = t1.slice(2).map((e1, t1)=>e1 + (e1 - 1) * (n1[t1] - 1)), c1 = s1.map((e1, t1)=>e1 + r1[t1] + r1[t1 + a1]), p1 = c1.map((e1, t1)=>Math.floor((e1 - l1[t1] + o1[t1]) / o1[t1]));\n                return [\n                    i1,\n                    u1\n                ].concat(...p1);\n            }, t1.conv = (e1, t1, n1)=>(g1(t1, n1), p1(e1, t1, n1));\n            const p1 = (e1, t1, n1)=>{\n                const r1 = h1(n1, t1), o1 = e1.session.pack, a1 = 1 === r1.kernelShape[0] && 1 === r1.kernelShape[1];\n                return r1.group > 1 ? [\n                    e1.run((0, i1.createUnpackedGroupedConvProgramInfoLoader)(e1, t1, r1), t1)\n                ] : a1 && o1 ? [\n                    d1(e1, t1, r1)\n                ] : o1 && 4 === t1[0].dims.length && 1 === t1[0].dims[0] && !a1 ? [\n                    (0, s1.conv2DPacked)(e1, t1, r1)\n                ] : [\n                    f1(e1, t1, r1)\n                ];\n            }, d1 = (e1, n1, r1)=>{\n                const o1 = n1[0].dims, i1 = n1[1].dims, s1 = (0, t1.calculateOutputShape)(o1, i1, r1.dilations, r1.pads, r1.strides), a1 = e1.reshapeUnpacked(n1[0], [\n                    o1[1],\n                    o1[2] * o1[3]\n                ]), u1 = e1.reshapeUnpacked(n1[1], [\n                    i1[0],\n                    i1[1]\n                ]), l1 = n1.length > 2 ? [\n                    u1,\n                    a1,\n                    n1[2]\n                ] : [\n                    u1,\n                    a1\n                ], p1 = e1.run((0, c1.createMatmulProgramInfoLoader)(l1, r1), l1);\n                return e1.reshapeUnpacked(p1, s1);\n            }, f1 = (e1, n1, r1)=>{\n                const o1 = n1[0].dims, i1 = n1[1].dims, s1 = (0, t1.calculateOutputShape)(o1, i1, r1.dilations, r1.pads, r1.strides), u1 = e1.run((0, l1.createIm2ColProgramInfoLoader)(e1, n1[0], n1[1], s1, r1), [\n                    n1[0]\n                ]), c1 = 3 === n1.length ? [\n                    u1,\n                    n1[1],\n                    n1[2]\n                ] : [\n                    u1,\n                    n1[1]\n                ];\n                return e1.run((0, a1.createDotProductProgramInfoLoader)(e1, n1, s1, r1), c1);\n            }, h1 = (e1, t1)=>{\n                const n1 = e1.kernelShape.slice();\n                if (0 === e1.kernelShape.length) for(let e1 = 2; e1 < t1[1].dims.length; ++e1)n1.push(t1[1].dims[e1]);\n                const r1 = e1.pads.slice();\n                o1.PoolConvUtil.adjustPadsBasedOnAutoPad(t1[0].dims, e1.strides, e1.dilations, n1, r1, e1.autoPad);\n                const i1 = Object.assign({}, e1);\n                return Object.assign(i1, {\n                    kernelShape: n1,\n                    pads: r1,\n                    cacheKey: e1.cacheKey\n                }), i1;\n            };\n            t1.parseConvAttributes = (e1)=>{\n                const t1 = e1.attributes, n1 = (0, u1.parseInternalActivationAttributes)(t1), o1 = t1.getString(\"auto_pad\", \"NOTSET\"), i1 = t1.getInts(\"dilations\", [\n                    1,\n                    1\n                ]), s1 = t1.getInt(\"group\", 1), a1 = t1.getInts(\"kernel_shape\", []), l1 = t1.getInts(\"pads\", [\n                    0,\n                    0,\n                    0,\n                    0\n                ]), c1 = t1.getInts(\"strides\", [\n                    1,\n                    1\n                ]);\n                return (0, r1.createAttributeWithCacheKey)(Object.assign({\n                    autoPad: o1,\n                    dilations: i1,\n                    group: s1,\n                    kernelShape: a1,\n                    pads: l1,\n                    strides: c1\n                }, n1));\n            };\n            const g1 = (e1, t1)=>{\n                if (!e1 || 2 !== e1.length && 3 !== e1.length) throw new Error(\"Conv requires 2 or 3 inputs\");\n                if (4 !== e1[0].dims.length || 4 !== e1[1].dims.length) throw new Error(\"currently only support 2-dimensional conv\");\n                if (e1[0].dims[1] !== e1[1].dims[1] * t1.group) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n                if (3 === e1.length && (1 !== e1[2].dims.length || e1[1].dims[0] !== e1[2].dims[0])) throw new Error(\"invalid bias\");\n                const n1 = e1[0].dims.length - 2;\n                if (t1.dilations.length !== n1) throw new Error(`dilations should be ${n1}D`);\n                if (t1.strides.length !== n1) throw new Error(`strides should be ${n1}D`);\n                if (t1.pads.length !== 2 * n1) throw new Error(`pads should be ${2 * n1}D`);\n                if (0 !== t1.kernelShape.length && t1.kernelShape.length !== e1[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n                if (\"float32\" !== e1[0].type || \"float32\" !== e1[1].type) throw new Error(\"Conv input(X,W) should be float tensor\");\n                if (3 === e1.length && \"float32\" !== e1[2].type) throw new Error(\"Conv input(bias) should be float tensor\");\n            };\n        },\n        6742: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseDepthToSpaceAttributes = t1.depthToSpace = void 0;\n            const r1 = n1(5707);\n            t1.depthToSpace = (e1, t1, n1)=>{\n                o1(t1);\n                const i1 = n1.blocksize, s1 = i1 * i1, a1 = \"DCR\" === n1.mode ? [\n                    0,\n                    3,\n                    4,\n                    1,\n                    5,\n                    2\n                ] : [\n                    0,\n                    1,\n                    4,\n                    2,\n                    5,\n                    3\n                ], u1 = \"DCR\" === n1.mode ? [\n                    t1[0].dims[0],\n                    i1,\n                    i1,\n                    t1[0].dims[1] / s1,\n                    t1[0].dims[2],\n                    t1[0].dims[3]\n                ] : [\n                    t1[0].dims[0],\n                    t1[0].dims[1] / s1,\n                    i1,\n                    i1,\n                    t1[0].dims[2],\n                    t1[0].dims[3]\n                ], l1 = e1.reshapeUnpacked(t1[0], u1), c1 = {\n                    perm: a1,\n                    cacheKey: `${a1}`\n                }, [p1] = (0, r1.transpose)(e1, [\n                    l1\n                ], c1), d1 = [\n                    t1[0].dims[0],\n                    t1[0].dims[1] / s1,\n                    t1[0].dims[2] * i1,\n                    t1[0].dims[3] * i1\n                ];\n                return [\n                    e1.reshapeUnpacked(p1, d1)\n                ];\n            }, t1.parseDepthToSpaceAttributes = (e1)=>{\n                const t1 = e1.attributes.getInt(\"blocksize\");\n                if (t1 < 1) throw new Error(`blocksize must be >= 1, but got : ${t1} for DepthToSpace`);\n                const n1 = e1.attributes.getString(\"mode\", \"DCR\");\n                if (\"DCR\" !== n1 && \"CRD\" !== n1) throw new Error(`unrecognized mode: ${n1} for DepthToSpace`);\n                return {\n                    mode: n1,\n                    blocksize: t1\n                };\n            };\n            const o1 = (e1)=>{\n                if (1 !== e1.length) throw new Error(`DepthToSpace expect 1 inputs, but got ${e1.length}`);\n                if (\"string\" === e1[0].type || 4 !== e1[0].dims.length) throw new TypeError(\"DepthToSpace input should be a 4-D numeric tensor\");\n            };\n        },\n        3281: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createDotProductProgramInfoLoader = void 0;\n            const r1 = n1(7273), o1 = n1(6757), i1 = n1(5639), s1 = n1(2150), a1 = n1(1625);\n            t1.createDotProductProgramInfoLoader = (e1, t1, n1, u1)=>{\n                const l1 = ((e1, t1)=>({\n                        name: \"ConvDotProduct\",\n                        inputNames: e1 ? [\n                            \"Im2Col\",\n                            \"K\",\n                            \"B\"\n                        ] : [\n                            \"Im2Col\",\n                            \"K\"\n                        ],\n                        inputTypes: e1 ? [\n                            i1.TextureType.unpacked,\n                            i1.TextureType.packedLastDimension,\n                            i1.TextureType.unpacked\n                        ] : [\n                            i1.TextureType.unpacked,\n                            i1.TextureType.packedLastDimension\n                        ],\n                        cacheKey: t1.activationCacheKey\n                    }))(t1.length > 2, u1);\n                return Object.assign(Object.assign({}, l1), {\n                    get: ()=>((e1, t1, n1, u1, l1)=>{\n                            const c1 = n1[0].dims, p1 = n1[1].dims, d1 = [\n                                p1[0],\n                                Math.ceil(c1[1] * p1[2] * p1[3] / 4)\n                            ], f1 = (0, a1.calculateIm2ColDims)(c1, p1, u1), [h1, g1] = e1.calculateTextureWidthAndHeight(d1, i1.TextureType.packedLastDimension), b1 = r1.ShapeUtil.computeStrides(f1), [m1, y1] = e1.calculateTextureWidthAndHeight(f1, i1.TextureType.packedLastDimension), _1 = u1.length, v1 = n1.length < 3 ? \"0.0\" : \"_B(b)\", T1 = Math.ceil(c1[1] * p1[2] * p1[3] / 4), { activationFunction: x1, applyActivation: w1 } = (0, s1.getActivationSnippet)(l1), O1 = (0, o1.getGlsl)(e1.session.backend.glContext.version), S1 = `\\n${x1}\\nfloat process(int indices[${_1}]) {\\n  int b[1];\\n  b[0] = indices[1];\\n  int im2col[4];\\n  im2col[0] = indices[0];\\n  im2col[1] = indices[2];\\n  im2col[2] = indices[3];\\n  int im2colOffset = im2col[0] * ${b1[0]} + im2col[1] * ${b1[1]} + im2col[2] * ${b1[2]};\\n  int kernelOffset = indices[1] * ${d1[1]};\\n  float value = ${v1};\\n  for (int i = 0; i < ${T1}; ++i) {\\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m1}, ${y1});\\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h1}, ${g1});\\n    value += dot(${O1.texture2D}(Im2Col, im2colCoords), ${O1.texture2D}(K, kernelCoords));\\n    ++im2colOffset;\\n    ++kernelOffset;\\n  }\\n  ${w1}\\n  return value;\\n}`;\n                            return Object.assign(Object.assign({}, t1), {\n                                output: {\n                                    dims: u1,\n                                    type: n1[0].type,\n                                    textureType: i1.TextureType.unpacked\n                                },\n                                shaderSource: S1\n                            });\n                        })(e1, l1, t1, n1, u1)\n                });\n            };\n        },\n        4125: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseFlattenAttributes = t1.flatten = void 0;\n            const r1 = n1(7273);\n            t1.flatten = (e1, t1, n1)=>{\n                o1(t1, n1);\n                const i1 = r1.ShapeUtil.flattenShape(t1[0].dims, n1);\n                return [\n                    e1.reshapeUnpacked(t1[0], i1)\n                ];\n            }, t1.parseFlattenAttributes = (e1)=>e1.attributes.getInt(\"axis\", 1);\n            const o1 = (e1, t1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Flatten requires 1 input.\");\n                const n1 = e1[0].dims.length;\n                if (0 === n1) throw new Error(\"scalar tensor is not supported.\");\n                if (t1 < -n1 || t1 > n1) throw new Error(\"Invalid axis\");\n                if (\"string\" === e1[0].type) throw new Error(\"string tensor is not supported.\");\n            };\n        },\n        2150: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseInternalActivationAttributes = t1.getActivationSnippet = void 0;\n            const r1 = n1(7273), o1 = n1(9087);\n            t1.getActivationSnippet = function(e1) {\n                let t1;\n                switch(e1.activation){\n                    case \"Relu\":\n                        t1 = (0, o1.glslRelu)();\n                        break;\n                    case \"Sigmoid\":\n                        t1 = (0, o1.glslSigmoid)();\n                        break;\n                    case \"Clip\":\n                        t1 = (0, o1.glslClip)(e1.clipMin, e1.clipMax);\n                        break;\n                    default:\n                        return {\n                            activationFunction: \"\",\n                            applyActivation: \"\"\n                        };\n                }\n                const n1 = t1.name;\n                return {\n                    activationFunction: t1.body,\n                    applyActivation: `value = ${n1}_(value);`\n                };\n            }, t1.parseInternalActivationAttributes = (e1)=>{\n                const t1 = e1.getString(\"activation\", \"\");\n                if (\"Clip\" === t1) {\n                    const [n1, o1] = e1.getFloats(\"activation_params\", [\n                        r1.MIN_CLIP,\n                        r1.MAX_CLIP\n                    ]);\n                    return {\n                        activation: t1,\n                        clipMax: o1,\n                        clipMin: n1,\n                        activationCacheKey: `${t1}:${n1},${o1}`\n                    };\n                }\n                return {\n                    activation: t1,\n                    activationCacheKey: t1\n                };\n            };\n        },\n        6149: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseGatherAttributes = t1.gather = void 0;\n            const r1 = n1(4910), o1 = n1(6145), i1 = n1(7273), s1 = n1(5639);\n            t1.gather = (e1, t1, n1)=>(l1(t1, n1.axis), [\n                    e1.run(u1(e1, t1, n1), t1)\n                ]), t1.parseGatherAttributes = (e1)=>(0, r1.createAttributeWithCacheKey)({\n                    axis: e1.attributes.getInt(\"axis\", 0)\n                });\n            const a1 = {\n                name: \"Gather\",\n                inputNames: [\n                    \"A\",\n                    \"B\"\n                ],\n                inputTypes: [\n                    s1.TextureType.unpacked,\n                    s1.TextureType.unpacked\n                ]\n            }, u1 = (e1, t1, n1)=>{\n                const r1 = Object.assign(Object.assign({}, a1), {\n                    cacheHint: n1.cacheKey\n                });\n                return Object.assign(Object.assign({}, r1), {\n                    get: ()=>((e1, t1, n1, r1)=>{\n                            const o1 = n1[0].dims.slice(), a1 = n1[1].dims.slice(), u1 = new Array(o1.length + a1.length - 1);\n                            r1 = i1.ShapeUtil.normalizeAxis(r1, o1.length);\n                            const l1 = [];\n                            for(let e1 = 0; e1 < u1.length; e1++)e1 < r1 ? (u1[e1] = o1[e1], l1.push(`inputIdx[${e1}] = outputIdx[${e1}];`)) : e1 < r1 + a1.length ? (u1[e1] = a1[e1 - r1], l1.push(`indexDataIdx[${e1 - r1}] = outputIdx[${e1}];`)) : (u1[e1] = o1[e1 - a1.length + 1], l1.push(`inputIdx[${e1 - a1.length + 1}] = outputIdx[${e1}];`));\n                            const c1 = `\\n      float process(int outputIdx[${u1.length || 1}]) {\\n        int inputIdx[${o1.length}];\\n        int indexDataIdx[${a1.length || 1}];\\n        indexDataIdx[0] = 0;\\n        ${l1.join(\"\\n        \")}\\n        int idx = int(_B(indexDataIdx));\\n        inputIdx[${r1}] = idx < 0 ? idx + ${o1[r1]} : idx;\\n        return _A(inputIdx);\\n      }`;\n                            return Object.assign(Object.assign({}, t1), {\n                                output: {\n                                    dims: u1,\n                                    type: n1[0].type,\n                                    textureType: s1.TextureType.unpacked\n                                },\n                                shaderSource: c1\n                            });\n                        })(0, r1, t1, n1.axis)\n                });\n            }, l1 = (e1, t1)=>{\n                if (!e1 || 2 !== e1.length) throw new Error(\"Gather requires 2 inputs.\");\n                const n1 = e1[0].dims.length;\n                if (n1 < 1) throw new Error(\"Invalid input shape.\");\n                if (t1 < -n1 || t1 > n1 - 1) throw new Error(\"Invalid axis.\");\n                if (-1 === o1.NUMBER_TYPES.indexOf(e1[0].type)) throw new Error(\"Invaid input type.\");\n                if (\"int32\" !== e1[1].type && \"int16\" !== e1[1].type) throw new Error(\"Invaid input type.\");\n            };\n        },\n        5378: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseGemmAttributesV11 = t1.parseGemmAttributesV7 = t1.gemm = void 0;\n            const r1 = n1(4910), o1 = n1(7273), i1 = n1(5639);\n            t1.gemm = (e1, t1, n1)=>(l1(t1, n1), [\n                    e1.run(a1(t1, n1), t1)\n                ]);\n            const s1 = (e1, t1)=>{\n                const n1 = 0 !== e1.attributes.getInt(\"transA\", 0), o1 = 0 !== e1.attributes.getInt(\"transB\", 0), i1 = e1.attributes.getFloat(\"alpha\", 1), s1 = e1.attributes.getFloat(\"beta\", 1);\n                return (0, r1.createAttributeWithCacheKey)({\n                    transA: n1,\n                    transB: o1,\n                    alpha: i1,\n                    beta: s1,\n                    isOptionalC: t1\n                });\n            };\n            t1.parseGemmAttributesV7 = (e1)=>s1(e1, !1), t1.parseGemmAttributesV11 = (e1)=>s1(e1, !0);\n            const a1 = (e1, t1)=>{\n                const n1 = {\n                    name: \"Gemm\",\n                    inputNames: 3 === e1.length ? [\n                        \"A\",\n                        \"B\",\n                        \"C\"\n                    ] : [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: 3 === e1.length ? [\n                        i1.TextureType.unpacked,\n                        i1.TextureType.unpacked,\n                        i1.TextureType.unpacked\n                    ] : [\n                        i1.TextureType.unpacked,\n                        i1.TextureType.unpacked\n                    ],\n                    key: t1.cacheKey\n                };\n                return Object.assign(Object.assign({}, n1), {\n                    get: ()=>u1(n1, e1, t1)\n                });\n            }, u1 = (e1, t1, n1)=>{\n                const r1 = t1[0].dims.slice(), s1 = t1[1].dims.slice(), [a1, u1] = o1.GemmUtil.getShapeOfGemmResult(r1, n1.transA, s1, n1.transB, 3 === t1.length ? t1[2].dims : void 0), l1 = [\n                    a1,\n                    u1\n                ];\n                if (!l1) throw new Error(\"Can't use gemm on the given tensors\");\n                let c1 = r1[r1.length - 1], p1 = \"\";\n                n1.transA && (c1 = r1[0]), n1.transA && n1.transB ? p1 = \"value += _A_T(a) * _B_T(b);\" : n1.transA && !n1.transB ? p1 = \"value += _A_T(a) * _B(b);\" : !n1.transA && n1.transB ? p1 = \"value += _A(a) * _B_T(b);\" : n1.transA || n1.transB || (p1 = \"value += _A(a) * _B(b);\");\n                const d1 = l1.length, f1 = `\\n      float process(int indices[${d1}]) {\\n          int a[${d1}];\\n          int b[${d1}];\\n          ${3 === t1.length ? `int c[${t1[2].dims.length}];` : \"\"}\\n\\n          copyVec(indices, a);\\n          copyVec(indices, b);\\n          ${3 === t1.length ? \"bcastIndices_C(indices, c);\" : \"\"}\\n\\n          float value = 0.0;\\n          for (int k=0; k<${c1}; ++k) {\\n              a[${d1 - 1}] = k;\\n              b[${d1 - 2}] = k;\\n              ${p1}\\n          }\\n\\n          value = value * alpha;\\n          ${3 === t1.length ? \"value += beta * _C(c);\" : \"\"}\\n          return value;\\n      }`;\n                return Object.assign(Object.assign({}, e1), {\n                    output: {\n                        dims: l1,\n                        type: t1[0].type,\n                        textureType: i1.TextureType.unpacked\n                    },\n                    variables: [\n                        {\n                            name: \"alpha\",\n                            type: \"float\",\n                            data: n1.alpha\n                        },\n                        {\n                            name: \"beta\",\n                            type: \"float\",\n                            data: n1.beta\n                        }\n                    ],\n                    shaderSource: f1\n                });\n            }, l1 = (e1, t1)=>{\n                if (!e1) throw new Error(\"Input is missing\");\n                if (t1.isOptionalC && (e1.length < 2 || e1.length > 3)) throw new Error(\"Invaid input shape.\");\n                if (!t1.isOptionalC && 3 !== e1.length) throw new Error(\"Gemm requires 3 inputs\");\n                if (3 === e1.length && 1 !== e1[2].dims.length && 2 !== e1[2].dims.length) throw new Error(\"Invalid input shape of C\");\n                if (\"float32\" !== e1[0].type && \"float64\" !== e1[0].type || \"float32\" !== e1[1].type && \"float64\" !== e1[1].type || 3 === e1.length && \"float32\" !== e1[2].type && \"float64\" !== e1[2].type) throw new Error(\"Invalid input type.\");\n                if (e1[0].type !== e1[1].type || 3 === e1.length && e1[0].type !== e1[2].type) throw new Error(\"Input types are mismatched\");\n            };\n        },\n        5950: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createPackedIm2ColProgramInfoLoader = void 0;\n            const r1 = n1(6757), o1 = n1(5639), i1 = n1(5614);\n            t1.createPackedIm2ColProgramInfoLoader = (e1, t1, n1, s1, a1)=>{\n                const u1 = (l1 = a1.cacheKey, {\n                    name: \"Im2Col (packed)\",\n                    inputNames: [\n                        \"A\"\n                    ],\n                    inputTypes: [\n                        o1.TextureType.packed\n                    ],\n                    cacheHint: l1\n                });\n                var l1;\n                return Object.assign(Object.assign({}, u1), {\n                    get: ()=>((e1, t1, n1, s1, a1, u1)=>{\n                            const l1 = n1.dims, c1 = s1.dims, p1 = a1.length, d1 = [\n                                c1[1] * c1[2] * c1[3],\n                                a1[2] * a1[3]\n                            ], f1 = c1[2] * c1[3], h1 = (0, i1.unpackFromChannel)(), g1 = (0, r1.getGlsl)(e1.session.backend.glContext.version);\n                            let b1 = \"\";\n                            for(let e1 = 0; e1 <= 1; e1++)for(let t1 = 0; t1 <= 1; t1++)b1 += `\\n            blockIndex = rc.x + ${t1};\\n            pos = rc.y + ${e1};\\n\\n            if(blockIndex < ${d1[1]} && pos < ${d1[0]}) {\\n              offsetY = int(blockIndex / (${a1[p1 - 1]})) * ${u1.strides[0]} -\\n                ${u1.pads[0]};\\n              d0 = offsetY + ${u1.dilations[0]} * (imod(pos, ${f1}) / ${c1[2]});\\n\\n              if(d0 < ${l1[2]} && d0 >= 0) {\\n                offsetX = imod(blockIndex, ${a1[p1 - 1]}) * ${u1.strides[1]} -\\n                  ${u1.pads[1]};\\n                d1 = offsetX + ${u1.dilations[1]} * imod(imod(pos, ${f1}), ${c1[2]});\\n\\n                if(d1 < ${l1[3]} && d1 >= 0) {\\n\\n                  ch = int(float(pos)/ ${f1}.);\\n                    innerDims = vec2(d0, d1);\\n                    result[${2 * e1 + t1}] = getChannel(\\n                      getA(0, ch, int(innerDims.x),\\n                      int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n\\n          `;\n                            const m1 = `\\n      ${h1}\\n\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n          vec4 result = vec4(0.0);\\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n          vec2 innerDims;\\n          ${b1}\\n          ${g1.output} = result;\\n      }\\n            `;\n                            return Object.assign(Object.assign({}, t1), {\n                                output: {\n                                    dims: d1,\n                                    type: n1.type,\n                                    textureType: o1.TextureType.packed\n                                },\n                                shaderSource: m1,\n                                hasMain: !0\n                            });\n                        })(e1, u1, t1, n1, s1, a1)\n                });\n            };\n        },\n        1625: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.calculateIm2ColDims = t1.createIm2ColProgramInfoLoader = void 0;\n            const r1 = n1(5639);\n            t1.createIm2ColProgramInfoLoader = (e1, n1, o1, i1, s1)=>{\n                const a1 = (u1 = s1.cacheKey, {\n                    name: \"Im2Col\",\n                    inputNames: [\n                        \"X\"\n                    ],\n                    inputTypes: [\n                        r1.TextureType.unpacked\n                    ],\n                    cacheHint: u1\n                });\n                var u1;\n                return Object.assign(Object.assign({}, a1), {\n                    get: ()=>((e1, n1, o1, i1, s1, a1)=>{\n                            const u1 = o1.dims, l1 = i1.dims, c1 = s1.length, p1 = (0, t1.calculateIm2ColDims)(u1, l1, s1, 4), d1 = `\\n        const int XC = ${u1[1]};\\n        const int XH = ${u1[2]};\\n        const int XW = ${u1[3]};\\n        const int KH = ${a1.kernelShape[0]};\\n        const int KW = ${a1.kernelShape[1]};\\n        const int dilationH = ${a1.dilations[0]};\\n        const int dilationW = ${a1.dilations[1]};\\n        const int strideH = ${a1.strides[0]};\\n        const int strideW = ${a1.strides[1]};\\n        const int padH = ${a1.pads[0]};\\n        const int padW = ${a1.pads[1]};\\n        const int KHKW = KH*KW;\\n        const int XCKHKW = XC * KHKW;\\n        const int outputChannels = 4;\\n        vec4 process(int indices[${c1}]) {\\n          int b  = indices[0]; // batch size\\n          int oh = indices[1] * strideH - padH; //output height\\n          int ow = indices[2] * strideW - padW; //output width\\n          int p = indices[3] * outputChannels; //patch\\n          vec4 value = vec4(0.0);\\n          for(int i=0; i < outputChannels; ++i) {\\n            if(p < XCKHKW) {\\n              int patchC = p / KHKW;\\n              int patchH = (p - patchC*KHKW) / KW;\\n              int patchW = (p - patchC*KHKW) - patchH * KW;\\n              int xh2 = oh + patchH * dilationH;\\n              int xw2 = ow + patchW * dilationW;\\n              int x[${u1.length}];\\n              x[0] = b;\\n              x[1] = patchC;\\n              x[2] = xh2;\\n              x[3] = xw2;\\n              if(xh2 >= 0 &&\\n                  xh2 < XH &&\\n                  xw2 >= 0 &&\\n                  xw2 < XW) {\\n                value[i] = _X(x);\\n              }\\n            }\\n            ++p;\\n          }\\n          return value;\\n        }\\n        `;\n                            return Object.assign(Object.assign({}, n1), {\n                                output: {\n                                    dims: p1,\n                                    type: o1.type,\n                                    textureType: r1.TextureType.packedLastDimension\n                                },\n                                shaderSource: d1\n                            });\n                        })(0, a1, n1, o1, i1, s1)\n                });\n            }, t1.calculateIm2ColDims = (e1, t1, n1, r1 = 4)=>[\n                    n1[0],\n                    n1[2],\n                    n1[3],\n                    Math.ceil(e1[1] * t1[2] * t1[3] / r1)\n                ];\n        },\n        6981: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseImageScalerAttributes = t1.imageScaler = void 0;\n            const r1 = n1(4910), o1 = n1(5639);\n            t1.imageScaler = (e1, t1, n1)=>(u1(t1), [\n                    e1.run(s1(e1, t1, n1), t1)\n                ]), t1.parseImageScalerAttributes = (e1)=>{\n                const t1 = e1.attributes.getFloat(\"scale\"), n1 = e1.attributes.getFloats(\"bias\");\n                return (0, r1.createAttributeWithCacheKey)({\n                    scale: t1,\n                    bias: n1\n                });\n            };\n            const i1 = {\n                name: \"ImageScaler\",\n                inputNames: [\n                    \"X\"\n                ],\n                inputTypes: [\n                    o1.TextureType.unpacked\n                ]\n            }, s1 = (e1, t1, n1)=>{\n                const r1 = Object.assign(Object.assign({}, i1), {\n                    cacheHint: n1.cacheKey\n                });\n                return Object.assign(Object.assign({}, r1), {\n                    get: ()=>((e1, t1, n1, r1)=>{\n                            const i1 = n1[0].dims.slice(), s1 = i1.length, u1 = `\\n      ${a1(r1.bias.length)}\\n      float process(int indices[${s1}]) {\\n        return _X(indices) * scale + getBias(bias, indices[1]);\\n      }`;\n                            return Object.assign(Object.assign({}, t1), {\n                                output: {\n                                    dims: i1,\n                                    type: n1[0].type,\n                                    textureType: o1.TextureType.unpacked\n                                },\n                                variables: [\n                                    {\n                                        name: \"bias\",\n                                        type: \"float\",\n                                        arrayLength: r1.bias.length,\n                                        data: r1.bias\n                                    },\n                                    {\n                                        name: \"scale\",\n                                        type: \"float\",\n                                        data: r1.scale\n                                    }\n                                ],\n                                shaderSource: u1\n                            });\n                        })(0, r1, t1, n1)\n                });\n            }, a1 = (e1)=>{\n                const t1 = [\n                    `float getBias(float bias[${e1}], int channel) {`\n                ];\n                for(let n1 = 0; n1 < e1; ++n1)0 === n1 ? t1.push(`\\tif (channel == ${n1}) { return bias[${n1}]; }`) : n1 === e1 - 1 ? t1.push(`\\telse { return bias[${n1}]; }`) : t1.push(`\\telse if (channel == ${n1}) { return bias[${n1}]; }`);\n                return t1.push(\"\t}\"), t1.join(\"\\n\");\n            }, u1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"ImageScaler requires 1 input.\");\n                if (4 !== e1[0].dims.length) throw new Error(\"Invalid input shape.\");\n                if (\"float32\" !== e1[0].type && \"float64\" !== e1[0].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        7413: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseInstanceNormalizationAttributes = t1.instanceNormalization = void 0;\n            const r1 = n1(6757), o1 = n1(5639);\n            t1.instanceNormalization = (e1, t1, n1)=>{\n                l1(t1);\n                const r1 = e1.run(s1(t1[0]), t1);\n                return [\n                    e1.run(u1(e1, t1[0], n1, r1.dims), [\n                        t1[0],\n                        r1,\n                        t1[1],\n                        t1[2]\n                    ])\n                ];\n            }, t1.parseInstanceNormalizationAttributes = (e1)=>e1.attributes.getFloat(\"epsilon\", 1e-5);\n            const i1 = {\n                name: \"InstanceNormalization_MeanAndVariance\",\n                inputNames: [\n                    \"X\"\n                ],\n                inputTypes: [\n                    o1.TextureType.unpacked\n                ]\n            }, s1 = (e1)=>Object.assign(Object.assign({}, i1), {\n                    get: ()=>((e1, t1)=>{\n                            const n1 = t1.dims.slice(), r1 = n1[1], i1 = n1[2] * n1[3], s1 = [\n                                n1[0],\n                                r1\n                            ], a1 = `\\n      vec4 process(int[2] indices) {\\n        vec4 v = vec4(0.0);\\n        int a[4];\\n        a[0] = indices[0];\\n        a[1] = indices[1];\\n        float temp = 0.0;\\n        for(int a2=0; a2<${n1[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n1[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += x;\\n          }\\n        }\\n        float mean = temp / float(${i1});\\n        temp = 0.0;\\n        for(int a2=0; a2<${n1[2]}; a2++) {\\n          a[2] = a2;\\n          for(int a3=0; a3<${n1[3]}; a3++) {\\n            a[3] = a3;\\n            float x = _X(a);\\n            temp += (x - mean) * (x - mean);\\n          }\\n        }\\n        v.r = mean;\\n        v.g = temp / float(${i1});\\n\\n        return v;\\n      }`;\n                            return Object.assign(Object.assign({}, e1), {\n                                output: {\n                                    dims: s1,\n                                    type: t1.type,\n                                    textureType: o1.TextureType.packedLastDimension\n                                },\n                                shaderSource: a1\n                            });\n                        })(i1, e1)\n                }), a1 = {\n                name: \"InstanceNormalization_ComputeOutput\",\n                inputNames: [\n                    \"X\",\n                    \"MeanAndVariance\",\n                    \"Scale\",\n                    \"B\"\n                ],\n                inputTypes: [\n                    o1.TextureType.unpacked,\n                    o1.TextureType.packedLastDimension,\n                    o1.TextureType.unpacked,\n                    o1.TextureType.unpacked\n                ]\n            }, u1 = (e1, t1, n1, i1)=>{\n                const s1 = Object.assign(Object.assign({}, a1), {\n                    cacheHint: `${n1}`\n                });\n                return Object.assign(Object.assign({}, s1), {\n                    get: ()=>((e1, t1, n1, i1, s1)=>{\n                            const a1 = (0, r1.getGlsl)(e1.session.backend.glContext.version), [u1, l1] = e1.calculateTextureWidthAndHeight(s1, o1.TextureType.packedLastDimension), [c1, p1] = [\n                                u1 / 4,\n                                l1\n                            ], d1 = `\\n      vec4 get_MeanAndVariance(int[2] mv) {\\n        int offset = indicesToOffset_MeanAndVariance(mv);\\n        vec2 coords = offsetToCoords(offset, ${c1}, ${p1});\\n        return ${a1.texture2D}(MeanAndVariance, coords);\\n      }\\n\\n      float process(int[4] indices) {\\n        int mv[2];\\n        mv[0] = indices[0];\\n        mv[1] = indices[1];\\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\\n        float mean = mean_and_variance.r;\\n        float variance = mean_and_variance.g;\\n\\n        int sb[1];\\n        sb[0] = indices[1];\\n        float scale = _Scale(sb);\\n        float b = _B(sb);\\n\\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\\n      }`;\n                            return Object.assign(Object.assign({}, t1), {\n                                output: {\n                                    dims: n1.dims,\n                                    type: n1.type,\n                                    textureType: o1.TextureType.unpacked\n                                },\n                                variables: [\n                                    {\n                                        name: \"epsilon\",\n                                        type: \"float\",\n                                        data: i1\n                                    }\n                                ],\n                                shaderSource: d1\n                            });\n                        })(e1, s1, t1, n1, i1)\n                });\n            }, l1 = (e1)=>{\n                if (!e1 || 3 !== e1.length) throw new Error(\"InstanceNormalization requires 3 inputs.\");\n                const t1 = e1[0], n1 = e1[1], r1 = e1[2];\n                if (t1.dims.length < 3 || 1 !== n1.dims.length || 1 !== r1.dims.length) throw new Error(\"Invalid input shape.\");\n                if (n1.dims[0] !== t1.dims[1] || r1.dims[0] !== t1.dims[1]) throw new Error(\"Input shapes are mismatched.\");\n                if (\"float32\" !== t1.type && \"float64\" !== t1.type || \"float32\" !== n1.type && \"float64\" !== n1.type || \"float32\" !== r1.type && \"float64\" !== r1.type) throw new Error(\"Invalid input type.\");\n                if (4 !== e1[0].dims.length) throw new Error(\"Only support 4-D input shape.\");\n            };\n        },\n        7006: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createLrnProgramInfoLoader = t1.parseLrnAttributes = t1.lrn = void 0;\n            const r1 = n1(4910), o1 = n1(5639);\n            t1.lrn = (e1, t1, n1)=>(a1(t1), [\n                    e1.run(s1(t1, n1), t1)\n                ]), t1.parseLrnAttributes = (e1)=>{\n                const t1 = e1.attributes.getFloat(\"alpha\", 1e-4), n1 = e1.attributes.getFloat(\"beta\", .75), o1 = e1.attributes.getFloat(\"bias\", 1), i1 = e1.attributes.getInt(\"size\");\n                return (0, r1.createAttributeWithCacheKey)({\n                    alpha: t1,\n                    beta: n1,\n                    bias: o1,\n                    size: i1\n                });\n            };\n            const i1 = {\n                name: \"LRN\",\n                inputNames: [\n                    \"X\"\n                ],\n                inputTypes: [\n                    o1.TextureType.unpacked\n                ]\n            };\n            function s1(e1, t1) {\n                return Object.assign(Object.assign({}, i1), {\n                    cacheHint: t1.cacheKey,\n                    get: ()=>(function(e1, t1) {\n                            const n1 = e1[0].dims[1], r1 = e1[0].dims.length, s1 = -Math.floor((t1.size - 1) / 2), a1 = Math.ceil((t1.size - 1) / 2), u1 = `float(${t1.alpha}) / float(${t1.size})`, l1 = `\\n    float process(int indices[${r1}]) {\\n        int c = indices[1];\\n        float x = _X(indices);\\n        float square_sum = 0.0;\\n\\n        for (int i = ${s1}; i <= ${a1}; i++) {\\n          int idx = c + i;\\n          if (c >= 0 && c < ${n1}) {\\n            indices[1] = idx;\\n            float j = _X(indices);\\n            square_sum += j * j;\\n          }\\n        }\\n        return x / pow(float(${t1.bias}) + ${u1} * square_sum, float(${t1.beta}));\\n    }`;\n                            return Object.assign(Object.assign({}, i1), {\n                                cacheHint: t1.cacheKey,\n                                output: {\n                                    dims: e1[0].dims,\n                                    type: e1[0].type,\n                                    textureType: o1.TextureType.unpacked\n                                },\n                                shaderSource: l1\n                            });\n                        })(e1, t1)\n                });\n            }\n            t1.createLrnProgramInfoLoader = s1;\n            const a1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"LRN requires 1 input.\");\n                if (4 !== e1[0].dims.length) throw new Error('currently only support LRN for input with \"NCHW\" format');\n                if (\"float32\" !== e1[0].type) throw new Error(\"input should be float type\");\n            };\n        },\n        5632: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createPackedMatmulProgramInfoLoader = void 0;\n            const r1 = n1(7273), o1 = n1(6757), i1 = n1(5639), s1 = n1(432), a1 = n1(2150), u1 = n1(8276);\n            t1.createPackedMatmulProgramInfoLoader = (e1, t1, n1)=>{\n                const l1 = (c1 = t1.length > 2, p1 = n1.activationCacheKey, {\n                    name: \"MatMul (packed)\",\n                    inputNames: c1 ? [\n                        \"A\",\n                        \"B\",\n                        \"Bias\"\n                    ] : [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: c1 ? [\n                        i1.TextureType.packed,\n                        i1.TextureType.packed,\n                        i1.TextureType.packed\n                    ] : [\n                        i1.TextureType.packed,\n                        i1.TextureType.packed\n                    ],\n                    cacheHint: p1\n                });\n                var c1, p1;\n                return Object.assign(Object.assign({}, l1), {\n                    get: ()=>((e1, t1, n1, l1)=>{\n                            const c1 = n1.length > 2, p1 = c1 ? \"value += getBiasForMatmul();\" : \"\", d1 = n1[0].dims, f1 = n1[1].dims, h1 = r1.BroadcastUtil.calcShape(d1, f1, !0), g1 = !r1.ShapeUtil.areEqual(n1[0].dims, n1[1].dims);\n                            if (!h1) throw new Error(\"Can't use matmul on the given tensors\");\n                            const b1 = d1[d1.length - 1], m1 = Math.ceil(b1 / 2), y1 = d1.length, _1 = f1.length, v1 = (0, o1.getGlsl)(e1.session.backend.glContext.version), T1 = (0, s1.getCoordsDataType)(h1.length), x1 = h1.length, w1 = (0, s1.getGlChannels)(), { activationFunction: O1, applyActivation: S1 } = (0, a1.getActivationSnippet)(l1), A1 = c1 ? `${(0, u1.getBiasForMatmul)(T1, w1, n1[2].dims, h1, !0)}` : \"\", P1 = g1 ? `${function(e1, t1, n1, o1) {\n                                let i1 = [], s1 = [];\n                                const a1 = n1[0].dims, u1 = n1[1].dims, l1 = a1.length, c1 = u1.length, p1 = o1.length, d1 = p1 - l1, f1 = p1 - c1;\n                                i1 = a1.map((e1, n1)=>`coords.${t1[n1 + d1]}`), i1[l1 - 1] = \"i*2\", i1.join(\", \"), s1 = u1.map((e1, n1)=>`coords.${t1[n1 + f1]}`), s1[c1 - 2] = \"i*2\", s1.join(\", \");\n                                const h1 = r1.BroadcastUtil.getBroadcastDims(a1, o1), g1 = r1.BroadcastUtil.getBroadcastDims(u1, o1), b1 = h1.map((e1)=>`coords.${t1[e1 + d1]} = 0;`).join(\"\\n\"), m1 = g1.map((e1)=>`coords.${t1[e1 + f1]} = 0;`).join(\"\\n\"), y1 = `int lastDim = coords.${t1[p1 - 1]};\\n  coords.${t1[p1 - 1]} = coords.${t1[p1 - 2]};\\n  coords.${t1[p1 - 2]} = lastDim;`;\n                                return `\\nvec4 getAAtOutCoordsMatmul(int i) {\\n  ${e1} coords = getOutputCoords();\\n  ${y1}\\n  ${b1}\\n  vec4 outputValue = getA(${i1});\\n  return outputValue;\\n}\\n\\nvec4 getBAtOutCoordsMatmul(int i) {\\n  ${e1} coords = getOutputCoords();\\n  ${y1}\\n  ${m1}\\n  vec4 outputValue = getB(${s1});\\n  return outputValue;\\n}`;\n                            }(T1, w1, n1, h1)}` : \"\", I1 = g1 ? \"getAAtOutCoordsMatmul(i)\" : `getA(${function(e1, t1) {\n                                let n1 = \"\";\n                                for(let r1 = 0; r1 < t1 - 2; r1++)n1 += `rc.${e1[r1]}, `;\n                                return n1 += `rc.${e1[t1 - 2]}, i*2`, n1;\n                            }(w1, y1)})`, E1 = g1 ? \"getBAtOutCoordsMatmul(i)\" : `getB(${function(e1, t1) {\n                                let n1 = \"\";\n                                for(let r1 = 0; r1 < t1 - 2; r1++)n1 += `rc.${e1[r1]}, `;\n                                return n1 += `i*2, rc.${e1[t1 - 1]}`, n1;\n                            }(w1, _1)})`, D1 = `\\n            ${P1}\\n            ${A1}\\n            ${O1}\\n            void main() {\\n              ${g1 ? \"\" : `${T1} rc =\\n          getOutputCoords(); int lastDim = rc.${w1[x1 - 1]}; rc.${w1[x1 - 1]} =\\n          rc.${w1[x1 - 2]}; rc.${w1[x1 - 2]} = lastDim;\\n      `}\\n\\n              vec4 value = vec4(0);\\n              for (int i = 0; i < ${m1}; i++) {\\n                vec4 a = ${I1};\\n                vec4 b = ${E1};\\n\\n                value += (a.rrbb * b.rgrg);\\n                value += (a.ggaa * b.baba);\\n              }\\n              ${p1}\\n              ${S1}\\n              ${v1.output} = value;\\n            }`;\n                            return Object.assign(Object.assign({}, t1), {\n                                output: {\n                                    dims: h1,\n                                    type: n1[0].type,\n                                    textureType: i1.TextureType.packed\n                                },\n                                shaderSource: D1,\n                                hasMain: !0\n                            });\n                        })(e1, l1, t1, n1)\n                });\n            };\n        },\n        8276: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.getBiasForMatmul = t1.createMatmulProgramInfoLoader = t1.parseMatMulAttributes = t1.matMul = void 0;\n            const r1 = n1(7273), o1 = n1(5639), i1 = n1(432), s1 = n1(2150), a1 = n1(5632);\n            t1.matMul = (e1, t1, n1)=>(c1(t1), e1.session.pack ? [\n                    e1.run((0, a1.createPackedMatmulProgramInfoLoader)(e1, t1, n1), t1)\n                ] : [\n                    e1.run(l1(t1, n1), t1)\n                ]), t1.parseMatMulAttributes = (e1)=>(0, s1.parseInternalActivationAttributes)(e1.attributes);\n            const u1 = (e1, t1)=>({\n                    name: \"MatMul\",\n                    inputNames: e1 ? [\n                        \"A\",\n                        \"B\",\n                        \"Bias\"\n                    ] : [\n                        \"A\",\n                        \"B\"\n                    ],\n                    inputTypes: e1 ? [\n                        o1.TextureType.unpacked,\n                        o1.TextureType.unpacked,\n                        o1.TextureType.unpacked\n                    ] : [\n                        o1.TextureType.unpacked,\n                        o1.TextureType.unpacked\n                    ],\n                    cacheHint: t1\n                });\n            function l1(e1, t1) {\n                const n1 = u1(e1.length > 2, t1.activationCacheKey);\n                return Object.assign(Object.assign({}, n1), {\n                    get: ()=>(function(e1, t1, n1) {\n                            const a1 = t1[0].dims, u1 = t1[1].dims, l1 = r1.BroadcastUtil.calcShape(a1, u1, !0);\n                            if (!l1) throw new Error(\"Can't use matmul on the given tensors\");\n                            const c1 = (0, i1.getCoordsDataType)(l1.length), d1 = (0, i1.getGlChannels)(), { activationFunction: f1, applyActivation: h1 } = (0, s1.getActivationSnippet)(n1), g1 = t1.length > 2, b1 = g1 ? \"value += getBiasForMatmul();\" : \"\", m1 = g1 ? `${p1(c1, d1, t1[2].dims, l1, !1)}` : \"\", y1 = l1.length, _1 = a1.length, v1 = u1.length, T1 = `\\n    ${f1}\\n    ${m1}\\n    float process(int indices[${y1}]) {\\n        int a[${_1}];\\n        int b[${v1}];\\n        bcastMatmulIndices_A(indices, a);\\n        bcastMatmulIndices_B(indices, b);\\n\\n        float value;\\n        for (int k=0; k<${a1[a1.length - 1]}; ++k) {\\n            a[${_1 - 1}] = k;\\n            b[${v1 - 2}] = k;\\n            value += _A(a) * _B(b);\\n        }\\n        ${b1}\\n        ${h1}\\n        return value;\\n    }`;\n                            return Object.assign(Object.assign({}, e1), {\n                                output: {\n                                    dims: l1,\n                                    type: t1[0].type,\n                                    textureType: o1.TextureType.unpacked\n                                },\n                                shaderSource: T1\n                            });\n                        })(n1, e1, t1)\n                });\n            }\n            t1.createMatmulProgramInfoLoader = l1;\n            const c1 = (e1)=>{\n                if (!e1 || 2 !== e1.length) throw new Error(\"MatMul requires 2 inputs.\");\n                if (e1[0].dims[e1[0].dims.length - 1] !== e1[1].dims[e1[1].dims.length - 2]) throw new Error(\"shared dimension does not match.\");\n                if (\"float32\" !== e1[0].type && \"float64\" !== e1[0].type || \"float32\" !== e1[1].type && \"float64\" !== e1[1].type) throw new Error(\"inputs should be float type\");\n                if (e1[0].type !== e1[1].type) throw new Error(\"inputs types should match\");\n            };\n            function p1(e1, t1, n1, o1, i1) {\n                let s1 = \"\";\n                const a1 = n1.length, u1 = o1.length, l1 = u1 - a1;\n                s1 = u1 < 2 && a1 > 0 ? \"coords\" : n1.map((e1, n1)=>`coords.${t1[n1 + l1]}`).join(\", \");\n                const c1 = r1.BroadcastUtil.getBroadcastDims(n1, o1).map((e1)=>`coords.${t1[e1 + l1]} = 0;`).join(\"\\n\");\n                let p1 = \"vec4(outputValue.xx, outputValue.yy)\";\n                return 1 === r1.ShapeUtil.size(n1) && (p1 = \"vec4(outputValue.x)\"), i1 ? `\\nvec4 getBiasForMatmul() {\\n  ${e1} coords = getOutputCoords();\\n  ${c1}\\n  vec4 outputValue = getBias(${s1});\\n  return ${p1};\\n}` : `\\nfloat getBiasForMatmul() {\\n  ${e1} coords = getOutputCoords();\\n  ${c1}\\n  return getBias(coords.x);\\n}`;\n            }\n            t1.getBiasForMatmul = p1;\n        },\n        9: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createPackProgramInfoLoader = void 0;\n            const r1 = n1(6757), o1 = n1(5639), i1 = n1(432), s1 = n1(5614), a1 = {\n                name: \"pack\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    o1.TextureType.unpackedReversed\n                ]\n            };\n            t1.createPackProgramInfoLoader = (e1, t1)=>Object.assign(Object.assign({}, a1), {\n                    get: ()=>((e1, t1)=>{\n                            const n1 = (0, r1.getGlsl)(e1.session.backend.glContext.version), u1 = t1.dims, l1 = u1.length, c1 = t1.dims.length, p1 = (0, i1.getCoordsDataType)(c1), d1 = (0, s1.getChannels)(\"rc\", c1), f1 = (h1 = c1, g1 = d1, b1 = u1[u1.length - 2], m1 = u1[u1.length - 1], 0 === h1 || 1 === h1 ? \"\" : `\\n    int r = ${g1[h1 - 2]};\\n    int c = ${g1[h1 - 1]};\\n    int rp1 = ${g1[h1 - 2]} + 1;\\n    int cp1 = ${g1[h1 - 1]} + 1;\\n    bool rEdge = rp1 >= ${m1};\\n    bool cEdge = cp1 >= ${b1};\\n    `);\n                            var h1, g1, b1, m1;\n                            let y1;\n                            y1 = 0 === l1 ? [\n                                1,\n                                1\n                            ] : 1 === l1 ? [\n                                u1[0],\n                                1\n                            ] : [\n                                u1[c1 - 1],\n                                u1[c1 - 2]\n                            ];\n                            const _1 = function(e1, t1, n1) {\n                                if (0 === e1) return \"false\";\n                                if (1 === e1) return `rc > ${t1[0]}`;\n                                let r1 = \"\";\n                                for(let o1 = e1 - 2; o1 < e1; o1++)r1 += `${n1[o1]} >= ${t1[o1 - e1 + 2]}`, o1 < e1 - 1 && (r1 += \"||\");\n                                return r1;\n                            }(c1, y1, d1), v1 = function(e1, t1) {\n                                const n1 = e1.length;\n                                if (0 === n1) return \"getA(), 0, 0, 0\";\n                                if (1 === n1) return `getA(rc),\\n            rc + 1 >= ${e1[0]} ? 0. : getA(rc + 1),\\n            0, 0`;\n                                let r1 = \"\";\n                                if (n1 > 2) for(let e1 = 0; e1 < n1 - 2; ++e1)r1 += `${t1[e1]},`;\n                                return `getA(${r1}r, c),\\n          rEdge ? 0. : getA(${r1}rp1, c),\\n          cEdge ? 0. : getA(${r1}r, cp1),\\n          rEdge || cEdge ? 0. : getA(${r1}rp1, cp1)`;\n                            }(u1, d1), T1 = `\\n        void main() {\\n          ${p1} rc = getOutputCoords();\\n\\n          if(${_1}) {\\n            ${n1.output} = vec4(0);\\n          } else {\\n            ${f1}\\n\\n            ${n1.output} = vec4(${v1});\\n          }\\n        }\\n      `;\n                            return Object.assign(Object.assign({}, a1), {\n                                hasMain: !0,\n                                output: {\n                                    dims: t1.dims,\n                                    type: t1.type,\n                                    textureType: o1.TextureType.packed\n                                },\n                                shaderSource: T1\n                            });\n                        })(e1, t1)\n                });\n        },\n        5614: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.unpackFromChannel = t1.getChannels = t1.getVecChannels = void 0;\n            const r1 = n1(432);\n            function o1(e1, t1) {\n                return (0, r1.getGlChannels)(t1).map((t1)=>`${e1}.${t1}`);\n            }\n            t1.getVecChannels = o1, t1.getChannels = function(e1, t1) {\n                return 1 === t1 ? [\n                    e1\n                ] : o1(e1, t1);\n            }, t1.unpackFromChannel = function() {\n                return \"\\n    float getChannel(vec4 frag, int dim) {\\n      int modCoord = imod(dim, 2);\\n      return modCoord == 0 ? frag.r : frag.g;\\n    }\\n\\n    float getChannel(vec4 frag, vec2 innerDims) {\\n      vec2 modCoord = mod(innerDims, 2.);\\n      return modCoord.x == 0. ?\\n        (modCoord.y == 0. ? frag.r : frag.g) :\\n        (modCoord.y == 0. ? frag.b : frag.a);\\n    }\\n  \";\n            };\n        },\n        5565: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parsePadAttributesV11 = t1.padV11 = t1.parsePadAttributesV2 = t1.padV2 = void 0;\n            const r1 = n1(4910), o1 = n1(7273), i1 = n1(6757), s1 = n1(5639), a1 = {\n                name: \"Pad\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    s1.TextureType.unpacked\n                ]\n            };\n            t1.padV2 = (e1, t1, n1)=>(c1(t1), [\n                    e1.run(Object.assign(Object.assign({}, a1), {\n                        cacheHint: n1.cacheKey,\n                        get: ()=>l1(e1, t1[0], n1)\n                    }), t1)\n                ]), t1.parsePadAttributesV2 = (e1)=>{\n                const t1 = e1.attributes.getString(\"mode\", \"constant\"), n1 = e1.attributes.getFloat(\"value\", 0), o1 = e1.attributes.getInts(\"pads\");\n                return (0, r1.createAttributeWithCacheKey)({\n                    mode: t1,\n                    value: n1,\n                    pads: o1\n                });\n            }, t1.padV11 = (e1, n1, r1)=>{\n                p1(n1);\n                const o1 = u1(e1, n1, r1);\n                return (0, t1.padV2)(e1, [\n                    n1[0]\n                ], o1);\n            }, t1.parsePadAttributesV11 = (e1)=>e1.attributes.getString(\"mode\", \"constant\");\n            const u1 = (e1, t1, n1)=>{\n                if (!e1.session.isInitializer(t1[1].dataId) || t1.length >= 3 && !e1.session.isInitializer(t1[2].dataId)) throw new Error(\"dynamic pad attributes are not allowed\");\n                const o1 = Array.from(t1[1].integerData), i1 = t1.length >= 3 ? t1[2].floatData[0] : 0;\n                return (0, r1.createAttributeWithCacheKey)({\n                    mode: n1,\n                    pads: o1,\n                    value: i1\n                });\n            }, l1 = (e1, t1, n1)=>{\n                const r1 = o1.ShapeUtil.padShape(t1.dims.slice(), n1.pads), i1 = r1.length, a1 = `\\n      ${d1(e1, t1, n1)}\\n      float process(int[${i1}] indices) {\\n          return padA(indices);\\n      }`;\n                return {\n                    name: \"Pad\",\n                    inputNames: [\n                        \"A\"\n                    ],\n                    inputTypes: [\n                        s1.TextureType.unpacked\n                    ],\n                    output: {\n                        dims: r1,\n                        type: t1.type,\n                        textureType: s1.TextureType.unpacked\n                    },\n                    shaderSource: a1\n                };\n            }, c1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Pad requires 1 input\");\n                if (\"float32\" !== e1[0].type && \"float64\" !== e1[0].type) throw new Error(\"Invalid input type.\");\n            }, p1 = (e1)=>{\n                if (!e1 || 2 !== e1.length && 3 !== e1.length) throw new Error(\"Pad requires 2 or 3 inputs\");\n                if (\"int32\" !== e1[1].type) throw new Error(\"Invalid input type.\");\n                if (e1.length >= 3 && \"string\" === e1[2].type) throw new Error(\"Invalid input type.\");\n            }, d1 = (e1, t1, n1)=>{\n                const r1 = (0, i1.getGlsl)(e1.session.backend.glContext.version), [a1, u1] = e1.calculateTextureWidthAndHeight(t1.dims, s1.TextureType.unpacked), l1 = o1.ShapeUtil.computeStrides(t1.dims);\n                switch(n1.mode){\n                    case \"constant\":\n                        return f1(r1, t1.dims, l1, a1, u1, n1.pads, n1.value);\n                    case \"reflect\":\n                        return h1(r1, t1.dims, l1, a1, u1, n1.pads);\n                    case \"edge\":\n                        return g1(r1, t1.dims, l1, a1, u1, n1.pads);\n                    default:\n                        throw new Error(\"Invalid mode\");\n                }\n            }, f1 = (e1, t1, n1, r1, o1, i1, s1)=>{\n                const a1 = t1.length;\n                let u1 = \"\";\n                for(let e1 = a1 - 1; e1 >= 0; --e1)u1 += `\\n        k = m[${e1}] - ${i1[e1]};\\n        if (k < 0)  return constant;\\n        if (k >= ${t1[e1]}) return constant;\\n        offset += k * ${n1[e1]};\\n        `;\n                return `\\n      float padA(int m[${a1}]) {\\n        const float constant = float(${s1});\\n        int offset = 0;\\n        int k = 0;\\n        ${u1}\\n        vec2 coords = offsetToCoords(offset, ${r1}, ${o1});\\n        float value = getColorAsFloat(${e1.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n            }, h1 = (e1, t1, n1, r1, o1, i1)=>{\n                const s1 = t1.length;\n                let a1 = \"\";\n                for(let e1 = s1 - 1; e1 >= 0; --e1)a1 += `\\n        k = m[${e1}] - ${i1[e1]};\\n        if (k < 0) { k = -k; }\\n        {\\n          const int _2n_1 = ${2 * (t1[e1] - 1)};\\n          k = int( mod( float(k), float(_2n_1) ) ) ;\\n          if(k >= ${t1[e1]}) { k = _2n_1 - k; }\\n        }\\n        offset += k * ${n1[e1]};\\n        `;\n                return `\\n      float padA(int m[${s1}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${a1}\\n        vec2 coords = offsetToCoords(offset, ${r1}, ${o1});\\n        float value = getColorAsFloat(${e1.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n            }, g1 = (e1, t1, n1, r1, o1, i1)=>{\n                const s1 = t1.length;\n                let a1 = \"\";\n                for(let e1 = s1 - 1; e1 >= 0; --e1)a1 += `\\n        k = m[${e1}] - ${i1[e1]};\\n        if (k < 0)  k = 0;\\n        if (k >= ${t1[e1]}) k = ${t1[e1] - 1};\\n        offset += k * ${n1[e1]};\\n      `;\n                return `\\n      float padA(int m[${s1}]) {\\n        int offset = 0;\\n        int k = 0;\\n        ${a1}\\n        vec2 coords = offsetToCoords(offset, ${r1}, ${o1});\\n        float value = getColorAsFloat(${e1.texture2D}(A, coords));\\n        return value;\\n      }\\n      `;\n            };\n        },\n        2834: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.globalMaxPool = t1.parseMaxPoolAttributes = t1.maxPool = t1.parseGlobalAveragePoolAttributes = t1.globalAveragePool = t1.parseAveragePoolAttributes = t1.averagePool = void 0;\n            const r1 = n1(4910), o1 = n1(7273), i1 = n1(5639);\n            t1.averagePool = (e1, t1, n1)=>{\n                p1(t1);\n                const r1 = {\n                    name: \"AveragePool\",\n                    inputNames: [\n                        \"X\"\n                    ],\n                    inputTypes: [\n                        i1.TextureType.unpacked\n                    ],\n                    cacheHint: n1.cacheKey\n                };\n                return [\n                    e1.run(Object.assign(Object.assign({}, r1), {\n                        get: ()=>s1(t1, r1, !1, n1)\n                    }), t1)\n                ];\n            }, t1.parseAveragePoolAttributes = (e1)=>{\n                const t1 = e1.attributes.getString(\"auto_pad\", \"NOTSET\"), n1 = e1.attributes.getInt(\"ceil_mode\", 0), o1 = 0 !== e1.attributes.getInt(\"count_include_pad\", 0), i1 = e1.attributes.getInts(\"kernel_shape\"), s1 = e1.attributes.getInts(\"strides\", []), a1 = e1.attributes.getInts(\"pads\", []);\n                if (0 !== n1) throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");\n                return (0, r1.createAttributeWithCacheKey)({\n                    autoPad: t1,\n                    ceilMode: n1,\n                    countIncludePad: o1,\n                    kernelShape: i1,\n                    strides: s1,\n                    pads: a1\n                });\n            };\n            const s1 = (e1, t1, n1, r1)=>{\n                const [s1, a1] = u1(e1, r1, n1), l1 = o1.ShapeUtil.size(s1.kernelShape);\n                let c1 = \"\";\n                s1.countIncludePad ? c1 += `value /= float(${l1});` : c1 += `value /= float(${l1} - pad);`;\n                const p1 = `\\n        ${d1(e1[0].dims, s1, \"value += _X(x);\", c1, \"0.0\")}\\n      `;\n                return Object.assign(Object.assign({}, t1), {\n                    output: {\n                        dims: a1,\n                        type: e1[0].type,\n                        textureType: i1.TextureType.unpacked\n                    },\n                    shaderSource: p1\n                });\n            };\n            t1.globalAveragePool = (e1, t1, n1)=>{\n                p1(t1);\n                const r1 = {\n                    name: \"GlobalAveragePool\",\n                    inputNames: [\n                        \"X\"\n                    ],\n                    inputTypes: [\n                        i1.TextureType.unpacked\n                    ],\n                    cacheHint: `${n1.countIncludePad}`\n                };\n                return [\n                    e1.run(Object.assign(Object.assign({}, r1), {\n                        get: ()=>s1(t1, r1, !0, n1)\n                    }), t1)\n                ];\n            }, t1.parseGlobalAveragePoolAttributes = (e1)=>{\n                const t1 = 0 !== e1.attributes.getInt(\"count_include_pad\", 0);\n                return (0, r1.createAttributeWithCacheKey)({\n                    autoPad: \"\",\n                    ceilMode: 0,\n                    countIncludePad: t1,\n                    kernelShape: [],\n                    strides: [],\n                    pads: []\n                });\n            }, t1.maxPool = (e1, t1, n1)=>{\n                p1(t1);\n                const r1 = {\n                    name: \"MaxPool\",\n                    inputNames: [\n                        \"X\"\n                    ],\n                    inputTypes: [\n                        i1.TextureType.unpacked\n                    ],\n                    cacheHint: n1.cacheKey\n                };\n                return [\n                    e1.run(Object.assign(Object.assign({}, r1), {\n                        get: ()=>a1(t1, r1, !1, n1)\n                    }), t1)\n                ];\n            }, t1.parseMaxPoolAttributes = (e1)=>{\n                const t1 = e1.attributes.getString(\"auto_pad\", \"NOTSET\"), n1 = e1.attributes.getInt(\"ceil_mode\", 0), o1 = e1.attributes.getInts(\"kernel_shape\"), i1 = e1.attributes.getInts(\"strides\", []), s1 = e1.attributes.getInts(\"pads\", []), a1 = e1.attributes.getInt(\"storage_order\", 0), u1 = e1.attributes.getInts(\"dilations\", []);\n                if (0 !== a1) throw new Error(\"column major storage order is not yet supported for MaxPool\");\n                if (0 !== n1) throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");\n                return (0, r1.createAttributeWithCacheKey)({\n                    autoPad: t1,\n                    ceilMode: n1,\n                    countIncludePad: !1,\n                    kernelShape: o1,\n                    strides: i1,\n                    pads: s1,\n                    storageOrder: a1,\n                    dilations: u1\n                });\n            };\n            const a1 = (e1, t1, n1, r1)=>{\n                const [o1, s1] = u1(e1, r1, n1), a1 = `\\n      ${d1(e1[0].dims, o1, \"\\n      value = max(_X(x), value);\\n    \", \"\", \"-1e5\")}\\n    `;\n                return Object.assign(Object.assign({}, t1), {\n                    output: {\n                        dims: s1,\n                        type: e1[0].type,\n                        textureType: i1.TextureType.unpacked\n                    },\n                    shaderSource: a1\n                });\n            }, u1 = (e1, t1, n1)=>{\n                const r1 = e1[0].dims.slice(), i1 = Object.hasOwnProperty.call(t1, \"dilations\"), s1 = t1.kernelShape.slice(), a1 = t1.strides.slice(), u1 = i1 ? t1.dilations.slice() : [], l1 = t1.pads.slice();\n                o1.PoolConvUtil.adjustPoolAttributes(n1, r1, s1, a1, u1, l1);\n                const c1 = o1.PoolConvUtil.computePoolOutputShape(n1, r1, a1, u1, s1, l1, t1.autoPad), p1 = Object.assign({}, t1);\n                return i1 ? Object.assign(p1, {\n                    kernelShape: s1,\n                    strides: a1,\n                    pads: l1,\n                    dilations: u1,\n                    cacheKey: t1.cacheKey\n                }) : Object.assign(p1, {\n                    kernelShape: s1,\n                    strides: a1,\n                    pads: l1,\n                    cacheKey: t1.cacheKey\n                }), [\n                    p1,\n                    c1\n                ];\n            }, l1 = {\n                autoPad: \"\",\n                ceilMode: 0,\n                countIncludePad: !1,\n                kernelShape: [],\n                strides: [],\n                pads: [],\n                storageOrder: 0,\n                dilations: [],\n                cacheKey: \"\"\n            }, c1 = {\n                name: \"GlobalMaxPool\",\n                inputNames: [\n                    \"X\"\n                ],\n                inputTypes: [\n                    i1.TextureType.unpacked\n                ]\n            };\n            t1.globalMaxPool = (e1, t1)=>(p1(t1), [\n                    e1.run(Object.assign(Object.assign({}, c1), {\n                        get: ()=>a1(t1, c1, !0, l1)\n                    }), t1)\n                ]);\n            const p1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Pool ops requires 1 input.\");\n                if (\"float32\" !== e1[0].type && \"float64\" !== e1[0].type) throw new Error(\"Invalid input type.\");\n            }, d1 = (e1, t1, n1, r1, i1)=>{\n                const s1 = e1.length;\n                if (t1.kernelShape.length <= 2) {\n                    const o1 = t1.kernelShape[t1.kernelShape.length - 1], a1 = t1.strides[t1.strides.length - 1], u1 = t1.pads[t1.pads.length / 2 - 1], l1 = t1.pads[t1.pads.length - 1], c1 = e1[s1 - 1];\n                    let p1 = \"\", d1 = \"\", f1 = \"\";\n                    if (p1 = u1 + l1 !== 0 ? `\\n          for (int i = 0; i < ${o1}; i++) {\\n            x[${s1} - 1] = indices[${s1} - 1] * ${a1} - ${u1} + i;\\n            if (x[${s1} - 1] < 0 || x[${s1} - 1] >= ${c1}) {\\n              pad++;\\n              continue;\\n            }\\n            ${n1}\\n          }` : `\\n          for (int i = 0; i < ${o1}; i++) {\\n            x[${s1} - 1] = indices[${s1} - 1] * ${a1} - ${u1} + i;\\n            ${n1}\\n          }`, 2 === t1.kernelShape.length) {\n                        const n1 = t1.kernelShape[t1.kernelShape.length - 2], r1 = t1.strides[t1.strides.length - 2], i1 = t1.pads[t1.pads.length / 2 - 2], a1 = t1.pads[t1.pads.length - 2], u1 = e1[s1 - 2];\n                        d1 = i1 + a1 !== 0 ? `\\n            for (int j = 0; j < ${n1}; j++) {\\n              x[${s1} - 2] = indices[${s1} - 2] * ${r1} - ${i1} + j;\\n              if (x[${s1} - 2] < 0 || x[${s1} - 2] >= ${u1}) {\\n                pad+= ${o1};\\n                continue;\\n              }\\n          ` : `\\n            for (int j = 0; j < ${n1}; j++) {\\n              x[${s1} - 2] = indices[${s1} - 2] * ${r1} - ${i1} + j;\\n            `, f1 = \"\\n          }\\n        \";\n                    }\n                    return `\\n        float process(int indices[${s1}]) {\\n          int x[${s1}];\\n          copyVec(indices, x);\\n\\n          float value = ${i1};\\n          int pad = 0;\\n          ${d1}\\n          ${p1}\\n          ${f1}\\n          ${r1}\\n          return value;\\n        }\\n      `;\n                }\n                {\n                    const a1 = o1.ShapeUtil.size(t1.kernelShape), u1 = o1.ShapeUtil.computeStrides(t1.kernelShape), l1 = u1.length, c1 = t1.pads.length, p1 = h1(l1), d1 = f1(e1, \"inputDims\"), g1 = f1(t1.pads, \"pads\"), b1 = f1(u1, \"kernelStrides\"), m1 = f1(t1.strides, \"strides\");\n                    let y1 = \"\";\n                    return y1 = t1.pads.reduce((e1, t1)=>e1 + t1) ? `\\n            if (x[j] >= inputDims[j] || x[j] < 0) {\\n              pad++;\\n              isPad = true;\\n              break;\\n            }\\n          }\\n          if (!isPad) {\\n            ${n1}\\n          }` : `\\n          }\\n          ${n1}\\n        `, `\\n        ${p1}\\n        float process(int indices[${s1}]) {\\n          int x[${s1}];\\n          copyVec(indices, x);\\n          int offset[${l1}];\\n          int pads[${c1}];\\n          int inputDims[${s1}];\\n          int kernelStrides[${l1}];\\n          int strides[${l1}];\\n          ${g1}\\n          ${d1}\\n          ${m1}\\n          ${b1}\\n\\n          float value = ${i1};\\n          int pad = 0;\\n          bool isPad = false;\\n          for (int i = 0; i < ${a1}; i++) {\\n            offsetToIndices(i, kernelStrides, offset);\\n            isPad = false;\\n            for (int j = ${s1} - ${l1}; j < ${s1}; j++) {\\n              x[j] = indices[j] * strides[j - ${s1} + ${l1}]\\n                + offset[j - ${s1} + ${l1}] - pads[j - 2];\\n              ${y1}\\n          }\\n          ${r1}\\n\\n          return value;\\n        }\\n      `;\n                }\n            }, f1 = (e1, t1)=>{\n                let n1 = \"\";\n                for(let r1 = 0; r1 < e1.length; r1++)n1 += `\\n      ${t1}[${r1}] = ${e1[r1]};\\n    `;\n                return n1;\n            }, h1 = (e1)=>`\\n  void offsetToIndices(int offset, int[${e1}] strides, out int[${e1}] indices) {\\n    if (${e1} == 0) {\\n      return;\\n    }\\n    for (int i = 0; i < ${e1} - 1; ++i) {\\n      indices[i] = offset / strides[i];\\n      offset -= indices[i] * strides[i];\\n    }\\n    indices[${e1} - 1] = offset;\\n  }`;\n        },\n        1010: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.reduceLogSumSquare = t1.reduceLogSum = t1.reduceProd = t1.reduceMin = t1.reduceMax = t1.reduceMean = t1.reduceSum = t1.parseReduceAttributes = void 0;\n            const r1 = n1(4910), o1 = n1(6145), i1 = n1(7273), s1 = n1(5639), a1 = (e1, t1, n1, r1, o1)=>{\n                l1(t1);\n                const i1 = {\n                    name: r1,\n                    inputNames: [\n                        \"A\"\n                    ],\n                    inputTypes: [\n                        s1.TextureType.unpacked\n                    ]\n                };\n                return [\n                    e1.run(Object.assign(Object.assign({}, i1), {\n                        cacheHint: n1.cacheKey,\n                        get: ()=>u1(e1, t1, n1, r1, o1, i1)\n                    }), t1)\n                ];\n            };\n            t1.parseReduceAttributes = (e1)=>{\n                const t1 = e1.attributes.getInts(\"axes\", []), n1 = 1 === e1.attributes.getInt(\"keepdims\", 1);\n                return (0, r1.createAttributeWithCacheKey)({\n                    axes: t1,\n                    keepDims: n1\n                });\n            };\n            const u1 = (e1, t1, n1, r1, o1, a1)=>{\n                const u1 = [], l1 = t1[0].dims.length || 1, c1 = [], p1 = i1.ShapeUtil.normalizeAxes(n1.axes, t1[0].dims.length), d1 = o1(t1, p1);\n                let f1 = d1[1];\n                for(let e1 = 0; e1 < t1[0].dims.length; e1++)p1.indexOf(e1) >= 0 || 0 === p1.length ? (n1.keepDims && u1.push(1), f1 = `\\n          for(int j${e1} = 0; j${e1} < ${t1[0].dims[e1]}; j${e1}++) {\\n            inputIdx[${e1}] = j${e1};\\n            ${f1}\\n          }`) : (c1.push(`inputIdx[${e1}] = outputIdx[${u1.length}];`), u1.push(t1[0].dims[e1]));\n                const h1 = `\\n      float process(int outputIdx[${u1.length || 1}]) {\\n        float value;                 // final result\\n        int inputIdx[${l1}];      // addressing input data\\n        ${c1.join(\"\\n\")}\\n        ${d1[0]}       // init ops for reduce max/min\\n        ${f1}\\n        ${d1[2]}       // final computation for reduce mean\\n        return value;\\n      }`;\n                return Object.assign(Object.assign({}, a1), {\n                    output: {\n                        dims: u1,\n                        type: t1[0].type,\n                        textureType: s1.TextureType.unpacked\n                    },\n                    shaderSource: h1\n                });\n            }, l1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Reduce op requires 1 input.\");\n                if (-1 === o1.NUMBER_TYPES.indexOf(e1[0].type)) throw new Error(\"Invalid input type.\");\n            };\n            t1.reduceSum = (e1, t1, n1)=>a1(e1, t1, n1, \"ReduceSum\", ()=>[\n                        \"value = 0.0;\",\n                        \"value += _A(inputIdx);\",\n                        \"\"\n                    ]), t1.reduceMean = (e1, t1, n1)=>a1(e1, t1, n1, \"ReduceMean\", (e1, t1)=>{\n                    let n1 = 1;\n                    for(let r1 = 0; r1 < e1[0].dims.length; r1++)(t1.indexOf(r1) >= 0 || 0 === t1.length) && (n1 *= e1[0].dims[r1]);\n                    return [\n                        \"value = 0.0;\",\n                        \"value += _A(inputIdx);\",\n                        `value /= ${n1}.;`\n                    ];\n                }), t1.reduceMax = (e1, t1, n1)=>a1(e1, t1, n1, \"ReduceMax\", (e1, t1)=>{\n                    const n1 = [];\n                    for(let r1 = 0; r1 < e1[0].dims.length; r1++)(t1.indexOf(r1) >= 0 || 0 === t1.length) && n1.push(`inputIdx[${r1}] = 0;`);\n                    return [\n                        `${n1.join(\"\\n\")}\\nvalue = _A(inputIdx);`,\n                        \"value = max(value, _A(inputIdx));\",\n                        \"\"\n                    ];\n                }), t1.reduceMin = (e1, t1, n1)=>a1(e1, t1, n1, \"ReduceMin\", (e1, t1)=>{\n                    const n1 = [];\n                    for(let r1 = 0; r1 < e1[0].dims.length; r1++)(t1.indexOf(r1) >= 0 || 0 === t1.length) && n1.push(`inputIdx[${r1}] = 0;`);\n                    return [\n                        `${n1.join(\"\\n\")}\\nvalue = _A(inputIdx);`,\n                        \"value = min(value, _A(inputIdx));\",\n                        \"\"\n                    ];\n                }), t1.reduceProd = (e1, t1, n1)=>a1(e1, t1, n1, \"ReduceProd\", ()=>[\n                        \"value = 1.0;\",\n                        \"value *= _A(inputIdx);\",\n                        \"\"\n                    ]), t1.reduceLogSum = (e1, t1, n1)=>a1(e1, t1, n1, \"ReduceLogSum\", ()=>[\n                        \"value = 0.0;\",\n                        \"value += _A(inputIdx);\",\n                        \"value = log(value);\"\n                    ]), t1.reduceLogSumSquare = (e1, t1, n1)=>a1(e1, t1, n1, \"ReduceLogSumSquare\", ()=>[\n                        \"float t; value = 0.0;\",\n                        \"t = _A(inputIdx); value += t * t;\",\n                        \"\"\n                    ]);\n        },\n        7379: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.isReshapeCheap = t1.processDims3D = t1.createPackedReshape3DProgramInfoLoader = void 0;\n            const r1 = n1(7273), o1 = n1(6757), i1 = n1(5639), s1 = n1(5614);\n            t1.createPackedReshape3DProgramInfoLoader = (e1, t1, n1)=>{\n                const a1 = ((e1)=>({\n                        name: \"Reshape (packed)\",\n                        inputTypes: [\n                            i1.TextureType.packed\n                        ],\n                        inputNames: [\n                            \"A\"\n                        ],\n                        cacheHint: `${e1}`\n                    }))(n1);\n                return Object.assign(Object.assign({}, a1), {\n                    get: ()=>((e1, t1, n1, a1)=>{\n                            const u1 = t1.dims, l1 = a1;\n                            let c1 = \"\";\n                            for(let e1 = 0; e1 < 4; e1++){\n                                let t1 = \"\";\n                                switch(e1){\n                                    case 0:\n                                        t1 = \"outputCoords = rc;\";\n                                        break;\n                                    case 1:\n                                        t1 = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z);\";\n                                        break;\n                                    case 2:\n                                        t1 = \"outputCoords = ivec3(rc.x, rc.y, rc.z+1);\";\n                                        break;\n                                    case 3:\n                                        t1 = \"outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);\";\n                                        break;\n                                    default:\n                                        throw new Error;\n                                }\n                                c1 += `\\n        ${t1}\\n        ${e1 > 0 ? \"if(outputCoords.y < rows && outputCoords.z < cols){\" : \"\"}\\n          int flattenedIndex = getFlattenedIndex(outputCoords);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[${e1}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\\n\\n        ${e1 > 0 ? \"}\" : \"\"}\\n      `;\n                            }\n                            const p1 = (0, o1.getGlsl)(e1.session.backend.glContext.version), d1 = `\\n      ${function(e1) {\n                                const t1 = r1.ShapeUtil.computeStrides(e1), n1 = [\n                                    \"b\",\n                                    \"r\",\n                                    \"c\"\n                                ], o1 = \"index\", i1 = t1.map((e1, r1)=>`int ${n1[r1]} = ${o1} / ${e1}; ${r1 === t1.length - 1 ? `int ${n1[r1 + 1]} = ${o1} - ${n1[r1]} * ${e1}` : `index -= ${n1[r1]} * ${e1}`};`).join(\"\");\n                                return `\\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      ${i1}\\n      return ivec3(b, r, c);\\n    }\\n  `;\n                            }(u1)}\\n      ${function(e1) {\n                                const t1 = r1.ShapeUtil.computeStrides(e1);\n                                return `\\n  int getFlattenedIndex(ivec3 coords) {\\n    // reverse y, z order\\n    return coords.x * ${t1[0]} + coords.z * ${t1[1]} + coords.y;\\n  }\\n`;\n                            }(l1)}\\n      ${(0, s1.unpackFromChannel)()}\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.0);\\n\\n        ivec3 outputCoords;\\n        int rows = ${l1[2]};\\n        int cols = ${l1[1]};\\n\\n        ${c1}\\n        ${p1.output} = result;\\n      }\\n    `;\n                            return Object.assign(Object.assign({}, n1), {\n                                output: {\n                                    dims: l1,\n                                    type: t1.type,\n                                    textureType: i1.TextureType.packed\n                                },\n                                shaderSource: d1,\n                                hasMain: !0\n                            });\n                        })(e1, t1, a1, n1)\n                });\n            }, t1.processDims3D = function(e1) {\n                if (0 === e1.length) return [\n                    1,\n                    1,\n                    1\n                ];\n                let t1 = 1;\n                for(let n1 = 0; n1 < e1.length - 2; ++n1)t1 *= e1[n1];\n                return [\n                    t1,\n                    e1.length > 1 ? e1[e1.length - 2] : 1,\n                    e1[e1.length - 1]\n                ];\n            }, t1.isReshapeCheap = function(e1, t1) {\n                let n1 = !1;\n                return n1 = 0 === e1.length || 0 === t1.length || (e1.length < 2 || t1.length < 2 ? e1[e1.length - 1] === t1[t1.length - 1] : e1[e1.length - 1] === t1[t1.length - 1] && e1[e1.length - 2] === t1[t1.length - 2]), n1;\n            };\n        },\n        8126: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.reshape = void 0;\n            const r1 = n1(7273);\n            t1.reshape = (e1, t1)=>{\n                const n1 = r1.ShapeUtil.calculateReshapedDims(t1[0].dims, t1[1].integerData);\n                return e1.session.pack ? [\n                    e1.reshapePacked(t1[0], n1)\n                ] : [\n                    e1.reshapeUnpacked(t1[0], n1)\n                ];\n            };\n        },\n        2801: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseResizeAttributesV11 = t1.parseResizeAttributesV10 = t1.resize = void 0;\n            const r1 = n1(6757), o1 = n1(5639), i1 = n1(432), s1 = n1(5614), a1 = n1(3980), u1 = {\n                name: \"Resize\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    o1.TextureType.packed\n                ]\n            };\n            t1.resize = (e1, t1, n1)=>((0, a1.validateInputs)(t1, n1), [\n                    e1.run(Object.assign(Object.assign({}, u1), {\n                        cacheHint: n1.cacheKey,\n                        get: ()=>l1(e1, t1, n1)\n                    }), t1)\n                ]), t1.parseResizeAttributesV10 = (e1)=>(0, a1.parseUpsampleAttributes)(e1, 10), t1.parseResizeAttributesV11 = (e1)=>(0, a1.parseUpsampleAttributes)(e1, 11);\n            const l1 = (e1, t1, n1)=>{\n                const a1 = (0, r1.getGlsl)(e1.session.backend.glContext.version), [l1, p1] = c1(t1, n1);\n                if (l1.every((e1)=>1 === e1) && \"tf_crop_and_resize\" !== n1.coordinateTransformMode) return Object.assign(Object.assign({}, u1), {\n                    output: {\n                        dims: p1,\n                        type: t1[0].type,\n                        textureType: o1.TextureType.packed\n                    },\n                    hasMain: !0,\n                    shaderSource: `void main() {\\n                    vec4 v = ${a1.texture2D}(X, TexCoords);\\n                    ${a1.output} = v;\\n                }`\n                });\n                const d1 = p1.length;\n                if (d1 < 2) throw new Error(`output dimension should be at least 2, but got ${d1}`);\n                const f1 = p1[d1 - 2], h1 = p1[d1 - 1], g1 = t1[0].dims;\n                if (d1 !== g1.length) throw new Error(`output dimension should match input ${g1.length}, but got ${d1}`);\n                const b1 = g1[d1 - 2], m1 = g1[d1 - 1], y1 = l1[d1 - 2], _1 = l1[d1 - 1];\n                let v1 = \"\";\n                if (\"linear\" !== n1.mode) throw new Error(`resize (packed) does not support mode: '${n1.mode}'`);\n                switch(n1.coordinateTransformMode){\n                    case \"asymmetric\":\n                        v1 = \"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return vec4(coords) / scaleWHWH;\\n                    }\\n                \";\n                        break;\n                    case \"half_pixel\":\n                        v1 = \"\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\\n                    }\\n                \";\n                        break;\n                    case \"pytorch_half_pixel\":\n                        v1 = `\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 fcoords = vec4(coords);\\n                        return vec4(\\n                            ${h1}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\\n                            ${f1}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\\n                            ${h1}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\\n                            ${f1}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\\n                          );\\n                    }\\n                `;\n                        break;\n                    case \"align_corners\":\n                        v1 = `\\n                    vec4 getSourceFracIndex(ivec4 coords) {\\n                        vec4 resized = vec4(${h1}.0 - 1.0, ${f1}.0 - 1.0, ${h1}.0 - 1.0,\\n                            ${f1}.0 - 1.0);\\n                        vec4 original = vec4(${m1}.0 - 1.0, ${b1}.0 - 1.0, ${m1}.0 - 1.0,\\n                            ${b1}.0 - 1.0);\\n                        vec4 new_scale = original / resized;\\n                        return vec4(coords) * new_scale;\\n                    }\\n                `;\n                        break;\n                    default:\n                        throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n1.coordinateTransformMode}'`);\n                }\n                const T1 = (0, i1.getCoordsDataType)(d1), x1 = `\\n            const vec2 inputWH = vec2(${b1}.0, ${m1}.0);\\n            const vec4 scaleWHWH = vec4(float(${y1}), float(${_1}), float(${y1}), float(${_1}));\\n            ${(0, s1.unpackFromChannel)()}\\n            ${v1}\\n            float getAValue(int x10, int r, int c, int d) {\\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\\n            }\\n            void main() {\\n                ${T1} rc = getOutputCoords();\\n\\n                int batch = rc[0];\\n                int depth = rc[1];\\n\\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\\n\\n                // calculate the source index in fraction\\n                vec4 sourceFrac = getSourceFracIndex(coords);\\n\\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\\n\\n                bool hasNextRow = rc.w < ${f1 - 1};\\n                bool hasNextCol = rc.z < ${h1 - 1};\\n\\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\\n                vec4 topLeft = vec4(\\n                    getAValue(batch, depth, x00.x, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\\n                vec4 topRight = vec4(\\n                    getAValue(batch, depth, x00.x, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\\n                vec4 bottomLeft = vec4(\\n                    getAValue(batch, depth, x00.z, x00.y),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\\n\\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\\n                vec4 bottomRight = vec4(\\n                    getAValue(batch, depth, x00.z, x00.w),\\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\\n\\n                // calculate the interpolation fraction on u and v direction\\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\\n\\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\\n\\n                ${a1.output} = vec4(newValue);\\n            }\\n        `;\n                return Object.assign(Object.assign({}, u1), {\n                    output: {\n                        dims: p1,\n                        type: t1[0].type,\n                        textureType: o1.TextureType.packed\n                    },\n                    hasMain: !0,\n                    shaderSource: x1\n                });\n            }, c1 = (e1, t1)=>{\n                const n1 = e1[0].dims;\n                let r1, o1 = t1.scales;\n                if (0 === o1.length) {\n                    const i1 = e1[t1.scalesInputIdx];\n                    if (i1 && 0 !== i1.size) {\n                        if (e1[t1.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n                        o1 = p1(i1, t1.mode, t1.isResize);\n                    } else {\n                        const i1 = e1[t1.sizesInputIdx];\n                        if (!i1 || 0 === i1.size) throw new Error(\"Either scales or sizes MUST be provided as input.\");\n                        r1 = Array.from(i1.integerData), o1 = d1(r1, n1, t1.mode, t1.isResize);\n                    }\n                } else if (e1[t1.sizesInputIdx]) throw new Error(\"Only one of scales or sizes must be provided as input.\");\n                const i1 = r1 || n1.map((e1, t1)=>Math.floor(e1 * o1[t1]));\n                return [\n                    o1,\n                    i1\n                ];\n            }, p1 = (e1, t1, n1)=>{\n                const r1 = Array.from(e1.floatData);\n                return (0, a1.scalesValidation)(r1, t1, n1), r1;\n            }, d1 = (e1, t1, n1, r1)=>{\n                const o1 = t1.length, i1 = new Array(o1);\n                for(let n1 = 0, r1 = o1; n1 < r1; n1++)if (0 === t1[n1]) {\n                    if (0 !== e1[n1]) throw new Error(\"Input dim is zero but required output dim is non-zero.\");\n                    i1[n1] = 1;\n                } else i1[n1] = e1[n1] / t1[n1];\n                return (0, a1.scalesValidation)(i1, n1, r1), i1;\n            };\n        },\n        565: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.shape = void 0;\n            const r1 = n1(9240);\n            t1.shape = (e1, t1)=>(o1(t1), [\n                    new r1.Tensor([\n                        t1[0].dims.length\n                    ], \"int32\", void 0, void 0, new Int32Array(t1[0].dims))\n                ]);\n            const o1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Shape requires 1 input.\");\n            };\n        },\n        2444: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.sliceV10 = t1.parseSliceAttributes = t1.slice = void 0;\n            const r1 = n1(4910), o1 = n1(6145), i1 = n1(7273), s1 = n1(5639), a1 = {\n                name: \"Slice\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    s1.TextureType.unpacked\n                ]\n            };\n            t1.slice = (e1, t1, n1)=>(l1(t1), [\n                    e1.run(Object.assign(Object.assign({}, a1), {\n                        cacheHint: n1.cacheKey,\n                        get: ()=>u1(e1, t1[0], n1)\n                    }), t1)\n                ]), t1.parseSliceAttributes = (e1)=>{\n                const t1 = e1.attributes.getInts(\"starts\"), n1 = e1.attributes.getInts(\"ends\"), o1 = e1.attributes.getInts(\"axes\", []);\n                return (0, r1.createAttributeWithCacheKey)({\n                    starts: t1,\n                    ends: n1,\n                    axes: o1\n                });\n            };\n            const u1 = (e1, t1, n1)=>{\n                const r1 = 0 === n1.axes.length ? t1.dims.slice(0).map((e1, t1)=>t1) : n1.axes, o1 = i1.ShapeUtil.normalizeAxes(r1, t1.dims.length), u1 = n1.starts.map((e1, n1)=>e1 > t1.dims[o1[n1]] - 1 ? t1.dims[o1[n1]] : i1.ShapeUtil.normalizeAxis(e1, t1.dims[o1[n1]])), l1 = n1.ends.map((e1, n1)=>e1 > t1.dims[o1[n1]] - 1 ? t1.dims[o1[n1]] : i1.ShapeUtil.normalizeAxis(e1, t1.dims[o1[n1]])), c1 = t1.dims.slice(), p1 = [];\n                for(let e1 = 0; e1 < o1.length; e1++)c1[o1[e1]] = l1[e1] - u1[e1], u1[e1] > 0 && p1.push(`outputIdx[${o1[e1]}] += ${u1[e1]};`);\n                const d1 = `\\n      float process(int outputIdx[${c1.length}]) {\\n        ${p1.join(\"\\n      \")}\\n        return _A(outputIdx);\\n      }`;\n                return Object.assign(Object.assign({}, a1), {\n                    output: {\n                        dims: c1,\n                        type: t1.type,\n                        textureType: s1.TextureType.unpacked\n                    },\n                    shaderSource: d1\n                });\n            }, l1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Slice requires 1 input.\");\n                if (-1 === o1.NUMBER_TYPES.indexOf(e1[0].type)) throw new Error(\"Invalid input type.\");\n            };\n            t1.sliceV10 = (e1, t1)=>{\n                p1(t1);\n                const n1 = c1(e1, t1);\n                return [\n                    e1.run(Object.assign(Object.assign({}, a1), {\n                        cacheHint: n1.cacheKey,\n                        get: ()=>u1(e1, t1[0], n1)\n                    }), [\n                        t1[0]\n                    ])\n                ];\n            };\n            const c1 = (e1, t1)=>{\n                if (!e1.session.isInitializer(t1[1].dataId) || !e1.session.isInitializer(t1[2].dataId) || t1.length >= 4 && !e1.session.isInitializer(t1[3].dataId) || t1.length >= 5 && !e1.session.isInitializer(t1[4].dataId)) throw new Error(\"dynamic slice attributes are not allowed\");\n                if (t1.length >= 5 && t1[4].integerData.some((e1)=>1 !== e1)) throw new Error(\"currently non-1 steps is not supported for Slice\");\n                const n1 = Array.from(t1[1].integerData), r1 = Array.from(t1[2].integerData), o1 = t1.length >= 4 ? Array.from(t1[3].integerData) : [];\n                return {\n                    starts: n1,\n                    ends: r1,\n                    axes: o1,\n                    cacheKey: `${o1};${n1};${r1}`\n                };\n            }, p1 = (e1)=>{\n                if (!e1 || e1.length < 3 || e1.length > 5) throw new Error(\"Invalid input number.\");\n                if (\"int32\" !== e1[1].type || 1 !== e1[1].dims.length) throw new Error(\"Invalid input type.\");\n                if (\"int32\" !== e1[2].type || 1 !== e1[2].dims.length) throw new Error(\"Invalid input type.\");\n                if (e1.length >= 4 && (\"int32\" !== e1[3].type || 1 !== e1[3].dims.length)) throw new Error(\"Invalid input type.\");\n                if (e1.length >= 5 && (\"int32\" !== e1[4].type || 1 !== e1[4].dims.length)) throw new Error(\"Invalid input type.\");\n            };\n        },\n        815: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.softmaxV13 = t1.parseSoftmaxAttributesV13 = t1.parseSoftmaxAttributes = t1.softmax = void 0;\n            const r1 = n1(4910), o1 = n1(7273), i1 = n1(6757), s1 = n1(5639), a1 = n1(5707), u1 = {\n                name: \"SoftmaxComputeMax\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    s1.TextureType.unpacked\n                ]\n            }, l1 = {\n                name: \"SoftmaxComputeScale\",\n                inputNames: [\n                    \"A\",\n                    \"Max\"\n                ],\n                inputTypes: [\n                    s1.TextureType.unpacked,\n                    s1.TextureType.unpacked\n                ]\n            }, c1 = {\n                name: \"SoftMax\",\n                inputNames: [\n                    \"A\",\n                    \"Max\",\n                    \"Norm\"\n                ],\n                inputTypes: [\n                    s1.TextureType.unpacked,\n                    s1.TextureType.unpacked,\n                    s1.TextureType.unpacked\n                ]\n            };\n            t1.softmax = (e1, t1, n1)=>{\n                g1(t1);\n                const r1 = t1[0].dims.slice(), i1 = o1.ShapeUtil.normalizeAxis(n1.axis, r1.length), s1 = o1.ShapeUtil.sizeToDimension(r1, i1), a1 = o1.ShapeUtil.sizeFromDimension(r1, i1);\n                return p1(e1, t1, n1, s1, a1);\n            }, t1.parseSoftmaxAttributes = (e1)=>(0, r1.createAttributeWithCacheKey)({\n                    axis: e1.attributes.getInt(\"axis\", 1)\n                }), t1.parseSoftmaxAttributesV13 = (e1)=>(0, r1.createAttributeWithCacheKey)({\n                    axis: e1.attributes.getInt(\"axis\", -1)\n                }), t1.softmaxV13 = (e1, t1, n1)=>{\n                g1(t1);\n                const i1 = t1[0].dims.slice(), s1 = o1.ShapeUtil.normalizeAxis(n1.axis, i1.length), u1 = i1.length, l1 = s1 !== u1 - 1, c1 = [];\n                let d1, f1 = [], h1 = [];\n                l1 && (f1 = Array.from({\n                    length: u1\n                }).map((e1, t1)=>t1), f1[s1] = u1 - 1, f1[u1 - 1] = s1, f1.map((e1)=>c1.push(i1[e1])), d1 = (0, r1.createAttributeWithCacheKey)({\n                    perm: f1\n                }), h1 = (0, a1.transpose)(e1, t1, d1));\n                const b1 = l1 ? o1.ShapeUtil.sizeToDimension(c1, u1 - 1) : o1.ShapeUtil.sizeToDimension(i1, u1 - 1), m1 = l1 ? o1.ShapeUtil.sizeFromDimension(c1, u1 - 1) : o1.ShapeUtil.sizeFromDimension(i1, u1 - 1), y1 = p1(e1, l1 ? h1 : t1, n1, b1, m1);\n                return l1 ? (0, a1.transpose)(e1, y1, d1) : y1;\n            };\n            const p1 = (e1, t1, n1, r1, o1)=>{\n                const i1 = d1(e1, t1[0], r1, o1, [\n                    r1\n                ]), s1 = e1.run(Object.assign(Object.assign({}, u1), {\n                    cacheHint: n1.cacheKey,\n                    get: ()=>i1\n                }), t1), a1 = f1(e1, t1[0], r1, o1, i1.output.dims, [\n                    r1\n                ]), p1 = e1.run(Object.assign(Object.assign({}, l1), {\n                    cacheHint: n1.cacheKey,\n                    get: ()=>a1\n                }), [\n                    t1[0],\n                    s1\n                ]), g1 = h1(e1, t1[0], r1, o1, i1.output.dims, a1.output.dims);\n                return [\n                    e1.run(Object.assign(Object.assign({}, c1), {\n                        cacheHint: n1.cacheKey,\n                        get: ()=>g1\n                    }), [\n                        t1[0],\n                        s1,\n                        p1\n                    ])\n                ];\n            }, d1 = (e1, t1, n1, r1, o1)=>{\n                const [a1, l1] = e1.calculateTextureWidthAndHeight(t1.dims, s1.TextureType.unpacked), c1 = o1.length;\n                if (n1 < 1 || r1 < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n                if (1 !== o1.length) throw new Error(\"Dimensionality of the output should be 1\");\n                if (o1[0] !== n1) throw new Error(\"Shape of the output should be equal to logical row count\");\n                const p1 = (0, i1.getGlsl)(e1.session.backend.glContext.version), d1 = `\\n      float process(int[${c1}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r1};\\n\\n        float max = getColorAsFloat(${p1.texture2D}(A, offsetToCoords(logical_row_start_offset, ${a1},\\n        ${l1} )));\\n        for(int i=1; i<${r1}; ++i)\\n        {\\n          float current = getColorAsFloat(${p1.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${a1}, ${l1})));\\n          if(current > max)\\n          max = current;\\n        }\\n\\n        return max;\\n      }`;\n                return Object.assign(Object.assign({}, u1), {\n                    output: {\n                        dims: o1,\n                        type: t1.type,\n                        textureType: s1.TextureType.unpacked\n                    },\n                    shaderSource: d1\n                });\n            }, f1 = (e1, t1, n1, r1, o1, a1)=>{\n                const [u1, c1] = e1.calculateTextureWidthAndHeight(t1.dims, s1.TextureType.unpacked), p1 = a1.length;\n                if (n1 < 1 || r1 < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n                if (1 !== a1.length) throw new Error(\"Dimensionality of the output should be 1\");\n                if (a1[0] !== n1) throw new Error(\"Shape of the output should be equal to logical row count\");\n                if (1 !== o1.length) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n                if (o1[0] !== n1) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n                const d1 = `\\n      float process(int[${p1}] indices) {\\n        int logical_row_start_offset = indices[0] * ${r1};\\n\\n        float norm_factor = 0.0;\\n        float max = _Max(indices);\\n        for(int i=0; i<${r1}; ++i)\\n        {\\n          norm_factor += exp(getColorAsFloat(${(0, i1.getGlsl)(e1.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\\n            ${u1}, ${c1}))) - max);\\n        }\\n\\n        return norm_factor;\\n      }`;\n                return Object.assign(Object.assign({}, l1), {\n                    output: {\n                        dims: a1,\n                        type: t1.type,\n                        textureType: s1.TextureType.unpacked\n                    },\n                    shaderSource: d1\n                });\n            }, h1 = (e1, t1, n1, r1, o1, i1)=>{\n                const [a1, u1] = e1.calculateTextureWidthAndHeight(t1.dims, s1.TextureType.unpacked), l1 = t1.dims.length;\n                if (n1 < 1 || r1 < 1) throw new Error(\"Logical row count N and feature count D must be greater than or equal to 1\");\n                if (1 !== o1.length || 1 !== i1.length) throw new Error(\"Dimensionality of the intermediate results should be 1\");\n                if (o1[0] !== n1 || i1[0] !== n1) throw new Error(\"Shape of the intermediate results should be equal to logical row count\");\n                const p1 = `\\n      float process(int[${l1}] indices) {\\n\\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\\n      int offset = coordsToOffset(TexCoords, ${a1}, ${u1});\\n\\n      //determine the logical row for this index\\n      int logical_row_index[1];\\n      logical_row_index[0] = offset / ${r1};\\n\\n      float norm_factor = _Norm(logical_row_index);\\n\\n      // avoid possible division by 0\\n      // if norm_facor is 0, all elements are zero\\n      // if so, return 0\\n      if(norm_factor == 0.0)\\n        return 0.0;\\n\\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\\n    }`;\n                return Object.assign(Object.assign({}, c1), {\n                    output: {\n                        dims: t1.dims,\n                        type: t1.type,\n                        textureType: s1.TextureType.unpacked\n                    },\n                    shaderSource: p1\n                });\n            }, g1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Softmax requires 1 input.\");\n                if (\"float32\" !== e1[0].type && \"float64\" !== e1[0].type) throw new Error(\"Invalid input type\");\n            };\n        },\n        564: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseSplitAttributes = t1.split = void 0;\n            const r1 = n1(4910), o1 = n1(7273), i1 = n1(5639), s1 = {\n                name: \"Split\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    i1.TextureType.unpacked\n                ]\n            };\n            t1.split = (e1, t1, n1)=>{\n                l1(t1);\n                const r1 = o1.ShapeUtil.normalizeAxis(n1.axis, t1[0].dims.length), i1 = a1(e1, t1, r1, n1), c1 = [];\n                for(let o1 = 0; o1 < i1; ++o1)c1.push(e1.run(Object.assign(Object.assign({}, s1), {\n                    cacheHint: `${n1.cacheKey};${o1}`,\n                    get: ()=>u1(e1, t1[0], n1, r1, o1)\n                }), t1));\n                return c1;\n            }, t1.parseSplitAttributes = (e1)=>{\n                const t1 = e1.attributes.getInt(\"axis\", 0), n1 = e1.attributes.getInts(\"split\", []), o1 = e1.outputs.length;\n                return (0, r1.createAttributeWithCacheKey)({\n                    axis: t1,\n                    split: n1,\n                    numOutputs: o1\n                });\n            };\n            const a1 = (e1, t1, n1, r1)=>{\n                const [, i1] = o1.SplitUtil.splitShape(t1[0].dims, n1, r1.split, r1.numOutputs);\n                return i1.length;\n            }, u1 = (e1, t1, n1, r1, a1)=>{\n                const [u1, l1] = o1.SplitUtil.splitShape(t1.dims, r1, n1.split, n1.numOutputs), c1 = l1[a1], p1 = u1[a1], d1 = `\\n      float process(int indices[${p1.length}]) {\\n        indices[${r1}] += ${c1};\\n        return _A(indices);\\n      }\\n    `;\n                return Object.assign(Object.assign({}, s1), {\n                    cacheHint: `${n1.cacheKey}:${a1}`,\n                    output: {\n                        dims: p1,\n                        type: t1.type,\n                        textureType: i1.TextureType.unpacked\n                    },\n                    shaderSource: d1\n                });\n            }, l1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Split requires one input.\");\n                if (\"int8\" !== e1[0].type && \"uint8\" !== e1[0].type && \"int16\" !== e1[0].type && \"uint16\" !== e1[0].type && \"int32\" !== e1[0].type && \"uint32\" !== e1[0].type && \"float32\" !== e1[0].type && \"float64\" !== e1[0].type && \"bool\" !== e1[0].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        5416: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseSqueezeAttributes = t1.squeezeV13 = t1.squeeze = void 0;\n            const r1 = n1(7273);\n            t1.squeeze = (e1, t1, n1)=>{\n                o1(t1);\n                const i1 = r1.ShapeUtil.squeezeShape(t1[0].dims, n1);\n                return [\n                    e1.reshapeUnpacked(t1[0], i1)\n                ];\n            }, t1.squeezeV13 = (e1, n1)=>(i1(n1), (0, t1.squeeze)(e1, [\n                    n1[0]\n                ], Array.from(n1[1].integerData))), t1.parseSqueezeAttributes = (e1)=>e1.attributes.getInts(\"axes\");\n            const o1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Squeeze requires 1 input.\");\n                if (\"string\" === e1[0].type) throw new Error(\"invalid input tensor types.\");\n            }, i1 = (e1)=>{\n                if (!e1 || 2 !== e1.length) throw new Error(\"Squeeze requires 2 inputs.\");\n                if (\"int32\" !== e1[1].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        1240: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.sum = void 0;\n            const r1 = n1(6757), o1 = n1(5639);\n            t1.sum = (e1, t1)=>{\n                s1(t1);\n                const n1 = {\n                    name: \"Sum\",\n                    inputNames: t1.map((e1, t1)=>`X${t1}`),\n                    inputTypes: new Array(t1.length).fill(o1.TextureType.unpacked)\n                };\n                return [\n                    e1.run(Object.assign(Object.assign({}, n1), {\n                        get: ()=>i1(e1, t1, n1)\n                    }), t1)\n                ];\n            };\n            const i1 = (e1, t1, n1)=>{\n                const i1 = (0, r1.getGlsl)(e1.session.backend.glContext.version), s1 = t1[0].dims.slice(), a1 = t1.map((e1, t1)=>`${i1.texture2D}(X${t1},TexCoords)`).join(\" + \"), u1 = `\\n      void main() {\\n        vec4 result = ${a1};\\n        ${i1.output} = result;\\n      }\\n    `;\n                return Object.assign(Object.assign({}, n1), {\n                    output: {\n                        dims: s1,\n                        type: t1[0].type,\n                        textureType: o1.TextureType.unpacked\n                    },\n                    hasMain: !0,\n                    shaderSource: u1\n                });\n            }, s1 = (e1)=>{\n                if (!e1 || 0 === e1.length) throw new Error(\"Sum requires inputs.\");\n                const t1 = e1[0].dims.length;\n                for(let n1 = 1; n1 < e1.length; n1++){\n                    if (t1 !== e1[n1].dims.length) throw new Error(\"Input shapes are mismatched.\");\n                    for(let r1 = 0; r1 < t1; r1++)if (e1[0].dims[r1] !== e1[n1].dims[r1]) throw new Error(\"Input shapes are not matched.\");\n                }\n                if (\"float32\" !== e1[0].type && \"float64\" !== e1[0].type) throw new Error(\"Invalid input type.\");\n                for(let t1 = 1; t1 < e1.length; t1++)if (e1[0].type !== e1[t1].type) throw new Error(\"Input types are not matched.\");\n            };\n        },\n        5944: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.tile = void 0;\n            const r1 = n1(6145), o1 = n1(5639);\n            t1.tile = (e1, t1)=>{\n                s1(t1);\n                const n1 = {\n                    name: \"Tile\",\n                    inputNames: [\n                        \"A\"\n                    ],\n                    inputTypes: [\n                        o1.TextureType.unpacked\n                    ]\n                };\n                return [\n                    e1.run(Object.assign(Object.assign({}, n1), {\n                        get: ()=>i1(e1, t1, n1)\n                    }), t1)\n                ];\n            };\n            const i1 = (e1, t1, n1)=>{\n                const r1 = t1[0].dims.slice(), i1 = new Array(r1.length), s1 = [];\n                for(let e1 = 0; e1 < r1.length; e1++)i1[e1] = r1[e1] * t1[1].numberData[e1], s1.push(`inputIdx[${e1}] = int(mod(float(outputIdx[${e1}]), ${r1[e1]}.));`);\n                const a1 = i1.length, u1 = `\\n      float process(int outputIdx[${a1}]) {\\n        int inputIdx[${a1}];\\n        ${s1.join(\"\\n\")}\\n        return _A(inputIdx);\\n      }\\n    `;\n                return Object.assign(Object.assign({}, n1), {\n                    output: {\n                        dims: i1,\n                        type: t1[0].type,\n                        textureType: o1.TextureType.unpacked\n                    },\n                    shaderSource: u1\n                });\n            }, s1 = (e1)=>{\n                if (!e1 || 2 !== e1.length) throw new Error(\"Tile requires 2 input.\");\n                if (1 !== e1[1].dims.length) throw new Error(\"The second input shape must 1 dimension.\");\n                if (e1[1].dims[0] !== e1[0].dims.length) throw new Error(\"Invalid input shape.\");\n                if (-1 === r1.NUMBER_TYPES.indexOf(e1[0].type)) throw new Error(\"Invalid input type.\");\n                if (\"int32\" !== e1[1].type && \"int16\" !== e1[1].type) throw new Error(\"Invalid repeat type.\");\n            };\n        },\n        5707: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseTransposeAttributes = t1.transpose = void 0;\n            const r1 = n1(4910), o1 = n1(7273), i1 = n1(5639), s1 = {\n                name: \"Transpose\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    i1.TextureType.unpacked\n                ]\n            };\n            t1.transpose = (e1, t1, n1)=>(p1(t1), [\n                    e1.run(Object.assign(Object.assign({}, s1), {\n                        cacheHint: n1.cacheKey,\n                        get: ()=>a1(e1, t1[0], n1.perm)\n                    }), t1)\n                ]), t1.parseTransposeAttributes = (e1)=>(0, r1.createAttributeWithCacheKey)({\n                    perm: e1.attributes.getInts(\"perm\", [])\n                });\n            const a1 = (e1, t1, n1)=>{\n                const r1 = t1.dims;\n                n1 = u1(r1, n1);\n                const o1 = l1(r1, n1), a1 = r1.length, p1 = `\\n      ${c1(\"perm\", n1, a1)}\\n      float process(int indices[${a1}]) {\\n        int a[${a1}];\\n        perm(a, indices);\\n        return _A(a);\\n      }`;\n                return Object.assign(Object.assign({}, s1), {\n                    output: {\n                        dims: o1,\n                        type: t1.type,\n                        textureType: i1.TextureType.unpacked\n                    },\n                    shaderSource: p1\n                });\n            }, u1 = (e1, t1)=>(t1 && t1.length !== e1.length && (t1 = [\n                    ...e1.keys()\n                ].reverse()), t1), l1 = (e1, t1)=>(t1 = u1(e1, t1), o1.ShapeUtil.sortBasedOnPerm(e1, t1)), c1 = (e1, t1, n1)=>{\n                const r1 = [];\n                r1.push(`void ${e1}(out int a[${n1}], int src[${n1}]) {`);\n                for(let e1 = 0; e1 < n1; ++e1)r1.push(`\\ta[${t1[e1]}]=src[${e1}];`);\n                return r1.push(\"\t}\"), r1.join(\"\\n\");\n            }, p1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Transpose requires 1 input.\");\n                if (\"float32\" !== e1[0].type && \"float64\" !== e1[0].type) throw new Error(\"input should be float tensor\");\n            };\n        },\n        2488: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.encodeAsUint8 = void 0;\n            const r1 = n1(6757), o1 = n1(5639);\n            t1.encodeAsUint8 = (e1, t1)=>{\n                const n1 = t1.shape, i1 = (0, r1.getGlsl)(e1.session.backend.glContext.version), s1 = `\\n    const float FLOAT_MAX = 1.70141184e38;\\n    const float FLOAT_MIN = 1.17549435e-38;\\n\\n    bool isNaN(float val) {\\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\\n    }\\n\\n    highp vec4 encodeAsUint8(highp float v) {\\n      if (isNaN(v)) {\\n        return vec4(255, 255, 255, 255);\\n      }\\n\\n      highp float av = abs(v);\\n\\n      if(av < FLOAT_MIN) {\\n        return vec4(0.0, 0.0, 0.0, 0.0);\\n      } else if(v > FLOAT_MAX) {\\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n      } else if(v < -FLOAT_MAX) {\\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n      }\\n\\n      highp vec4 c = vec4(0,0,0,0);\\n\\n      highp float e = floor(log2(av));\\n      highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n      c[2] = floor(128.0 * m);\\n      m -= c[2] / 128.0;\\n      c[1] = floor(32768.0 * m);\\n      m -= c[1] / 32768.0;\\n      c[0] = floor(8388608.0 * m);\\n\\n      highp float ebias = e + 127.0;\\n      c[3] = floor(ebias / 2.0);\\n      ebias -= c[3] * 2.0;\\n      c[2] += floor(ebias) * 128.0;\\n\\n      c[3] += 128.0 * step(0.0, -v);\\n\\n      return c / 255.0;\\n    }\\n\\n    void main() {\\n      float value = ${i1.texture2D}(X,TexCoords).r;\\n      ${i1.output} = encodeAsUint8(value);\\n    }`, a1 = {\n                    name: \"Uint8Encode\",\n                    inputTypes: [\n                        o1.TextureType.unpacked\n                    ],\n                    inputNames: [\n                        \"X\"\n                    ],\n                    output: {\n                        dims: n1,\n                        type: t1.tensor.type,\n                        textureType: o1.TextureType.downloadUint8AsFloat\n                    },\n                    shaderSource: s1,\n                    hasMain: !0\n                };\n                return e1.executeProgram(a1, [\n                    t1.tensor\n                ]);\n            };\n        },\n        9087: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.tanh = t1.tan = t1.sqrt = t1.sin = t1.sigmoid = t1.relu = t1.not = t1.neg = t1.log = t1.parseLeakyReluAttributes = t1.leakyRelu = t1.identity = t1.floor = t1.exp = t1.parseEluAttributes = t1.elu = t1.cos = t1.ceil = t1.clipV11 = t1.parseClipAttributes = t1.clip = t1.atan = t1.asin = t1.acos = t1.abs = t1.glslTanh = t1.glslTan = t1.glslSqrt = t1.glslSigmoid = t1.glslRelu = t1.glslSin = t1.glslNot = t1.glslNeg = t1.glslLog = t1.glslLeakyRelu = t1.glslIdentity = t1.glslClip = t1.glslFloor = t1.glslExp = t1.glslElu = t1.glslCos = t1.glslCeil = t1.glslAtan = t1.glslAsin = t1.glslAcos = t1.glslAbs = void 0;\n            const r1 = n1(4910), o1 = n1(7273), i1 = n1(1997), s1 = n1(6757), a1 = n1(5639);\n            function u1() {\n                return E1(\"abs\");\n            }\n            function l1() {\n                return E1(\"acos\");\n            }\n            function c1() {\n                return E1(\"asin\");\n            }\n            function p1() {\n                return E1(\"atan\");\n            }\n            function d1() {\n                return E1(\"ceil\");\n            }\n            function f1() {\n                return E1(\"cos\");\n            }\n            function h1(e1) {\n                const t1 = \"elu\";\n                return {\n                    body: `\\n  const float alpha = float(${e1});\\n\\n  float ${t1}_(float a) {\\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\\n  }\\n  vec4 ${t1}_(vec4 v) {\\n    return vec4(${t1}_(v.x), ${t1}_(v.y), ${t1}_(v.z), ${t1}_(v.w));\\n  }\\n  `,\n                    name: t1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            function g1() {\n                return E1(\"exp\");\n            }\n            function b1() {\n                return E1(\"floor\");\n            }\n            function m1(e1, t1) {\n                const n1 = \"clip\";\n                return {\n                    body: `\\n  const float min = float(${e1});\\n  const float max = float(${t1});\\n\\n  float ${n1}_(float a) {\\n    return clamp(a, min, max);\\n  }\\n  vec4 ${n1}_(vec4 v) {\\n    return clamp(v, min, max);\\n  }\\n  `,\n                    name: n1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            function y1() {\n                const e1 = \"indentity\";\n                return {\n                    body: `\\n  float ${e1}_(float a) {\\n    return a;\\n  }\\n  vec4 ${e1}_(vec4 v) {\\n    return v;\\n  }\\n  `,\n                    name: e1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            function _1(e1) {\n                const t1 = \"leakyRelu\";\n                return {\n                    body: `\\n  const float alpha = float(${e1});\\n\\n  float ${t1}_(float a) {\\n    return a < 0.0 ? a * alpha : a;\\n  }\\n  vec4 ${t1}_(vec4 v) {\\n    return vec4(${t1}_(v.x), ${t1}_(v.y), ${t1}_(v.z), ${t1}_(v.w));\\n  }\\n  `,\n                    name: t1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            function v1() {\n                return E1(\"log\");\n            }\n            function T1() {\n                const e1 = \"neg\";\n                return {\n                    body: `\\n  float ${e1}_(float a) {\\n    return -a;\\n  }\\n  vec4 ${e1}_(vec4 v) {\\n    return -v;\\n  }\\n  `,\n                    name: e1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            function x1() {\n                const e1 = \"not\";\n                return {\n                    body: `\\n  float ${e1}_(float a) {\\n    return float( ! bool(a) );\\n  }\\n  bool ${e1}_(bool a) {\\n    return !a;\\n  }\\n  vec4 ${e1}_(vec4 v) {\\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\\n  }\\n  bvec4 ${e1}_(bvec4 v) {\\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\\n  }\\n  `,\n                    name: e1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            function w1() {\n                return E1(\"sin\");\n            }\n            function O1() {\n                const e1 = \"relu\";\n                return {\n                    body: `\\n  float ${e1}_(float a) {\\n    return max( a, 0.0 );\\n  }\\n  vec4 ${e1}_(vec4 v) {\\n    return max( v, 0.0 );\\n  }\\n  `,\n                    name: e1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            function S1() {\n                const e1 = \"sigmoid\";\n                return {\n                    body: `\\n  float ${e1}_(float a) {\\n    return 1.0 / (1.0 + exp(-a));\\n  }\\n  vec4 ${e1}_(vec4 v) {\\n    return 1.0 / (1.0 + exp(-v));\\n  }\\n  `,\n                    name: e1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            function A1() {\n                return E1(\"sqrt\");\n            }\n            function P1() {\n                return E1(\"tan\");\n            }\n            function I1() {\n                const e1 = \"tanh\";\n                return {\n                    body: `\\n  float ${e1}_(float a) {\\n    a = clamp(a, -10., 10.);\\n    a = exp(2.*a);\\n    return (a - 1.) / (a + 1.);\\n  }\\n  vec4 ${e1}_(vec4 v) {\\n    v = clamp(v, -10., 10.);\\n    v = exp(2.*v);\\n    return (v - 1.) / (v + 1.);\\n  }\\n  `,\n                    name: e1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            function E1(e1) {\n                return {\n                    body: `\\n  float ${e1}_(float a) {\\n    return ${e1}(a);\\n  }\\n  vec4 ${e1}_(vec4 v) {\\n    return ${e1}(v);\\n  }\\n  `,\n                    name: e1,\n                    type: i1.FunctionType.ValueBased\n                };\n            }\n            t1.glslAbs = u1, t1.glslAcos = l1, t1.glslAsin = c1, t1.glslAtan = p1, t1.glslCeil = d1, t1.glslCos = f1, t1.glslElu = h1, t1.glslExp = g1, t1.glslFloor = b1, t1.glslClip = m1, t1.glslIdentity = y1, t1.glslLeakyRelu = _1, t1.glslLog = v1, t1.glslNeg = T1, t1.glslNot = x1, t1.glslSin = w1, t1.glslRelu = O1, t1.glslSigmoid = S1, t1.glslSqrt = A1, t1.glslTan = P1, t1.glslTanh = I1;\n            const D1 = (e1, t1, n1, r1)=>{\n                const o1 = e1.session.pack ? a1.TextureType.packed : a1.TextureType.unpacked, i1 = {\n                    name: n1.name,\n                    inputTypes: [\n                        o1\n                    ],\n                    inputNames: [\n                        \"A\"\n                    ],\n                    cacheHint: r1\n                };\n                return Object.assign(Object.assign({}, i1), {\n                    get: ()=>((e1, t1, n1, r1)=>{\n                            const o1 = e1.session.pack ? a1.TextureType.packed : a1.TextureType.unpacked, i1 = (0, s1.getGlsl)(e1.session.backend.glContext.version);\n                            return Object.assign(Object.assign({}, t1), {\n                                output: {\n                                    dims: n1.dims,\n                                    type: n1.type,\n                                    textureType: o1\n                                },\n                                shaderSource: `\\n     ${r1.body}\\n     void main() {\\n       vec4 v = ${i1.texture2D}(A, TexCoords);\\n       v = ${r1.name}_(v);\\n       ${i1.output} = v;\\n     }\\n     `,\n                                hasMain: !0\n                            });\n                        })(e1, i1, t1, n1)\n                });\n            };\n            t1.abs = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], u1()), t1)\n                ], t1.acos = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], l1()), t1)\n                ], t1.asin = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], c1()), t1)\n                ], t1.atan = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], p1()), t1)\n                ], t1.clip = (e1, t1, n1)=>[\n                    e1.run(D1(e1, t1[0], m1(n1.min, n1.max), n1.cacheKey), t1)\n                ], t1.parseClipAttributes = (e1)=>(0, r1.createAttributeWithCacheKey)({\n                    min: e1.attributes.getFloat(\"min\", o1.MIN_CLIP),\n                    max: e1.attributes.getFloat(\"max\", o1.MAX_CLIP)\n                }), t1.clipV11 = (e1, n1)=>{\n                const r1 = $1(e1, n1);\n                return (0, t1.clip)(e1, [\n                    n1[0]\n                ], r1);\n            };\n            const $1 = (e1, t1)=>{\n                if (t1.length >= 3 && (!e1.session.isInitializer(t1[1].dataId) || !e1.session.isInitializer(t1[2].dataId))) throw new Error(\"dynamic clip attributes are not allowed\");\n                const n1 = t1.length >= 3 ? t1[1].numberData[0] : o1.MIN_CLIP, i1 = t1.length >= 3 ? t1[2].numberData[0] : o1.MAX_CLIP;\n                return (0, r1.createAttributeWithCacheKey)({\n                    min: n1,\n                    max: i1\n                });\n            };\n            t1.ceil = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], d1()), t1)\n                ], t1.cos = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], f1()), t1)\n                ], t1.elu = (e1, t1, n1)=>[\n                    e1.run(D1(e1, t1[0], h1(n1.alpha), n1.cacheKey), t1)\n                ], t1.parseEluAttributes = (e1)=>(0, r1.createAttributeWithCacheKey)({\n                    alpha: e1.attributes.getFloat(\"alpha\", 1)\n                }), t1.exp = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], g1()), t1)\n                ], t1.floor = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], b1()), t1)\n                ], t1.identity = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], y1()), t1)\n                ], t1.leakyRelu = (e1, t1, n1)=>[\n                    e1.run(D1(e1, t1[0], _1(n1.alpha), n1.cacheKey), t1)\n                ], t1.parseLeakyReluAttributes = (e1)=>(0, r1.createAttributeWithCacheKey)({\n                    alpha: e1.attributes.getFloat(\"alpha\", .01)\n                }), t1.log = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], v1()), t1)\n                ], t1.neg = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], T1()), t1)\n                ], t1.not = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], x1()), t1)\n                ], t1.relu = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], O1()), t1)\n                ], t1.sigmoid = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], S1()), t1)\n                ], t1.sin = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], w1()), t1)\n                ], t1.sqrt = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], A1()), t1)\n                ], t1.tan = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], P1()), t1)\n                ], t1.tanh = (e1, t1)=>[\n                    e1.run(D1(e1, t1[0], I1()), t1)\n                ];\n        },\n        540: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createUnpackProgramInfoLoader = t1.createUnpackProgramInfo = void 0;\n            const r1 = n1(6757), o1 = n1(5639), i1 = n1(432), s1 = n1(5614), a1 = {\n                name: \"unpack\",\n                inputNames: [\n                    \"A\"\n                ],\n                inputTypes: [\n                    o1.TextureType.packed\n                ]\n            };\n            t1.createUnpackProgramInfo = (e1, t1)=>{\n                const n1 = t1.dims.length, u1 = (0, s1.getChannels)(\"rc\", n1), l1 = u1.slice(-2), c1 = (0, i1.getCoordsDataType)(n1), p1 = (0, s1.unpackFromChannel)(), d1 = 0 === t1.dims.length ? \"\" : function(e1, t1) {\n                    if (1 === e1) return \"rc\";\n                    let n1 = \"\";\n                    for(let r1 = 0; r1 < e1; r1++)n1 += t1[r1], r1 < e1 - 1 && (n1 += \",\");\n                    return n1;\n                }(n1, u1), f1 = n1 <= 1 ? \"rc\" : `vec2(${l1.join(\",\")})`, h1 = `\\n    ${p1}\\n    void main() {\\n      ${c1} rc = getOutputCoords();\\n\\n       // Sample the texture with the coords to get the rgba channel value.\\n       vec4 packedInput = getA(${d1});\\n\\n       ${(0, r1.getGlsl)(e1.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${f1}), 0, 0, 0);\\n     }\\n   `;\n                return Object.assign(Object.assign({}, a1), {\n                    hasMain: !0,\n                    output: {\n                        dims: t1.dims,\n                        type: t1.type,\n                        textureType: o1.TextureType.unpacked\n                    },\n                    shaderSource: h1\n                });\n            }, t1.createUnpackProgramInfoLoader = (e1, n1)=>Object.assign(Object.assign({}, a1), {\n                    get: ()=>(0, t1.createUnpackProgramInfo)(e1, n1)\n                });\n        },\n        7862: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.parseUnsqueezeAttributes = t1.unsqueezeV13 = t1.unsqueeze = void 0;\n            const r1 = n1(7273);\n            t1.unsqueeze = (e1, t1, n1)=>{\n                o1(t1);\n                const i1 = r1.ShapeUtil.unsqueezeShape(t1[0].dims, n1);\n                return [\n                    e1.reshapeUnpacked(t1[0], i1)\n                ];\n            }, t1.unsqueezeV13 = (e1, n1)=>(i1(n1), (0, t1.unsqueeze)(e1, [\n                    n1[0]\n                ], Array.from(n1[1].integerData))), t1.parseUnsqueezeAttributes = (e1)=>e1.attributes.getInts(\"axes\");\n            const o1 = (e1)=>{\n                if (!e1 || 1 !== e1.length) throw new Error(\"Unsqueeze requires 1 input.\");\n                if (\"string\" === e1[0].type) throw new Error(\"invalid input tensor types.\");\n            }, i1 = (e1)=>{\n                if (!e1 || 2 !== e1.length) throw new Error(\"Unsqueeze requires 2 inputs.\");\n                if (\"int32\" !== e1[1].type) throw new Error(\"Invalid input type.\");\n            };\n        },\n        3980: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.scalesValidation = t1.validateInputs = t1.parseUpsampleAttributes = t1.parseUpsampleAttributesV9 = t1.parseUpsampleAttributesV7 = t1.upsample = void 0;\n            const r1 = n1(4910), o1 = n1(6757), i1 = n1(5639), s1 = {\n                name: \"Upsample\",\n                inputNames: [\n                    \"X\"\n                ],\n                inputTypes: [\n                    i1.TextureType.unpacked\n                ]\n            };\n            t1.upsample = (e1, n1, r1)=>((0, t1.validateInputs)(n1, r1), [\n                    e1.run(Object.assign(Object.assign({}, s1), {\n                        cacheHint: r1.cacheKey,\n                        get: ()=>a1(e1, n1, r1)\n                    }), n1)\n                ]), t1.parseUpsampleAttributesV7 = (e1)=>(0, t1.parseUpsampleAttributes)(e1, 7), t1.parseUpsampleAttributesV9 = (e1)=>(0, t1.parseUpsampleAttributes)(e1, 9), t1.parseUpsampleAttributes = (e1, n1)=>{\n                const o1 = n1 >= 10, i1 = e1.attributes.getString(\"mode\", \"nearest\");\n                if (\"nearest\" !== i1 && \"linear\" !== i1 && (n1 < 11 || \"cubic\" !== i1)) throw new Error(`unrecognized mode: ${i1}`);\n                let s1 = [];\n                n1 < 9 && (s1 = e1.attributes.getFloats(\"scales\"), (0, t1.scalesValidation)(s1, i1, o1));\n                const a1 = e1.attributes.getFloat(\"extrapolation_value\", 0), u1 = n1 > 10 ? e1.attributes.getString(\"coordinate_transformation_mode\", \"half_pixel\") : \"asymmetric\";\n                if (-1 === [\n                    \"asymmetric\",\n                    \"pytorch_half_pixel\",\n                    \"tf_half_pixel_for_nn\",\n                    \"align_corners\",\n                    \"tf_crop_and_resize\",\n                    \"half_pixel\"\n                ].indexOf(u1)) throw new Error(`coordinate_transform_mode '${u1}' is not supported`);\n                const l1 = \"tf_crop_and_resize\" === u1, c1 = l1, p1 = \"nearest\" === i1 && n1 >= 11 ? e1.attributes.getString(\"nearest_mode\", \"round_prefer_floor\") : \"\";\n                if (-1 === [\n                    \"round_prefer_floor\",\n                    \"round_prefer_ceil\",\n                    \"floor\",\n                    \"ceil\",\n                    \"\"\n                ].indexOf(p1)) throw new Error(`nearest_mode '${p1}' is not supported`);\n                const d1 = e1.attributes.getFloat(\"cubic_coeff_a\", -.75), f1 = 0 !== e1.attributes.getInt(\"exclude_outside\", 0);\n                if (f1 && \"cubic\" !== i1) throw new Error(\"exclude_outside can be set to 1 only when mode is CUBIC.\");\n                const h1 = n1 < 11 || \"nearest\" === i1 && \"asymmetric\" === u1 && \"floor\" === p1;\n                let g1 = 0, b1 = 0, m1 = 0;\n                return n1 > 10 ? e1.inputs.length > 2 ? (g1 = 1, b1 = 2, m1 = 3) : (b1 = 1, m1 = 2) : 9 === n1 && (b1 = 1), (0, r1.createAttributeWithCacheKey)({\n                    opset: n1,\n                    isResize: o1,\n                    mode: i1,\n                    scales: s1,\n                    extrapolationValue: a1,\n                    coordinateTransformMode: u1,\n                    useExtrapolation: c1,\n                    needRoiInput: l1,\n                    nearestMode: p1,\n                    cubicCoefficientA: d1,\n                    excludeOutside: f1,\n                    useNearest2xOptimization: h1,\n                    roiInputIdx: g1,\n                    scalesInputIdx: b1,\n                    sizesInputIdx: m1\n                });\n            };\n            const a1 = (e1, t1, n1)=>{\n                const r1 = (0, o1.getGlsl)(e1.session.backend.glContext.version), [a1, u1] = e1.calculateTextureWidthAndHeight(t1[0].dims, i1.TextureType.unpacked), l1 = t1[0].dims.map((e1, t1)=>Math.floor(e1 * n1.scales[t1])), [c1, p1] = e1.calculateTextureWidthAndHeight(l1, i1.TextureType.unpacked), d1 = l1.length, f1 = new Array(d1), h1 = new Array(d1);\n                let g1 = `\\n      int output_pitches[${d1}];\\n      int input_pitches[${d1}];\\n      `;\n                for(let e1 = d1 - 1; e1 >= 0; e1--)f1[e1] = e1 === d1 - 1 ? 1 : f1[e1 + 1] * l1[e1 + 1], h1[e1] = e1 === d1 - 1 ? 1 : h1[e1 + 1] * t1[0].dims[e1 + 1], g1 += `\\n        output_pitches[${e1}] = ${f1[e1]};\\n        input_pitches[${e1}] = ${h1[e1]};\\n        `;\n                const b1 = `\\n      float getInputFloat(int index) {\\n        vec2 coords = offsetToCoords(index, ${a1}, ${u1});\\n        float value = getColorAsFloat(${r1.texture2D}(X, coords));\\n        return value;\\n      }\\n      `, m1 = \"nearest\" === n1.mode ? `\\n    ${b1}\\n    float process(int indices[${d1}]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${c1}, ${p1});\\n\\n      ${g1}\\n\\n      int d, m;\\n      for (int dim = 0; dim < ${d1}; ++dim) {\\n        d = output_index / output_pitches[dim];\\n        m = output_index - d * output_pitches[dim];\\n        output_index = m;\\n\\n        if (scales[dim] != 1 && d > 0) {\\n          int d2 = d / scales[dim];\\n          m = d - d2 * scales[dim];\\n          d = d2;\\n        }\\n        input_index += input_pitches[dim] * d;\\n      }\\n\\n      return getInputFloat(input_index);\\n    }` : 4 === d1 ? `\\n    ${b1}\\n    float process(int indices[4]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${c1}, ${p1});\\n\\n      ${g1}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m / output_pitches[1];\\n      m = m - index_of_dim1 * output_pitches[1];\\n      index_of_dim2 = m / output_pitches[2];\\n      m = m - index_of_dim2 * output_pitches[2];\\n      index_of_dim3 = m;\\n\\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\\n      index_of_input_dim2 = index_of_dim2 / scales[2];\\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\\n      index_of_input_dim3 = index_of_dim3 / scales[3];\\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\\n\\n      input_index = index_of_dim0 * input_pitches[0] +\\n            index_of_dim1 * input_pitches[1] +\\n            index_of_input_dim2 * input_pitches[2] +\\n            index_of_input_dim3;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim2 = false;\\n      if (index_of_input_dim2 == (${t1[0].dims[2]} - 1)) {\\n        // It's the end in dimension 2\\n        x01 = x00;\\n        end_of_dim2 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[2]);\\n      }\\n\\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\\n        // It's the end in dimension 3\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\\n    }` : `\\n    ${b1}\\n    float process(int indices[2]) {\\n      int input_index = 0;\\n      int output_index = coordsToOffset(TexCoords, ${c1}, ${p1});\\n\\n      ${g1}\\n\\n      int m;\\n      int index_of_dim0, index_of_dim1;\\n      index_of_dim0 = output_index / output_pitches[0];\\n      m = output_index - index_of_dim0 * output_pitches[0];\\n      index_of_dim1 = m;\\n\\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\\n      index_of_input_dim0 = index_of_dim0 / scales[0];\\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\\n      index_of_input_dim1 = index_of_dim1 / scales[1];\\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\\n\\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\\n\\n      float x00 = getInputFloat(input_index);\\n      float x10, x01, x11;\\n\\n      bool end_of_dim0 = false;\\n      if (index_of_input_dim0 == (${t1[0].dims[0]} - 1)) {\\n        // It's the end in dimension 0\\n        x01 = x00;\\n        end_of_dim0 = true;\\n      } else {\\n        x01 = getInputFloat(input_index + input_pitches[0]);\\n      }\\n\\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\\n        // It's the end in dimension 1\\n        x10 = x00;\\n        x11 = x01;\\n      }\\n      else {\\n        x10 = getInputFloat(input_index + 1);\\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\\n      }\\n\\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\\n    }`;\n                return Object.assign(Object.assign({}, s1), {\n                    output: {\n                        dims: l1,\n                        type: t1[0].type,\n                        textureType: i1.TextureType.unpacked\n                    },\n                    shaderSource: m1,\n                    variables: [\n                        {\n                            name: \"scales\",\n                            type: \"int\",\n                            arrayLength: n1.scales.length,\n                            data: n1.scales.map((e1)=>Math.ceil(e1))\n                        }\n                    ]\n                });\n            };\n            t1.validateInputs = (e1, t1)=>{\n                if (!e1 || t1.opset < 9 && 1 !== e1.length || t1.opset >= 9 && t1.opset < 11 && 2 !== e1.length || t1.opset >= 11 && e1.length < 2) throw new Error(\"invalid inputs.\");\n                if (t1.scales.length > 0 && e1[0].dims.length !== t1.scales.length) throw new Error(\"Invalid input shape.\");\n                if (\"string\" === e1[0].type) throw new Error(\"Invalid input tensor types.\");\n            }, t1.scalesValidation = (e1, t1, n1)=>{\n                if (n1) {\n                    for (const t1 of e1)if (t1 <= 0) throw new Error(\"Scale value should be greater than 0.\");\n                } else for (const t1 of e1)if (t1 < 1) throw new Error(\"Scale value should be greater than or equal to 1.\");\n                if (!(\"linear\" !== t1 && \"cubic\" !== t1 || 2 === e1.length || 4 === e1.length && 1 === e1[0] && 1 === e1[1])) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n1 ? \"Resize\" : \"Upsample\"} opeartor.`);\n            };\n        },\n        2757: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.ProgramManager = void 0;\n            const r1 = n1(6207), o1 = n1(1315), i1 = n1(8897), s1 = n1(6757);\n            t1.ProgramManager = class {\n                constructor(e1, t1, n1){\n                    this.profiler = e1, this.glContext = t1, this.textureLayoutStrategy = n1, this.repo = new Map, this.attributesBound = !1;\n                }\n                getArtifact(e1) {\n                    return this.repo.get(e1);\n                }\n                setArtifact(e1, t1) {\n                    this.repo.set(e1, t1);\n                }\n                run(e1, t1, n1) {\n                    var r1;\n                    this.profiler.event(\"op\", `ProgramManager.run ${null !== (r1 = e1.programInfo.name) && void 0 !== r1 ? r1 : \"unknown kernel\"}`, ()=>{\n                        var r1;\n                        const i1 = this.glContext.gl, s1 = e1.program;\n                        i1.useProgram(s1);\n                        try {\n                            this.bindOutput(n1), this.attributesBound || this.bindAttributes(e1.attribLocations), this.bindUniforms(e1.uniformLocations, null !== (r1 = e1.programInfo.variables) && void 0 !== r1 ? r1 : [], t1);\n                        } catch (t1) {\n                            throw o1.Logger.error(\"ProgramManager\", e1.programInfo.shaderSource), t1;\n                        }\n                        this.profiler.event(\"backend\", \"GlContext.draw()\", ()=>{\n                            this.glContext.draw();\n                        });\n                    }, this.glContext);\n                }\n                dispose() {\n                    this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((e1)=>this.glContext.deleteProgram(e1.program));\n                }\n                build(e1, t1, n1) {\n                    return this.profiler.event(\"backend\", \"ProgramManager.build\", ()=>{\n                        const r1 = new i1.GlslPreprocessor(this.glContext, e1, t1, n1), o1 = r1.preprocess(), s1 = this.compile(o1);\n                        return {\n                            programInfo: e1,\n                            program: s1,\n                            uniformLocations: this.getUniformLocations(s1, r1.context.programInfo.inputNames, r1.context.programInfo.variables),\n                            attribLocations: this.getAttribLocations(s1)\n                        };\n                    });\n                }\n                compile(e1) {\n                    if (!this.vertexShader) {\n                        o1.Logger.verbose(\"ProrgramManager\", \"Compiling and caching Vertex shader for the first time\");\n                        const e1 = (0, s1.getVertexShaderSource)(this.glContext.version);\n                        this.vertexShader = this.glContext.compileShader(e1, this.glContext.gl.VERTEX_SHADER);\n                    }\n                    r1.env.debug && o1.Logger.verbose(\"ProrgramManager\", `FragShader:\\n${e1}\\n`);\n                    const t1 = this.glContext.compileShader(e1, this.glContext.gl.FRAGMENT_SHADER), n1 = this.glContext.createProgram(this.vertexShader, t1);\n                    return this.glContext.deleteShader(t1), n1;\n                }\n                bindOutput(e1) {\n                    const t1 = e1.width, n1 = e1.height;\n                    o1.Logger.verbose(\"ProrgramManager\", `Binding output texture to Framebuffer: w/h=${t1}/${n1}, shape=${e1.shape}, type=${e1.tensor.type}`), this.glContext.attachFramebuffer(e1.texture, t1, n1);\n                }\n                bindAttributes(e1) {\n                    const t1 = e1.position, n1 = e1.textureCoord;\n                    this.glContext.setVertexAttributes(t1, n1), this.attributesBound = !0;\n                }\n                bindUniforms(e1, t1, n1) {\n                    var r1;\n                    const o1 = this.glContext.gl;\n                    let i1 = 0;\n                    for (const { name: s1, type: a1, location: u1, arrayLength: l1 } of e1){\n                        const e1 = null === (r1 = t1.find((e1)=>e1.name === s1)) || void 0 === r1 ? void 0 : r1.data;\n                        if (\"sampler2D\" !== a1 && !e1) throw new Error(`variable '${s1}' does not have data defined in program info`);\n                        switch(a1){\n                            case \"sampler2D\":\n                                this.bindTexture(n1[i1], u1, i1), i1++;\n                                break;\n                            case \"float\":\n                                l1 ? o1.uniform1fv(u1, e1) : o1.uniform1f(u1, e1);\n                                break;\n                            case \"int\":\n                                l1 ? o1.uniform1iv(u1, e1) : o1.uniform1i(u1, e1);\n                                break;\n                            default:\n                                throw new Error(`Uniform not implemented: ${a1}`);\n                        }\n                    }\n                }\n                bindTexture(e1, t1, n1) {\n                    this.glContext.bindTextureToUniform(e1.texture, n1, t1);\n                }\n                getAttribLocations(e1) {\n                    return {\n                        position: this.getAttribLocation(e1, \"position\"),\n                        textureCoord: this.getAttribLocation(e1, \"textureCoord\")\n                    };\n                }\n                getUniformLocations(e1, t1, n1) {\n                    const r1 = [];\n                    if (t1) for (const n1 of t1)r1.push({\n                        name: n1,\n                        type: \"sampler2D\",\n                        location: this.getUniformLocation(e1, n1)\n                    });\n                    if (n1) for (const t1 of n1)r1.push(Object.assign(Object.assign({}, t1), {\n                        location: this.getUniformLocation(e1, t1.name)\n                    }));\n                    return r1;\n                }\n                getUniformLocation(e1, t1) {\n                    const n1 = this.glContext.gl.getUniformLocation(e1, t1);\n                    if (null === n1) throw new Error(`Uniform ${t1} not found.`);\n                    return n1;\n                }\n                getAttribLocation(e1, t1) {\n                    return this.glContext.gl.getAttribLocation(e1, t1);\n                }\n            };\n        },\n        2171: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.WebGLSessionHandler = void 0;\n            const r1 = n1(1315), o1 = n1(5881), i1 = n1(7860), s1 = n1(4110), a1 = n1(2757), u1 = n1(7618), l1 = n1(5243);\n            t1.WebGLSessionHandler = class {\n                constructor(e1, t1){\n                    this.backend = e1, this.context = t1, this.layoutStrategy = new u1.PreferLogicalStrategy(e1.glContext.maxTextureSize), this.programManager = new a1.ProgramManager(this.context.profiler, e1.glContext, this.layoutStrategy), this.textureManager = new l1.TextureManager(e1.glContext, this.layoutStrategy, this.context.profiler, {\n                        reuseTextures: \"full\" === e1.textureCacheMode\n                    }), this.packedTextureDataCache = new Map, this.unpackedTextureDataCache = new Map, this.pack = e1.pack, this.pack2unpackMap = new Map, this.unpack2packMap = new Map;\n                }\n                createInferenceHandler() {\n                    return new i1.WebGLInferenceHandler(this);\n                }\n                onGraphInitialized(e1) {\n                    const t1 = e1.getValues().filter((e1)=>-1 === e1.from && e1.tensor).map((e1)=>e1.tensor.dataId);\n                    this.initializers = new Set(t1);\n                }\n                isInitializer(e1) {\n                    return !!this.initializers && this.initializers.has(e1);\n                }\n                addInitializer(e1) {\n                    this.initializers.add(e1);\n                }\n                getTextureData(e1, t1) {\n                    return t1 ? this.packedTextureDataCache.get(e1) : this.unpackedTextureDataCache.get(e1);\n                }\n                setTextureData(e1, t1, n1 = !1) {\n                    r1.Logger.verbose(\"WebGLSessionHandler\", \"Storing Texture data in cache\"), n1 ? this.packedTextureDataCache.set(e1, t1) : this.unpackedTextureDataCache.set(e1, t1);\n                }\n                dispose() {\n                    this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((e1)=>this.textureManager.releaseTexture(e1, !0)), this.packedTextureDataCache = new Map, this.unpackedTextureDataCache.forEach((e1)=>this.textureManager.releaseTexture(e1, !0)), this.unpackedTextureDataCache = new Map;\n                }\n                resolve(e1, t1, n1) {\n                    const r1 = (0, o1.resolveOperator)(e1, t1, s1.WEBGL_OP_RESOLVE_RULES);\n                    return {\n                        impl: r1.opImpl,\n                        context: r1.opInit ? r1.opInit(e1, n1) : e1\n                    };\n                }\n            };\n        },\n        9622: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.Uint8DataEncoder = t1.RGBAFloatDataEncoder = t1.RedFloat32DataEncoder = void 0;\n            const r1 = n1(1315);\n            t1.RedFloat32DataEncoder = class {\n                constructor(e1, t1 = 1){\n                    if (1 === t1) this.internalFormat = e1.R32F, this.format = e1.RED, this.textureType = e1.FLOAT, this.channelSize = t1;\n                    else {\n                        if (4 !== t1) throw new Error(`Invalid number of channels: ${t1}`);\n                        this.internalFormat = e1.RGBA32F, this.format = e1.RGBA, this.textureType = e1.FLOAT, this.channelSize = t1;\n                    }\n                }\n                encode(e1, t1) {\n                    let n1, o1;\n                    return e1.constructor !== Float32Array && (r1.Logger.warning(\"Encoder\", \"data was not of type Float32; creating new Float32Array\"), o1 = new Float32Array(e1)), t1 * this.channelSize > e1.length ? (r1.Logger.warning(\"Encoder\", \"Source data too small. Allocating larger array\"), o1 = e1, n1 = this.allocate(t1 * this.channelSize), o1.forEach((e1, t1)=>n1[t1] = e1)) : (o1 = e1, n1 = o1), n1;\n                }\n                allocate(e1) {\n                    return new Float32Array(4 * e1);\n                }\n                decode(e1, t1) {\n                    return 1 === this.channelSize ? e1.filter((e1, t1)=>t1 % 4 == 0).subarray(0, t1) : e1.subarray(0, t1);\n                }\n            }, t1.RGBAFloatDataEncoder = class {\n                constructor(e1, t1 = 1, n1){\n                    if (1 !== t1 && 4 !== t1) throw new Error(`Invalid number of channels: ${t1}`);\n                    this.internalFormat = e1.RGBA, this.format = e1.RGBA, this.channelSize = t1, this.textureType = n1 || e1.FLOAT;\n                }\n                encode(e1, t1) {\n                    let n1 = e1;\n                    return 1 === this.channelSize && (r1.Logger.verbose(\"Encoder\", \"Exploding into a larger array\"), n1 = this.allocate(t1), e1.forEach((e1, t1)=>n1[4 * t1] = e1)), n1;\n                }\n                allocate(e1) {\n                    return new Float32Array(4 * e1);\n                }\n                decode(e1, t1) {\n                    return 1 === this.channelSize ? e1.filter((e1, t1)=>t1 % 4 == 0).subarray(0, t1) : e1.subarray(0, t1);\n                }\n            }, t1.Uint8DataEncoder = class {\n                constructor(e1, t1 = 1){\n                    if (this.channelSize = 4, 1 === t1) this.internalFormat = e1.ALPHA, this.format = e1.ALPHA, this.textureType = e1.UNSIGNED_BYTE, this.channelSize = t1;\n                    else {\n                        if (4 !== t1) throw new Error(`Invalid number of channels: ${t1}`);\n                        this.internalFormat = e1.RGBA, this.format = e1.RGBA, this.textureType = e1.UNSIGNED_BYTE, this.channelSize = t1;\n                    }\n                }\n                encode(e1, t1) {\n                    return new Uint8Array(e1.buffer, e1.byteOffset, e1.byteLength);\n                }\n                allocate(e1) {\n                    return new Uint8Array(e1 * this.channelSize);\n                }\n                decode(e1, t1) {\n                    if (e1 instanceof Uint8Array) return e1.subarray(0, t1);\n                    throw new Error(`Invalid array type: ${e1.constructor}`);\n                }\n            };\n        },\n        7618: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.getBatchDim = t1.sizeToSquarishShape = t1.getRowsCols = t1.sizeFromShape = t1.isInt = t1.parseAxisParam = t1.squeezeShape = t1.PreferLogicalStrategy = t1.AlwaysKeepOriginalSizeStrategy = void 0;\n            const r1 = n1(1315), o1 = n1(7273);\n            function i1(e1, t1) {\n                const n1 = [], r1 = [], o1 = null != t1 && Array.isArray(t1) && 0 === t1.length, i1 = null == t1 || o1 ? null : s1(t1, e1).sort();\n                let a1 = 0;\n                for(let t1 = 0; t1 < e1.length; ++t1){\n                    if (null != i1) {\n                        if (i1[a1] === t1 && 1 !== e1[t1]) throw new Error(`Can't squeeze axis ${t1} since its dim '${e1[t1]}' is not 1`);\n                        (null == i1[a1] || i1[a1] > t1) && 1 === e1[t1] && (n1.push(e1[t1]), r1.push(t1)), i1[a1] <= t1 && a1++;\n                    }\n                    1 !== e1[t1] && (n1.push(e1[t1]), r1.push(t1));\n                }\n                return {\n                    newShape: n1,\n                    keptDims: r1\n                };\n            }\n            function s1(e1, t1) {\n                const n1 = t1.length;\n                return e1 = null == e1 ? t1.map((e1, t1)=>t1) : [].concat(e1), (0, o1.assert)(e1.every((e1)=>e1 >= -n1 && e1 < n1), ()=>`All values in axis param must be in range [-${n1}, ${n1}) but got axis ${e1}`), (0, o1.assert)(e1.every(a1), ()=>`All values in axis param must be integers but got axis ${e1}`), e1.map((e1)=>e1 < 0 ? n1 + e1 : e1);\n            }\n            function a1(e1) {\n                return e1 % 1 == 0;\n            }\n            function u1(e1) {\n                if (0 === e1.length) return 1;\n                let t1 = e1[0];\n                for(let n1 = 1; n1 < e1.length; n1++)t1 *= e1[n1];\n                return t1;\n            }\n            function l1(e1) {\n                const t1 = Math.ceil(Math.sqrt(e1));\n                return [\n                    t1,\n                    Math.ceil(e1 / t1)\n                ];\n            }\n            t1.AlwaysKeepOriginalSizeStrategy = class {\n                constructor(e1){\n                    this.maxTextureSize = e1;\n                }\n                computeTextureWH(e1, t1) {\n                    if (0 === e1.length) return [\n                        1,\n                        1\n                    ];\n                    const n1 = this.maxTextureSize;\n                    if (t1 && void 0 !== t1.breakAxis) {\n                        const o1 = t1.breakAxis >= e1.length ? 1 : e1.slice(t1.breakAxis).reduce((e1, t1)=>e1 * t1), i1 = t1.breakAxis <= 0 ? 1 : e1.slice(0, t1.breakAxis).reduce((e1, t1)=>e1 * t1);\n                        if (!(o1 > n1 || i1 > n1)) return [\n                            o1,\n                            i1\n                        ];\n                        r1.Logger.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${e1}, breakAxis:${t1.breakAxis}`);\n                    }\n                    const o1 = e1.reduce((e1, t1)=>e1 * t1);\n                    let i1 = Math.floor(Math.sqrt(o1));\n                    for(; i1 < n1 && i1 < o1 && o1 % i1 != 0; i1++);\n                    if (i1 >= n1 || o1 % i1 != 0) throw new Error(`The given dimensions are outside this GPU's boundaries: ${e1}`);\n                    return [\n                        i1,\n                        o1 / i1\n                    ];\n                }\n            }, t1.PreferLogicalStrategy = class {\n                constructor(e1){\n                    this.maxTextureSize = e1;\n                }\n                computeTextureWH(e1, t1) {\n                    const n1 = this.computeTexture(e1, t1);\n                    return t1 && t1.isPacked && (n1[0] /= 2, n1[1] /= 2), t1 && t1.reverseWH ? [\n                        n1[1],\n                        n1[0]\n                    ] : n1;\n                }\n                computeTexture(e1, t1) {\n                    const n1 = t1 && t1.isPacked;\n                    if (0 === e1.length) return n1 ? [\n                        2,\n                        2\n                    ] : [\n                        1,\n                        1\n                    ];\n                    let o1 = this.maxTextureSize;\n                    if (t1 && void 0 !== t1.breakAxis) {\n                        const n1 = t1.breakAxis >= e1.length ? 1 : e1.slice(t1.breakAxis).reduce((e1, t1)=>e1 * t1), i1 = t1.breakAxis <= 0 ? 1 : e1.slice(0, t1.breakAxis).reduce((e1, t1)=>e1 * t1);\n                        if (!(n1 > o1 || i1 > o1)) return [\n                            n1,\n                            i1\n                        ];\n                        r1.Logger.verbose(\"TextureLayout\", `Given width/height preferences were unattainable: shape:${e1}, breakAxis:${t1.breakAxis}`);\n                    }\n                    let s1 = e1.slice(0);\n                    if (n1 && (o1 *= 2, s1 = s1.map((e1, t1)=>t1 >= s1.length - 2 ? s1[t1] % 2 == 0 ? s1[t1] : s1[t1] + 1 : s1[t1]), 1 === s1.length && (s1 = [\n                        2,\n                        s1[0]\n                    ])), 2 !== s1.length) {\n                        const e1 = i1(s1);\n                        s1 = e1.newShape;\n                    }\n                    const a1 = u1(s1);\n                    return s1.length <= 1 && a1 <= o1 ? [\n                        1,\n                        a1\n                    ] : 2 === s1.length && s1[0] <= o1 && s1[1] <= o1 ? s1 : 3 === s1.length && s1[0] * s1[1] <= o1 && s1[2] <= o1 ? [\n                        s1[0] * s1[1],\n                        s1[2]\n                    ] : 3 === s1.length && s1[0] <= o1 && s1[1] * s1[2] <= o1 ? [\n                        s1[0],\n                        s1[1] * s1[2]\n                    ] : 4 === s1.length && s1[0] * s1[1] * s1[2] <= o1 && s1[3] <= o1 ? [\n                        s1[0] * s1[1] * s1[2],\n                        s1[3]\n                    ] : 4 === s1.length && s1[0] <= o1 && s1[1] * s1[2] * s1[3] <= o1 ? [\n                        s1[0],\n                        s1[1] * s1[2] * s1[3]\n                    ] : n1 ? l1(a1 / 4).map((e1)=>2 * e1) : l1(a1);\n                }\n            }, t1.squeezeShape = i1, t1.parseAxisParam = s1, t1.isInt = a1, t1.sizeFromShape = u1, t1.getRowsCols = function(e1) {\n                if (0 === e1.length) throw Error(\"Cannot get rows and columns of an empty shape array.\");\n                return [\n                    e1.length > 1 ? e1[e1.length - 2] : 1,\n                    e1[e1.length - 1]\n                ];\n            }, t1.sizeToSquarishShape = l1, t1.getBatchDim = function(e1, t1 = 2) {\n                return u1(e1.slice(0, e1.length - t1));\n            };\n        },\n        3314: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createTextureLayoutFromShape = t1.calculateTextureWidthAndHeight = t1.createTextureLayoutFromTextureType = void 0;\n            const r1 = n1(7273), o1 = n1(5639);\n            t1.createTextureLayoutFromTextureType = (e1, n1, r1)=>{\n                const i1 = r1 === o1.TextureType.unpacked || r1 === o1.TextureType.unpackedReversed ? 1 : 4, s1 = r1 === o1.TextureType.packed, a1 = r1 === o1.TextureType.unpackedReversed || r1 === o1.TextureType.packed, u1 = r1 === o1.TextureType.packedLastDimension ? n1.length - 1 : void 0, l1 = r1 === o1.TextureType.packedLastDimension ? n1.map((e1, t1)=>t1 === n1.length - 1 ? 4 * e1 : e1) : void 0;\n                return (0, t1.createTextureLayoutFromShape)(e1, n1, i1, l1, {\n                    isPacked: s1,\n                    reverseWH: a1,\n                    breakAxis: u1\n                });\n            }, t1.calculateTextureWidthAndHeight = (e1, n1, r1)=>{\n                const o1 = (0, t1.createTextureLayoutFromTextureType)(e1, n1, r1);\n                return [\n                    o1.width,\n                    o1.height\n                ];\n            }, t1.createTextureLayoutFromShape = (e1, t1, n1 = 1, o1, i1)=>{\n                const s1 = !(!i1 || !i1.isPacked), [a1, u1] = e1.computeTextureWH(s1 && o1 || t1, i1), l1 = t1.length;\n                let c1 = t1.slice(0);\n                if (0 === l1 && (c1 = [\n                    1\n                ]), 1 === n1) o1 = t1;\n                else if (s1) {\n                    if (4 !== n1) throw new Error(\"a packed texture must be 4-channel\");\n                    o1 = t1, l1 > 0 && (c1[l1 - 1] = Math.ceil(c1[l1 - 1] / 2)), l1 > 1 && (c1[l1 - 2] = Math.ceil(c1[l1 - 2] / 2));\n                } else if (!o1) throw new Error(\"Unpacked shape is needed when using channels > 1\");\n                return {\n                    width: a1,\n                    height: u1,\n                    channels: n1,\n                    isPacked: s1,\n                    shape: c1,\n                    strides: r1.ShapeUtil.computeStrides(c1),\n                    unpackedShape: o1,\n                    reversedWH: i1 && i1.reverseWH\n                };\n            };\n        },\n        5243: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.TextureManager = void 0;\n            const r1 = n1(1315);\n            t1.TextureManager = class {\n                constructor(e1, t1, n1, r1){\n                    this.glContext = e1, this.layoutStrategy = t1, this.profiler = n1, this.config = r1, this.pendingRead = new Map, r1.reuseTextures && (this.inUseTextures = new Map, this.idleTextures = new Map, this.textureLookup = new Map);\n                }\n                createTextureFromLayout(e1, t1, n1, o1) {\n                    const i1 = this.toEncoderType(e1), s1 = this.glContext.getEncoder(i1, t1.channels || 1, o1);\n                    if (t1.isPacked && 1 === o1) throw new Error(\"not implemented\");\n                    const a1 = t1.width, u1 = t1.height;\n                    let l1, c1;\n                    if (this.config.reuseTextures) {\n                        l1 = `${a1}x${u1}_${s1.format}_${s1.internalFormat}_${s1.textureType}`, c1 = this.inUseTextures.get(l1), c1 || (c1 = [], this.inUseTextures.set(l1, c1));\n                        const t1 = this.idleTextures.get(l1);\n                        if (t1 && t1.length > 0) {\n                            const r1 = t1.pop();\n                            return c1.push(r1), 1 === o1 && this.glContext.updateTexture(r1, a1, u1, s1, this.toTextureData(e1, n1)), r1;\n                        }\n                    }\n                    r1.Logger.verbose(\"TextureManager\", `Creating new texture of size ${t1.width}x${t1.height}`);\n                    const p1 = this.glContext.allocateTexture(a1, u1, s1, this.toTextureData(e1, n1));\n                    return this.config.reuseTextures && (c1.push(p1), this.textureLookup.set(p1, l1)), p1;\n                }\n                readTexture(e1, t1, n1) {\n                    return n1 || (n1 = 1), this.profiler.event(\"backend\", \"TextureManager.readTexture\", ()=>{\n                        const r1 = e1.shape.reduce((e1, t1)=>e1 * t1) * n1, o1 = this.glContext.readTexture(e1.texture, e1.width, e1.height, r1, this.toEncoderType(t1), n1);\n                        return this.toTensorData(t1, o1);\n                    });\n                }\n                async readTextureAsync(e1, t1, n1) {\n                    const r1 = e1.tensor.dataId;\n                    if (n1 || (n1 = 1), this.pendingRead.has(r1)) {\n                        const e1 = this.pendingRead.get(r1);\n                        return new Promise((t1)=>null == e1 ? void 0 : e1.push(t1));\n                    }\n                    return this.profiler.event(\"backend\", \"TextureManager.readTextureAsync\", async ()=>{\n                        this.pendingRead.set(r1, []);\n                        const o1 = e1.shape.reduce((e1, t1)=>e1 * t1) * n1;\n                        await this.glContext.createAndWaitForFence();\n                        const i1 = this.glContext.readTexture(e1.texture, e1.width, e1.height, o1, this.toEncoderType(t1), n1), s1 = this.toTensorData(t1, i1), a1 = this.pendingRead.get(r1);\n                        return this.pendingRead.delete(r1), null == a1 || a1.forEach((e1)=>e1(s1)), s1;\n                    });\n                }\n                readUint8TextureAsFloat(e1) {\n                    return this.profiler.event(\"backend\", \"TextureManager.readUint8TextureAsFloat\", ()=>{\n                        const t1 = e1.shape.reduce((e1, t1)=>e1 * t1), n1 = this.glContext.readTexture(e1.texture, e1.width, e1.height, 4 * t1, \"byte\", 4);\n                        return new Float32Array(n1.buffer, n1.byteOffset, t1);\n                    });\n                }\n                releaseTexture(e1, t1) {\n                    let n1;\n                    if (this.config.reuseTextures && (n1 = this.textureLookup.get(e1.texture), n1)) {\n                        t1 && this.textureLookup.delete(n1);\n                        const r1 = this.inUseTextures.get(n1);\n                        if (r1) {\n                            const t1 = r1.indexOf(e1.texture);\n                            if (-1 !== t1) {\n                                r1.splice(t1, 1);\n                                let o1 = this.idleTextures.get(n1);\n                                o1 || (o1 = [], this.idleTextures.set(n1, o1)), o1.push(e1.texture);\n                            }\n                        }\n                    }\n                    n1 && !t1 || (r1.Logger.verbose(\"TextureManager\", `Deleting texture of size ${e1.width}x${e1.height}`), this.glContext.deleteTexture(e1.texture));\n                }\n                toTensorData(e1, t1) {\n                    switch(e1){\n                        case \"int16\":\n                            return t1 instanceof Int16Array ? t1 : Int16Array.from(t1);\n                        case \"int32\":\n                            return t1 instanceof Int32Array ? t1 : Int32Array.from(t1);\n                        case \"int8\":\n                            return t1 instanceof Int8Array ? t1 : Int8Array.from(t1);\n                        case \"uint16\":\n                            return t1 instanceof Uint16Array ? t1 : Uint16Array.from(t1);\n                        case \"uint32\":\n                            return t1 instanceof Uint32Array ? t1 : Uint32Array.from(t1);\n                        case \"uint8\":\n                        case \"bool\":\n                            return t1 instanceof Uint8Array ? t1 : Uint8Array.from(t1);\n                        case \"float32\":\n                            return t1 instanceof Float32Array ? t1 : Float32Array.from(t1);\n                        case \"float64\":\n                            return t1 instanceof Float64Array ? t1 : Float64Array.from(t1);\n                        default:\n                            throw new Error(`TensorData type ${e1} is not supported`);\n                    }\n                }\n                toTextureData(e1, t1) {\n                    if (t1) return t1 instanceof Float32Array ? t1 : new Float32Array(t1);\n                }\n                toEncoderType(e1) {\n                    return \"float\";\n                }\n                clearActiveTextures() {\n                    this.glContext.clearActiveTextures();\n                }\n            };\n        },\n        5639: (e1, t1)=>{\n            \"use strict\";\n            var n1;\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.TextureType = void 0, (n1 = t1.TextureType || (t1.TextureType = {}))[n1.unpacked = 0] = \"unpacked\", n1[n1.unpackedReversed = 1] = \"unpackedReversed\", n1[n1.packed = 2] = \"packed\", n1[n1.downloadUint8AsFloat = 3] = \"downloadUint8AsFloat\", n1[n1.packedLastDimension = 4] = \"packedLastDimension\";\n        },\n        432: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.getGlChannels = t1.getCoordsDataType = t1.getSqueezedParams = t1.squeezeInputShape = t1.generateShaderFuncNameFromInputSamplerNameAtOutCoords = t1.generateShaderFuncNameFromInputSamplerName = t1.repeatedTry = t1.getPackedShape = void 0;\n            const r1 = n1(7273);\n            t1.getPackedShape = function(e1) {\n                const t1 = e1.length;\n                return e1.slice(0, t1 - 1).concat(e1[t1 - 1] / 4);\n            }, t1.repeatedTry = async function(e1, t1 = (e1)=>0, n1) {\n                return new Promise((r1, o1)=>{\n                    let i1 = 0;\n                    const s1 = ()=>{\n                        if (e1()) return void r1();\n                        i1++;\n                        const a1 = t1(i1);\n                        null != n1 && i1 >= n1 ? o1() : setTimeout(s1, a1);\n                    };\n                    s1();\n                });\n            }, t1.generateShaderFuncNameFromInputSamplerName = function(e1) {\n                return (0, r1.assert)(void 0 !== e1 && 0 !== e1.length, ()=>\"empty string found for sampler name\"), \"get\" + e1.charAt(0).toUpperCase() + e1.slice(1);\n            }, t1.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(e1) {\n                return (0, r1.assert)(void 0 !== e1 && 0 !== e1.length, ()=>\"empty string found for sampler name\"), \"get\" + e1.charAt(0).toUpperCase() + e1.slice(1) + \"AtOutCoords\";\n            }, t1.squeezeInputShape = function(e1, t1) {\n                let n1 = JSON.parse(JSON.stringify(e1));\n                return n1 = t1, n1;\n            }, t1.getSqueezedParams = function(e1, t1) {\n                return t1.map((t1)=>e1[t1]).join(\", \");\n            }, t1.getCoordsDataType = function(e1) {\n                if (e1 <= 1) return \"int\";\n                if (2 === e1) return \"ivec2\";\n                if (3 === e1) return \"ivec3\";\n                if (4 === e1) return \"ivec4\";\n                if (5 === e1) return \"ivec5\";\n                if (6 === e1) return \"ivec6\";\n                throw Error(`GPU for rank ${e1} is not yet supported`);\n            }, t1.getGlChannels = function(e1 = 6) {\n                return [\n                    \"x\",\n                    \"y\",\n                    \"z\",\n                    \"w\",\n                    \"u\",\n                    \"v\"\n                ].slice(0, e1);\n            };\n        },\n        3389: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.createNewWebGLContext = t1.createWebGLContext = void 0;\n            const r1 = n1(1315), o1 = n1(3524), i1 = {};\n            function s1(e1, t1) {\n                let n1;\n                const i1 = {\n                    alpha: !1,\n                    depth: !1,\n                    antialias: !1,\n                    stencil: !1,\n                    preserveDrawingBuffer: !1,\n                    premultipliedAlpha: !1,\n                    failIfMajorPerformanceCaveat: !1\n                };\n                if ((!t1 || \"webgl2\" === t1) && (n1 = e1.getContext(\"webgl2\", i1), n1)) try {\n                    return new o1.WebGLContext(n1, 2);\n                } catch (e1) {\n                    r1.Logger.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl2'. Error: ${e1}`);\n                }\n                if ((!t1 || \"webgl\" === t1) && (n1 = e1.getContext(\"webgl\", i1) || e1.getContext(\"experimental-webgl\", i1), n1)) try {\n                    return new o1.WebGLContext(n1, 1);\n                } catch (e1) {\n                    r1.Logger.warning(\"GlContextFactory\", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e1}`);\n                }\n                throw new Error(\"WebGL is not supported\");\n            }\n            t1.createWebGLContext = function e1(t1) {\n                let n1;\n                if (t1 && \"webgl2\" !== t1 || !(\"webgl2\" in i1) ? t1 && \"webgl\" !== t1 || !(\"webgl\" in i1) || (n1 = i1.webgl) : n1 = i1.webgl2, !n1) try {\n                    n1 = s1(function() {\n                        if (\"undefined\" == typeof OffscreenCanvas) throw new TypeError(\"failed to create offscreen canvas: OffscreenCanvas is not supported\");\n                        return new OffscreenCanvas(1, 1);\n                    }(), t1);\n                } catch (e1) {\n                    n1 = s1(function() {\n                        if (\"undefined\" == typeof document) throw new TypeError(\"failed to create canvas: document is not supported\");\n                        const e1 = document.createElement(\"canvas\");\n                        return e1.width = 1, e1.height = 1, e1;\n                    }(), t1);\n                }\n                t1 = t1 || 1 === n1.version ? \"webgl\" : \"webgl2\";\n                const r1 = n1.gl;\n                return i1[t1] = n1, r1.isContextLost() ? (delete i1[t1], e1(t1)) : (r1.disable(r1.DEPTH_TEST), r1.disable(r1.STENCIL_TEST), r1.disable(r1.BLEND), r1.disable(r1.DITHER), r1.disable(r1.POLYGON_OFFSET_FILL), r1.disable(r1.SAMPLE_COVERAGE), r1.enable(r1.SCISSOR_TEST), r1.enable(r1.CULL_FACE), r1.cullFace(r1.BACK), n1);\n            }, t1.createNewWebGLContext = s1;\n        },\n        3524: function(e1, t1, n1) {\n            \"use strict\";\n            var r1 = this && this.__createBinding || (Object.create ? function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1);\n                var o1 = Object.getOwnPropertyDescriptor(t1, n1);\n                o1 && !(\"get\" in o1 ? !t1.__esModule : o1.writable || o1.configurable) || (o1 = {\n                    enumerable: !0,\n                    get: function() {\n                        return t1[n1];\n                    }\n                }), Object.defineProperty(e1, r1, o1);\n            } : function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1), e1[r1] = t1[n1];\n            }), o1 = this && this.__setModuleDefault || (Object.create ? function(e1, t1) {\n                Object.defineProperty(e1, \"default\", {\n                    enumerable: !0,\n                    value: t1\n                });\n            } : function(e1, t1) {\n                e1.default = t1;\n            }), i1 = this && this.__importStar || function(e1) {\n                if (e1 && e1.__esModule) return e1;\n                var t1 = {};\n                if (null != e1) for(var n1 in e1)\"default\" !== n1 && Object.prototype.hasOwnProperty.call(e1, n1) && r1(t1, e1, n1);\n                return o1(t1, e1), t1;\n            };\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.WebGLContext = t1.linearSearchLastTrue = void 0;\n            const s1 = n1(6207), a1 = i1(n1(9622)), u1 = n1(432);\n            function l1(e1) {\n                let t1 = 0;\n                for(; t1 < e1.length && e1[t1](); ++t1);\n                return t1 - 1;\n            }\n            t1.linearSearchLastTrue = l1, t1.WebGLContext = class {\n                constructor(e1, t1){\n                    this.frameBufferBound = !1, this.itemsToPoll = [], this.gl = e1, this.version = t1, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();\n                }\n                allocateTexture(e1, t1, n1, r1) {\n                    const o1 = this.gl, i1 = o1.createTexture();\n                    o1.bindTexture(o1.TEXTURE_2D, i1), o1.texParameteri(o1.TEXTURE_2D, o1.TEXTURE_MIN_FILTER, o1.NEAREST), o1.texParameteri(o1.TEXTURE_2D, o1.TEXTURE_MAG_FILTER, o1.NEAREST), o1.texParameteri(o1.TEXTURE_2D, o1.TEXTURE_WRAP_S, o1.CLAMP_TO_EDGE), o1.texParameteri(o1.TEXTURE_2D, o1.TEXTURE_WRAP_T, o1.CLAMP_TO_EDGE);\n                    const s1 = r1 ? n1.encode(r1, e1 * t1) : null;\n                    return o1.texImage2D(o1.TEXTURE_2D, 0, n1.internalFormat, e1, t1, 0, n1.format, n1.textureType, s1), this.checkError(), i1;\n                }\n                updateTexture(e1, t1, n1, r1, o1) {\n                    const i1 = this.gl;\n                    i1.bindTexture(i1.TEXTURE_2D, e1);\n                    const s1 = r1.encode(o1, t1 * n1);\n                    i1.texSubImage2D(i1.TEXTURE_2D, 0, 0, 0, t1, n1, r1.format, r1.textureType, s1), this.checkError();\n                }\n                attachFramebuffer(e1, t1, n1) {\n                    const r1 = this.gl;\n                    r1.bindTexture(r1.TEXTURE_2D, e1), r1.bindFramebuffer(r1.FRAMEBUFFER, this.framebuffer), r1.framebufferTexture2D(r1.FRAMEBUFFER, r1.COLOR_ATTACHMENT0, r1.TEXTURE_2D, e1, 0), this.checkError(), r1.viewport(0, 0, t1, n1), r1.scissor(0, 0, t1, n1);\n                }\n                readTexture(e1, t1, n1, r1, o1, i1) {\n                    const s1 = this.gl;\n                    i1 || (i1 = 1), this.frameBufferBound || this.attachFramebuffer(e1, t1, n1);\n                    const a1 = this.getEncoder(o1, i1), u1 = a1.allocate(t1 * n1);\n                    return s1.bindTexture(s1.TEXTURE_2D, e1), s1.framebufferTexture2D(s1.FRAMEBUFFER, s1.COLOR_ATTACHMENT0, s1.TEXTURE_2D, e1, 0), s1.readPixels(0, 0, t1, n1, s1.RGBA, a1.textureType, u1), this.checkError(), a1.decode(u1, r1);\n                }\n                isFramebufferReady() {\n                    return !0;\n                }\n                getActiveTexture() {\n                    const e1 = this.gl;\n                    return \"TEXTURE\" + (e1.getParameter(this.gl.ACTIVE_TEXTURE) - e1.TEXTURE0);\n                }\n                getTextureBinding() {\n                    return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);\n                }\n                getFramebufferBinding() {\n                    return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);\n                }\n                setVertexAttributes(e1, t1) {\n                    const n1 = this.gl;\n                    n1.vertexAttribPointer(e1, 3, n1.FLOAT, !1, 20, 0), n1.enableVertexAttribArray(e1), -1 !== t1 && (n1.vertexAttribPointer(t1, 2, n1.FLOAT, !1, 20, 12), n1.enableVertexAttribArray(t1)), this.checkError();\n                }\n                createProgram(e1, t1) {\n                    const n1 = this.gl, r1 = n1.createProgram();\n                    return n1.attachShader(r1, e1), n1.attachShader(r1, t1), n1.linkProgram(r1), r1;\n                }\n                compileShader(e1, t1) {\n                    const n1 = this.gl, r1 = n1.createShader(t1);\n                    if (!r1) throw new Error(`createShader() returned null with type ${t1}`);\n                    if (n1.shaderSource(r1, e1), n1.compileShader(r1), !1 === n1.getShaderParameter(r1, n1.COMPILE_STATUS)) throw new Error(`Failed to compile shader: ${n1.getShaderInfoLog(r1)}\\nShader source:\\n${e1}`);\n                    return r1;\n                }\n                deleteShader(e1) {\n                    this.gl.deleteShader(e1);\n                }\n                bindTextureToUniform(e1, t1, n1) {\n                    const r1 = this.gl;\n                    r1.activeTexture(r1.TEXTURE0 + t1), this.checkError(), r1.bindTexture(r1.TEXTURE_2D, e1), this.checkError(), r1.uniform1i(n1, t1), this.checkError();\n                }\n                draw() {\n                    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();\n                }\n                checkError() {\n                    if (s1.env.debug) {\n                        const e1 = this.gl, t1 = e1.getError();\n                        let n1 = \"\";\n                        switch(t1){\n                            case e1.NO_ERROR:\n                                return;\n                            case e1.INVALID_ENUM:\n                                n1 = \"INVALID_ENUM\";\n                                break;\n                            case e1.INVALID_VALUE:\n                                n1 = \"INVALID_VALUE\";\n                                break;\n                            case e1.INVALID_OPERATION:\n                                n1 = \"INVALID_OPERATION\";\n                                break;\n                            case e1.INVALID_FRAMEBUFFER_OPERATION:\n                                n1 = \"INVALID_FRAMEBUFFER_OPERATION\";\n                                break;\n                            case e1.OUT_OF_MEMORY:\n                                n1 = \"OUT_OF_MEMORY\";\n                                break;\n                            case e1.CONTEXT_LOST_WEBGL:\n                                n1 = \"CONTEXT_LOST_WEBGL\";\n                                break;\n                            default:\n                                n1 = `Unknown WebGL Error: ${t1.toString(16)}`;\n                        }\n                        throw new Error(n1);\n                    }\n                }\n                deleteTexture(e1) {\n                    this.gl.deleteTexture(e1);\n                }\n                deleteProgram(e1) {\n                    this.gl.deleteProgram(e1);\n                }\n                getEncoder(e1, t1, n1 = 0) {\n                    if (2 === this.version) return new a1.RedFloat32DataEncoder(this.gl, t1);\n                    switch(e1){\n                        case \"float\":\n                            return 1 === n1 || this.isRenderFloat32Supported ? new a1.RGBAFloatDataEncoder(this.gl, t1) : new a1.RGBAFloatDataEncoder(this.gl, t1, this.textureHalfFloatExtension.HALF_FLOAT_OES);\n                        case \"int\":\n                            throw new Error(\"not implemented\");\n                        case \"byte\":\n                            return new a1.Uint8DataEncoder(this.gl, t1);\n                        default:\n                            throw new Error(`Invalid dataType: ${e1}`);\n                    }\n                }\n                clearActiveTextures() {\n                    const e1 = this.gl;\n                    for(let t1 = 0; t1 < this.maxTextureImageUnits; ++t1)e1.activeTexture(e1.TEXTURE0 + t1), e1.bindTexture(e1.TEXTURE_2D, null);\n                }\n                dispose() {\n                    if (this.disposed) return;\n                    const e1 = this.gl;\n                    e1.bindFramebuffer(e1.FRAMEBUFFER, null), e1.deleteFramebuffer(this.framebuffer), e1.bindBuffer(e1.ARRAY_BUFFER, null), e1.deleteBuffer(this.vertexbuffer), e1.bindBuffer(e1.ELEMENT_ARRAY_BUFFER, null), e1.finish(), this.disposed = !0;\n                }\n                createDefaultGeometry() {\n                    return new Float32Array([\n                        -1,\n                        1,\n                        0,\n                        0,\n                        1,\n                        -1,\n                        -1,\n                        0,\n                        0,\n                        0,\n                        1,\n                        1,\n                        0,\n                        1,\n                        1,\n                        1,\n                        -1,\n                        0,\n                        1,\n                        0\n                    ]);\n                }\n                createVertexbuffer() {\n                    const e1 = this.gl, t1 = e1.createBuffer();\n                    if (!t1) throw new Error(\"createBuffer() returned null\");\n                    const n1 = this.createDefaultGeometry();\n                    return e1.bindBuffer(e1.ARRAY_BUFFER, t1), e1.bufferData(e1.ARRAY_BUFFER, n1, e1.STATIC_DRAW), this.checkError(), t1;\n                }\n                createFramebuffer() {\n                    const e1 = this.gl.createFramebuffer();\n                    if (!e1) throw new Error(\"createFramebuffer returned null\");\n                    return e1;\n                }\n                queryVitalParameters() {\n                    const e1 = this.gl;\n                    if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error(\"both float32 and float16 TextureType are not supported\");\n                    this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = e1.getParameter(e1.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = e1.getParameter(e1.MAX_TEXTURE_IMAGE_UNITS), this.version;\n                }\n                getExtensions() {\n                    2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension(\"EXT_color_buffer_float\"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension(\"EXT_disjoint_timer_query_webgl2\")) : (this.textureFloatExtension = this.gl.getExtension(\"OES_texture_float\"), this.textureHalfFloatExtension = this.gl.getExtension(\"OES_texture_half_float\"));\n                }\n                checkFloatTextureAttachableToFrameBuffer() {\n                    const e1 = this.gl, t1 = e1.createTexture();\n                    e1.bindTexture(e1.TEXTURE_2D, t1);\n                    const n1 = 2 === this.version ? e1.RGBA32F : e1.RGBA;\n                    e1.texImage2D(e1.TEXTURE_2D, 0, n1, 1, 1, 0, e1.RGBA, e1.FLOAT, null);\n                    const r1 = e1.createFramebuffer();\n                    e1.bindFramebuffer(e1.FRAMEBUFFER, r1), e1.framebufferTexture2D(e1.FRAMEBUFFER, e1.COLOR_ATTACHMENT0, e1.TEXTURE_2D, t1, 0);\n                    const o1 = e1.checkFramebufferStatus(e1.FRAMEBUFFER) === e1.FRAMEBUFFER_COMPLETE;\n                    return e1.bindTexture(e1.TEXTURE_2D, null), e1.bindFramebuffer(e1.FRAMEBUFFER, null), e1.deleteTexture(t1), e1.deleteFramebuffer(r1), o1;\n                }\n                checkRenderFloat32() {\n                    if (2 === this.version) {\n                        if (!this.colorBufferFloatExtension) return !1;\n                    } else if (!this.textureFloatExtension) return !1;\n                    return this.isFloatTextureAttachableToFrameBuffer;\n                }\n                checkFloat32Download() {\n                    if (2 === this.version) {\n                        if (!this.colorBufferFloatExtension) return !1;\n                    } else {\n                        if (!this.textureFloatExtension) return !1;\n                        if (!this.gl.getExtension(\"WEBGL_color_buffer_float\")) return !1;\n                    }\n                    return this.isFloatTextureAttachableToFrameBuffer;\n                }\n                checkFloat32Blend() {\n                    const e1 = this.gl;\n                    let t1, n1, r1, o1, i1;\n                    try {\n                        t1 = e1.createTexture(), n1 = e1.createFramebuffer(), e1.bindTexture(e1.TEXTURE_2D, t1);\n                        const s1 = 2 === this.version ? e1.RGBA32F : e1.RGBA;\n                        return e1.texImage2D(e1.TEXTURE_2D, 0, s1, 1, 1, 0, e1.RGBA, e1.FLOAT, null), e1.bindFramebuffer(e1.FRAMEBUFFER, n1), e1.framebufferTexture2D(e1.FRAMEBUFFER, e1.COLOR_ATTACHMENT0, e1.TEXTURE_2D, t1, 0), e1.enable(e1.BLEND), r1 = e1.createShader(e1.VERTEX_SHADER), !!r1 && (e1.shaderSource(r1, \"void main(){}\"), e1.compileShader(r1), o1 = e1.createShader(e1.FRAGMENT_SHADER), !!o1 && (e1.shaderSource(o1, \"precision highp float;void main(){gl_FragColor=vec4(0.5);}\"), e1.compileShader(o1), i1 = e1.createProgram(), !!i1 && (e1.attachShader(i1, r1), e1.attachShader(i1, o1), e1.linkProgram(i1), e1.useProgram(i1), e1.drawArrays(e1.POINTS, 0, 1), e1.getError() === e1.NO_ERROR)));\n                    } finally{\n                        e1.disable(e1.BLEND), i1 && e1.deleteProgram(i1), r1 && e1.deleteShader(r1), o1 && e1.deleteShader(o1), n1 && (e1.bindFramebuffer(e1.FRAMEBUFFER, null), e1.deleteFramebuffer(n1)), t1 && (e1.bindTexture(e1.TEXTURE_2D, null), e1.deleteTexture(t1));\n                    }\n                }\n                beginTimer() {\n                    if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {\n                        const e1 = this.gl, t1 = this.disjointTimerQueryWebgl2Extension, n1 = e1.createQuery();\n                        return e1.beginQuery(t1.TIME_ELAPSED_EXT, n1), n1;\n                    }\n                    throw new Error(\"WebGL1 profiling currently not supported.\");\n                }\n                endTimer() {\n                    if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error(\"WebGL1 profiling currently not supported\");\n                    {\n                        const e1 = this.gl, t1 = this.disjointTimerQueryWebgl2Extension;\n                        e1.endQuery(t1.TIME_ELAPSED_EXT);\n                    }\n                }\n                isTimerResultAvailable(e1) {\n                    let t1 = !1, n1 = !1;\n                    if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error(\"WebGL1 profiling currently not supported\");\n                    {\n                        const r1 = this.gl, o1 = this.disjointTimerQueryWebgl2Extension;\n                        t1 = r1.getQueryParameter(e1, r1.QUERY_RESULT_AVAILABLE), n1 = r1.getParameter(o1.GPU_DISJOINT_EXT);\n                    }\n                    return t1 && !n1;\n                }\n                getTimerResult(e1) {\n                    let t1 = 0;\n                    if (2 !== this.version) throw new Error(\"WebGL1 profiling currently not supported\");\n                    {\n                        const n1 = this.gl;\n                        t1 = n1.getQueryParameter(e1, n1.QUERY_RESULT), n1.deleteQuery(e1);\n                    }\n                    return t1 / 1e6;\n                }\n                async waitForQueryAndGetTime(e1) {\n                    return await (0, u1.repeatedTry)(()=>this.isTimerResultAvailable(e1)), this.getTimerResult(e1);\n                }\n                async createAndWaitForFence() {\n                    const e1 = this.createFence(this.gl);\n                    return this.pollFence(e1);\n                }\n                createFence(e1) {\n                    let t1;\n                    const n1 = e1, r1 = n1.fenceSync(n1.SYNC_GPU_COMMANDS_COMPLETE, 0);\n                    return e1.flush(), t1 = null === r1 ? ()=>!0 : ()=>{\n                        const e1 = n1.clientWaitSync(r1, 0, 0);\n                        return e1 === n1.ALREADY_SIGNALED || e1 === n1.CONDITION_SATISFIED;\n                    }, {\n                        query: r1,\n                        isFencePassed: t1\n                    };\n                }\n                async pollFence(e1) {\n                    return new Promise((t1)=>{\n                        this.addItemToPoll(()=>e1.isFencePassed(), ()=>t1());\n                    });\n                }\n                pollItems() {\n                    const e1 = l1(this.itemsToPoll.map((e1)=>e1.isDoneFn));\n                    for(let t1 = 0; t1 <= e1; ++t1){\n                        const { resolveFn: e1 } = this.itemsToPoll[t1];\n                        e1();\n                    }\n                    this.itemsToPoll = this.itemsToPoll.slice(e1 + 1);\n                }\n                async addItemToPoll(e1, t1) {\n                    this.itemsToPoll.push({\n                        isDoneFn: e1,\n                        resolveFn: t1\n                    }), this.itemsToPoll.length > 1 || await (0, u1.repeatedTry)(()=>(this.pollItems(), 0 === this.itemsToPoll.length));\n                }\n            };\n        },\n        6496: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.ExecutionPlan = void 0;\n            const r1 = n1(1315);\n            class o1 {\n                constructor(e1, t1){\n                    this.op = e1, this.node = t1;\n                }\n            }\n            t1.ExecutionPlan = class {\n                constructor(e1, t1, n1){\n                    this.graph = e1, this.profiler = n1, this.initialize(t1);\n                }\n                initialize(e1) {\n                    this.profiler.event(\"session\", \"ExecutionPlan.initialize\", ()=>{\n                        const t1 = this.graph.getNodes();\n                        if (t1.length !== e1.length) throw new Error(\"The size of nodes and OPs do not match.\");\n                        this._ops = e1.map((e1, n1)=>new o1(e1, t1[n1])), this.reset(), this._starter = [], this._ops.forEach((e1, t1)=>{\n                            let n1 = !0;\n                            for (const t1 of e1.node.inputs)if (!this._values[t1] && -1 === this.graph.getInputIndices().indexOf(t1)) {\n                                n1 = !1;\n                                break;\n                            }\n                            n1 && this._starter.push(t1);\n                        });\n                    });\n                }\n                reset() {\n                    this._values = this.graph.getValues().map((e1)=>e1.tensor);\n                }\n                async execute(e1, t1) {\n                    return this.profiler.event(\"session\", \"ExecutionPlan.execute\", async ()=>{\n                        this.reset();\n                        const n1 = e1.createInferenceHandler(), o1 = this.graph.getInputIndices();\n                        if (t1.length !== o1.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t1.length} expected: ${o1.length}`);\n                        t1.forEach((e1, t1)=>{\n                            const n1 = o1[t1];\n                            this._values[n1] = e1;\n                        });\n                        const i1 = this._starter.slice(0), s1 = this.graph.getValues(), a1 = this.graph.getNodes();\n                        let u1 = 0;\n                        for(; u1 < i1.length;){\n                            const e1 = i1[u1++], t1 = this._ops[e1], o1 = t1.node.inputs.map((e1)=>this._values[e1]);\n                            if (-1 !== o1.indexOf(void 0)) throw new Error(`unresolved input detected: op: ${t1.node}`);\n                            const l1 = o1;\n                            r1.Logger.verbose(\"ExecPlan\", `Runing op:${t1.node.name} (${l1.map((e1, n1)=>`'${t1.node.inputs[n1]}': ${e1.type}[${e1.dims.join(\",\")}]`).join(\", \")})`);\n                            const c1 = await this.profiler.event(\"node\", t1.node.name, async ()=>t1.op.impl(n1, l1, t1.op.context));\n                            if (c1.length !== t1.node.outputs.length) throw new Error(\"the size of output does not match model definition.\");\n                            c1.forEach((e1, n1)=>{\n                                const r1 = t1.node.outputs[n1];\n                                if (this._values[r1]) throw new Error(`output [${r1}] already has value: op:${t1.node.name}`);\n                                this._values[r1] = e1;\n                            });\n                            const p1 = new Set;\n                            c1.forEach((e1, n1)=>{\n                                const r1 = t1.node.outputs[n1];\n                                for (const e1 of s1[r1].to){\n                                    const t1 = a1[e1];\n                                    let n1 = !0;\n                                    for (const e1 of t1.inputs)if (!this._values[e1]) {\n                                        n1 = !1;\n                                        break;\n                                    }\n                                    n1 && p1.add(e1);\n                                }\n                            }), i1.push(...p1);\n                        }\n                        const l1 = [];\n                        for(let e1 = 0; e1 < this.graph.getOutputIndices().length; e1++){\n                            const t1 = this.graph.getOutputIndices()[e1], n1 = this._values[t1];\n                            if (void 0 === n1) throw new Error(`required output [${t1}] does not have value`);\n                            0 === t1 ? await n1.getData() : n1.data, l1.push(n1);\n                        }\n                        return r1.Logger.verbose(\"ExecPlan\", \"disposing of inferenceHandler\"), n1.dispose(), l1;\n                    });\n                }\n            };\n        },\n        4662: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.Graph = void 0;\n            const r1 = n1(6874), o1 = n1(5127), i1 = n1(2446), s1 = n1(9240), a1 = n1(7273);\n            var u1 = o1.onnxruntime.experimental.fbs;\n            t1.Graph = {\n                from: (e1, t1)=>new p1(e1, t1)\n            };\n            class l1 {\n                constructor(e1){\n                    this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, e1 && (this.type = a1.ProtoUtil.tensorValueTypeFromProto(e1.type.tensorType));\n                }\n                get from() {\n                    return this._from;\n                }\n                get to() {\n                    return this._to;\n                }\n            }\n            class c1 {\n                constructor(e1, t1){\n                    e1 instanceof i1.onnx.NodeProto ? (this.name = e1.name, this.opType = e1.opType, this.attributes = new r1.Attribute(e1.attribute)) : e1 instanceof u1.Node && (this.name = null != t1 ? t1 : e1.name(), this.opType = e1.opType(), this.attributes = new r1.Attribute(a1.ProtoUtil.tensorAttributesFromORTFormat(e1))), this.inputs = [], this.outputs = [], this.executeNode = !0;\n                }\n            }\n            class p1 {\n                constructor(e1, t1){\n                    if (!e1) throw new TypeError(\"graph is empty\");\n                    this.buildGraph(e1), this.transformGraph(t1), this.checkIsAcyclic();\n                }\n                getInputIndices() {\n                    return this._allInputIndices;\n                }\n                getInputNames() {\n                    return this._allInputNames;\n                }\n                getOutputIndices() {\n                    return this._allOutputIndices;\n                }\n                getOutputNames() {\n                    return this._allOutputNames;\n                }\n                getValues() {\n                    return this._allData;\n                }\n                getNodes() {\n                    return this._nodes;\n                }\n                buildGraph(e1) {\n                    if (e1 instanceof i1.onnx.GraphProto) this.buildGraphFromOnnxFormat(e1);\n                    else {\n                        if (!(e1 instanceof u1.Graph)) throw new TypeError(\"Graph type is not supported.\");\n                        this.buildGraphFromOrtFormat(e1);\n                    }\n                }\n                buildGraphFromOnnxFormat(e1) {\n                    const t1 = new Map;\n                    this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n                    const n1 = new Map;\n                    if (!e1.input) throw new Error(\"missing information in graph: input\");\n                    const r1 = [];\n                    for (const n1 of e1.input){\n                        if (t1.has(n1.name)) throw new Error(`duplicated input name: ${n1.name}`);\n                        const e1 = this._allData.push(new l1(n1)) - 1;\n                        t1.set(n1.name, e1), r1.push(n1.name);\n                    }\n                    if (!e1.initializer) throw new Error(\"missing information in graph: initializer\");\n                    for (const n1 of e1.initializer){\n                        let e1 = t1.get(n1.name);\n                        if (void 0 === e1) {\n                            const r1 = new l1;\n                            r1.type = {\n                                shape: {\n                                    dims: a1.ProtoUtil.tensorDimsFromProto(n1.dims)\n                                },\n                                tensorType: a1.ProtoUtil.tensorDataTypeFromProto(n1.dataType)\n                            }, e1 = this._allData.push(r1) - 1, t1.set(n1.name, e1);\n                        }\n                        this._allData[e1]._from = -1, this._allData[e1].tensor = s1.Tensor.fromProto(n1);\n                    }\n                    for(let e1 = 0; e1 < this._allData.length; e1++)this._allData[e1].tensor || (this._allInputIndices.push(e1), this._allInputNames.push(r1[e1]));\n                    if (!e1.output) throw new Error(\"missing information in graph: output\");\n                    for (const n1 of e1.output){\n                        if (t1.has(n1.name)) throw new Error(`duplicated output name: ${n1.name}`);\n                        const e1 = this._allData.push(new l1(n1)) - 1;\n                        t1.set(n1.name, e1), this._allOutputIndices.push(e1), this._allOutputNames.push(n1.name);\n                    }\n                    if (!e1.node) throw new Error(\"missing information in graph: node\");\n                    for (const t1 of e1.node){\n                        if (!t1.name) for(let e1 = 0;; e1++){\n                            const r1 = `unnamed_${t1.opType}_${e1}`;\n                            if (!n1.has(r1)) {\n                                t1.name = r1;\n                                break;\n                            }\n                        }\n                        if (n1.has(t1.name)) throw new Error(`duplicated node name: ${t1.name}`);\n                        const e1 = this._nodes.push(new c1(t1)) - 1;\n                        n1.set(t1.name, e1);\n                    }\n                    for(let n1 = 0; n1 < this._nodes.length; n1++){\n                        const r1 = this._nodes[n1], o1 = e1.node[n1];\n                        if (!o1.output) throw new Error(`missing output for node: ${o1.name}`);\n                        for (const e1 of o1.output){\n                            let i1 = t1.get(e1);\n                            if (void 0 === i1 && (i1 = this._allData.push(new l1) - 1, t1.set(e1, i1)), r1.outputs.push(i1), void 0 !== this._allData[i1]._from) throw new Error(`multiple nodes output to one data value: ${i1}`);\n                            if (this._allData[i1]._from = n1, \"Constant\" === o1.opType) {\n                                if (!o1.attribute || 1 !== o1.attribute.length || !o1.attribute[0].t) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n                                if (!o1.output || 1 !== o1.output.length) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n                                r1.outputs.pop(), r1.executeNode = !1, this._allData[i1]._from = -1, this._allData[i1].tensor = s1.Tensor.fromProto(o1.attribute[0].t);\n                            }\n                        }\n                    }\n                    for(let n1 = 0; n1 < this._nodes.length; n1++){\n                        const r1 = this._nodes[n1], o1 = e1.node[n1];\n                        if (!o1.input) throw new Error(`missing input for node: ${o1.name}`);\n                        for (const e1 of o1.input){\n                            const i1 = t1.get(e1);\n                            if (void 0 === i1) {\n                                if (\"\" === e1 && (3 === o1.input.length || 4 === o1.input.length) && \"Resize\" === o1.opType) continue;\n                                throw new Error(`unrecognized input '${e1}' for node: ${o1.name}`);\n                            }\n                            r1.inputs.push(i1), this._allData[i1]._to.push(n1);\n                        }\n                    }\n                    return !0;\n                }\n                buildGraphFromOrtFormat(e1) {\n                    var t1, n1, r1;\n                    const o1 = new Map;\n                    this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];\n                    const i1 = new Map, p1 = [];\n                    for(let i1 = 0; i1 < e1.inputsLength(); i1++){\n                        const s1 = e1.inputs(i1);\n                        if (o1.has(s1)) throw new Error(`duplicated input name: ${s1}`);\n                        for(let i1 = 0; i1 < e1.nodeArgsLength(); i1++)if ((null === (t1 = e1.nodeArgs(i1)) || void 0 === t1 ? void 0 : t1.name()) === s1) {\n                            const t1 = new l1;\n                            if ((null === (r1 = null === (n1 = e1.nodeArgs(i1)) || void 0 === n1 ? void 0 : n1.type()) || void 0 === r1 ? void 0 : r1.valueType()) !== u1.TypeInfoValue.tensor_type) throw new Error(\"Unexpected value type for the nodeArg.\");\n                            const c1 = e1.nodeArgs(i1).type().value(new u1.TensorTypeAndShape), d1 = a1.ProtoUtil.tensorDataTypeFromProto(c1.elemType()), f1 = c1.shape(), h1 = [];\n                            for(let e1 = 0; e1 < f1.dimLength(); e1++)h1.push(a1.LongUtil.longToNumber(f1.dim(e1).value().dimValue()));\n                            t1.type = {\n                                shape: {\n                                    dims: h1\n                                },\n                                tensorType: d1\n                            };\n                            const g1 = this._allData.push(t1) - 1;\n                            o1.set(s1, g1), p1.push(s1);\n                        }\n                    }\n                    for(let t1 = 0; t1 < e1.initializersLength(); t1++){\n                        const n1 = e1.initializers(t1);\n                        let r1 = o1.get(n1.name());\n                        if (void 0 === r1) {\n                            const e1 = new l1, t1 = a1.ProtoUtil.tensorDimsFromORTFormat(n1), i1 = a1.ProtoUtil.tensorDataTypeFromProto(n1.dataType());\n                            e1.type = {\n                                shape: {\n                                    dims: t1\n                                },\n                                tensorType: i1\n                            }, r1 = this._allData.push(e1) - 1, o1.set(n1.name(), r1);\n                        }\n                        this._allData[r1]._from = -1, this._allData[r1].tensor = s1.Tensor.fromOrtTensor(n1);\n                    }\n                    for(let e1 = 0; e1 < this._allData.length; e1++)this._allData[e1].tensor || (this._allInputIndices.push(e1), this._allInputNames.push(p1[e1]));\n                    for(let t1 = 0; t1 < e1.outputsLength(); t1++){\n                        const n1 = e1.outputs(t1);\n                        if (o1.has(n1)) throw new Error(`duplicated output name: ${n1}`);\n                        const r1 = this._allData.push(new l1) - 1;\n                        o1.set(n1, r1), this._allOutputIndices.push(r1), this._allOutputNames.push(n1);\n                    }\n                    if (!e1.nodes) throw new Error(\"missing information in graph: node\");\n                    for(let t1 = 0; t1 < e1.nodesLength(); t1++){\n                        const n1 = e1.nodes(t1);\n                        let r1 = n1.name();\n                        if (!r1) for(let e1 = 0; r1 = `unnamed_${n1.opType()}_${e1}`, i1.has(r1); e1++);\n                        if (i1.has(r1)) throw new Error(`duplicated node name: ${r1}`);\n                        const o1 = this._nodes.push(new c1(n1, r1)) - 1;\n                        i1.set(r1, o1);\n                    }\n                    for(let t1 = 0; t1 < this._nodes.length; t1++){\n                        const n1 = this._nodes[t1], r1 = e1.nodes(t1);\n                        if (null == r1) throw new Error(`No node exists at index ${t1}`);\n                        if (0 === (null == r1 ? void 0 : r1.outputsLength())) throw new Error(`missing output for node: ${r1.name}`);\n                        for(let e1 = 0; e1 < (null == r1 ? void 0 : r1.outputsLength()); e1++){\n                            const i1 = null == r1 ? void 0 : r1.outputs(e1);\n                            let a1 = o1.get(i1);\n                            if (void 0 === a1 && (a1 = this._allData.push(new l1) - 1, o1.set(i1, a1)), n1.outputs.push(a1), void 0 !== this._allData[a1]._from) throw new Error(`multiple nodes output to one data value: ${a1}`);\n                            if (this._allData[a1]._from = t1, \"Constant\" === r1.opType()) {\n                                if (1 !== r1.attributesLength() || !r1.attributes(0).t()) throw new Error(\"missing attributes or missing tensor value in attributes for this Constant operator\");\n                                if (1 !== r1.outputsLength()) throw new Error(\"missing output or incorrect number of outputs for this Constant operator\");\n                                n1.outputs.pop(), n1.executeNode = !1, this._allData[a1]._from = -1, this._allData[a1].tensor = s1.Tensor.fromOrtTensor(r1.attributes(0).t());\n                            }\n                        }\n                    }\n                    for(let t1 = 0; t1 < this._nodes.length; t1++){\n                        const n1 = this._nodes[t1], r1 = e1.nodes(t1);\n                        if (0 === r1.inputsLength()) throw new Error(`missing input for node: ${r1.name}`);\n                        for(let e1 = 0; e1 < r1.inputsLength(); e1++){\n                            const i1 = r1.inputs(e1), s1 = o1.get(i1);\n                            if (void 0 === s1) throw new Error(`unrecognized input '${i1}' for node: ${r1.name()}`);\n                            n1.inputs.push(s1), this._allData[s1]._to.push(t1);\n                        }\n                    }\n                }\n                checkIsAcyclic() {\n                    const e1 = new Set;\n                    this._allInputIndices.forEach((t1)=>{\n                        this._allData[t1]._to.forEach((t1)=>{\n                            e1.add(t1);\n                        });\n                    });\n                    const t1 = Array.from(e1), n1 = new Array(this._nodes.length).fill(\"white\");\n                    for(; t1.length > 0;){\n                        const e1 = t1.pop();\n                        \"gray\" === n1[e1] ? n1[e1] = \"black\" : (t1.push(e1), n1[e1] = \"gray\", this._nodes[e1].outputs.forEach((r1)=>{\n                            const o1 = this._allData[r1];\n                            if (void 0 !== o1.tensor) throw new Error(\"node outputs should not be initialized\");\n                            if (o1._from !== e1) throw new Error(\"from property of the Value object doesn't match index of Node being processed\");\n                            o1._to.forEach((e1)=>{\n                                if (\"gray\" === n1[e1]) throw new Error(\"model graph is cyclic\");\n                                \"white\" === n1[e1] && t1.push(e1);\n                            });\n                        }));\n                    }\n                }\n                transformGraph(e1) {\n                    this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), e1 && e1.transformGraph(this), this.finalizeGraph();\n                }\n                finalizeGraph() {\n                    let e1 = 0;\n                    const t1 = new Array(this._nodes.length, 0);\n                    let n1 = 0;\n                    for(let e1 = 0; e1 < this._nodes.length; e1++)t1[e1] = n1, this._nodes[e1].executeNode ? (n1 !== e1 && (this._nodes[n1] = this._nodes[e1]), n1++) : this._nodes[e1].outputs.forEach((e1)=>{\n                        this._allData[e1]._from = -2;\n                    });\n                    this._nodes.splice(n1, this._nodes.length - n1);\n                    for(let e1 = 0; e1 < this._allData.length; e1++){\n                        const n1 = this._allData[e1];\n                        void 0 !== n1._from && -1 !== n1._from && -2 !== n1._from && (n1._from = t1[n1._from]);\n                        for(let e1 = 0; e1 < n1._to.length; e1++){\n                            if (!(n1._to[e1] >= 0)) throw new Error(\"Trying to update a removed node\");\n                            n1._to[e1] = t1[n1._to[e1]];\n                        }\n                    }\n                    e1 = 0;\n                    for(let t1 = 0; t1 < this._allData.length; t1++)if (-2 !== this._allData[t1].from || -1 !== this._allOutputIndices.indexOf(t1 + e1)) {\n                        if (e1 > 0) {\n                            let n1 = -1;\n                            void 0 !== this._allData[t1].from && -1 !== this._allData[t1].from ? (n1 = this._nodes[this._allData[t1].from].outputs.indexOf(t1 + e1), -1 !== n1 && (this._nodes[this._allData[t1].from].outputs[n1] = t1)) : (n1 = this._allInputIndices.indexOf(t1 + e1), -1 !== n1 && (this._allInputIndices[n1] = t1)), this._allData[t1].to.forEach((r1)=>{\n                                n1 = this._nodes[r1].inputs.indexOf(t1 + e1), -1 !== n1 && (this._nodes[r1].inputs[n1] = t1);\n                            }), 0 === this._allData[t1].to.length && (n1 = this._allOutputIndices.indexOf(t1 + e1), -1 !== n1 && (this._allOutputIndices[n1] = t1));\n                        }\n                    } else e1++, this._allData.splice(t1, 1), t1--;\n                }\n                deleteNode(e1) {\n                    const t1 = this._nodes[e1];\n                    if (t1.outputs.length > 1) {\n                        for(let e1 = 1; e1 < t1.outputs.length; e1++)if (this._allData[t1.outputs[e1]].to.length > 0) throw new Error(\"Node deletion with more than one output connected to other nodes is not supported. \");\n                    }\n                    t1.executeNode = !1;\n                    const n1 = t1.inputs[0], r1 = t1.outputs[0], o1 = this._allData[r1].to;\n                    for(let n1 = 0; n1 < t1.inputs.length; n1++){\n                        const r1 = this._allData[t1.inputs[n1]].to.indexOf(e1);\n                        if (-1 === r1) throw new Error(\"The Value object doesn't have the current Node in it's 'to' property \");\n                        this._allData[t1.inputs[n1]].to.splice(r1, 1);\n                    }\n                    this._allData[r1]._to = [];\n                    const i1 = this._allOutputIndices.indexOf(r1);\n                    if (-1 !== i1 && (this._allOutputIndices[i1] = n1), o1 && o1.length > 0) for (const e1 of o1){\n                        const t1 = this._nodes[e1].inputs.indexOf(r1);\n                        if (-1 === t1) throw new Error(\"The Node object doesn't have the output Value in it's 'inputs' property \");\n                        this._nodes[e1].inputs[t1] = n1, this._allData[n1].to.push(e1);\n                    }\n                }\n                removeAllDropoutNodes() {\n                    let e1 = 0;\n                    for (const t1 of this._nodes){\n                        if (\"Dropout\" === t1.opType) {\n                            if (1 !== t1.inputs.length) throw new Error(\"Dropout nodes should only contain one input. \");\n                            if (1 !== t1.outputs.length && 2 !== t1.outputs.length) throw new Error(\"Dropout nodes should contain either 1 or 2 output(s)\");\n                            if (2 === t1.outputs.length && 0 !== this._allData[t1.outputs[1]]._to.length) throw new Error(\"Dropout nodes's second output should not be referenced by other nodes\");\n                            this.deleteNode(e1);\n                        }\n                        e1++;\n                    }\n                }\n                removeAllIdentityNodes() {\n                    let e1 = 0;\n                    for (const t1 of this._nodes)\"Identity\" === t1.opType && this.deleteNode(e1), e1++;\n                }\n                isActivation(e1) {\n                    switch(e1.opType){\n                        case \"Relu\":\n                        case \"Sigmoid\":\n                        case \"Clip\":\n                            return !0;\n                        default:\n                            return !1;\n                    }\n                }\n                fuseConvActivationNodes() {\n                    for (const e1 of this._nodes)if (\"Conv\" === e1.opType) {\n                        const t1 = this._allData[e1.outputs[0]]._to;\n                        if (1 === t1.length && this.isActivation(this._nodes[t1[0]])) {\n                            const n1 = this._nodes[t1[0]];\n                            if (\"Clip\" === n1.opType) if (1 === n1.inputs.length) try {\n                                e1.attributes.set(\"activation_params\", \"floats\", [\n                                    n1.attributes.getFloat(\"min\"),\n                                    n1.attributes.getFloat(\"max\")\n                                ]);\n                            } catch (t1) {\n                                e1.attributes.set(\"activation_params\", \"floats\", [\n                                    a1.MIN_CLIP,\n                                    a1.MAX_CLIP\n                                ]);\n                            }\n                            else {\n                                if (!(n1.inputs.length >= 3 && void 0 !== this._allData[n1.inputs[1]].tensor && void 0 !== this._allData[n1.inputs[2]].tensor)) continue;\n                                e1.attributes.set(\"activation_params\", \"floats\", [\n                                    this._allData[n1.inputs[1]].tensor.floatData[0],\n                                    this._allData[n1.inputs[2]].tensor.floatData[0]\n                                ]);\n                            }\n                            e1.attributes.set(\"activation\", \"string\", n1.opType), this.deleteNode(t1[0]);\n                        }\n                    }\n                }\n            }\n        },\n        1315: (e1, t1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.now = t1.Profiler = t1.Logger = void 0;\n            const n1 = {\n                verbose: 1e3,\n                info: 2e3,\n                warning: 4e3,\n                error: 5e3,\n                fatal: 6e3\n            }, r1 = {\n                none: new class {\n                    log(e1, t1, n1) {}\n                },\n                console: new class {\n                    log(e1, t1, n1) {\n                        console.log(`${this.color(e1)} ${n1 ? \"\\x1b[35m\" + n1 + \"\\x1b[0m \" : \"\"}${t1}`);\n                    }\n                    color(e1) {\n                        switch(e1){\n                            case \"verbose\":\n                                return \"\\x1b[34;40mv\\x1b[0m\";\n                            case \"info\":\n                                return \"\\x1b[32mi\\x1b[0m\";\n                            case \"warning\":\n                                return \"\\x1b[30;43mw\\x1b[0m\";\n                            case \"error\":\n                                return \"\\x1b[31;40me\\x1b[0m\";\n                            case \"fatal\":\n                                return \"\\x1b[101mf\\x1b[0m\";\n                            default:\n                                throw new Error(`unsupported severity: ${e1}`);\n                        }\n                    }\n                }\n            }, o1 = {\n                provider: \"console\",\n                minimalSeverity: \"warning\",\n                logDateTime: !0,\n                logSourceLocation: !1\n            };\n            let i1 = {\n                \"\": o1\n            };\n            function s1(e1, t1, n1, r1) {\n                if (void 0 === t1) return o1 = e1, {\n                    verbose: s1.verbose.bind(null, o1),\n                    info: s1.info.bind(null, o1),\n                    warning: s1.warning.bind(null, o1),\n                    error: s1.error.bind(null, o1),\n                    fatal: s1.fatal.bind(null, o1)\n                };\n                if (void 0 === n1) a1(e1, t1);\n                else if (\"number\" == typeof n1 && void 0 === r1) a1(e1, t1);\n                else if (\"string\" == typeof n1 && void 0 === r1) a1(e1, n1, 0, t1);\n                else {\n                    if (\"string\" != typeof n1 || \"number\" != typeof r1) throw new TypeError(\"input is valid\");\n                    a1(e1, n1, 0, t1);\n                }\n                var o1;\n            }\n            function a1(e1, t1, o1, s1) {\n                const a1 = i1[s1 || \"\"] || i1[\"\"];\n                n1[e1] < n1[a1.minimalSeverity] || (a1.logDateTime && (t1 = `${(new Date).toISOString()}|${t1}`), a1.logSourceLocation, r1[a1.provider].log(e1, t1, s1));\n            }\n            !function(e1) {\n                function t1(e1) {\n                    i1 = {}, n1(\"\", e1 || {});\n                }\n                function n1(e1, n1) {\n                    if (\"*\" === e1) t1(n1);\n                    else {\n                        const t1 = i1[e1] || o1;\n                        i1[e1] = {\n                            provider: n1.provider || t1.provider,\n                            minimalSeverity: n1.minimalSeverity || t1.minimalSeverity,\n                            logDateTime: void 0 === n1.logDateTime ? t1.logDateTime : n1.logDateTime,\n                            logSourceLocation: void 0 === n1.logSourceLocation ? t1.logSourceLocation : n1.logSourceLocation\n                        };\n                    }\n                }\n                e1.verbose = function(t1, n1) {\n                    e1(\"verbose\", t1, n1);\n                }, e1.info = function(t1, n1) {\n                    e1(\"info\", t1, n1);\n                }, e1.warning = function(t1, n1) {\n                    e1(\"warning\", t1, n1);\n                }, e1.error = function(t1, n1) {\n                    e1(\"error\", t1, n1);\n                }, e1.fatal = function(t1, n1) {\n                    e1(\"fatal\", t1, n1);\n                }, e1.reset = t1, e1.set = n1, e1.setWithEnv = function(e1) {\n                    const t1 = {};\n                    e1.logLevel && (t1.minimalSeverity = e1.logLevel), n1(\"\", t1);\n                };\n            }(s1 || (s1 = {})), t1.Logger = s1;\n            class u1 {\n                constructor(e1, t1, n1, r1, o1, i1){\n                    this.category = e1, this.name = t1, this.startTime = n1, this.endCallback = r1, this.timer = o1, this.ctx = i1;\n                }\n                async end() {\n                    return this.endCallback(this);\n                }\n                async checkTimer() {\n                    if (void 0 === this.ctx || void 0 === this.timer) throw new Error(\"No webgl timer found\");\n                    return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);\n                }\n            }\n            class l1 {\n                constructor(e1, t1, n1, r1){\n                    this.category = e1, this.name = t1, this.startTime = n1, this.endTime = r1;\n                }\n            }\n            t1.Profiler = class {\n                static create(e1) {\n                    return void 0 === e1 ? new this : new this(e1.maxNumberEvents, e1.flushBatchSize, e1.flushIntervalInMilliseconds);\n                }\n                constructor(e1, t1, n1){\n                    this._started = !1, this._flushPointer = 0, this._started = !1, this._maxNumberEvents = void 0 === e1 ? 1e4 : e1, this._flushBatchSize = void 0 === t1 ? 10 : t1, this._flushIntervalInMilliseconds = void 0 === n1 ? 5e3 : n1;\n                }\n                start() {\n                    this._started = !0, this._timingEvents = [], this._flushTime = (0, t1.now)(), this._flushPointer = 0;\n                }\n                stop() {\n                    for(this._started = !1; this._flushPointer < this._timingEvents.length; this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);\n                }\n                event(e1, t1, n1, r1) {\n                    const o1 = this._started ? this.begin(e1, t1, r1) : void 0;\n                    let i1 = !1;\n                    const s1 = n1();\n                    if (s1 && \"function\" == typeof s1.then) return i1 = !0, new Promise((e1, t1)=>{\n                        s1.then(async (t1)=>{\n                            o1 && await o1.end(), e1(t1);\n                        }, async (e1)=>{\n                            o1 && await o1.end(), t1(e1);\n                        });\n                    });\n                    if (!i1 && o1) {\n                        const e1 = o1.end();\n                        if (e1 && \"function\" == typeof e1.then) return new Promise((t1, n1)=>{\n                            e1.then(()=>{\n                                t1(s1);\n                            }, (e1)=>{\n                                n1(e1);\n                            });\n                        });\n                    }\n                    return s1;\n                }\n                begin(e1, n1, r1) {\n                    if (!this._started) throw new Error(\"profiler is not started yet\");\n                    if (void 0 === r1) {\n                        const r1 = (0, t1.now)();\n                        return this.flush(r1), new u1(e1, n1, r1, (e1)=>this.endSync(e1));\n                    }\n                    {\n                        const t1 = r1.beginTimer();\n                        return new u1(e1, n1, 0, async (e1)=>this.end(e1), t1, r1);\n                    }\n                }\n                async end(e1) {\n                    const t1 = await e1.checkTimer();\n                    this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l1(e1.category, e1.name, e1.startTime, t1)), this.flush(t1));\n                }\n                endSync(e1) {\n                    const n1 = (0, t1.now)();\n                    this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new l1(e1.category, e1.name, e1.startTime, n1)), this.flush(n1));\n                }\n                logOneEvent(e1) {\n                    t1.Logger.verbose(`Profiler.${e1.category}`, `${(e1.endTime - e1.startTime).toFixed(2)}ms on event '${e1.name}' at ${e1.endTime.toFixed(2)}`);\n                }\n                flush(e1) {\n                    if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || e1 - this._flushTime >= this._flushIntervalInMilliseconds) {\n                        for(const e1 = this._flushPointer; this._flushPointer < e1 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);\n                        this._flushTime = (0, t1.now)();\n                    }\n                }\n                get started() {\n                    return this._started;\n                }\n            }, t1.now = \"undefined\" != typeof performance && performance.now ? ()=>performance.now() : Date.now;\n        },\n        1745: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.Model = void 0;\n            const r1 = n1(5686), o1 = n1(4662), i1 = n1(5127), s1 = n1(2446), a1 = n1(7273);\n            var u1 = i1.onnxruntime.experimental.fbs;\n            t1.Model = class {\n                constructor(){}\n                load(e1, t1, n1) {\n                    if (!n1) try {\n                        return void this.loadFromOnnxFormat(e1, t1);\n                    } catch (e1) {\n                        if (void 0 !== n1) throw e1;\n                    }\n                    this.loadFromOrtFormat(e1, t1);\n                }\n                loadFromOnnxFormat(e1, t1) {\n                    const n1 = s1.onnx.ModelProto.decode(e1);\n                    if (a1.LongUtil.longToNumber(n1.irVersion) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n                    this._opsets = n1.opsetImport.map((e1)=>({\n                            domain: e1.domain,\n                            version: a1.LongUtil.longToNumber(e1.version)\n                        })), this._graph = o1.Graph.from(n1.graph, t1);\n                }\n                loadFromOrtFormat(e1, t1) {\n                    const n1 = new r1.flatbuffers.ByteBuffer(e1), i1 = u1.InferenceSession.getRootAsInferenceSession(n1).model();\n                    if (a1.LongUtil.longToNumber(i1.irVersion()) < 3) throw new Error(\"only support ONNX model with IR_VERSION>=3\");\n                    this._opsets = [];\n                    for(let e1 = 0; e1 < i1.opsetImportLength(); e1++){\n                        const t1 = i1.opsetImport(e1);\n                        this._opsets.push({\n                            domain: null == t1 ? void 0 : t1.domain(),\n                            version: a1.LongUtil.longToNumber(t1.version())\n                        });\n                    }\n                    this._graph = o1.Graph.from(i1.graph(), t1);\n                }\n                get graph() {\n                    return this._graph;\n                }\n                get opsets() {\n                    return this._opsets;\n                }\n            };\n        },\n        6145: (e1, t1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.FLOAT_TYPES = t1.INT_TYPES = t1.NUMBER_TYPES = void 0, t1.NUMBER_TYPES = [\n                \"float32\",\n                \"float64\",\n                \"int32\",\n                \"int16\",\n                \"int8\",\n                \"uint16\",\n                \"uint32\",\n                \"uint8\"\n            ], t1.INT_TYPES = [\n                \"int32\",\n                \"int16\",\n                \"int8\",\n                \"uint16\",\n                \"uint32\",\n                \"uint8\"\n            ], t1.FLOAT_TYPES = [\n                \"float32\",\n                \"float64\"\n            ];\n        },\n        5881: (e1, t1)=>{\n            \"use strict\";\n            function n1(e1, t1) {\n                if (t1.endsWith(\"+\")) {\n                    const n1 = Number.parseInt(t1.substring(0, t1.length - 1), 10);\n                    return !isNaN(n1) && n1 <= e1;\n                }\n                if (2 === t1.split(\"-\").length) {\n                    const n1 = t1.split(\"-\"), r1 = Number.parseInt(n1[0], 10), o1 = Number.parseInt(n1[1], 10);\n                    return !isNaN(r1) && !isNaN(o1) && r1 <= e1 && e1 <= o1;\n                }\n                return Number.parseInt(t1, 10) === e1;\n            }\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.resolveOperator = void 0, t1.resolveOperator = function(e1, t1, r1) {\n                for (const o1 of r1){\n                    const r1 = o1[0], i1 = o1[1], s1 = o1[2], a1 = o1[3], u1 = o1[4];\n                    if (e1.opType === r1) {\n                        for (const e1 of t1)if ((e1.domain === i1 || \"ai.onnx\" === e1.domain && \"\" === i1) && n1(e1.version, s1)) return {\n                            opImpl: a1,\n                            opInit: u1\n                        };\n                    }\n                }\n                throw new TypeError(`cannot resolve operator '${e1.opType}' with opsets: ${t1.map((e1)=>`${e1.domain || \"ai.onnx\"} v${e1.version}`).join(\", \")}`);\n            };\n        },\n        5127: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.onnxruntime = void 0;\n            const r1 = n1(5686);\n            var o1, i1;\n            o1 = t1.onnxruntime || (t1.onnxruntime = {}), function(e1) {\n                let t1;\n                !function(e1) {\n                    e1[e1.UNDEFINED = 0] = \"UNDEFINED\", e1[e1.FLOAT = 1] = \"FLOAT\", e1[e1.INT = 2] = \"INT\", e1[e1.STRING = 3] = \"STRING\", e1[e1.TENSOR = 4] = \"TENSOR\", e1[e1.GRAPH = 5] = \"GRAPH\", e1[e1.FLOATS = 6] = \"FLOATS\", e1[e1.INTS = 7] = \"INTS\", e1[e1.STRINGS = 8] = \"STRINGS\", e1[e1.TENSORS = 9] = \"TENSORS\", e1[e1.GRAPHS = 10] = \"GRAPHS\", e1[e1.SPARSE_TENSOR = 11] = \"SPARSE_TENSOR\", e1[e1.SPARSE_TENSORS = 12] = \"SPARSE_TENSORS\";\n                }(t1 = e1.AttributeType || (e1.AttributeType = {}));\n            }((i1 = o1.experimental || (o1.experimental = {})).fbs || (i1.fbs = {})), function(e1) {\n                !function(e1) {\n                    !function(e1) {\n                        let t1;\n                        !function(e1) {\n                            e1[e1.UNKNOWN = 0] = \"UNKNOWN\", e1[e1.VALUE = 1] = \"VALUE\", e1[e1.PARAM = 2] = \"PARAM\";\n                        }(t1 = e1.DimensionValueType || (e1.DimensionValueType = {}));\n                    }(e1.fbs || (e1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(e1) {\n                    !function(e1) {\n                        let t1;\n                        !function(e1) {\n                            e1[e1.UNDEFINED = 0] = \"UNDEFINED\", e1[e1.FLOAT = 1] = \"FLOAT\", e1[e1.UINT8 = 2] = \"UINT8\", e1[e1.INT8 = 3] = \"INT8\", e1[e1.UINT16 = 4] = \"UINT16\", e1[e1.INT16 = 5] = \"INT16\", e1[e1.INT32 = 6] = \"INT32\", e1[e1.INT64 = 7] = \"INT64\", e1[e1.STRING = 8] = \"STRING\", e1[e1.BOOL = 9] = \"BOOL\", e1[e1.FLOAT16 = 10] = \"FLOAT16\", e1[e1.DOUBLE = 11] = \"DOUBLE\", e1[e1.UINT32 = 12] = \"UINT32\", e1[e1.UINT64 = 13] = \"UINT64\", e1[e1.COMPLEX64 = 14] = \"COMPLEX64\", e1[e1.COMPLEX128 = 15] = \"COMPLEX128\", e1[e1.BFLOAT16 = 16] = \"BFLOAT16\", e1[e1.FLOAT8E4M3FN = 17] = \"FLOAT8E4M3FN\", e1[e1.FLOAT8E4M3FNUZ = 18] = \"FLOAT8E4M3FNUZ\", e1[e1.FLOAT8E5M2 = 19] = \"FLOAT8E5M2\", e1[e1.FLOAT8E5M2FNUZ = 20] = \"FLOAT8E5M2FNUZ\";\n                        }(t1 = e1.TensorDataType || (e1.TensorDataType = {}));\n                    }(e1.fbs || (e1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(e1) {\n                    !function(e1) {\n                        let t1;\n                        !function(e1) {\n                            e1[e1.Primitive = 0] = \"Primitive\", e1[e1.Fused = 1] = \"Fused\";\n                        }(t1 = e1.NodeType || (e1.NodeType = {}));\n                    }(e1.fbs || (e1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(e1) {\n                    !function(e1) {\n                        let t1;\n                        !function(e1) {\n                            e1[e1.NONE = 0] = \"NONE\", e1[e1.tensor_type = 1] = \"tensor_type\", e1[e1.sequence_type = 2] = \"sequence_type\", e1[e1.map_type = 3] = \"map_type\";\n                        }(t1 = e1.TypeInfoValue || (e1.TypeInfoValue = {}));\n                    }(e1.fbs || (e1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsShape(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsShape(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            dim(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 4);\n                                return r1 ? (n1 || new e1.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            dimLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 4);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            static startShape(e1) {\n                                e1.startObject(1);\n                            }\n                            static addDim(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static createDimVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startDimVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static endShape(e1) {\n                                return e1.endObject();\n                            }\n                            static createShape(e1, t1) {\n                                return n1.startShape(e1), n1.addDim(e1, t1), n1.endShape(e1);\n                            }\n                        }\n                        t1.Shape = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsDimension(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsDimension(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            value(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 4);\n                                return n1 ? (t1 || new e1.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            denotation(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 6);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            static startDimension(e1) {\n                                e1.startObject(2);\n                            }\n                            static addValue(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addDenotation(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static endDimension(e1) {\n                                return e1.endObject();\n                            }\n                            static createDimension(e1, t1, r1) {\n                                return n1.startDimension(e1), n1.addValue(e1, t1), n1.addDenotation(e1, r1), n1.endDimension(e1);\n                            }\n                        }\n                        t1.Dimension = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsDimensionValue(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsDimensionValue(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            dimType() {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.readInt8(this.bb_pos + t1) : e1.experimental.fbs.DimensionValueType.UNKNOWN;\n                            }\n                            dimValue() {\n                                let e1 = this.bb.__offset(this.bb_pos, 6);\n                                return e1 ? this.bb.readInt64(this.bb_pos + e1) : this.bb.createLong(0, 0);\n                            }\n                            dimParam(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 8);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            static startDimensionValue(e1) {\n                                e1.startObject(3);\n                            }\n                            static addDimType(t1, n1) {\n                                t1.addFieldInt8(0, n1, e1.experimental.fbs.DimensionValueType.UNKNOWN);\n                            }\n                            static addDimValue(e1, t1) {\n                                e1.addFieldInt64(1, t1, e1.createLong(0, 0));\n                            }\n                            static addDimParam(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static endDimensionValue(e1) {\n                                return e1.endObject();\n                            }\n                            static createDimensionValue(e1, t1, r1, o1) {\n                                return n1.startDimensionValue(e1), n1.addDimType(e1, t1), n1.addDimValue(e1, r1), n1.addDimParam(e1, o1), n1.endDimensionValue(e1);\n                            }\n                        }\n                        t1.DimensionValue = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsTensorTypeAndShape(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsTensorTypeAndShape(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            elemType() {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.readInt32(this.bb_pos + t1) : e1.experimental.fbs.TensorDataType.UNDEFINED;\n                            }\n                            shape(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 6);\n                                return n1 ? (t1 || new e1.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            static startTensorTypeAndShape(e1) {\n                                e1.startObject(2);\n                            }\n                            static addElemType(t1, n1) {\n                                t1.addFieldInt32(0, n1, e1.experimental.fbs.TensorDataType.UNDEFINED);\n                            }\n                            static addShape(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static endTensorTypeAndShape(e1) {\n                                return e1.endObject();\n                            }\n                            static createTensorTypeAndShape(e1, t1, r1) {\n                                return n1.startTensorTypeAndShape(e1), n1.addElemType(e1, t1), n1.addShape(e1, r1), n1.endTensorTypeAndShape(e1);\n                            }\n                        }\n                        t1.TensorTypeAndShape = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsMapType(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsMapType(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            keyType() {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.readInt32(this.bb_pos + t1) : e1.experimental.fbs.TensorDataType.UNDEFINED;\n                            }\n                            valueType(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 6);\n                                return n1 ? (t1 || new e1.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            static startMapType(e1) {\n                                e1.startObject(2);\n                            }\n                            static addKeyType(t1, n1) {\n                                t1.addFieldInt32(0, n1, e1.experimental.fbs.TensorDataType.UNDEFINED);\n                            }\n                            static addValueType(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static endMapType(e1) {\n                                return e1.endObject();\n                            }\n                            static createMapType(e1, t1, r1) {\n                                return n1.startMapType(e1), n1.addKeyType(e1, t1), n1.addValueType(e1, r1), n1.endMapType(e1);\n                            }\n                        }\n                        t1.MapType = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsSequenceType(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsSequenceType(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            elemType(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 4);\n                                return n1 ? (t1 || new e1.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            static startSequenceType(e1) {\n                                e1.startObject(1);\n                            }\n                            static addElemType(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static endSequenceType(e1) {\n                                return e1.endObject();\n                            }\n                            static createSequenceType(e1, t1) {\n                                return n1.startSequenceType(e1), n1.addElemType(e1, t1), n1.endSequenceType(e1);\n                            }\n                        }\n                        t1.SequenceType = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(e1) {\n                    (e1.fbs || (e1.fbs = {})).EdgeEnd = class {\n                        constructor(){\n                            this.bb = null, this.bb_pos = 0;\n                        }\n                        __init(e1, t1) {\n                            return this.bb_pos = e1, this.bb = t1, this;\n                        }\n                        nodeIndex() {\n                            return this.bb.readUint32(this.bb_pos);\n                        }\n                        srcArgIndex() {\n                            return this.bb.readInt32(this.bb_pos + 4);\n                        }\n                        dstArgIndex() {\n                            return this.bb.readInt32(this.bb_pos + 8);\n                        }\n                        static createEdgeEnd(e1, t1, n1, r1) {\n                            return e1.prep(4, 12), e1.writeInt32(r1), e1.writeInt32(n1), e1.writeInt32(t1), e1.offset();\n                        }\n                    };\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsNodeEdge(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsNodeEdge(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            nodeIndex() {\n                                let e1 = this.bb.__offset(this.bb_pos, 4);\n                                return e1 ? this.bb.readUint32(this.bb_pos + e1) : 0;\n                            }\n                            inputEdges(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 6);\n                                return r1 ? (n1 || new e1.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos + r1) + 12 * t1, this.bb) : null;\n                            }\n                            inputEdgesLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 6);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            outputEdges(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 8);\n                                return r1 ? (n1 || new e1.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos + r1) + 12 * t1, this.bb) : null;\n                            }\n                            outputEdgesLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 8);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            static startNodeEdge(e1) {\n                                e1.startObject(3);\n                            }\n                            static addNodeIndex(e1, t1) {\n                                e1.addFieldInt32(0, t1, 0);\n                            }\n                            static addInputEdges(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static startInputEdgesVector(e1, t1) {\n                                e1.startVector(12, t1, 4);\n                            }\n                            static addOutputEdges(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static startOutputEdgesVector(e1, t1) {\n                                e1.startVector(12, t1, 4);\n                            }\n                            static endNodeEdge(e1) {\n                                return e1.endObject();\n                            }\n                            static createNodeEdge(e1, t1, r1, o1) {\n                                return n1.startNodeEdge(e1), n1.addNodeIndex(e1, t1), n1.addInputEdges(e1, r1), n1.addOutputEdges(e1, o1), n1.endNodeEdge(e1);\n                            }\n                        }\n                        t1.NodeEdge = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsNode(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsNode(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            name(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            docString(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 6);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            domain(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 8);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            sinceVersion() {\n                                let e1 = this.bb.__offset(this.bb_pos, 10);\n                                return e1 ? this.bb.readInt32(this.bb_pos + e1) : 0;\n                            }\n                            index() {\n                                let e1 = this.bb.__offset(this.bb_pos, 12);\n                                return e1 ? this.bb.readUint32(this.bb_pos + e1) : 0;\n                            }\n                            opType(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 14);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            type() {\n                                let t1 = this.bb.__offset(this.bb_pos, 16);\n                                return t1 ? this.bb.readInt32(this.bb_pos + t1) : e1.experimental.fbs.NodeType.Primitive;\n                            }\n                            executionProviderType(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 18);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            inputs(e1, t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 20);\n                                return n1 ? this.bb.__string(this.bb.__vector(this.bb_pos + n1) + 4 * e1, t1) : null;\n                            }\n                            inputsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 20);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            outputs(e1, t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 22);\n                                return n1 ? this.bb.__string(this.bb.__vector(this.bb_pos + n1) + 4 * e1, t1) : null;\n                            }\n                            outputsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 22);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            attributes(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 24);\n                                return r1 ? (n1 || new e1.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            attributesLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 24);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            inputArgCounts(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 26);\n                                return t1 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + t1) + 4 * e1) : 0;\n                            }\n                            inputArgCountsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 26);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            inputArgCountsArray() {\n                                let e1 = this.bb.__offset(this.bb_pos, 26);\n                                return e1 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e1), this.bb.__vector_len(this.bb_pos + e1)) : null;\n                            }\n                            implicitInputs(e1, t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 28);\n                                return n1 ? this.bb.__string(this.bb.__vector(this.bb_pos + n1) + 4 * e1, t1) : null;\n                            }\n                            implicitInputsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 28);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            static startNode(e1) {\n                                e1.startObject(13);\n                            }\n                            static addName(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addDocString(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static addDomain(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static addSinceVersion(e1, t1) {\n                                e1.addFieldInt32(3, t1, 0);\n                            }\n                            static addIndex(e1, t1) {\n                                e1.addFieldInt32(4, t1, 0);\n                            }\n                            static addOpType(e1, t1) {\n                                e1.addFieldOffset(5, t1, 0);\n                            }\n                            static addType(t1, n1) {\n                                t1.addFieldInt32(6, n1, e1.experimental.fbs.NodeType.Primitive);\n                            }\n                            static addExecutionProviderType(e1, t1) {\n                                e1.addFieldOffset(7, t1, 0);\n                            }\n                            static addInputs(e1, t1) {\n                                e1.addFieldOffset(8, t1, 0);\n                            }\n                            static createInputsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startInputsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addOutputs(e1, t1) {\n                                e1.addFieldOffset(9, t1, 0);\n                            }\n                            static createOutputsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startOutputsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addAttributes(e1, t1) {\n                                e1.addFieldOffset(10, t1, 0);\n                            }\n                            static createAttributesVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startAttributesVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addInputArgCounts(e1, t1) {\n                                e1.addFieldOffset(11, t1, 0);\n                            }\n                            static createInputArgCountsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addInt32(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startInputArgCountsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addImplicitInputs(e1, t1) {\n                                e1.addFieldOffset(12, t1, 0);\n                            }\n                            static createImplicitInputsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startImplicitInputsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static endNode(e1) {\n                                return e1.endObject();\n                            }\n                            static createNode(e1, t1, r1, o1, i1, s1, a1, u1, l1, c1, p1, d1, f1, h1) {\n                                return n1.startNode(e1), n1.addName(e1, t1), n1.addDocString(e1, r1), n1.addDomain(e1, o1), n1.addSinceVersion(e1, i1), n1.addIndex(e1, s1), n1.addOpType(e1, a1), n1.addType(e1, u1), n1.addExecutionProviderType(e1, l1), n1.addInputs(e1, c1), n1.addOutputs(e1, p1), n1.addAttributes(e1, d1), n1.addInputArgCounts(e1, f1), n1.addImplicitInputs(e1, h1), n1.endNode(e1);\n                            }\n                        }\n                        t1.Node = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsValueInfo(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsValueInfo(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            name(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            docString(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 6);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            type(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 8);\n                                return n1 ? (t1 || new e1.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            static startValueInfo(e1) {\n                                e1.startObject(3);\n                            }\n                            static addName(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addDocString(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static addType(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static endValueInfo(e1) {\n                                return e1.endObject();\n                            }\n                            static createValueInfo(e1, t1, r1, o1) {\n                                return n1.startValueInfo(e1), n1.addName(e1, t1), n1.addDocString(e1, r1), n1.addType(e1, o1), n1.endValueInfo(e1);\n                            }\n                        }\n                        t1.ValueInfo = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsTypeInfo(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsTypeInfo(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            denotation(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            valueType() {\n                                let t1 = this.bb.__offset(this.bb_pos, 6);\n                                return t1 ? this.bb.readUint8(this.bb_pos + t1) : e1.experimental.fbs.TypeInfoValue.NONE;\n                            }\n                            value(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 8);\n                                return t1 ? this.bb.__union(e1, this.bb_pos + t1) : null;\n                            }\n                            static startTypeInfo(e1) {\n                                e1.startObject(3);\n                            }\n                            static addDenotation(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addValueType(t1, n1) {\n                                t1.addFieldInt8(1, n1, e1.experimental.fbs.TypeInfoValue.NONE);\n                            }\n                            static addValue(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static endTypeInfo(e1) {\n                                return e1.endObject();\n                            }\n                            static createTypeInfo(e1, t1, r1, o1) {\n                                return n1.startTypeInfo(e1), n1.addDenotation(e1, t1), n1.addValueType(e1, r1), n1.addValue(e1, o1), n1.endTypeInfo(e1);\n                            }\n                        }\n                        t1.TypeInfo = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(e1) {\n                    !function(e1) {\n                        class t1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsOperatorSetId(e1, n1) {\n                                return (n1 || new t1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsOperatorSetId(e1, n1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (n1 || new t1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            domain(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            version() {\n                                let e1 = this.bb.__offset(this.bb_pos, 6);\n                                return e1 ? this.bb.readInt64(this.bb_pos + e1) : this.bb.createLong(0, 0);\n                            }\n                            static startOperatorSetId(e1) {\n                                e1.startObject(2);\n                            }\n                            static addDomain(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addVersion(e1, t1) {\n                                e1.addFieldInt64(1, t1, e1.createLong(0, 0));\n                            }\n                            static endOperatorSetId(e1) {\n                                return e1.endObject();\n                            }\n                            static createOperatorSetId(e1, n1, r1) {\n                                return t1.startOperatorSetId(e1), t1.addDomain(e1, n1), t1.addVersion(e1, r1), t1.endOperatorSetId(e1);\n                            }\n                        }\n                        e1.OperatorSetId = t1;\n                    }(e1.fbs || (e1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsTensor(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsTensor(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            name(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            docString(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 6);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            dims(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 8);\n                                return t1 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t1) + 8 * e1) : this.bb.createLong(0, 0);\n                            }\n                            dimsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 8);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            dataType() {\n                                let t1 = this.bb.__offset(this.bb_pos, 10);\n                                return t1 ? this.bb.readInt32(this.bb_pos + t1) : e1.experimental.fbs.TensorDataType.UNDEFINED;\n                            }\n                            rawData(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 12);\n                                return t1 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t1) + e1) : 0;\n                            }\n                            rawDataLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 12);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            rawDataArray() {\n                                let e1 = this.bb.__offset(this.bb_pos, 12);\n                                return e1 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e1), this.bb.__vector_len(this.bb_pos + e1)) : null;\n                            }\n                            stringData(e1, t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 14);\n                                return n1 ? this.bb.__string(this.bb.__vector(this.bb_pos + n1) + 4 * e1, t1) : null;\n                            }\n                            stringDataLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 14);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            static startTensor(e1) {\n                                e1.startObject(6);\n                            }\n                            static addName(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addDocString(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static addDims(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static createDimsVector(e1, t1) {\n                                e1.startVector(8, t1.length, 8);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addInt64(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startDimsVector(e1, t1) {\n                                e1.startVector(8, t1, 8);\n                            }\n                            static addDataType(t1, n1) {\n                                t1.addFieldInt32(3, n1, e1.experimental.fbs.TensorDataType.UNDEFINED);\n                            }\n                            static addRawData(e1, t1) {\n                                e1.addFieldOffset(4, t1, 0);\n                            }\n                            static createRawDataVector(e1, t1) {\n                                e1.startVector(1, t1.length, 1);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addInt8(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startRawDataVector(e1, t1) {\n                                e1.startVector(1, t1, 1);\n                            }\n                            static addStringData(e1, t1) {\n                                e1.addFieldOffset(5, t1, 0);\n                            }\n                            static createStringDataVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startStringDataVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static endTensor(e1) {\n                                return e1.endObject();\n                            }\n                            static createTensor(e1, t1, r1, o1, i1, s1, a1) {\n                                return n1.startTensor(e1), n1.addName(e1, t1), n1.addDocString(e1, r1), n1.addDims(e1, o1), n1.addDataType(e1, i1), n1.addRawData(e1, s1), n1.addStringData(e1, a1), n1.endTensor(e1);\n                            }\n                        }\n                        t1.Tensor = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsSparseTensor(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsSparseTensor(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            values(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 4);\n                                return n1 ? (t1 || new e1.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            indices(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 6);\n                                return n1 ? (t1 || new e1.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            dims(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 8);\n                                return t1 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t1) + 8 * e1) : this.bb.createLong(0, 0);\n                            }\n                            dimsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 8);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            static startSparseTensor(e1) {\n                                e1.startObject(3);\n                            }\n                            static addValues(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addIndices(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static addDims(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static createDimsVector(e1, t1) {\n                                e1.startVector(8, t1.length, 8);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addInt64(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startDimsVector(e1, t1) {\n                                e1.startVector(8, t1, 8);\n                            }\n                            static endSparseTensor(e1) {\n                                return e1.endObject();\n                            }\n                            static createSparseTensor(e1, t1, r1, o1) {\n                                return n1.startSparseTensor(e1), n1.addValues(e1, t1), n1.addIndices(e1, r1), n1.addDims(e1, o1), n1.endSparseTensor(e1);\n                            }\n                        }\n                        t1.SparseTensor = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsAttribute(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsAttribute(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            name(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            docString(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 6);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            type() {\n                                let t1 = this.bb.__offset(this.bb_pos, 8);\n                                return t1 ? this.bb.readInt32(this.bb_pos + t1) : e1.experimental.fbs.AttributeType.UNDEFINED;\n                            }\n                            f() {\n                                let e1 = this.bb.__offset(this.bb_pos, 10);\n                                return e1 ? this.bb.readFloat32(this.bb_pos + e1) : 0;\n                            }\n                            i() {\n                                let e1 = this.bb.__offset(this.bb_pos, 12);\n                                return e1 ? this.bb.readInt64(this.bb_pos + e1) : this.bb.createLong(0, 0);\n                            }\n                            s(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 14);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            t(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 16);\n                                return n1 ? (t1 || new e1.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            g(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 18);\n                                return n1 ? (t1 || new e1.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            floats(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 20);\n                                return t1 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + t1) + 4 * e1) : 0;\n                            }\n                            floatsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 20);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            floatsArray() {\n                                let e1 = this.bb.__offset(this.bb_pos, 20);\n                                return e1 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e1), this.bb.__vector_len(this.bb_pos + e1)) : null;\n                            }\n                            ints(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 22);\n                                return t1 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + t1) + 8 * e1) : this.bb.createLong(0, 0);\n                            }\n                            intsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 22);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            strings(e1, t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 24);\n                                return n1 ? this.bb.__string(this.bb.__vector(this.bb_pos + n1) + 4 * e1, t1) : null;\n                            }\n                            stringsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 24);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            tensors(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 26);\n                                return r1 ? (n1 || new e1.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            tensorsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 26);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            graphs(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 28);\n                                return r1 ? (n1 || new e1.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            graphsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 28);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            static startAttribute(e1) {\n                                e1.startObject(13);\n                            }\n                            static addName(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addDocString(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static addType(t1, n1) {\n                                t1.addFieldInt32(2, n1, e1.experimental.fbs.AttributeType.UNDEFINED);\n                            }\n                            static addF(e1, t1) {\n                                e1.addFieldFloat32(3, t1, 0);\n                            }\n                            static addI(e1, t1) {\n                                e1.addFieldInt64(4, t1, e1.createLong(0, 0));\n                            }\n                            static addS(e1, t1) {\n                                e1.addFieldOffset(5, t1, 0);\n                            }\n                            static addT(e1, t1) {\n                                e1.addFieldOffset(6, t1, 0);\n                            }\n                            static addG(e1, t1) {\n                                e1.addFieldOffset(7, t1, 0);\n                            }\n                            static addFloats(e1, t1) {\n                                e1.addFieldOffset(8, t1, 0);\n                            }\n                            static createFloatsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addFloat32(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startFloatsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addInts(e1, t1) {\n                                e1.addFieldOffset(9, t1, 0);\n                            }\n                            static createIntsVector(e1, t1) {\n                                e1.startVector(8, t1.length, 8);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addInt64(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startIntsVector(e1, t1) {\n                                e1.startVector(8, t1, 8);\n                            }\n                            static addStrings(e1, t1) {\n                                e1.addFieldOffset(10, t1, 0);\n                            }\n                            static createStringsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startStringsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addTensors(e1, t1) {\n                                e1.addFieldOffset(11, t1, 0);\n                            }\n                            static createTensorsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startTensorsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addGraphs(e1, t1) {\n                                e1.addFieldOffset(12, t1, 0);\n                            }\n                            static createGraphsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startGraphsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static endAttribute(e1) {\n                                return e1.endObject();\n                            }\n                            static createAttribute(e1, t1, r1, o1, i1, s1, a1, u1, l1, c1, p1, d1, f1, h1) {\n                                return n1.startAttribute(e1), n1.addName(e1, t1), n1.addDocString(e1, r1), n1.addType(e1, o1), n1.addF(e1, i1), n1.addI(e1, s1), n1.addS(e1, a1), n1.addT(e1, u1), n1.addG(e1, l1), n1.addFloats(e1, c1), n1.addInts(e1, p1), n1.addStrings(e1, d1), n1.addTensors(e1, f1), n1.addGraphs(e1, h1), n1.endAttribute(e1);\n                            }\n                        }\n                        t1.Attribute = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsGraph(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsGraph(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            initializers(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 4);\n                                return r1 ? (n1 || new e1.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            initializersLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 4);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            nodeArgs(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 6);\n                                return r1 ? (n1 || new e1.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            nodeArgsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 6);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            nodes(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 8);\n                                return r1 ? (n1 || new e1.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            nodesLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 8);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            maxNodeIndex() {\n                                let e1 = this.bb.__offset(this.bb_pos, 10);\n                                return e1 ? this.bb.readUint32(this.bb_pos + e1) : 0;\n                            }\n                            nodeEdges(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 12);\n                                return r1 ? (n1 || new e1.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            nodeEdgesLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 12);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            inputs(e1, t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 14);\n                                return n1 ? this.bb.__string(this.bb.__vector(this.bb_pos + n1) + 4 * e1, t1) : null;\n                            }\n                            inputsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 14);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            outputs(e1, t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 16);\n                                return n1 ? this.bb.__string(this.bb.__vector(this.bb_pos + n1) + 4 * e1, t1) : null;\n                            }\n                            outputsLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 16);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            sparseInitializers(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 18);\n                                return r1 ? (n1 || new e1.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            sparseInitializersLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 18);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            static startGraph(e1) {\n                                e1.startObject(8);\n                            }\n                            static addInitializers(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static createInitializersVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startInitializersVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addNodeArgs(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static createNodeArgsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startNodeArgsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addNodes(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static createNodesVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startNodesVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addMaxNodeIndex(e1, t1) {\n                                e1.addFieldInt32(3, t1, 0);\n                            }\n                            static addNodeEdges(e1, t1) {\n                                e1.addFieldOffset(4, t1, 0);\n                            }\n                            static createNodeEdgesVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startNodeEdgesVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addInputs(e1, t1) {\n                                e1.addFieldOffset(5, t1, 0);\n                            }\n                            static createInputsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startInputsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addOutputs(e1, t1) {\n                                e1.addFieldOffset(6, t1, 0);\n                            }\n                            static createOutputsVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startOutputsVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addSparseInitializers(e1, t1) {\n                                e1.addFieldOffset(7, t1, 0);\n                            }\n                            static createSparseInitializersVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startSparseInitializersVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static endGraph(e1) {\n                                return e1.endObject();\n                            }\n                            static createGraph(e1, t1, r1, o1, i1, s1, a1, u1, l1) {\n                                return n1.startGraph(e1), n1.addInitializers(e1, t1), n1.addNodeArgs(e1, r1), n1.addNodes(e1, o1), n1.addMaxNodeIndex(e1, i1), n1.addNodeEdges(e1, s1), n1.addInputs(e1, a1), n1.addOutputs(e1, u1), n1.addSparseInitializers(e1, l1), n1.endGraph(e1);\n                            }\n                        }\n                        t1.Graph = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsModel(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsModel(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            irVersion() {\n                                let e1 = this.bb.__offset(this.bb_pos, 4);\n                                return e1 ? this.bb.readInt64(this.bb_pos + e1) : this.bb.createLong(0, 0);\n                            }\n                            opsetImport(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 6);\n                                return r1 ? (n1 || new e1.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            opsetImportLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 6);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            producerName(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 8);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            producerVersion(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 10);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            domain(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 12);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            modelVersion() {\n                                let e1 = this.bb.__offset(this.bb_pos, 14);\n                                return e1 ? this.bb.readInt64(this.bb_pos + e1) : this.bb.createLong(0, 0);\n                            }\n                            docString(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 16);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            graph(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 18);\n                                return n1 ? (t1 || new e1.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            graphDocString(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 20);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            static startModel(e1) {\n                                e1.startObject(9);\n                            }\n                            static addIrVersion(e1, t1) {\n                                e1.addFieldInt64(0, t1, e1.createLong(0, 0));\n                            }\n                            static addOpsetImport(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static createOpsetImportVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startOpsetImportVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addProducerName(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static addProducerVersion(e1, t1) {\n                                e1.addFieldOffset(3, t1, 0);\n                            }\n                            static addDomain(e1, t1) {\n                                e1.addFieldOffset(4, t1, 0);\n                            }\n                            static addModelVersion(e1, t1) {\n                                e1.addFieldInt64(5, t1, e1.createLong(0, 0));\n                            }\n                            static addDocString(e1, t1) {\n                                e1.addFieldOffset(6, t1, 0);\n                            }\n                            static addGraph(e1, t1) {\n                                e1.addFieldOffset(7, t1, 0);\n                            }\n                            static addGraphDocString(e1, t1) {\n                                e1.addFieldOffset(8, t1, 0);\n                            }\n                            static endModel(e1) {\n                                return e1.endObject();\n                            }\n                            static createModel(e1, t1, r1, o1, i1, s1, a1, u1, l1, c1) {\n                                return n1.startModel(e1), n1.addIrVersion(e1, t1), n1.addOpsetImport(e1, r1), n1.addProducerName(e1, o1), n1.addProducerVersion(e1, i1), n1.addDomain(e1, s1), n1.addModelVersion(e1, a1), n1.addDocString(e1, u1), n1.addGraph(e1, l1), n1.addGraphDocString(e1, c1), n1.endModel(e1);\n                            }\n                        }\n                        t1.Model = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(e1) {\n                    !function(e1) {\n                        class t1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsKernelCreateInfos(e1, n1) {\n                                return (n1 || new t1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsKernelCreateInfos(e1, n1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (n1 || new t1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            nodeIndices(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t1) + 4 * e1) : 0;\n                            }\n                            nodeIndicesLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 4);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            nodeIndicesArray() {\n                                let e1 = this.bb.__offset(this.bb_pos, 4);\n                                return e1 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e1), this.bb.__vector_len(this.bb_pos + e1)) : null;\n                            }\n                            kernelDefHashes(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 6);\n                                return t1 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t1) + 8 * e1) : this.bb.createLong(0, 0);\n                            }\n                            kernelDefHashesLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 6);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            static startKernelCreateInfos(e1) {\n                                e1.startObject(2);\n                            }\n                            static addNodeIndices(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static createNodeIndicesVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addInt32(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startNodeIndicesVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static addKernelDefHashes(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static createKernelDefHashesVector(e1, t1) {\n                                e1.startVector(8, t1.length, 8);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addInt64(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startKernelDefHashesVector(e1, t1) {\n                                e1.startVector(8, t1, 8);\n                            }\n                            static endKernelCreateInfos(e1) {\n                                return e1.endObject();\n                            }\n                            static createKernelCreateInfos(e1, n1, r1) {\n                                return t1.startKernelCreateInfos(e1), t1.addNodeIndices(e1, n1), t1.addKernelDefHashes(e1, r1), t1.endKernelCreateInfos(e1);\n                            }\n                        }\n                        e1.KernelCreateInfos = t1;\n                    }(e1.fbs || (e1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsSubGraphSessionState(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsSubGraphSessionState(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            graphId(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            sessionState(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 6);\n                                return n1 ? (t1 || new e1.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            static startSubGraphSessionState(e1) {\n                                e1.startObject(2);\n                            }\n                            static addGraphId(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addSessionState(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static endSubGraphSessionState(e1) {\n                                let t1 = e1.endObject();\n                                return e1.requiredField(t1, 4), t1;\n                            }\n                            static createSubGraphSessionState(e1, t1, r1) {\n                                return n1.startSubGraphSessionState(e1), n1.addGraphId(e1, t1), n1.addSessionState(e1, r1), n1.endSubGraphSessionState(e1);\n                            }\n                        }\n                        t1.SubGraphSessionState = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsSessionState(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsSessionState(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            kernels(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 4);\n                                return n1 ? (t1 || new e1.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            subGraphSessionStates(t1, n1) {\n                                let r1 = this.bb.__offset(this.bb_pos, 6);\n                                return r1 ? (n1 || new e1.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r1) + 4 * t1), this.bb) : null;\n                            }\n                            subGraphSessionStatesLength() {\n                                let e1 = this.bb.__offset(this.bb_pos, 6);\n                                return e1 ? this.bb.__vector_len(this.bb_pos + e1) : 0;\n                            }\n                            static startSessionState(e1) {\n                                e1.startObject(2);\n                            }\n                            static addKernels(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addSubGraphSessionStates(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static createSubGraphSessionStatesVector(e1, t1) {\n                                e1.startVector(4, t1.length, 4);\n                                for(let n1 = t1.length - 1; n1 >= 0; n1--)e1.addOffset(t1[n1]);\n                                return e1.endVector();\n                            }\n                            static startSubGraphSessionStatesVector(e1, t1) {\n                                e1.startVector(4, t1, 4);\n                            }\n                            static endSessionState(e1) {\n                                return e1.endObject();\n                            }\n                            static createSessionState(e1, t1, r1) {\n                                return n1.startSessionState(e1), n1.addKernels(e1, t1), n1.addSubGraphSessionStates(e1, r1), n1.endSessionState(e1);\n                            }\n                        }\n                        t1.SessionState = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {})), function(e1) {\n                !function(t1) {\n                    !function(t1) {\n                        class n1 {\n                            constructor(){\n                                this.bb = null, this.bb_pos = 0;\n                            }\n                            __init(e1, t1) {\n                                return this.bb_pos = e1, this.bb = t1, this;\n                            }\n                            static getRootAsInferenceSession(e1, t1) {\n                                return (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static getSizePrefixedRootAsInferenceSession(e1, t1) {\n                                return e1.setPosition(e1.position() + r1.flatbuffers.SIZE_PREFIX_LENGTH), (t1 || new n1).__init(e1.readInt32(e1.position()) + e1.position(), e1);\n                            }\n                            static bufferHasIdentifier(e1) {\n                                return e1.__has_identifier(\"ORTM\");\n                            }\n                            ortVersion(e1) {\n                                let t1 = this.bb.__offset(this.bb_pos, 4);\n                                return t1 ? this.bb.__string(this.bb_pos + t1, e1) : null;\n                            }\n                            model(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 6);\n                                return n1 ? (t1 || new e1.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            sessionState(t1) {\n                                let n1 = this.bb.__offset(this.bb_pos, 8);\n                                return n1 ? (t1 || new e1.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos + n1), this.bb) : null;\n                            }\n                            static startInferenceSession(e1) {\n                                e1.startObject(3);\n                            }\n                            static addOrtVersion(e1, t1) {\n                                e1.addFieldOffset(0, t1, 0);\n                            }\n                            static addModel(e1, t1) {\n                                e1.addFieldOffset(1, t1, 0);\n                            }\n                            static addSessionState(e1, t1) {\n                                e1.addFieldOffset(2, t1, 0);\n                            }\n                            static endInferenceSession(e1) {\n                                return e1.endObject();\n                            }\n                            static finishInferenceSessionBuffer(e1, t1) {\n                                e1.finish(t1, \"ORTM\");\n                            }\n                            static finishSizePrefixedInferenceSessionBuffer(e1, t1) {\n                                e1.finish(t1, \"ORTM\", !0);\n                            }\n                            static createInferenceSession(e1, t1, r1, o1) {\n                                return n1.startInferenceSession(e1), n1.addOrtVersion(e1, t1), n1.addModel(e1, r1), n1.addSessionState(e1, o1), n1.endInferenceSession(e1);\n                            }\n                        }\n                        t1.InferenceSession = n1;\n                    }(t1.fbs || (t1.fbs = {}));\n                }(e1.experimental || (e1.experimental = {}));\n            }(t1.onnxruntime || (t1.onnxruntime = {}));\n        },\n        1723: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.OnnxjsSessionHandler = void 0;\n            const r1 = n1(6207), o1 = n1(9240);\n            t1.OnnxjsSessionHandler = class {\n                constructor(e1){\n                    this.session = e1, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;\n                }\n                async dispose() {}\n                async run(e1, t1, n1) {\n                    const i1 = new Map;\n                    for(const t1 in e1)if (Object.hasOwnProperty.call(e1, t1)) {\n                        const n1 = e1[t1];\n                        i1.set(t1, new o1.Tensor(n1.dims, n1.type, void 0, void 0, n1.data));\n                    }\n                    const s1 = await this.session.run(i1), a1 = {};\n                    return s1.forEach((e1, t1)=>{\n                        a1[t1] = new r1.Tensor(e1.type, e1.data, e1.dims);\n                    }), a1;\n                }\n                startProfiling() {\n                    this.session.startProfiling();\n                }\n                endProfiling() {\n                    this.session.endProfiling();\n                }\n            };\n        },\n        6027: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.Session = void 0;\n            const r1 = n1(6231), o1 = n1(6464), i1 = n1(1975), s1 = n1(6496), a1 = n1(1315), u1 = n1(1745);\n            t1.Session = class {\n                constructor(e1 = {}){\n                    this._initialized = !1, this.backendHint = e1.backendHint, this.profiler = a1.Profiler.create(e1.profiler), this.context = {\n                        profiler: this.profiler,\n                        graphInputTypes: [],\n                        graphInputDims: []\n                    };\n                }\n                get inputNames() {\n                    return this._model.graph.getInputNames();\n                }\n                get outputNames() {\n                    return this._model.graph.getOutputNames();\n                }\n                startProfiling() {\n                    this.profiler.start();\n                }\n                endProfiling() {\n                    this.profiler.stop();\n                }\n                async loadModel(e1, t1, n1) {\n                    await this.profiler.event(\"session\", \"Session.loadModel\", async ()=>{\n                        const s1 = await (0, i1.resolveBackend)(this.backendHint);\n                        if (this.sessionHandler = s1.createSessionHandler(this.context), this._model = new u1.Model, \"string\" == typeof e1) {\n                            const t1 = e1.endsWith(\".ort\");\n                            if (\"undefined\" != typeof process && process.versions && process.versions.node) {\n                                const n1 = await (0, o1.promisify)(r1.readFile)(e1);\n                                this.initialize(n1, t1);\n                            } else {\n                                const n1 = await fetch(e1), r1 = await n1.arrayBuffer();\n                                this.initialize(new Uint8Array(r1), t1);\n                            }\n                        } else if (ArrayBuffer.isView(e1)) this.initialize(e1);\n                        else {\n                            const r1 = new Uint8Array(e1, t1 || 0, n1 || e1.byteLength);\n                            this.initialize(r1);\n                        }\n                    });\n                }\n                initialize(e1, t1) {\n                    if (this._initialized) throw new Error(\"already initialized\");\n                    this.profiler.event(\"session\", \"Session.initialize\", ()=>{\n                        const n1 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;\n                        this._model.load(e1, n1, t1), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new s1.ExecutionPlan(this._model.graph, this._ops, this.profiler);\n                    }), this._initialized = !0;\n                }\n                async run(e1) {\n                    if (!this._initialized) throw new Error(\"session not initialized yet\");\n                    return this.profiler.event(\"session\", \"Session.run\", async ()=>{\n                        const t1 = this.normalizeAndValidateInputs(e1), n1 = await this._executionPlan.execute(this.sessionHandler, t1);\n                        return this.createOutput(n1);\n                    });\n                }\n                normalizeAndValidateInputs(e1) {\n                    const t1 = this._model.graph.getInputNames();\n                    if (Array.isArray(e1)) {\n                        if (e1.length !== t1.length) throw new Error(`incorrect input array length: expected ${t1.length} but got ${e1.length}`);\n                    } else {\n                        if (e1.size !== t1.length) throw new Error(`incorrect input map size: expected ${t1.length} but got ${e1.size}`);\n                        const n1 = new Array(e1.size);\n                        let r1 = 0;\n                        for(let o1 = 0; o1 < t1.length; ++o1){\n                            const i1 = e1.get(t1[o1]);\n                            if (!i1) throw new Error(`missing input tensor for: '${name}'`);\n                            n1[r1++] = i1;\n                        }\n                        e1 = n1;\n                    }\n                    if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length) this.validateInputTensorDims(this.context.graphInputDims, e1, !1);\n                    else {\n                        const t1 = this._model.graph.getInputIndices(), n1 = this._model.graph.getValues(), r1 = new Array(t1.length);\n                        for(let o1 = 0; o1 < t1.length; ++o1){\n                            const i1 = n1[t1[o1]];\n                            r1[o1] = i1.type.shape.dims, this.context.graphInputTypes.push(i1.type.tensorType), this.context.graphInputDims.push(e1[o1].dims);\n                        }\n                        this.validateInputTensorDims(r1, e1, !0);\n                    }\n                    return this.validateInputTensorTypes(this.context.graphInputTypes, e1), e1;\n                }\n                validateInputTensorTypes(e1, t1) {\n                    for(let n1 = 0; n1 < t1.length; n1++){\n                        const r1 = e1[n1], o1 = t1[n1].type;\n                        if (r1 !== o1) throw new Error(`input tensor[${n1}] check failed: expected type '${r1}' but got ${o1}`);\n                    }\n                }\n                validateInputTensorDims(e1, t1, n1) {\n                    for(let r1 = 0; r1 < t1.length; r1++){\n                        const o1 = e1[r1], i1 = t1[r1].dims;\n                        if (!this.compareTensorDims(o1, i1, n1)) throw new Error(`input tensor[${r1}] check failed: expected shape '[${o1.join(\",\")}]' but got [${i1.join(\",\")}]`);\n                    }\n                }\n                compareTensorDims(e1, t1, n1) {\n                    if (e1.length !== t1.length) return !1;\n                    for(let r1 = 0; r1 < e1.length; ++r1)if (e1[r1] !== t1[r1] && (!n1 || 0 !== e1[r1])) return !1;\n                    return !0;\n                }\n                createOutput(e1) {\n                    const t1 = this._model.graph.getOutputNames();\n                    if (e1.length !== t1.length) throw new Error(\"expected number of outputs do not match number of generated outputs\");\n                    const n1 = new Map;\n                    for(let r1 = 0; r1 < t1.length; ++r1)n1.set(t1[r1], e1[r1]);\n                    return n1;\n                }\n                initializeOps(e1) {\n                    const t1 = e1.getNodes();\n                    this._ops = new Array(t1.length);\n                    for(let n1 = 0; n1 < t1.length; n1++)this._ops[n1] = this.sessionHandler.resolve(t1[n1], this._model.opsets, e1);\n                }\n            };\n        },\n        9240: function(e1, t1, n1) {\n            \"use strict\";\n            var r1 = this && this.__importDefault || function(e1) {\n                return e1 && e1.__esModule ? e1 : {\n                    default: e1\n                };\n            };\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.Tensor = void 0;\n            const o1 = n1(3442), i1 = r1(n1(1583)), s1 = n1(5127), a1 = n1(2446), u1 = n1(7273);\n            var l1 = s1.onnxruntime.experimental.fbs;\n            class c1 {\n                get data() {\n                    if (void 0 === this.cache) {\n                        const e1 = this.dataProvider(this.dataId);\n                        if (e1.length !== this.size) throw new Error(\"Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.\");\n                        this.cache = e1;\n                    }\n                    return this.cache;\n                }\n                get stringData() {\n                    if (\"string\" !== this.type) throw new TypeError(\"data type is not string\");\n                    return this.data;\n                }\n                get integerData() {\n                    switch(this.type){\n                        case \"uint8\":\n                        case \"int8\":\n                        case \"uint16\":\n                        case \"int16\":\n                        case \"int32\":\n                        case \"uint32\":\n                        case \"bool\":\n                            return this.data;\n                        default:\n                            throw new TypeError(\"data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)\");\n                    }\n                }\n                get floatData() {\n                    switch(this.type){\n                        case \"float32\":\n                        case \"float64\":\n                            return this.data;\n                        default:\n                            throw new TypeError(\"data type is not float (float32, float64)\");\n                    }\n                }\n                get numberData() {\n                    if (\"string\" !== this.type) return this.data;\n                    throw new TypeError(\"type cannot be non-number (string)\");\n                }\n                get(e1) {\n                    return this.data[u1.ShapeUtil.indicesToOffset(e1, this.strides)];\n                }\n                set(e1, t1) {\n                    this.data[u1.ShapeUtil.indicesToOffset(e1, this.strides)] = t1;\n                }\n                async getData() {\n                    return void 0 === this.cache && (this.cache = await this.asyncDataProvider(this.dataId)), this.cache;\n                }\n                get strides() {\n                    return this._strides || (this._strides = u1.ShapeUtil.computeStrides(this.dims)), this._strides;\n                }\n                constructor(e1, t1, n1, r1, i1, s1 = o1.Guid.create()){\n                    this.dims = e1, this.type = t1, this.dataProvider = n1, this.asyncDataProvider = r1, this.cache = i1, this.dataId = s1, this.size = u1.ShapeUtil.validateDimsAndCalcSize(e1);\n                    const a1 = this.size, l1 = void 0 === n1 && void 0 === r1 && void 0 === i1;\n                    if (void 0 !== i1 && i1.length !== a1) throw new RangeError(\"Input dims doesn't match data length.\");\n                    if (\"string\" === t1) {\n                        if (!(void 0 === i1 || Array.isArray(i1) && i1.every((e1)=>\"string\" == typeof e1))) throw new TypeError(\"cache should be a string array\");\n                        l1 && (this.cache = new Array(a1));\n                    } else {\n                        if (void 0 !== i1) {\n                            const e1 = d1(t1);\n                            if (!(i1 instanceof e1)) throw new TypeError(`cache should be type ${e1.name}`);\n                        }\n                        if (l1) {\n                            const e1 = new ArrayBuffer(a1 * function(e1) {\n                                switch(e1){\n                                    case \"bool\":\n                                    case \"int8\":\n                                    case \"uint8\":\n                                        return 1;\n                                    case \"int16\":\n                                    case \"uint16\":\n                                        return 2;\n                                    case \"int32\":\n                                    case \"uint32\":\n                                    case \"float32\":\n                                        return 4;\n                                    case \"float64\":\n                                        return 8;\n                                    default:\n                                        throw new Error(`cannot calculate sizeof() on type ${e1}`);\n                                }\n                            }(t1));\n                            this.cache = function(e1, t1) {\n                                return new (d1(t1))(e1);\n                            }(e1, t1);\n                        }\n                    }\n                }\n                static fromProto(e1) {\n                    if (!e1) throw new Error(\"cannot construct Value from an empty tensor\");\n                    const t1 = u1.ProtoUtil.tensorDataTypeFromProto(e1.dataType), n1 = u1.ProtoUtil.tensorDimsFromProto(e1.dims), r1 = new c1(n1, t1);\n                    if (\"string\" === t1) e1.stringData.forEach((e1, t1)=>{\n                        r1.data[t1] = (0, u1.decodeUtf8String)(e1);\n                    });\n                    else if (e1.rawData && \"number\" == typeof e1.rawData.byteLength && e1.rawData.byteLength > 0) {\n                        const t1 = r1.data, n1 = new DataView(e1.rawData.buffer, e1.rawData.byteOffset, e1.rawData.byteLength), o1 = p1(e1.dataType), i1 = e1.rawData.byteLength / o1;\n                        if (e1.rawData.byteLength % o1 != 0) throw new Error(\"invalid buffer length\");\n                        if (t1.length !== i1) throw new Error(\"buffer length mismatch\");\n                        for(let r1 = 0; r1 < i1; r1++){\n                            const i1 = h1(n1, e1.dataType, r1 * o1);\n                            t1[r1] = i1;\n                        }\n                    } else {\n                        let t1;\n                        switch(e1.dataType){\n                            case a1.onnx.TensorProto.DataType.FLOAT:\n                                t1 = e1.floatData;\n                                break;\n                            case a1.onnx.TensorProto.DataType.INT32:\n                            case a1.onnx.TensorProto.DataType.INT16:\n                            case a1.onnx.TensorProto.DataType.UINT16:\n                            case a1.onnx.TensorProto.DataType.INT8:\n                            case a1.onnx.TensorProto.DataType.UINT8:\n                            case a1.onnx.TensorProto.DataType.BOOL:\n                                t1 = e1.int32Data;\n                                break;\n                            case a1.onnx.TensorProto.DataType.INT64:\n                                t1 = e1.int64Data;\n                                break;\n                            case a1.onnx.TensorProto.DataType.DOUBLE:\n                                t1 = e1.doubleData;\n                                break;\n                            case a1.onnx.TensorProto.DataType.UINT32:\n                            case a1.onnx.TensorProto.DataType.UINT64:\n                                t1 = e1.uint64Data;\n                                break;\n                            default:\n                                throw new Error(\"unspecific error\");\n                        }\n                        if (null == t1) throw new Error(\"failed to populate data from a tensorproto value\");\n                        const n1 = r1.data;\n                        if (n1.length !== t1.length) throw new Error(\"array length mismatch\");\n                        for(let r1 = 0; r1 < t1.length; r1++){\n                            const o1 = t1[r1];\n                            i1.default.isLong(o1) ? n1[r1] = f1(o1, e1.dataType) : n1[r1] = o1;\n                        }\n                    }\n                    return r1;\n                }\n                static fromData(e1, t1, n1) {\n                    return new c1(t1, n1, void 0, void 0, e1);\n                }\n                static fromOrtTensor(e1) {\n                    if (!e1) throw new Error(\"cannot construct Value from an empty tensor\");\n                    const t1 = u1.ProtoUtil.tensorDimsFromORTFormat(e1), n1 = u1.ProtoUtil.tensorDataTypeFromProto(e1.dataType()), r1 = new c1(t1, n1);\n                    if (\"string\" === n1) for(let t1 = 0; t1 < e1.stringDataLength(); t1++)r1.data[t1] = e1.stringData(t1);\n                    else if (e1.rawDataArray() && \"number\" == typeof e1.rawDataLength() && e1.rawDataLength() > 0) {\n                        const t1 = r1.data, n1 = new DataView(e1.rawDataArray().buffer, e1.rawDataArray().byteOffset, e1.rawDataLength()), o1 = p1(e1.dataType()), i1 = e1.rawDataLength() / o1;\n                        if (e1.rawDataLength() % o1 != 0) throw new Error(\"invalid buffer length\");\n                        if (t1.length !== i1) throw new Error(\"buffer length mismatch\");\n                        for(let r1 = 0; r1 < i1; r1++){\n                            const i1 = h1(n1, e1.dataType(), r1 * o1);\n                            t1[r1] = i1;\n                        }\n                    }\n                    return r1;\n                }\n            }\n            function p1(e1) {\n                switch(e1){\n                    case a1.onnx.TensorProto.DataType.UINT8:\n                    case a1.onnx.TensorProto.DataType.INT8:\n                    case a1.onnx.TensorProto.DataType.BOOL:\n                        return 1;\n                    case a1.onnx.TensorProto.DataType.UINT16:\n                    case a1.onnx.TensorProto.DataType.INT16:\n                        return 2;\n                    case a1.onnx.TensorProto.DataType.FLOAT:\n                    case a1.onnx.TensorProto.DataType.INT32:\n                    case a1.onnx.TensorProto.DataType.UINT32:\n                        return 4;\n                    case a1.onnx.TensorProto.DataType.INT64:\n                    case a1.onnx.TensorProto.DataType.DOUBLE:\n                    case a1.onnx.TensorProto.DataType.UINT64:\n                        return 8;\n                    default:\n                        throw new Error(`cannot calculate sizeof() on type ${a1.onnx.TensorProto.DataType[e1]}`);\n                }\n            }\n            function d1(e1) {\n                switch(e1){\n                    case \"bool\":\n                    case \"uint8\":\n                        return Uint8Array;\n                    case \"int8\":\n                        return Int8Array;\n                    case \"int16\":\n                        return Int16Array;\n                    case \"uint16\":\n                        return Uint16Array;\n                    case \"int32\":\n                        return Int32Array;\n                    case \"uint32\":\n                        return Uint32Array;\n                    case \"int64\":\n                        return BigInt64Array;\n                    case \"float32\":\n                        return Float32Array;\n                    case \"float64\":\n                        return Float64Array;\n                    default:\n                        throw new Error(\"unspecified error\");\n                }\n            }\n            function f1(e1, t1) {\n                if (t1 === a1.onnx.TensorProto.DataType.INT64 || t1 === l1.TensorDataType.INT64) {\n                    if (e1.greaterThanOrEqual(2147483648) || e1.lessThan(-2147483648)) throw new TypeError(\"int64 is not supported\");\n                } else {\n                    if (t1 !== a1.onnx.TensorProto.DataType.UINT32 && t1 !== l1.TensorDataType.UINT32 && t1 !== a1.onnx.TensorProto.DataType.UINT64 && t1 !== l1.TensorDataType.UINT64) throw new TypeError(`not a LONG type: ${a1.onnx.TensorProto.DataType[t1]}`);\n                    if (e1.greaterThanOrEqual(4294967296) || e1.lessThan(0)) throw new TypeError(\"uint64 is not supported\");\n                }\n                return e1.toNumber();\n            }\n            function h1(e1, t1, n1) {\n                switch(t1){\n                    case a1.onnx.TensorProto.DataType.BOOL:\n                    case a1.onnx.TensorProto.DataType.UINT8:\n                        return e1.getUint8(n1);\n                    case a1.onnx.TensorProto.DataType.INT8:\n                        return e1.getInt8(n1);\n                    case a1.onnx.TensorProto.DataType.UINT16:\n                        return e1.getUint16(n1, !0);\n                    case a1.onnx.TensorProto.DataType.INT16:\n                        return e1.getInt16(n1, !0);\n                    case a1.onnx.TensorProto.DataType.FLOAT:\n                        return e1.getFloat32(n1, !0);\n                    case a1.onnx.TensorProto.DataType.INT32:\n                        return e1.getInt32(n1, !0);\n                    case a1.onnx.TensorProto.DataType.UINT32:\n                        return e1.getUint32(n1, !0);\n                    case a1.onnx.TensorProto.DataType.INT64:\n                        return f1(i1.default.fromBits(e1.getUint32(n1, !0), e1.getUint32(n1 + 4, !0), !1), t1);\n                    case a1.onnx.TensorProto.DataType.DOUBLE:\n                        return e1.getFloat64(n1, !0);\n                    case a1.onnx.TensorProto.DataType.UINT64:\n                        return f1(i1.default.fromBits(e1.getUint32(n1, !0), e1.getUint32(n1 + 4, !0), !0), t1);\n                    default:\n                        throw new Error(`cannot read from DataView for type ${a1.onnx.TensorProto.DataType[t1]}`);\n                }\n            }\n            t1.Tensor = c1;\n        },\n        7273: function(e1, t1, n1) {\n            \"use strict\";\n            var r1 = this && this.__importDefault || function(e1) {\n                return e1 && e1.__esModule ? e1 : {\n                    default: e1\n                };\n            };\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.decodeUtf8String = t1.MAX_CLIP = t1.MIN_CLIP = t1.PoolConvUtil = t1.ReduceUtil = t1.SplitUtil = t1.MathUtil = t1.ShapeUtil = t1.LongUtil = t1.ProtoUtil = t1.GemmUtil = t1.arrayCopyHelper = t1.BroadcastUtil = t1.MatMulUtil = t1.ArrayUtil = t1.assert = t1.checkInputsShape = void 0;\n            const o1 = n1(5686), i1 = r1(n1(1583)), s1 = n1(2446), a1 = n1(9240);\n            t1.checkInputsShape = function(e1, ...t1) {\n                if (!e1 || e1.length !== t1.length) return !1;\n                for(let n1 = 0; n1 < e1.length; n1++)if (!e1[n1].dims || e1[n1].dims.length !== t1[n1]) return !1;\n                return !0;\n            }, t1.assert = function(e1, t1) {\n                if (!e1) throw new Error(\"string\" == typeof t1 ? t1 : t1());\n            }, t1.ArrayUtil = class {\n                static arraysEqual(e1, t1) {\n                    if (e1.length !== t1.length) return !1;\n                    for(let n1 = 0; n1 < e1.length; n1++)if (e1[n1] !== t1[n1]) return !1;\n                    return !0;\n                }\n            };\n            class u1 {\n                static preprocessInputShapes(e1, t1) {\n                    return [\n                        1 === e1.length ? [\n                            1,\n                            e1[0]\n                        ] : e1,\n                        1 === t1.length ? [\n                            t1[0],\n                            1\n                        ] : t1\n                    ];\n                }\n                static postprocessOutputShape(e1, t1, n1) {\n                    1 === t1 && e1.splice(e1.length - 2, 1), 1 === n1 && e1.pop();\n                }\n                static calcMatMulShape(e1, t1) {\n                    return e1[1] !== t1[0] ? void 0 : [\n                        e1[0],\n                        t1[1]\n                    ];\n                }\n            }\n            t1.MatMulUtil = u1;\n            class l1 {\n                static calcShape(e1, t1, n1 = !1) {\n                    const r1 = e1.length, o1 = t1.length;\n                    if (0 === r1) return t1;\n                    if (0 === o1) return e1;\n                    const i1 = Math.max(e1.length, t1.length), s1 = new Array(i1);\n                    if (n1) {\n                        if (r1 < 2 || o1 < 2) return;\n                        const n1 = u1.calcMatMulShape([\n                            e1[r1 - 2],\n                            e1[r1 - 1]\n                        ], [\n                            t1[o1 - 2],\n                            t1[o1 - 1]\n                        ]);\n                        if (void 0 === n1) return;\n                        [s1[i1 - 2], s1[i1 - 1]] = n1;\n                    }\n                    for(let a1 = n1 ? 3 : 1; a1 <= i1; a1++){\n                        const n1 = r1 - a1 < 0 ? 1 : e1[r1 - a1], u1 = o1 - a1 < 0 ? 1 : t1[o1 - a1];\n                        if (n1 !== u1 && n1 > 1 && u1 > 1) return;\n                        s1[i1 - a1] = Math.max(n1, u1);\n                    }\n                    return s1;\n                }\n                static index(e1, t1) {\n                    const n1 = new Array(t1.length);\n                    return l1.fillIndex(e1, t1, n1), n1;\n                }\n                static fillIndex(e1, t1, n1) {\n                    const r1 = e1.length - t1.length;\n                    for(let o1 = 0; o1 < t1.length; o1++)n1[o1] = e1[r1 + o1] % t1[o1];\n                }\n                static calc(e1, t1, n1, r1, o1) {\n                    const i1 = l1.calcShape(e1.dims, t1.dims);\n                    if (i1) {\n                        if (r1 && !d1.areEqual(i1, e1.dims)) return;\n                        const s1 = d1.size(i1), u1 = r1 ? e1 : new a1.Tensor(i1, o1 || e1.type);\n                        if (0 === i1.length) u1.set([], n1(e1.get([]), t1.get([])));\n                        else {\n                            const r1 = new Array(i1.length), o1 = new Array(e1.dims.length), a1 = new Array(t1.dims.length);\n                            let c1, p1 = 0, d1 = 0, f1 = !1, h1 = !1;\n                            0 === e1.dims.length && (p1 = e1.get([]), f1 = !0), 0 === t1.dims.length && (d1 = t1.get([]), h1 = !0);\n                            for(let g1 = 0; g1 < s1; g1++){\n                                c1 = g1;\n                                for(let e1 = i1.length - 1; e1 >= 0; e1--)r1[e1] = c1 % i1[e1], c1 = Math.floor(c1 / i1[e1]);\n                                f1 || (l1.fillIndex(r1, e1.dims, o1), p1 = e1.get(o1)), h1 || (l1.fillIndex(r1, t1.dims, a1), d1 = t1.get(a1)), u1.set(r1, n1(p1, d1));\n                            }\n                        }\n                        return u1;\n                    }\n                }\n                static isValidBroadcast(e1, t1) {\n                    const n1 = e1.length, r1 = t1.length;\n                    if (n1 > r1) return !1;\n                    for(let o1 = 1; o1 <= n1; o1++)if (1 !== e1[n1 - o1] && e1[n1 - o1] !== t1[r1 - o1]) return !1;\n                    return !0;\n                }\n                static getBroadcastDims(e1, t1) {\n                    const n1 = e1.length, r1 = [];\n                    for(let o1 = 0; o1 < n1; o1++){\n                        const i1 = n1 - 1 - o1, s1 = e1[i1] || 1;\n                        (t1[t1.length - 1 - o1] || 1) > 1 && 1 === s1 && r1.unshift(i1);\n                    }\n                    return r1;\n                }\n            }\n            t1.BroadcastUtil = l1, t1.arrayCopyHelper = function(e1, t1, n1, r1, o1) {\n                if (r1 < 0 || r1 >= t1.length) throw new Error(\"sourceIndex out of bounds\");\n                if (n1 < 0 || n1 >= e1.length) throw new Error(\"targetIndex out of bounds\");\n                if (r1 + o1 > t1.length) throw new Error(\"source indices to be copied are outside bounds\");\n                if (n1 + o1 > e1.length) throw new Error(\"target array is too small to hold result\");\n                for(let i1 = 0; i1 < o1; i1++)e1[n1 + i1] = t1[r1 + i1];\n            }, t1.GemmUtil = class {\n                static getShapeOfGemmResult(e1, t1, n1, r1, o1) {\n                    if (2 !== e1.length || 2 !== n1.length) throw new Error(\"shape need to be of size 2\");\n                    let i1, s1, a1;\n                    t1 ? (i1 = e1[1], s1 = e1[0]) : (i1 = e1[0], s1 = e1[1]);\n                    let u1 = -1;\n                    if (r1 ? (a1 = n1[0], u1 = 1) : (a1 = n1[1], u1 = 0), n1[u1] !== s1) throw new Error(\"dimension mismatch\");\n                    if (i1 <= 0 || a1 <= 0 || s1 <= 0) throw new Error(\"invalid shape specified\");\n                    if (o1 && !l1.isValidBroadcast(o1, [\n                        i1,\n                        a1\n                    ])) throw new Error(\"gemm: invalid bias shape for broadcast\");\n                    return [\n                        i1,\n                        a1,\n                        s1\n                    ];\n                }\n            };\n            class c1 {\n                static tensorDataTypeFromProto(e1) {\n                    switch(e1){\n                        case s1.onnx.TensorProto.DataType.INT8:\n                            return \"int8\";\n                        case s1.onnx.TensorProto.DataType.UINT8:\n                            return \"uint8\";\n                        case s1.onnx.TensorProto.DataType.BOOL:\n                            return \"bool\";\n                        case s1.onnx.TensorProto.DataType.INT16:\n                            return \"int16\";\n                        case s1.onnx.TensorProto.DataType.UINT16:\n                            return \"uint16\";\n                        case s1.onnx.TensorProto.DataType.INT32:\n                            return \"int32\";\n                        case s1.onnx.TensorProto.DataType.UINT32:\n                            return \"uint32\";\n                        case s1.onnx.TensorProto.DataType.FLOAT:\n                            return \"float32\";\n                        case s1.onnx.TensorProto.DataType.DOUBLE:\n                            return \"float64\";\n                        case s1.onnx.TensorProto.DataType.STRING:\n                            return \"string\";\n                        case s1.onnx.TensorProto.DataType.INT64:\n                            return \"int32\";\n                        case s1.onnx.TensorProto.DataType.UINT64:\n                            return \"uint32\";\n                        default:\n                            throw new Error(`unsupported data type: ${s1.onnx.TensorProto.DataType[e1]}`);\n                    }\n                }\n                static tensorDataTypeStringToEnum(e1) {\n                    switch(e1){\n                        case \"int8\":\n                            return s1.onnx.TensorProto.DataType.INT8;\n                        case \"uint8\":\n                            return s1.onnx.TensorProto.DataType.UINT8;\n                        case \"bool\":\n                            return s1.onnx.TensorProto.DataType.BOOL;\n                        case \"int16\":\n                            return s1.onnx.TensorProto.DataType.INT16;\n                        case \"uint16\":\n                            return s1.onnx.TensorProto.DataType.UINT16;\n                        case \"int32\":\n                            return s1.onnx.TensorProto.DataType.INT32;\n                        case \"uint32\":\n                            return s1.onnx.TensorProto.DataType.UINT32;\n                        case \"float32\":\n                            return s1.onnx.TensorProto.DataType.FLOAT;\n                        case \"float64\":\n                            return s1.onnx.TensorProto.DataType.DOUBLE;\n                        case \"string\":\n                            return s1.onnx.TensorProto.DataType.STRING;\n                        case \"int64\":\n                            return s1.onnx.TensorProto.DataType.INT64;\n                        case \"uint64\":\n                            return s1.onnx.TensorProto.DataType.UINT64;\n                        default:\n                            throw new Error(`unsupported data type: ${e1}`);\n                    }\n                }\n                static tensorDimsFromProto(e1) {\n                    return e1.map((e1)=>i1.default.isLong(e1) ? e1.toNumber() : e1);\n                }\n                static tensorValueTypeFromProto(e1) {\n                    return {\n                        tensorType: c1.tensorDataTypeFromProto(e1.elemType),\n                        shape: {\n                            dims: c1.tensorDimsFromProto(e1.shape.dim.map((e1)=>e1.dimValue))\n                        }\n                    };\n                }\n                static tensorDimsFromORTFormat(e1) {\n                    const t1 = [];\n                    for(let n1 = 0; n1 < e1.dimsLength(); n1++)t1.push(p1.longToNumber(e1.dims(n1)));\n                    return t1;\n                }\n                static tensorAttributesFromORTFormat(e1) {\n                    const t1 = [];\n                    for(let n1 = 0; n1 < e1.attributesLength(); n1++)t1.push(e1.attributes(n1));\n                    return t1;\n                }\n            }\n            t1.ProtoUtil = c1;\n            class p1 {\n                static longToNumber(e1, t1) {\n                    return i1.default.isLong(e1) ? e1.toNumber() : e1 instanceof o1.flatbuffers.Long ? i1.default.fromValue({\n                        low: e1.low,\n                        high: e1.high,\n                        unsigned: null != t1 && t1\n                    }).toNumber() : e1;\n                }\n                static isLong(e1) {\n                    return i1.default.isLong(e1) || e1 instanceof o1.flatbuffers.Long;\n                }\n            }\n            t1.LongUtil = p1;\n            class d1 {\n                static size(e1) {\n                    return d1.getSizeFromDimensionRange(e1, 0, e1.length);\n                }\n                static sizeFromDimension(e1, t1) {\n                    if (t1 < 0 || t1 > e1.length) throw new Error(`invalid dimension of ${t1} for sizeFromDimension as Tensor has ${e1.length} dimensions.`);\n                    return d1.getSizeFromDimensionRange(e1, t1, e1.length);\n                }\n                static sizeToDimension(e1, t1) {\n                    if (t1 < 0 || t1 > e1.length) throw new Error(`invalid dimension of ${t1} for sizeToDimension as Tensor has ${e1.length} dimensions.`);\n                    return d1.getSizeFromDimensionRange(e1, 0, t1);\n                }\n                static getSizeFromDimensionRange(e1, t1, n1) {\n                    let r1 = 1;\n                    for(let o1 = t1; o1 < n1; o1++){\n                        if (e1[o1] <= 0) throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.\");\n                        r1 *= e1[o1];\n                    }\n                    return r1;\n                }\n                static computeStrides(e1) {\n                    const t1 = e1.length;\n                    if (0 === t1) return [];\n                    if (1 === t1) return [\n                        1\n                    ];\n                    const n1 = new Array(t1);\n                    n1[t1 - 1] = 1, n1[t1 - 2] = e1[t1 - 1];\n                    for(let r1 = t1 - 3; r1 >= 0; --r1)n1[r1] = n1[r1 + 1] * e1[r1 + 1];\n                    return n1;\n                }\n                static transpose(e1) {\n                    return e1.slice().reverse();\n                }\n                static indicesToOffset(e1, t1, n1) {\n                    void 0 === n1 && (n1 = e1.length);\n                    let r1 = 0;\n                    for(let o1 = 0; o1 < n1; ++o1)r1 += t1[o1] * e1[o1];\n                    return r1;\n                }\n                static offsetToIndices(e1, t1) {\n                    const n1 = t1.length;\n                    if (0 === n1) return [];\n                    if (1 === n1) return [\n                        e1 * t1[0]\n                    ];\n                    const r1 = new Array(t1.length);\n                    for(let n1 = 0; n1 < r1.length - 1; ++n1)r1[n1] = Math.floor(e1 / t1[n1]), e1 -= r1[n1] * t1[n1];\n                    return r1[r1.length - 1] = e1, r1;\n                }\n                static normalizeAxis(e1, t1) {\n                    if (e1 < -t1 && e1 >= t1) throw new Error(\"unsupported axis for this operation.\");\n                    return e1 < 0 ? e1 + t1 : e1;\n                }\n                static normalizeAxes(e1, t1) {\n                    return e1.map((e1)=>this.normalizeAxis(e1, t1));\n                }\n                static incrementIndex(e1, t1, n1) {\n                    if (0 === t1.length || 0 === e1.length) throw new Error(\"Index incrementing unsupported for scalar Tensor\");\n                    if (void 0 === n1) n1 = t1.length;\n                    else if (n1 <= 0 || n1 > t1.length) throw new Error(\"Incorrect axis to increment on\");\n                    for(let r1 = n1 - 1; r1 >= 0 && (e1[r1]++, !(e1[r1] < t1[r1])); --r1)e1[r1] = 0;\n                }\n                static calculateReshapedDims(e1, t1) {\n                    if (0 === t1.length) {\n                        if (0 === e1.length || 1 === d1.size(e1)) return [];\n                        throw new Error(\"cannot reshape to a scalar Tensor\");\n                    }\n                    const n1 = t1.length, r1 = new Array(n1);\n                    let o1 = -1, i1 = 1;\n                    for(let s1 = 0; s1 < n1; s1++){\n                        if (t1[s1] < -1) throw new Error(\"a dimension in shape hints cannot be less than -1\");\n                        if (-1 === t1[s1]) {\n                            if (-1 !== o1) throw new Error(\"at most one dimension in shape hints can be -1\");\n                            o1 = s1;\n                        } else {\n                            if (0 === t1[s1]) {\n                                if (s1 >= e1.length) throw new Error(\"the dimension with value zero exceeds the dimension size of the input tensor\");\n                                r1[s1] = e1[s1];\n                            } else r1[s1] = t1[s1];\n                            i1 *= r1[s1];\n                        }\n                    }\n                    const s1 = d1.size(e1);\n                    if (-1 !== o1) {\n                        if (s1 % i1 != 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e1}] Output shape: [${t1}]`);\n                        r1[o1] = s1 / i1;\n                    } else if (i1 !== s1) throw new Error(\"reshapedDims and originalDims don't have matching sizes\");\n                    return r1;\n                }\n                static sortBasedOnPerm(e1, t1) {\n                    return t1 ? t1.map((t1)=>e1[t1]) : e1.slice().reverse();\n                }\n                static padShape(e1, t1) {\n                    const n1 = e1.length;\n                    return e1.map((e1, r1)=>e1 + t1[r1] + t1[r1 + n1]);\n                }\n                static areEqual(e1, t1) {\n                    return e1.length === t1.length && e1.every((e1, n1)=>e1 === t1[n1]);\n                }\n                static validateDimsAndCalcSize(e1) {\n                    if (e1.length > 6) throw new TypeError(\"Only rank 0 to 6 is supported for tensor shape.\");\n                    let t1 = 1;\n                    for (const n1 of e1){\n                        if (!Number.isInteger(n1)) throw new TypeError(`Invalid shape: ${n1} is not an integer`);\n                        if (n1 < 0 || n1 > 2147483647) throw new TypeError(`Invalid shape: length ${n1} is not allowed`);\n                        t1 *= n1;\n                    }\n                    return t1;\n                }\n                static flattenShape(e1, t1) {\n                    t1 < 0 && (t1 += e1.length);\n                    const n1 = e1.reduce((e1, t1)=>e1 * t1, 1), r1 = e1.slice(t1).reduce((e1, t1)=>e1 * t1, 1);\n                    return [\n                        n1 / r1,\n                        r1\n                    ];\n                }\n                static squeezeShape(e1, t1) {\n                    const n1 = new Array;\n                    t1 = d1.normalizeAxes(t1, e1.length);\n                    for(let r1 = 0; r1 < e1.length; r1++){\n                        const o1 = t1.indexOf(r1) >= 0;\n                        if (o1 && 1 !== e1[r1]) throw new Error(\"squeeze an axis of size different than 1\");\n                        (0 === t1.length && e1[r1] > 1 || t1.length > 0 && !o1) && n1.push(e1[r1]);\n                    }\n                    return n1;\n                }\n                static unsqueezeShape(e1, t1) {\n                    const n1 = new Array(e1.length + t1.length);\n                    n1.fill(0);\n                    for(let e1 = 0; e1 < t1.length; e1++){\n                        const r1 = d1.normalizeAxis(t1[e1], n1.length);\n                        if (r1 >= n1.length) throw new Error(\"'axes' has an out of range axis\");\n                        if (0 !== n1[r1]) throw new Error(\"'axes' has a duplicate axis\");\n                        n1[r1] = 1;\n                    }\n                    let r1 = 0;\n                    for(let t1 = 0; t1 < n1.length; t1++)0 === n1[t1] && (n1[t1] = e1[r1++]);\n                    if (r1 !== e1.length) throw new Error(\"the unsqueezed dimension could not be established\");\n                    return n1;\n                }\n            }\n            t1.ShapeUtil = d1, t1.MathUtil = class {\n                static sqr(e1, t1, n1, r1, o1) {\n                    if (r1 < 0 || r1 >= t1.length) throw new Error(\"sourceIndex out of bounds\");\n                    if (n1 < 0 || n1 >= e1.length) throw new Error(\"targetIndex out of bounds\");\n                    if (r1 + o1 > t1.length) throw new Error(\"source indices to be copied are outside bounds\");\n                    if (n1 + o1 > e1.length) throw new Error(\"target array is too small to hold result\");\n                    for(let i1 = 0; i1 < o1; i1++)e1[n1 + i1] += Math.pow(t1[r1 + i1], 2);\n                }\n                static axpy(e1, t1, n1, r1, o1, i1) {\n                    if (r1 < 0 || r1 >= t1.length) throw new Error(\"sourceIndex out of bounds\");\n                    if (n1 < 0 || n1 >= e1.length) throw new Error(\"targetIndex out of bounds\");\n                    if (r1 + o1 > t1.length) throw new Error(\"source indices to be copied are outside bounds\");\n                    if (n1 + o1 > e1.length) throw new Error(\"target array is too small to hold result\");\n                    for(let s1 = 0; s1 < o1; s1++)e1[n1 + s1] += i1 * t1[r1 + s1];\n                }\n                static powx(e1, t1, n1, r1, o1, i1) {\n                    if (r1 < 0 || r1 >= t1.length) throw new Error(\"sourceIndex out of bounds\");\n                    if (n1 < 0 || n1 >= e1.length) throw new Error(\"targetIndex out of bounds\");\n                    if (r1 + o1 > t1.length) throw new Error(\"source indices to be copied are outside bounds\");\n                    if (n1 + o1 > e1.length) throw new Error(\"target array is too small to hold result\");\n                    for(let s1 = 0; s1 < o1; s1++)e1[n1 + s1] = Math.pow(t1[r1 + s1], i1);\n                }\n                static mul(e1, t1, n1, r1, o1) {\n                    if (r1 < 0 || r1 >= t1.length) throw new Error(\"sourceIndex out of bounds\");\n                    if (n1 < 0 || n1 >= e1.length) throw new Error(\"targetIndex out of bounds\");\n                    if (r1 + o1 > t1.length) throw new Error(\"source indices to be copied are outside bounds\");\n                    if (n1 + o1 > e1.length) throw new Error(\"target array is too small to hold result\");\n                    for(let i1 = 0; i1 < o1; i1++)e1[n1 + i1] = t1[r1 + i1] * e1[n1 + i1];\n                }\n            };\n            class f1 {\n                static splitShape(e1, t1, n1, r1) {\n                    if (0 === n1.length) {\n                        if (!r1) throw new Error(\"need to know number of outputs when the 'split' attribute is not specified\");\n                        f1.determineSplit(e1[t1], r1, n1);\n                    }\n                    const o1 = [], i1 = [\n                        0\n                    ];\n                    for(let r1 = 0; r1 < n1.length; ++r1){\n                        0 !== r1 && i1.push(i1[r1 - 1] + n1[r1 - 1]);\n                        const s1 = e1.slice();\n                        s1[t1] = n1[r1], o1.push(s1);\n                    }\n                    return [\n                        o1,\n                        i1\n                    ];\n                }\n                static determineSplit(e1, t1, n1) {\n                    if (e1 % t1 != 0) throw new Error(\"cannot split tensor to equal sized parts\");\n                    for(let r1 = 0; r1 < t1; ++r1)n1.push(e1 / t1);\n                }\n            }\n            t1.SplitUtil = f1;\n            class h1 {\n                static calcReduce(e1, t1, n1, r1, o1) {\n                    const i1 = e1.dims.slice(0);\n                    0 === t1.length && i1.forEach((e1, n1)=>t1.push(n1));\n                    const s1 = h1.calcReduceShape(i1, t1, !0), u1 = d1.size(s1), c1 = new a1.Tensor(s1, e1.type), p1 = d1.computeStrides(s1), f1 = d1.computeStrides(i1), g1 = new Array(i1.length);\n                    for(let n1 = 0; n1 < u1; n1++){\n                        const s1 = d1.offsetToIndices(n1, p1);\n                        l1.fillIndex(s1, i1, g1), c1.set(s1, h1.calcReduceByAxis(e1.numberData, t1, i1, 0, d1.indicesToOffset(g1, f1), r1, o1));\n                    }\n                    return n1 ? c1 : new a1.Tensor(h1.calcReduceShape(i1, t1, n1), c1.type, void 0, void 0, c1.data, c1.dataId);\n                }\n                static calcReduceByAxis(e1, t1, n1, r1, o1, i1, s1) {\n                    let a1 = 0;\n                    if (r1 >= t1.length) return i1(e1[o1]);\n                    const u1 = t1[r1], l1 = u1 >= n1.length ? 1 : d1.size(n1.slice(u1 + 1));\n                    for(let c1 = 0; c1 < n1[u1]; c1++)a1 = 0 === c1 ? h1.calcReduceByAxis(e1, t1, n1, r1 + 1, o1, i1, s1) : s1(a1, h1.calcReduceByAxis(e1, t1, n1, r1 + 1, o1, i1, s1)), o1 += l1;\n                    return a1;\n                }\n                static calcReduceShape(e1, t1, n1) {\n                    const r1 = e1.slice();\n                    for(let e1 = 0; e1 < t1.length; e1++)r1[t1[e1]] = n1 ? 1 : 0;\n                    return r1.filter((e1)=>0 !== e1);\n                }\n            }\n            t1.ReduceUtil = h1;\n            class g1 {\n                static adjustPoolAttributes(e1, t1, n1, r1, o1, i1) {\n                    if (!e1 && n1.length !== t1.length - 2) throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");\n                    if (e1) for(let e1 = 0; e1 < t1.length - 2; e1++)e1 >= n1.length ? n1.push(t1[e1 + 2]) : n1[e1] = t1[e1 + 2];\n                    for(let e1 = 0; e1 < n1.length; e1++)if (e1 < r1.length) {\n                        if (r1[e1] < 0) throw new Error(\"strides should be greater than or equal to 1\");\n                    } else r1.push(1);\n                    for(let e1 = 0; e1 < n1.length; e1++)if (e1 < o1.length) {\n                        if (o1[e1] < 0) throw new Error(\"dilations should be greater than or equal to 1\");\n                    } else o1.push(1);\n                    for(let e1 = 0; e1 < 2 * n1.length; e1++)if (e1 < i1.length) {\n                        if (i1[e1] < 0) throw new Error(\"pad should be greater than or equal to 1\");\n                    } else i1.push(0);\n                    for(let e1 = 0; e1 < n1.length; e1++){\n                        if (n1[e1] <= 0) throw new Error(\"kernel shapes need to be greater than 0\");\n                        if (i1[e1] >= n1[e1] || i1[e1 + n1.length] >= n1[e1]) throw new Error(\"pads should be smaller than kernel\");\n                    }\n                }\n                static adjustPadsBasedOnAutoPad(e1, t1, n1, r1, o1, i1) {\n                    if (i1) {\n                        if (o1.length !== 2 * (e1.length - 2)) throw new Error(\"length of pads should be twice the length of data dimensions\");\n                        if (t1.length !== e1.length - 2) throw new Error(\"length of strides should be the length of data dimensions\");\n                        if (r1.length !== e1.length - 2) throw new Error(\"length of kernel shapes should be the length of data dimensions\");\n                        for(let s1 = 0; s1 < e1.length - 2; s1++)g1.adjustPadAndReturnShape(e1[s1 + 2], t1[s1], n1[s1], r1[s1], o1, s1, s1 + e1.length - 2, i1);\n                    }\n                }\n                static computePoolOutputShape(e1, t1, n1, r1, o1, i1, s1) {\n                    if (t1.length <= 0) throw new Error(\"input shape must be of size greater than 0\");\n                    const a1 = [\n                        t1[0],\n                        t1[1]\n                    ];\n                    return g1.computeShapeHelper(e1, t1, a1, n1, r1, o1, i1, s1), a1;\n                }\n                static computeConvOutputShape(e1, t1, n1, r1, o1, i1, s1) {\n                    if (e1.length <= 0 || t1.length <= 0) throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");\n                    const a1 = [\n                        e1[0],\n                        t1[0]\n                    ];\n                    return g1.computeShapeHelper(!1, e1, a1, n1, r1, o1, i1, s1), a1;\n                }\n                static computeShapeHelper(e1, t1, n1, r1, o1, i1, s1, a1) {\n                    if (e1) for(let e1 = 0; e1 < t1.length - 2; e1++)n1.push(1);\n                    else for(let e1 = 0; e1 < t1.length - 2; e1++)n1.push(g1.adjustPadAndReturnShape(t1[e1 + 2], r1[e1], o1[e1], i1[e1], s1, e1, e1 + t1.length - 2, a1));\n                }\n                static adjustPadAndReturnShape(e1, t1, n1, r1, o1, i1, s1, a1) {\n                    const u1 = n1 * (r1 - 1) + 1;\n                    if (!a1 || \"NOTSET\" === a1) return Math.floor((e1 + o1[i1] + o1[s1] - u1) / t1 + 1);\n                    switch(a1){\n                        case \"VALID\":\n                            return o1[i1] = 0, o1[s1] = 0, Math.floor((e1 - u1) / t1 + 1);\n                        case \"SAME_LOWER\":\n                        case \"SAME_UPPER\":\n                            if (1 !== n1) throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");\n                            {\n                                const n1 = ((e1 + t1 - 1) / t1 - 1) * t1 + r1 - e1;\n                                return o1[i1] = \"SAME_LOWER\" === a1 ? Math.floor((n1 + 1) / 2) : Math.floor(n1 / 2), o1[s1] = n1 - o1[i1], Math.floor((e1 + n1 - r1) / t1 + 1);\n                            }\n                        default:\n                            throw new Error(\"Unsupported AutoPad type\");\n                    }\n                }\n            }\n            t1.PoolConvUtil = g1, t1.MIN_CLIP = -34028234663852886e22, t1.MAX_CLIP = 34028234663852886e22, t1.decodeUtf8String = function(e1) {\n                return (new TextDecoder).decode(e1);\n            };\n        },\n        8408: (e1, t1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.version = void 0, t1.version = \"1.16.3\";\n        },\n        9544: function(e1, t1, n1) {\n            \"use strict\";\n            var r1, o1 = this && this.__createBinding || (Object.create ? function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1);\n                var o1 = Object.getOwnPropertyDescriptor(t1, n1);\n                o1 && !(\"get\" in o1 ? !t1.__esModule : o1.writable || o1.configurable) || (o1 = {\n                    enumerable: !0,\n                    get: function() {\n                        return t1[n1];\n                    }\n                }), Object.defineProperty(e1, r1, o1);\n            } : function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1), e1[r1] = t1[n1];\n            }), i1 = this && this.__setModuleDefault || (Object.create ? function(e1, t1) {\n                Object.defineProperty(e1, \"default\", {\n                    enumerable: !0,\n                    value: t1\n                });\n            } : function(e1, t1) {\n                e1.default = t1;\n            }), s1 = this && this.__importStar || function(e1) {\n                if (e1 && e1.__esModule) return e1;\n                var t1 = {};\n                if (null != e1) for(var n1 in e1)\"default\" !== n1 && Object.prototype.hasOwnProperty.call(e1, n1) && o1(t1, e1, n1);\n                return i1(t1, e1), t1;\n            };\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.endProfiling = t1.run = t1.releaseSession = t1.createSession = t1.createSessionFinalize = t1.createSessionAllocate = t1.initializeRuntime = t1.initializeWebAssemblyInstance = void 0;\n            const a1 = n1(6207), u1 = s1(n1(1259)), l1 = n1(263), c1 = ()=>!!a1.env.wasm.proxy && \"undefined\" != typeof document;\n            let p1, d1, f1, h1 = !1, g1 = !1, b1 = !1;\n            const m1 = [], y1 = [], _1 = [], v1 = [], T1 = [], x1 = [], w1 = ()=>{\n                if (h1 || !g1 || b1 || !p1) throw new Error(\"worker not ready\");\n            }, O1 = (e1)=>{\n                switch(e1.data.type){\n                    case \"init-wasm\":\n                        h1 = !1, e1.data.err ? (b1 = !0, d1[1](e1.data.err)) : (g1 = !0, d1[0]());\n                        break;\n                    case \"init-ort\":\n                        e1.data.err ? f1[1](e1.data.err) : f1[0]();\n                        break;\n                    case \"create_allocate\":\n                        e1.data.err ? m1.shift()[1](e1.data.err) : m1.shift()[0](e1.data.out);\n                        break;\n                    case \"create_finalize\":\n                        e1.data.err ? y1.shift()[1](e1.data.err) : y1.shift()[0](e1.data.out);\n                        break;\n                    case \"create\":\n                        e1.data.err ? _1.shift()[1](e1.data.err) : _1.shift()[0](e1.data.out);\n                        break;\n                    case \"release\":\n                        e1.data.err ? v1.shift()[1](e1.data.err) : v1.shift()[0]();\n                        break;\n                    case \"run\":\n                        e1.data.err ? T1.shift()[1](e1.data.err) : T1.shift()[0](e1.data.out);\n                        break;\n                    case \"end-profiling\":\n                        e1.data.err ? x1.shift()[1](e1.data.err) : x1.shift()[0]();\n                }\n            }, S1 = \"undefined\" != typeof document ? null === (r1 = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r1 ? void 0 : r1.src : void 0;\n            t1.initializeWebAssemblyInstance = async ()=>{\n                if (c1()) {\n                    if (g1) return;\n                    if (h1) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n                    if (b1) throw new Error(\"previous call to 'initWasm()' failed.\");\n                    return h1 = !0, void 0 === a1.env.wasm.wasmPaths && S1 && 0 !== S1.indexOf(\"blob:\") && (a1.env.wasm.wasmPaths = S1.substr(0, +S1.lastIndexOf(\"/\") + 1)), new Promise((e1, t1)=>{\n                        null == p1 || p1.terminate(), p1 = n1(8050).Z(), p1.onmessage = O1, d1 = [\n                            e1,\n                            t1\n                        ];\n                        const r1 = {\n                            type: \"init-wasm\",\n                            in: a1.env.wasm\n                        };\n                        p1.postMessage(r1);\n                    });\n                }\n                return (0, l1.initializeWebAssembly)(a1.env.wasm);\n            }, t1.initializeRuntime = async (e1)=>{\n                if (c1()) return w1(), new Promise((t1, n1)=>{\n                    f1 = [\n                        t1,\n                        n1\n                    ];\n                    const r1 = {\n                        type: \"init-ort\",\n                        in: e1\n                    };\n                    p1.postMessage(r1);\n                });\n                await u1.initRuntime(e1);\n            }, t1.createSessionAllocate = async (e1)=>c1() ? (w1(), new Promise((t1, n1)=>{\n                    m1.push([\n                        t1,\n                        n1\n                    ]);\n                    const r1 = {\n                        type: \"create_allocate\",\n                        in: {\n                            model: e1\n                        }\n                    };\n                    p1.postMessage(r1, [\n                        e1.buffer\n                    ]);\n                })) : u1.createSessionAllocate(e1), t1.createSessionFinalize = async (e1, t1)=>c1() ? (w1(), new Promise((n1, r1)=>{\n                    y1.push([\n                        n1,\n                        r1\n                    ]);\n                    const o1 = {\n                        type: \"create_finalize\",\n                        in: {\n                            modeldata: e1,\n                            options: t1\n                        }\n                    };\n                    p1.postMessage(o1);\n                })) : u1.createSessionFinalize(e1, t1), t1.createSession = async (e1, t1)=>c1() ? (w1(), new Promise((n1, r1)=>{\n                    _1.push([\n                        n1,\n                        r1\n                    ]);\n                    const o1 = {\n                        type: \"create\",\n                        in: {\n                            model: e1,\n                            options: t1\n                        }\n                    };\n                    p1.postMessage(o1, [\n                        e1.buffer\n                    ]);\n                })) : u1.createSession(e1, t1), t1.releaseSession = async (e1)=>{\n                if (c1()) return w1(), new Promise((t1, n1)=>{\n                    v1.push([\n                        t1,\n                        n1\n                    ]);\n                    const r1 = {\n                        type: \"release\",\n                        in: e1\n                    };\n                    p1.postMessage(r1);\n                });\n                u1.releaseSession(e1);\n            }, t1.run = async (e1, t1, n1, r1, o1)=>c1() ? (w1(), new Promise((i1, s1)=>{\n                    T1.push([\n                        i1,\n                        s1\n                    ]);\n                    const a1 = {\n                        type: \"run\",\n                        in: {\n                            sessionId: e1,\n                            inputIndices: t1,\n                            inputs: n1,\n                            outputIndices: r1,\n                            options: o1\n                        }\n                    };\n                    p1.postMessage(a1, u1.extractTransferableBuffers(n1));\n                })) : u1.run(e1, t1, n1, r1, o1), t1.endProfiling = async (e1)=>{\n                if (c1()) return w1(), new Promise((t1, n1)=>{\n                    x1.push([\n                        t1,\n                        n1\n                    ]);\n                    const r1 = {\n                        type: \"end-profiling\",\n                        in: e1\n                    };\n                    p1.postMessage(r1);\n                });\n                u1.endProfiling(e1);\n            };\n        },\n        7918: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.setRunOptions = void 0;\n            const r1 = n1(263), o1 = n1(1497);\n            t1.setRunOptions = (e1)=>{\n                const t1 = (0, r1.getInstance)();\n                let n1 = 0;\n                const i1 = [], s1 = e1 || {};\n                try {\n                    if (void 0 === (null == e1 ? void 0 : e1.logSeverityLevel)) s1.logSeverityLevel = 2;\n                    else if (\"number\" != typeof e1.logSeverityLevel || !Number.isInteger(e1.logSeverityLevel) || e1.logSeverityLevel < 0 || e1.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e1.logSeverityLevel}`);\n                    if (void 0 === (null == e1 ? void 0 : e1.logVerbosityLevel)) s1.logVerbosityLevel = 0;\n                    else if (\"number\" != typeof e1.logVerbosityLevel || !Number.isInteger(e1.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e1.logVerbosityLevel}`);\n                    void 0 === (null == e1 ? void 0 : e1.terminate) && (s1.terminate = !1);\n                    let r1 = 0;\n                    return void 0 !== (null == e1 ? void 0 : e1.tag) && (r1 = (0, o1.allocWasmString)(e1.tag, i1)), n1 = t1._OrtCreateRunOptions(s1.logSeverityLevel, s1.logVerbosityLevel, !!s1.terminate, r1), 0 === n1 && (0, o1.checkLastError)(\"Can't create run options.\"), void 0 !== (null == e1 ? void 0 : e1.extra) && (0, o1.iterateExtraOptions)(e1.extra, \"\", new WeakSet, (e1, r1)=>{\n                        const s1 = (0, o1.allocWasmString)(e1, i1), a1 = (0, o1.allocWasmString)(r1, i1);\n                        0 !== t1._OrtAddRunConfigEntry(n1, s1, a1) && (0, o1.checkLastError)(`Can't set a run config entry: ${e1} - ${r1}.`);\n                    }), [\n                        n1,\n                        i1\n                    ];\n                } catch (e1) {\n                    throw 0 !== n1 && t1._OrtReleaseRunOptions(n1), i1.forEach((e1)=>t1._free(e1)), e1;\n                }\n            };\n        },\n        6640: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.OnnxruntimeWebAssemblySessionHandler = void 0;\n            const r1 = n1(6231), o1 = n1(6207), i1 = n1(6464), s1 = n1(9544);\n            let a1;\n            t1.OnnxruntimeWebAssemblySessionHandler = class {\n                async createSessionAllocate(e1) {\n                    const t1 = await fetch(e1);\n                    if (200 !== t1.status) throw new Error(`failed to load model: ${e1}`);\n                    const n1 = await t1.arrayBuffer();\n                    return (0, s1.createSessionAllocate)(new Uint8Array(n1));\n                }\n                async loadModel(e1, t1) {\n                    if (a1 || (await (0, s1.initializeRuntime)(o1.env), a1 = !0), \"string\" == typeof e1) if (\"undefined\" != typeof process && process.versions && process.versions.node) {\n                        const n1 = await (0, i1.promisify)(r1.readFile)(e1);\n                        [this.sessionId, this.inputNames, this.outputNames] = await (0, s1.createSession)(n1, t1);\n                    } else {\n                        const n1 = await this.createSessionAllocate(e1);\n                        [this.sessionId, this.inputNames, this.outputNames] = await (0, s1.createSessionFinalize)(n1, t1);\n                    }\n                    else [this.sessionId, this.inputNames, this.outputNames] = await (0, s1.createSession)(e1, t1);\n                }\n                async dispose() {\n                    return (0, s1.releaseSession)(this.sessionId);\n                }\n                async run(e1, t1, n1) {\n                    const r1 = [], i1 = [];\n                    Object.entries(e1).forEach((e1)=>{\n                        const t1 = e1[0], n1 = e1[1], o1 = this.inputNames.indexOf(t1);\n                        if (-1 === o1) throw new Error(`invalid input '${t1}'`);\n                        r1.push(n1), i1.push(o1);\n                    });\n                    const a1 = [];\n                    Object.entries(t1).forEach((e1)=>{\n                        const t1 = e1[0], n1 = this.outputNames.indexOf(t1);\n                        if (-1 === n1) throw new Error(`invalid output '${t1}'`);\n                        a1.push(n1);\n                    });\n                    const u1 = await (0, s1.run)(this.sessionId, i1, r1.map((e1)=>[\n                            e1.type,\n                            e1.dims,\n                            e1.data\n                        ]), a1, n1), l1 = {};\n                    for(let e1 = 0; e1 < u1.length; e1++)l1[this.outputNames[a1[e1]]] = new o1.Tensor(u1[e1][0], u1[e1][2], u1[e1][1]);\n                    return l1;\n                }\n                startProfiling() {}\n                endProfiling() {\n                    (0, s1.endProfiling)(this.sessionId);\n                }\n            };\n        },\n        7622: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.setSessionOptions = void 0;\n            const r1 = n1(263), o1 = n1(1497);\n            t1.setSessionOptions = (e1)=>{\n                var t1, n1, i1, s1;\n                const a1 = (0, r1.getInstance)();\n                let u1 = 0;\n                const l1 = [], c1 = e1 || {};\n                ((e1)=>{\n                    e1.extra || (e1.extra = {}), e1.extra.session || (e1.extra.session = {});\n                    const t1 = e1.extra.session;\n                    t1.use_ort_model_bytes_directly || (t1.use_ort_model_bytes_directly = \"1\"), e1.executionProviders && e1.executionProviders.some((e1)=>\"webgpu\" === (\"string\" == typeof e1 ? e1 : e1.name)) && (e1.enableMemPattern = !1);\n                })(c1);\n                try {\n                    const e1 = ((e1)=>{\n                        switch(e1){\n                            case \"disabled\":\n                                return 0;\n                            case \"basic\":\n                                return 1;\n                            case \"extended\":\n                                return 2;\n                            case \"all\":\n                                return 99;\n                            default:\n                                throw new Error(`unsupported graph optimization level: ${e1}`);\n                        }\n                    })(null !== (t1 = c1.graphOptimizationLevel) && void 0 !== t1 ? t1 : \"all\"), p1 = ((e1)=>{\n                        switch(e1){\n                            case \"sequential\":\n                                return 0;\n                            case \"parallel\":\n                                return 1;\n                            default:\n                                throw new Error(`unsupported execution mode: ${e1}`);\n                        }\n                    })(null !== (n1 = c1.executionMode) && void 0 !== n1 ? n1 : \"sequential\"), d1 = \"string\" == typeof c1.logId ? (0, o1.allocWasmString)(c1.logId, l1) : 0, f1 = null !== (i1 = c1.logSeverityLevel) && void 0 !== i1 ? i1 : 2;\n                    if (!Number.isInteger(f1) || f1 < 0 || f1 > 4) throw new Error(`log serverity level is not valid: ${f1}`);\n                    const h1 = null !== (s1 = c1.logVerbosityLevel) && void 0 !== s1 ? s1 : 0;\n                    if (!Number.isInteger(h1) || h1 < 0 || h1 > 4) throw new Error(`log verbosity level is not valid: ${h1}`);\n                    const g1 = \"string\" == typeof c1.optimizedModelFilePath ? (0, o1.allocWasmString)(c1.optimizedModelFilePath, l1) : 0;\n                    return u1 = a1._OrtCreateSessionOptions(e1, !!c1.enableCpuMemArena, !!c1.enableMemPattern, p1, !!c1.enableProfiling, 0, d1, f1, h1, g1), 0 === u1 && (0, o1.checkLastError)(\"Can't create session options.\"), c1.executionProviders && ((e1, t1, n1)=>{\n                        for (const i1 of t1){\n                            let t1 = \"string\" == typeof i1 ? i1 : i1.name;\n                            switch(t1){\n                                case \"xnnpack\":\n                                    t1 = \"XNNPACK\";\n                                    break;\n                                case \"webnn\":\n                                    if (t1 = \"WEBNN\", \"string\" != typeof i1) {\n                                        const t1 = i1;\n                                        if (null == t1 ? void 0 : t1.deviceType) {\n                                            const i1 = (0, o1.allocWasmString)(\"deviceType\", n1), s1 = (0, o1.allocWasmString)(t1.deviceType, n1);\n                                            0 !== (0, r1.getInstance)()._OrtAddSessionConfigEntry(e1, i1, s1) && (0, o1.checkLastError)(`Can't set a session config entry: 'deviceType' - ${t1.deviceType}.`);\n                                        }\n                                        if (null == t1 ? void 0 : t1.powerPreference) {\n                                            const i1 = (0, o1.allocWasmString)(\"powerPreference\", n1), s1 = (0, o1.allocWasmString)(t1.powerPreference, n1);\n                                            0 !== (0, r1.getInstance)()._OrtAddSessionConfigEntry(e1, i1, s1) && (0, o1.checkLastError)(`Can't set a session config entry: 'powerPreference' - ${t1.powerPreference}.`);\n                                        }\n                                    }\n                                    break;\n                                case \"webgpu\":\n                                    t1 = \"JS\";\n                                    break;\n                                case \"wasm\":\n                                case \"cpu\":\n                                    continue;\n                                default:\n                                    throw new Error(`not supported execution provider: ${t1}`);\n                            }\n                            const s1 = (0, o1.allocWasmString)(t1, n1);\n                            0 !== (0, r1.getInstance)()._OrtAppendExecutionProvider(e1, s1) && (0, o1.checkLastError)(`Can't append execution provider: ${t1}.`);\n                        }\n                    })(u1, c1.executionProviders, l1), void 0 !== c1.extra && (0, o1.iterateExtraOptions)(c1.extra, \"\", new WeakSet, (e1, t1)=>{\n                        const n1 = (0, o1.allocWasmString)(e1, l1), r1 = (0, o1.allocWasmString)(t1, l1);\n                        0 !== a1._OrtAddSessionConfigEntry(u1, n1, r1) && (0, o1.checkLastError)(`Can't set a session config entry: ${e1} - ${t1}.`);\n                    }), [\n                        u1,\n                        l1\n                    ];\n                } catch (e1) {\n                    throw 0 !== u1 && a1._OrtReleaseSessionOptions(u1), l1.forEach((e1)=>a1._free(e1)), e1;\n                }\n            };\n        },\n        7917: (e1, t1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.logLevelStringToEnum = t1.tensorTypeToTypedArrayConstructor = t1.getTensorElementSize = t1.tensorDataTypeEnumToString = t1.tensorDataTypeStringToEnum = void 0, t1.tensorDataTypeStringToEnum = (e1)=>{\n                switch(e1){\n                    case \"int8\":\n                        return 3;\n                    case \"uint8\":\n                        return 2;\n                    case \"bool\":\n                        return 9;\n                    case \"int16\":\n                        return 5;\n                    case \"uint16\":\n                        return 4;\n                    case \"int32\":\n                        return 6;\n                    case \"uint32\":\n                        return 12;\n                    case \"float16\":\n                        return 10;\n                    case \"float32\":\n                        return 1;\n                    case \"float64\":\n                        return 11;\n                    case \"string\":\n                        return 8;\n                    case \"int64\":\n                        return 7;\n                    case \"uint64\":\n                        return 13;\n                    default:\n                        throw new Error(`unsupported data type: ${e1}`);\n                }\n            }, t1.tensorDataTypeEnumToString = (e1)=>{\n                switch(e1){\n                    case 3:\n                        return \"int8\";\n                    case 2:\n                        return \"uint8\";\n                    case 9:\n                        return \"bool\";\n                    case 5:\n                        return \"int16\";\n                    case 4:\n                        return \"uint16\";\n                    case 6:\n                        return \"int32\";\n                    case 12:\n                        return \"uint32\";\n                    case 10:\n                        return \"float16\";\n                    case 1:\n                        return \"float32\";\n                    case 11:\n                        return \"float64\";\n                    case 8:\n                        return \"string\";\n                    case 7:\n                        return \"int64\";\n                    case 13:\n                        return \"uint64\";\n                    default:\n                        throw new Error(`unsupported data type: ${e1}`);\n                }\n            }, t1.getTensorElementSize = (e1)=>[\n                    void 0,\n                    4,\n                    1,\n                    1,\n                    2,\n                    2,\n                    4,\n                    8,\n                    void 0,\n                    1,\n                    2,\n                    8,\n                    4,\n                    8,\n                    void 0,\n                    void 0,\n                    void 0\n                ][e1], t1.tensorTypeToTypedArrayConstructor = (e1)=>{\n                switch(e1){\n                    case \"float16\":\n                    case \"uint16\":\n                        return Uint16Array;\n                    case \"float32\":\n                        return Float32Array;\n                    case \"uint8\":\n                    case \"bool\":\n                        return Uint8Array;\n                    case \"int8\":\n                        return Int8Array;\n                    case \"int16\":\n                        return Int16Array;\n                    case \"int32\":\n                        return Int32Array;\n                    case \"float64\":\n                        return Float64Array;\n                    case \"uint32\":\n                        return Uint32Array;\n                    case \"int64\":\n                        return BigInt64Array;\n                    case \"uint64\":\n                        return BigUint64Array;\n                    default:\n                        throw new Error(`unsupported type: ${e1}`);\n                }\n            }, t1.logLevelStringToEnum = (e1)=>{\n                switch(e1){\n                    case \"verbose\":\n                        return 0;\n                    case \"info\":\n                        return 1;\n                    case \"warning\":\n                        return 2;\n                    case \"error\":\n                        return 3;\n                    case \"fatal\":\n                        return 4;\n                    default:\n                        throw new Error(`unsupported logging level: ${e1}`);\n                }\n            };\n        },\n        1259: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.extractTransferableBuffers = t1.endProfiling = t1.run = t1.releaseSession = t1.createSession = t1.createSessionFinalize = t1.createSessionAllocate = t1.initRuntime = void 0;\n            const r1 = n1(7918), o1 = n1(7622), i1 = n1(7917), s1 = n1(263), a1 = n1(1497);\n            t1.initRuntime = async (e1)=>{\n                var t1, n1;\n                t1 = e1.wasm.numThreads, n1 = (0, i1.logLevelStringToEnum)(e1.logLevel), 0 !== (0, s1.getInstance)()._OrtInit(t1, n1) && (0, a1.checkLastError)(\"Can't initialize onnxruntime.\");\n            };\n            const u1 = new Map;\n            t1.createSessionAllocate = (e1)=>{\n                const t1 = (0, s1.getInstance)(), n1 = t1._malloc(e1.byteLength);\n                if (0 === n1) throw new Error(`Can't create a session. failed to allocate a buffer of size ${e1.byteLength}.`);\n                return t1.HEAPU8.set(e1, n1), [\n                    n1,\n                    e1.byteLength\n                ];\n            }, t1.createSessionFinalize = (e1, t1)=>{\n                const n1 = (0, s1.getInstance)();\n                let r1 = 0, i1 = 0, l1 = [];\n                const c1 = [], p1 = [];\n                try {\n                    [i1, l1] = (0, o1.setSessionOptions)(t1), r1 = n1._OrtCreateSession(e1[0], e1[1], i1), 0 === r1 && (0, a1.checkLastError)(\"Can't create a session.\");\n                    const [d1, f1] = ((e1)=>{\n                        const t1 = (0, s1.getInstance)(), n1 = t1.stackSave();\n                        try {\n                            const n1 = t1.stackAlloc(8);\n                            return 0 !== t1._OrtGetInputOutputCount(e1, n1, n1 + 4) && (0, a1.checkLastError)(\"Can't get session input/output count.\"), [\n                                t1.HEAP32[n1 / 4],\n                                t1.HEAP32[n1 / 4 + 1]\n                            ];\n                        } finally{\n                            t1.stackRestore(n1);\n                        }\n                    })(r1), h1 = [], g1 = [];\n                    for(let e1 = 0; e1 < d1; e1++){\n                        const t1 = n1._OrtGetInputName(r1, e1);\n                        0 === t1 && (0, a1.checkLastError)(\"Can't get an input name.\"), c1.push(t1), h1.push(n1.UTF8ToString(t1));\n                    }\n                    for(let e1 = 0; e1 < f1; e1++){\n                        const t1 = n1._OrtGetOutputName(r1, e1);\n                        0 === t1 && (0, a1.checkLastError)(\"Can't get an output name.\"), p1.push(t1), g1.push(n1.UTF8ToString(t1));\n                    }\n                    return u1.set(r1, [\n                        r1,\n                        c1,\n                        p1\n                    ]), [\n                        r1,\n                        h1,\n                        g1\n                    ];\n                } catch (e1) {\n                    throw c1.forEach((e1)=>n1._OrtFree(e1)), p1.forEach((e1)=>n1._OrtFree(e1)), 0 !== r1 && n1._OrtReleaseSession(r1), e1;\n                } finally{\n                    n1._free(e1[0]), 0 !== i1 && n1._OrtReleaseSessionOptions(i1), l1.forEach((e1)=>n1._free(e1));\n                }\n            }, t1.createSession = (e1, n1)=>{\n                const r1 = (0, t1.createSessionAllocate)(e1);\n                return (0, t1.createSessionFinalize)(r1, n1);\n            }, t1.releaseSession = (e1)=>{\n                const t1 = (0, s1.getInstance)(), n1 = u1.get(e1);\n                if (!n1) throw new Error(`cannot release session. invalid session id: ${e1}`);\n                const [r1, o1, i1] = n1;\n                o1.forEach((e1)=>t1._OrtFree(e1)), i1.forEach((e1)=>t1._OrtFree(e1)), t1._OrtReleaseSession(r1), u1.delete(e1);\n            }, t1.run = async (e1, t1, n1, o1, l1)=>{\n                const c1 = (0, s1.getInstance)(), p1 = u1.get(e1);\n                if (!p1) throw new Error(`cannot run inference. invalid session id: ${e1}`);\n                const [d1, f1, h1] = p1, g1 = t1.length, b1 = o1.length;\n                let m1 = 0, y1 = [];\n                const _1 = [], v1 = [];\n                try {\n                    [m1, y1] = (0, r1.setRunOptions)(l1);\n                    for(let e1 = 0; e1 < g1; e1++){\n                        const t1 = n1[e1][0], r1 = n1[e1][1], o1 = n1[e1][2];\n                        let s1, u1;\n                        if (Array.isArray(o1)) {\n                            u1 = 4 * o1.length, s1 = c1._malloc(u1), v1.push(s1);\n                            let e1 = s1 / 4;\n                            for(let t1 = 0; t1 < o1.length; t1++){\n                                if (\"string\" != typeof o1[t1]) throw new TypeError(`tensor data at index ${t1} is not a string`);\n                                c1.HEAPU32[e1++] = (0, a1.allocWasmString)(o1[t1], v1);\n                            }\n                        } else u1 = o1.byteLength, s1 = c1._malloc(u1), v1.push(s1), c1.HEAPU8.set(new Uint8Array(o1.buffer, o1.byteOffset, u1), s1);\n                        const l1 = c1.stackSave(), p1 = c1.stackAlloc(4 * r1.length);\n                        try {\n                            let n1 = p1 / 4;\n                            r1.forEach((e1)=>c1.HEAP32[n1++] = e1);\n                            const o1 = c1._OrtCreateTensor((0, i1.tensorDataTypeStringToEnum)(t1), s1, u1, p1, r1.length);\n                            0 === o1 && (0, a1.checkLastError)(`Can't create tensor for input[${e1}].`), _1.push(o1);\n                        } finally{\n                            c1.stackRestore(l1);\n                        }\n                    }\n                    const e1 = c1.stackSave(), s1 = c1.stackAlloc(4 * g1), u1 = c1.stackAlloc(4 * g1), p1 = c1.stackAlloc(4 * b1), T1 = c1.stackAlloc(4 * b1);\n                    try {\n                        let e1 = s1 / 4, n1 = u1 / 4, r1 = p1 / 4, l1 = T1 / 4;\n                        for(let r1 = 0; r1 < g1; r1++)c1.HEAPU32[e1++] = _1[r1], c1.HEAPU32[n1++] = f1[t1[r1]];\n                        for(let e1 = 0; e1 < b1; e1++)c1.HEAPU32[r1++] = 0, c1.HEAPU32[l1++] = h1[o1[e1]];\n                        let y1 = c1._OrtRun(d1, u1, s1, g1, T1, b1, p1, m1);\n                        const v1 = c1.jsepRunPromise;\n                        v1 && void 0 !== v1.then && (y1 = await v1);\n                        const x1 = [];\n                        0 !== y1 && (0, a1.checkLastError)(\"failed to call OrtRun().\");\n                        for(let e1 = 0; e1 < b1; e1++){\n                            const t1 = c1.HEAPU32[p1 / 4 + e1], n1 = c1.stackSave(), r1 = c1.stackAlloc(16);\n                            let o1, s1 = 0;\n                            try {\n                                y1 = c1._OrtGetTensorData(t1, r1, r1 + 4, r1 + 8, r1 + 12), 0 !== y1 && (0, a1.checkLastError)(`Can't access output tensor data on index ${e1}.`);\n                                let n1 = r1 / 4;\n                                const u1 = c1.HEAPU32[n1++];\n                                s1 = c1.HEAPU32[n1++];\n                                const l1 = c1.HEAPU32[n1++], p1 = c1.HEAPU32[n1++], d1 = [];\n                                for(let e1 = 0; e1 < p1; e1++)d1.push(c1.HEAPU32[l1 / 4 + e1]);\n                                c1._OrtFree(l1);\n                                const f1 = 0 === d1.length ? 1 : d1.reduce((e1, t1)=>e1 * t1);\n                                if (o1 = (0, i1.tensorDataTypeEnumToString)(u1), \"string\" === o1) {\n                                    const e1 = [];\n                                    let t1 = s1 / 4;\n                                    for(let n1 = 0; n1 < f1; n1++){\n                                        const r1 = c1.HEAPU32[t1++], o1 = n1 === f1 - 1 ? void 0 : c1.HEAPU32[t1] - r1;\n                                        e1.push(c1.UTF8ToString(r1, o1));\n                                    }\n                                    x1.push([\n                                        o1,\n                                        d1,\n                                        e1\n                                    ]);\n                                } else {\n                                    const e1 = new ((0, i1.tensorTypeToTypedArrayConstructor)(o1))(f1);\n                                    new Uint8Array(e1.buffer, e1.byteOffset, e1.byteLength).set(c1.HEAPU8.subarray(s1, s1 + e1.byteLength)), x1.push([\n                                        o1,\n                                        d1,\n                                        e1\n                                    ]);\n                                }\n                            } finally{\n                                c1.stackRestore(n1), \"string\" === o1 && s1 && c1._free(s1), c1._OrtReleaseTensor(t1);\n                            }\n                        }\n                        return x1;\n                    } finally{\n                        c1.stackRestore(e1);\n                    }\n                } finally{\n                    _1.forEach((e1)=>c1._OrtReleaseTensor(e1)), v1.forEach((e1)=>c1._free(e1)), 0 !== m1 && c1._OrtReleaseRunOptions(m1), y1.forEach((e1)=>c1._free(e1));\n                }\n            }, t1.endProfiling = (e1)=>{\n                const t1 = (0, s1.getInstance)(), n1 = u1.get(e1);\n                if (!n1) throw new Error(\"invalid session id\");\n                const r1 = n1[0], o1 = t1._OrtEndProfiling(r1);\n                0 === o1 && (0, a1.checkLastError)(\"Can't get an profile file name.\"), t1._OrtFree(o1);\n            }, t1.extractTransferableBuffers = (e1)=>{\n                const t1 = [];\n                for (const n1 of e1){\n                    const e1 = n1[2];\n                    !Array.isArray(e1) && e1.buffer && t1.push(e1.buffer);\n                }\n                return t1;\n            };\n        },\n        263: function(e1, t1, n1) {\n            \"use strict\";\n            var r1 = this && this.__createBinding || (Object.create ? function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1);\n                var o1 = Object.getOwnPropertyDescriptor(t1, n1);\n                o1 && !(\"get\" in o1 ? !t1.__esModule : o1.writable || o1.configurable) || (o1 = {\n                    enumerable: !0,\n                    get: function() {\n                        return t1[n1];\n                    }\n                }), Object.defineProperty(e1, r1, o1);\n            } : function(e1, t1, n1, r1) {\n                void 0 === r1 && (r1 = n1), e1[r1] = t1[n1];\n            }), o1 = this && this.__setModuleDefault || (Object.create ? function(e1, t1) {\n                Object.defineProperty(e1, \"default\", {\n                    enumerable: !0,\n                    value: t1\n                });\n            } : function(e1, t1) {\n                e1.default = t1;\n            }), i1 = this && this.__importStar || function(e1) {\n                if (e1 && e1.__esModule) return e1;\n                var t1 = {};\n                if (null != e1) for(var n1 in e1)\"default\" !== n1 && Object.prototype.hasOwnProperty.call(e1, n1) && r1(t1, e1, n1);\n                return o1(t1, e1), t1;\n            };\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.dispose = t1.getInstance = t1.initializeWebAssembly = void 0;\n            const s1 = i1(n1(1423)), a1 = n1(932), u1 = n1(3474);\n            let l1, c1 = !1, p1 = !1, d1 = !1;\n            t1.initializeWebAssembly = async (e1)=>{\n                if (c1) return Promise.resolve();\n                if (p1) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n                if (d1) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n                p1 = !0;\n                const t1 = e1.initTimeout, r1 = e1.numThreads, o1 = e1.simd, i1 = r1 > 1 && (()=>{\n                    try {\n                        return \"undefined\" != typeof SharedArrayBuffer && (\"undefined\" != typeof MessageChannel && (new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([\n                            0,\n                            97,\n                            115,\n                            109,\n                            1,\n                            0,\n                            0,\n                            0,\n                            1,\n                            4,\n                            1,\n                            96,\n                            0,\n                            0,\n                            3,\n                            2,\n                            1,\n                            0,\n                            5,\n                            4,\n                            1,\n                            3,\n                            1,\n                            1,\n                            10,\n                            11,\n                            1,\n                            9,\n                            0,\n                            65,\n                            0,\n                            254,\n                            16,\n                            2,\n                            0,\n                            26,\n                            11\n                        ])));\n                    } catch (e1) {\n                        return !1;\n                    }\n                })(), f1 = o1 && (()=>{\n                    try {\n                        return WebAssembly.validate(new Uint8Array([\n                            0,\n                            97,\n                            115,\n                            109,\n                            1,\n                            0,\n                            0,\n                            0,\n                            1,\n                            4,\n                            1,\n                            96,\n                            0,\n                            0,\n                            3,\n                            2,\n                            1,\n                            0,\n                            10,\n                            30,\n                            1,\n                            28,\n                            0,\n                            65,\n                            0,\n                            253,\n                            15,\n                            253,\n                            12,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            253,\n                            186,\n                            1,\n                            26,\n                            11\n                        ]));\n                    } catch (e1) {\n                        return !1;\n                    }\n                })(), h1 = e1.wasmPaths, g1 = \"string\" == typeof h1 ? h1 : void 0, b1 = ((e1, t1)=>t1 ? e1 ? \"ort-wasm-simd-threaded.wasm\" : \"ort-wasm-threaded.wasm\" : e1 ? \"ort-wasm-simd.wasm\" : \"ort-wasm.wasm\")(f1, i1), m1 = \"object\" == typeof h1 ? h1[b1] : void 0;\n                let y1 = !1;\n                const _1 = [];\n                if (t1 > 0 && _1.push(new Promise((e1)=>{\n                    setTimeout(()=>{\n                        y1 = !0, e1();\n                    }, t1);\n                })), _1.push(new Promise((e1, t1)=>{\n                    const r1 = i1 ? u1 : a1, o1 = {\n                        locateFile: (e1, t1)=>i1 && e1.endsWith(\".worker.js\") && \"undefined\" != typeof Blob ? URL.createObjectURL(new Blob([\n                                n1(4154)\n                            ], {\n                                type: \"text/javascript\"\n                            })) : e1.endsWith(\".wasm\") ? m1 || (null != g1 ? g1 : t1) + b1 : t1 + e1\n                    };\n                    if (i1) if (\"undefined\" == typeof Blob) o1.mainScriptUrlOrBlob = s1.join(__dirname, \"ort-wasm-threaded.js\");\n                    else {\n                        const e1 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r1.toString()}})();`;\n                        o1.mainScriptUrlOrBlob = new Blob([\n                            e1\n                        ], {\n                            type: \"text/javascript\"\n                        });\n                    }\n                    r1(o1).then((t1)=>{\n                        p1 = !1, c1 = !0, l1 = t1, e1();\n                    }, (e1)=>{\n                        p1 = !1, d1 = !0, t1(e1);\n                    });\n                })), await Promise.race(_1), y1) throw new Error(`WebAssembly backend initializing failed due to timeout: ${t1}ms`);\n            }, t1.getInstance = ()=>{\n                if (c1 && l1) return l1;\n                throw new Error(\"WebAssembly is not initialized yet.\");\n            }, t1.dispose = ()=>{\n                var e1;\n                !c1 || p1 || d1 || (p1 = !0, null === (e1 = l1.PThread) || void 0 === e1 || e1.terminateAllThreads(), l1 = void 0, p1 = !1, c1 = !1, d1 = !0);\n            };\n        },\n        1497: (e1, t1, n1)=>{\n            \"use strict\";\n            Object.defineProperty(t1, \"__esModule\", {\n                value: !0\n            }), t1.checkLastError = t1.iterateExtraOptions = t1.allocWasmString = void 0;\n            const r1 = n1(263);\n            t1.allocWasmString = (e1, t1)=>{\n                const n1 = (0, r1.getInstance)(), o1 = n1.lengthBytesUTF8(e1) + 1, i1 = n1._malloc(o1);\n                return n1.stringToUTF8(e1, i1, o1), t1.push(i1), i1;\n            }, t1.iterateExtraOptions = (e1, n1, r1, o1)=>{\n                if (\"object\" == typeof e1 && null !== e1) {\n                    if (r1.has(e1)) throw new Error(\"Circular reference in options\");\n                    r1.add(e1);\n                }\n                Object.entries(e1).forEach(([e1, i1])=>{\n                    const s1 = n1 ? n1 + e1 : e1;\n                    if (\"object\" == typeof i1) (0, t1.iterateExtraOptions)(i1, s1 + \".\", r1, o1);\n                    else if (\"string\" == typeof i1 || \"number\" == typeof i1) o1(s1, i1.toString());\n                    else {\n                        if (\"boolean\" != typeof i1) throw new Error(\"Can't handle extra config type: \" + typeof i1);\n                        o1(s1, i1 ? \"1\" : \"0\");\n                    }\n                });\n            }, t1.checkLastError = (e1)=>{\n                const t1 = (0, r1.getInstance)(), n1 = t1.stackSave();\n                try {\n                    const n1 = t1.stackAlloc(8);\n                    t1._OrtGetLastError(n1, n1 + 4);\n                    const r1 = t1.HEAP32[n1 / 4], o1 = t1.HEAPU32[n1 / 4 + 1], i1 = o1 ? t1.UTF8ToString(o1) : \"\";\n                    throw new Error(`${e1} ERROR_CODE: ${r1}, ERROR_MESSAGE: ${i1}`);\n                } finally{\n                    t1.stackRestore(n1);\n                }\n            };\n        },\n        8050: (e1, t1, n1)=>{\n            \"use strict\";\n            n1.d(t1, {\n                Z: ()=>i1\n            });\n            var r1 = n1(6614), o1 = n1.n(r1);\n            function i1() {\n                return o1()('/*!\\n* ONNX Runtime Web v1.16.3\\n* Copyright (c) Microsoft Corporation. All rights reserved.\\n* Licensed under the MIT License.\\n*/\\n(()=>{var e={918:(e,t,r)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.setRunOptions=void 0;const n=r(263),a=r(497);t.setRunOptions=e=>{const t=(0,n.getInstance)();let r=0;const o=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if(\"number\"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if(\"number\"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let n=0;return void 0!==(null==e?void 0:e.tag)&&(n=(0,a.allocWasmString)(e.tag,o)),r=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,n),0===r&&(0,a.checkLastError)(\"Can\\'t create run options.\"),void 0!==(null==e?void 0:e.extra)&&(0,a.iterateExtraOptions)(e.extra,\"\",new WeakSet,((e,n)=>{const s=(0,a.allocWasmString)(e,o),i=(0,a.allocWasmString)(n,o);0!==t._OrtAddRunConfigEntry(r,s,i)&&(0,a.checkLastError)(`Can\\'t set a run config entry: ${e} - ${n}.`)})),[r,o]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),o.forEach((e=>t._free(e))),e}}},622:(e,t,r)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.setSessionOptions=void 0;const n=r(263),a=r(497);t.setSessionOptions=e=>{var t,r,o,s;const i=(0,n.getInstance)();let u=0;const c=[],l=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some((e=>\"webgpu\"===(\"string\"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(l);try{const e=(e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=l.graphOptimizationLevel)&&void 0!==t?t:\"all\"),f=(e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(r=l.executionMode)&&void 0!==r?r:\"sequential\"),d=\"string\"==typeof l.logId?(0,a.allocWasmString)(l.logId,c):0,p=null!==(o=l.logSeverityLevel)&&void 0!==o?o:2;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log serverity level is not valid: ${p}`);const g=null!==(s=l.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h=\"string\"==typeof l.optimizedModelFilePath?(0,a.allocWasmString)(l.optimizedModelFilePath,c):0;return u=i._OrtCreateSessionOptions(e,!!l.enableCpuMemArena,!!l.enableMemPattern,f,!!l.enableProfiling,0,d,p,g,h),0===u&&(0,a.checkLastError)(\"Can\\'t create session options.\"),l.executionProviders&&((e,t,r)=>{for(const o of t){let t=\"string\"==typeof o?o:o.name;switch(t){case\"xnnpack\":t=\"XNNPACK\";break;case\"webnn\":if(t=\"WEBNN\",\"string\"!=typeof o){const t=o;if(null==t?void 0:t.deviceType){const o=(0,a.allocWasmString)(\"deviceType\",r),s=(0,a.allocWasmString)(t.deviceType,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,s)&&(0,a.checkLastError)(`Can\\'t set a session config entry: \\'deviceType\\' - ${t.deviceType}.`)}if(null==t?void 0:t.powerPreference){const o=(0,a.allocWasmString)(\"powerPreference\",r),s=(0,a.allocWasmString)(t.powerPreference,r);0!==(0,n.getInstance)()._OrtAddSessionConfigEntry(e,o,s)&&(0,a.checkLastError)(`Can\\'t set a session config entry: \\'powerPreference\\' - ${t.powerPreference}.`)}}break;case\"webgpu\":t=\"JS\";break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${t}`)}const s=(0,a.allocWasmString)(t,r);0!==(0,n.getInstance)()._OrtAppendExecutionProvider(e,s)&&(0,a.checkLastError)(`Can\\'t append execution provider: ${t}.`)}})(u,l.executionProviders,c),void 0!==l.extra&&(0,a.iterateExtraOptions)(l.extra,\"\",new WeakSet,((e,t)=>{const r=(0,a.allocWasmString)(e,c),n=(0,a.allocWasmString)(t,c);0!==i._OrtAddSessionConfigEntry(u,r,n)&&(0,a.checkLastError)(`Can\\'t set a session config entry: ${e} - ${t}.`)})),[u,c]}catch(e){throw 0!==u&&i._OrtReleaseSessionOptions(u),c.forEach((e=>i._free(e))),e}}},917:(e,t)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case\"float16\":case\"uint16\":return Uint16Array;case\"float32\":return Float32Array;case\"uint8\":case\"bool\":return Uint8Array;case\"int8\":return Int8Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,r)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initRuntime=void 0;const n=r(918),a=r(622),o=r(917),s=r(263),i=r(497);t.initRuntime=async e=>{var t,r;t=e.wasm.numThreads,r=(0,o.logLevelStringToEnum)(e.logLevel),0!==(0,s.getInstance)()._OrtInit(t,r)&&(0,i.checkLastError)(\"Can\\'t initialize onnxruntime.\")};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can\\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,s.getInstance)();let n=0,o=0,c=[];const l=[],f=[];try{[o,c]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n&&(0,i.checkLastError)(\"Can\\'t create a session.\");const[d,p]=(e=>{const t=(0,s.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);return 0!==t._OrtGetInputOutputCount(e,r,r+4)&&(0,i.checkLastError)(\"Can\\'t get session input/output count.\"),[t.HEAP32[r/4],t.HEAP32[r/4+1]]}finally{t.stackRestore(r)}})(n),g=[],h=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);0===t&&(0,i.checkLastError)(\"Can\\'t get an input name.\"),l.push(t),g.push(r.UTF8ToString(t))}for(let e=0;e<p;e++){const t=r._OrtGetOutputName(n,e);0===t&&(0,i.checkLastError)(\"Can\\'t get an output name.\"),f.push(t),h.push(r.UTF8ToString(t))}return u.set(n,[n,l,f]),[n,g,h]}catch(e){throw l.forEach((e=>r._OrtFree(e))),f.forEach((e=>r._OrtFree(e))),0!==n&&r._OrtReleaseSession(n),e}finally{r._free(e[0]),0!==o&&r._OrtReleaseSessionOptions(o),c.forEach((e=>r._free(e)))}},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,s.getInstance)(),r=u.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);const[n,a,o]=r;a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),t._OrtReleaseSession(n),u.delete(e)},t.run=async(e,t,r,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error(`cannot run inference. invalid session id: ${e}`);const[d,p,g]=f,h=t.length,m=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,n.setRunOptions)(c);for(let e=0;e<h;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if(\"string\"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,i.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*n.length);try{let r=f/4;n.forEach((e=>l.HEAP32[r++]=e));const a=l._OrtCreateTensor((0,o.tensorDataTypeStringToEnum)(t),s,u,f,n.length);0===a&&(0,i.checkLastError)(`Can\\'t create tensor for input[${e}].`),b.push(a)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*h),u=l.stackAlloc(4*h),f=l.stackAlloc(4*m),_=l.stackAlloc(4*m);try{let e=s/4,r=u/4,n=f/4,c=_/4;for(let n=0;n<h;n++)l.HEAPU32[e++]=b[n],l.HEAPU32[r++]=p[t[n]];for(let e=0;e<m;e++)l.HEAPU32[n++]=0,l.HEAPU32[c++]=g[a[e]];let v=l._OrtRun(d,u,s,h,_,m,f,y);const w=l.jsepRunPromise;w&&void 0!==w.then&&(v=await w);const O=[];0!==v&&(0,i.checkLastError)(\"failed to call OrtRun().\");for(let e=0;e<m;e++){const t=l.HEAPU32[f/4+e],r=l.stackSave(),n=l.stackAlloc(16);let a,s=0;try{v=l._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==v&&(0,i.checkLastError)(`Can\\'t access output tensor data on index ${e}.`);let r=n/4;const u=l.HEAPU32[r++];s=l.HEAPU32[r++];const c=l.HEAPU32[r++],f=l.HEAPU32[r++],d=[];for(let e=0;e<f;e++)d.push(l.HEAPU32[c/4+e]);l._OrtFree(c);const p=0===d.length?1:d.reduce(((e,t)=>e*t));if(a=(0,o.tensorDataTypeEnumToString)(u),\"string\"===a){const e=[];let t=s/4;for(let r=0;r<p;r++){const n=l.HEAPU32[t++],a=r===p-1?void 0:l.HEAPU32[t]-n;e.push(l.UTF8ToString(n,a))}O.push([a,d,e])}else{const e=new((0,o.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(s,s+e.byteLength)),O.push([a,d,e])}}finally{l.stackRestore(r),\"string\"===a&&s&&l._free(s),l._OrtReleaseTensor(t)}}return O}finally{l.stackRestore(e)}}finally{b.forEach((e=>l._OrtReleaseTensor(e))),w.forEach((e=>l._free(e))),0!==y&&l._OrtReleaseRunOptions(y),v.forEach((e=>l._free(e)))}},t.endProfiling=e=>{const t=(0,s.getInstance)(),r=u.get(e);if(!r)throw new Error(\"invalid session id\");const n=r[0],a=t._OrtEndProfiling(n);0===a&&(0,i.checkLastError)(\"Can\\'t get an profile file name.\"),t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,r){\"use strict\";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!(\"get\"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,\"default\",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)\"default\"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,\"__esModule\",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const s=o(r(17)),i=r(932),u=r(474);let c,l=!1,f=!1,d=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error(\"multiple calls to \\'initializeWebAssembly()\\' detected.\");if(d)throw new Error(\"previous call to \\'initializeWebAssembly()\\' failed.\");f=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return\"undefined\"!=typeof SharedArrayBuffer&&(\"undefined\"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),p=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),g=e.wasmPaths,h=\"string\"==typeof g?g:void 0,m=((e,t)=>t?e?\"ort-wasm-simd-threaded.wasm\":\"ort-wasm-threaded.wasm\":e?\"ort-wasm-simd.wasm\":\"ort-wasm.wasm\")(p,o),y=\"object\"==typeof g?g[m]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?u:i,a={locateFile:(e,t)=>o&&e.endsWith(\".worker.js\")&&\"undefined\"!=typeof Blob?URL.createObjectURL(new Blob([r(154)],{type:\"text/javascript\"})):e.endsWith(\".wasm\")?y||(null!=h?h:t)+m:t+e};if(o)if(\"undefined\"==typeof Blob)a.mainScriptUrlOrBlob=s.join(__dirname,\"ort-wasm-threaded.js\");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:\"text/javascript\"})}n(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,d=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error(\"WebAssembly is not initialized yet.\")},t.dispose=()=>{var e;!l||f||d||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,d=!0)}},497:(e,t,r)=>{\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.checkLastError=t.iterateExtraOptions=t.allocWasmString=void 0;const n=r(263);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o},t.iterateExtraOptions=(e,r,n,a)=>{if(\"object\"==typeof e&&null!==e){if(n.has(e))throw new Error(\"Circular reference in options\");n.add(e)}Object.entries(e).forEach((([e,o])=>{const s=r?r+e:e;if(\"object\"==typeof o)(0,t.iterateExtraOptions)(o,s+\".\",n,a);else if(\"string\"==typeof o||\"number\"==typeof o)a(s,o.toString());else{if(\"boolean\"!=typeof o)throw new Error(\"Can\\'t handle extra config type: \"+typeof o);a(s,o?\"1\":\"0\")}}))},t.checkLastError=e=>{const t=(0,n.getInstance)(),r=t.stackSave();try{const r=t.stackAlloc(8);t._OrtGetLastError(r,r+4);const n=t.HEAP32[r/4],a=t.HEAPU32[r/4+1],o=a?t.UTF8ToString(a):\"\";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}},474:(e,t,r)=>{var _scriptDir,n=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,\"undefined\"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){function t(){return k.buffer!=D.buffer&&Y(),D}function n(){return k.buffer!=D.buffer&&Y(),I}function a(){return k.buffer!=D.buffer&&Y(),U}function o(){return k.buffer!=D.buffer&&Y(),L}function s(){return k.buffer!=D.buffer&&Y(),W}var i,u,c=e;c.ready=new Promise(((e,t)=>{i=e,u=t}));var l,f,d,p=Object.assign({},c),g=\"./this.program\",h=(e,t)=>{throw t},m=\"object\"==typeof window,y=\"function\"==typeof importScripts,v=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,b=c.ENVIRONMENT_IS_PTHREAD||!1,w=\"\";function _(e){return c.locateFile?c.locateFile(e,w):w+e}if(v){var O=r(147),S=r(17);let t;w=y?S.dirname(w)+\"/\":__dirname+\"/\",l=(e,t)=>(e=e.startsWith(\"file://\")?new URL(e):S.normalize(e),O.readFileSync(e,t?void 0:\"utf8\")),d=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,r,n=!0)=>{e=e.startsWith(\"file://\")?new URL(e):S.normalize(e),O.readFile(e,n?void 0:\"utf8\",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!c.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),h=(e,t)=>{throw process.exitCode=e,t},c.inspect=()=>\"[Emscripten Module object]\";try{t=r(267)}catch(e){throw console.error(\\'The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?\\'),e}global.Worker=t.Worker}else(m||y)&&(y?w=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(w=document.currentScript.src),_scriptDir&&(w=_scriptDir),w=0!==w.indexOf(\"blob:\")?w.substr(0,w.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",v||(l=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.send(null),t.responseText},y&&(d=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.responseType=\"arraybuffer\",t.send(null),new Uint8Array(t.response)}),f=(e,t,r)=>{var n=new XMLHttpRequest;n.open(\"GET\",e,!0),n.responseType=\"arraybuffer\",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));v&&\"undefined\"==typeof performance&&(global.performance=r(74).performance);var E=console.log.bind(console),A=console.error.bind(console);v&&(E=(...e)=>O.writeSync(1,e.join(\" \")+\"\\\\n\"),A=(...e)=>O.writeSync(2,e.join(\" \")+\"\\\\n\"));var T,M=c.print||E,R=c.printErr||A;Object.assign(c,p),p=null,c.thisProgram&&(g=c.thisProgram),c.quit&&(h=c.quit),c.wasmBinary&&(T=c.wasmBinary);var F=c.noExitRuntime||!0;\"object\"!=typeof WebAssembly&&te(\"no native wasm support detected\");var k,C,x,P,D,I,U,L,W,H=!1;function Y(){var e=k.buffer;c.HEAP8=D=new Int8Array(e),c.HEAP16=new Int16Array(e),c.HEAP32=U=new Int32Array(e),c.HEAPU8=I=new Uint8Array(e),c.HEAPU16=new Uint16Array(e),c.HEAPU32=L=new Uint32Array(e),c.HEAPF32=new Float32Array(e),c.HEAPF64=W=new Float64Array(e)}var j=c.INITIAL_MEMORY||16777216;if(5242880<=j||te(\"INITIAL_MEMORY should be larger than STACK_SIZE, was \"+j+\"! (STACK_SIZE=5242880)\"),b)k=c.wasmMemory;else if(c.wasmMemory)k=c.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:j/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw R(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"),v&&R(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\"),Error(\"bad memory\");Y(),j=k.buffer.byteLength;var z,G=[],N=[],B=[],$=0;function q(){return F||0<$}var V,J,X=0,K=null,Z=null;function Q(){X++,c.monitorRunDependencies&&c.monitorRunDependencies(X)}function ee(){if(X--,c.monitorRunDependencies&&c.monitorRunDependencies(X),0==X&&(null!==K&&(clearInterval(K),K=null),Z)){var e=Z;Z=null,e()}}function te(e){throw c.onAbort&&c.onAbort(e),R(e=\"Aborted(\"+e+\")\"),H=!0,P=1,e=new WebAssembly.RuntimeError(e+\". Build with -sASSERTIONS for more info.\"),u(e),e}function re(e){return e.startsWith(\"data:application/octet-stream;base64,\")}function ne(e){if(e==V&&T)return new Uint8Array(T);if(d)return d(e);throw\"both async and sync fetching of the wasm failed\"}function ae(e,t,r){return function(e){if(!T&&(m||y)){if(\"function\"==typeof fetch&&!e.startsWith(\"file://\"))return fetch(e,{credentials:\"same-origin\"}).then((t=>{if(!t.ok)throw\"failed to load wasm binary file at \\'\"+e+\"\\'\";return t.arrayBuffer()})).catch((()=>ne(e)));if(f)return new Promise(((t,r)=>{f(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>ne(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{R(\"failed to asynchronously prepare wasm: \"+e),te(e)}))}function oe(e){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${e})`,this.status=e}function se(e){e.terminate(),e.onmessage=()=>{}}function ie(e){(e=ge.Fa[e])||te(),ge.fb(e)}function ue(e){var t=ge.Za();if(!t)return 6;ge.Ia.push(t),ge.Fa[e.Ha]=t,t.Ha=e.Ha;var r={cmd:\"run\",start_routine:e.gb,arg:e.Ya,pthread_ptr:e.Ha};return v&&t.unref(),t.postMessage(r,e.mb),0}re(V=\"ort-wasm-threaded.wasm\")||(V=_(V));var ce=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,le=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&ce)return ce.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n=\"\";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var s=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|s:(7&a)<<18|o<<12|s<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},fe=(e,t)=>(e>>>=0)?le(n(),e,t):\"\";function de(e){if(b)return qe(1,1,e);P=e,q()||(ge.hb(),c.onExit&&c.onExit(e),H=!0),h(e,new oe(e))}var pe=e=>{if(P=e,b)throw me(e),\"unwind\";de(e)},ge={La:[],Ia:[],Ta:[],Fa:{},Pa:function(){b?ge.ab():ge.$a()},$a:function(){G.unshift((()=>{Q(),ge.bb((()=>ee()))}))},ab:function(){ge.receiveObjectTransfer=ge.eb,ge.threadInitTLS=ge.Sa,ge.setExitStatus=ge.Ra,F=!1},Ra:function(e){P=e},rb:[\"$terminateWorker\"],hb:function(){for(var e of ge.Ia)se(e);for(e of ge.La)se(e);ge.La=[],ge.Ia=[],ge.Fa=[]},fb:function(e){var t=e.Ha;delete ge.Fa[t],ge.La.push(e),ge.Ia.splice(ge.Ia.indexOf(e),1),e.Ha=0,yt(t)},eb:function(){},Sa:function(){ge.Ta.forEach((e=>e()))},cb:e=>new Promise((t=>{e.onmessage=r=>{var n=(r=r.data).cmd;if(r.targetThread&&r.targetThread!=dt()){var a=ge.Fa[r.qb];a?a.postMessage(r,r.transferList):R(\\'Internal error! Worker sent a message \"\\'+n+\\'\" to target pthread \\'+r.targetThread+\", but that thread no longer exists!\")}else\"checkMailbox\"===n?He():\"spawnThread\"===n?ue(r):\"cleanupThread\"===n?ie(r.thread):\"killThread\"===n?(r=r.thread,n=ge.Fa[r],delete ge.Fa[r],se(n),yt(r),ge.Ia.splice(ge.Ia.indexOf(n),1),n.Ha=0):\"cancelThread\"===n?ge.Fa[r.thread].postMessage({cmd:\"cancel\"}):\"loaded\"===n?(e.loaded=!0,t(e)):\"alert\"===n?alert(\"Thread \"+r.threadId+\": \"+r.text):\"setimmediate\"===r.target?e.postMessage(r):\"callHandler\"===n?c[r.handler](...r.args):n&&R(\"worker sent an unknown command \"+n)},e.onerror=e=>{throw R(\"worker sent an error! \"+e.filename+\":\"+e.lineno+\": \"+e.message),e},v&&(e.on(\"message\",(function(t){e.onmessage({data:t})})),e.on(\"error\",(function(t){e.onerror(t)})));var r,n=[];for(r of[\"onExit\",\"onAbort\",\"print\",\"printErr\"])c.hasOwnProperty(r)&&n.push(r);e.postMessage({cmd:\"load\",handlers:n,urlOrBlob:c.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:x})})),bb:function(e){e()},Xa:function(){var e=_(\"ort-wasm-threaded.worker.js\");e=new Worker(e),ge.La.push(e)},Za:function(){return 0==ge.La.length&&(ge.Xa(),ge.cb(ge.La[0])),ge.La.pop()}};c.PThread=ge;var he=e=>{for(;0<e.length;)e.shift()(c)};function me(e){if(b)return qe(2,0,e);pe(e)}c.establishStackSpace=function(){var e=dt(),t=a()[e+52>>2>>>0];e=a()[e+56>>2>>>0],_t(t,t-e),St(t)};var ye=[];function ve(e){this.Oa=e-24,this.Wa=function(e){o()[this.Oa+4>>2>>>0]=e},this.Va=function(e){o()[this.Oa+8>>2>>>0]=e},this.Pa=function(e,t){this.Ua(),this.Wa(e),this.Va(t)},this.Ua=function(){o()[this.Oa+16>>2>>>0]=0}}function be(e,t,r,n){return b?qe(3,1,e,t,r,n):we(e,t,r,n)}function we(e,t,r,n){if(e>>>=0,t>>>=0,r>>>=0,n>>>=0,\"undefined\"==typeof SharedArrayBuffer)return R(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"),6;var a=[];return b&&0===a.length?be(e,t,r,n):(e={gb:r,Ha:e,Ya:n,mb:a},b?(e.ob=\"spawnThread\",postMessage(e,a),0):ue(e))}function _e(e,t,r){return b?qe(4,1,e,t,r):0}function Oe(e,t){if(b)return qe(5,1,e,t)}c.invokeEntryPoint=function(e,t){var r=ye[e];r||(e>=ye.length&&(ye.length=e+1),ye[e]=r=z.get(e)),e=r(t),q()?ge.Ra(e):vt(e)};var Se=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ee=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var s=e.charCodeAt(o);if(55296<=s&&57343>=s&&(s=65536+((1023&s)<<10)|1023&e.charCodeAt(++o)),127>=s){if(r>=n)break;t[r++>>>0]=s}else{if(2047>=s){if(r+1>=n)break;t[r++>>>0]=192|s>>6}else{if(65535>=s){if(r+2>=n)break;t[r++>>>0]=224|s>>12}else{if(r+3>=n)break;t[r++>>>0]=240|s>>18,t[r++>>>0]=128|s>>12&63}t[r++>>>0]=128|s>>6&63}t[r++>>>0]=128|63&s}}return t[r>>>0]=0,r-a},Ae=(e,t,r)=>Ee(e,n(),t,r);function Te(e,t){if(b)return qe(6,1,e,t)}function Me(e,t,r){if(b)return qe(7,1,e,t,r)}function Re(e,t,r){return b?qe(8,1,e,t,r):0}function Fe(e,t){if(b)return qe(9,1,e,t)}function ke(e,t,r){if(b)return qe(10,1,e,t,r)}function Ce(e,t,r,n){if(b)return qe(11,1,e,t,r,n)}function xe(e,t,r,n){if(b)return qe(12,1,e,t,r,n)}function Pe(e,t,r,n){if(b)return qe(13,1,e,t,r,n)}function De(e){if(b)return qe(14,1,e)}function Ie(e,t){if(b)return qe(15,1,e,t)}function Ue(e,t,r){if(b)return qe(16,1,e,t,r)}var Le=e=>{if(!H)try{if(e(),!q())try{b?vt(P):pe(P)}catch(e){e instanceof oe||\"unwind\"==e||h(1,e)}}catch(e){e instanceof oe||\"unwind\"==e||h(1,e)}};function We(e){e>>>=0,\"function\"==typeof Atomics.nb&&(Atomics.nb(a(),e>>2,e).value.then(He),e+=128,Atomics.store(a(),e>>2,1))}function He(){var e=dt();e&&(We(e),Le((()=>bt())))}c.__emscripten_thread_mailbox_await=We,c.checkMailbox=He;var Ye=e=>0==e%4&&(0!=e%100||0==e%400),je=[0,31,60,91,121,152,182,213,244,274,305,335],ze=[0,31,59,90,120,151,181,212,243,273,304,334];function Ge(e,t,r,n,a,o,s,i){return b?qe(17,1,e,t,r,n,a,o,s,i):-52}function Ne(e,t,r,n,a,o,s){if(b)return qe(18,1,e,t,r,n,a,o,s)}var Be=e=>{var t=Se(e)+1,r=pt(t);return r&&Ae(e,r,t),r},$e=e=>{var t=Ot();return e=e(),St(t),e};function qe(e,t){var r=arguments.length-2,n=arguments;return $e((()=>{for(var a=Et(8*r),o=a>>3,i=0;i<r;i++){var u=n[2+i];s()[o+i>>>0]=u}return mt(e,r,a,t)}))}var Ve,Je=[],Xe={},Ke=()=>{if(!Ve){var e,t={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:g||\"./this.program\"};for(e in Xe)void 0===Xe[e]?delete t[e]:t[e]=Xe[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);Ve=r}return Ve};function Ze(e,r){if(b)return qe(19,1,e,r);e>>>=0,r>>>=0;var n=0;return Ke().forEach((function(a,s){var i=r+n;for(s=o()[e+4*s>>2>>>0]=i,i=0;i<a.length;++i)t()[s++>>0>>>0]=a.charCodeAt(i);t()[s>>0>>>0]=0,n+=a.length+1})),0}function Qe(e,t){if(b)return qe(20,1,e,t);e>>>=0,t>>>=0;var r=Ke();o()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),o()[t>>2>>>0]=n,0}function et(e){return b?qe(21,1,e):52}function tt(e,t,r,n){return b?qe(22,1,e,t,r,n):52}function rt(e,t,r,n,a){return b?qe(23,1,e,t,r,n,a):70}var nt=[null,[],[]];function at(e,t,r,a){if(b)return qe(24,1,e,t,r,a);t>>>=0,r>>>=0,a>>>=0;for(var s=0,i=0;i<r;i++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=n()[u+l>>>0],d=nt[e];0===f||10===f?((1===e?M:R)(le(d,0)),d.length=0):d.push(f)}s+=c}return o()[a>>2>>>0]=s,0}var ot=e=>(ot=(()=>{if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues)return e=>(e.set(crypto.getRandomValues(new Uint8Array(e.byteLength))),e);if(v)try{var e=r(113);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}te(\"initRandomDevice\")})())(e),st=[31,29,31,30,31,30,31,31,30,31,30,31],it=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,r)=>{t().set(e,r>>>0)};function ct(e,t,r,n){function o(e,t,r){for(e=\"number\"==typeof e?e.toString():e||\"\";e.length<t;)e=r[0]+e;return e}function s(e,t){return o(e,t,\"0\")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function u(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function c(e){var t=e.Ja;for(e=new Date(new Date(e.Ka+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Ye(e.getFullYear())?st:it)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=u(new Date(e.getFullYear(),0,4)),r=u(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0,n>>>=0;var l=a()[n+40>>2>>>0];for(var f in n={kb:a()[n>>2>>>0],jb:a()[n+4>>2>>>0],Ma:a()[n+8>>2>>>0],Qa:a()[n+12>>2>>>0],Na:a()[n+16>>2>>>0],Ka:a()[n+20>>2>>>0],Ga:a()[n+24>>2>>>0],Ja:a()[n+28>>2>>>0],sb:a()[n+32>>2>>>0],ib:a()[n+36>>2>>>0],lb:l?fe(l):\"\"},r=fe(r),l={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(f,\"g\"),l[f]);var d=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),p=\"January February March April May June July August September October November December\".split(\" \");for(f in l={\"%a\":e=>d[e.Ga].substring(0,3),\"%A\":e=>d[e.Ga],\"%b\":e=>p[e.Na].substring(0,3),\"%B\":e=>p[e.Na],\"%C\":e=>s((e.Ka+1900)/100|0,2),\"%d\":e=>s(e.Qa,2),\"%e\":e=>o(e.Qa,2,\" \"),\"%g\":e=>c(e).toString().substring(2),\"%G\":e=>c(e),\"%H\":e=>s(e.Ma,2),\"%I\":e=>(0==(e=e.Ma)?e=12:12<e&&(e-=12),s(e,2)),\"%j\":e=>{for(var t=0,r=0;r<=e.Na-1;t+=(Ye(e.Ka+1900)?st:it)[r++]);return s(e.Qa+t,3)},\"%m\":e=>s(e.Na+1,2),\"%M\":e=>s(e.jb,2),\"%n\":()=>\"\\\\n\",\"%p\":e=>0<=e.Ma&&12>e.Ma?\"AM\":\"PM\",\"%S\":e=>s(e.kb,2),\"%t\":()=>\"\\\\t\",\"%u\":e=>e.Ga||7,\"%U\":e=>s(Math.floor((e.Ja+7-e.Ga)/7),2),\"%V\":e=>{var t=Math.floor((e.Ja+7-(e.Ga+6)%7)/7);if(2>=(e.Ga+371-e.Ja-2)%7&&t++,t)53==t&&(4==(r=(e.Ga+371-e.Ja)%7)||3==r&&Ye(e.Ka)||(t=1));else{t=52;var r=(e.Ga+7-e.Ja-1)%7;(4==r||5==r&&Ye(e.Ka%400-1))&&t++}return s(t,2)},\"%w\":e=>e.Ga,\"%W\":e=>s(Math.floor((e.Ja+7-(e.Ga+6)%7)/7),2),\"%y\":e=>(e.Ka+1900).toString().substring(2),\"%Y\":e=>e.Ka+1900,\"%z\":e=>{var t=0<=(e=e.ib);return e=Math.abs(e)/60,(t?\"+\":\"-\")+String(\"0000\"+(e/60*100+e%60)).slice(-4)},\"%Z\":e=>e.lb,\"%%\":()=>\"%\"},r=r.replace(/%%/g,\"\\\\0\\\\0\"),l)r.includes(f)&&(r=r.replace(new RegExp(f,\"g\"),l[f](n)));return f=function(e){var t=Array(Se(e)+1);return Ee(e,t,0,t.length),t}(r=r.replace(/\\\\0\\\\0/g,\"%\")),f.length>t?0:(ut(f,e),f.length-1)}ge.Pa();var lt=[null,de,me,be,_e,Oe,Te,Me,Re,Fe,ke,Ce,xe,Pe,De,Ie,Ue,Ge,Ne,Ze,Qe,et,tt,rt,at],ft={b:function(e,t,r){throw new ve(e>>>=0).Pa(t>>>0,r>>>0),e},N:function(e){gt(e>>>0,!y,1,!m,131072,!1),ge.Sa()},k:function(e){e>>>=0,b?postMessage({cmd:\"cleanupThread\",thread:e}):ie(e)},I:we,h:_e,T:Oe,E:Te,G:Me,U:Re,R:Fe,J:ke,Q:Ce,o:xe,F:Pe,C:De,S:Ie,D:Ue,q:()=>!0,A:function(e,t){(e>>>=0)==t>>>0?setTimeout((()=>He())):b?postMessage({targetThread:e,cmd:\"checkMailbox\"}):(e=ge.Fa[e])&&e.postMessage({cmd:\"checkMailbox\"})},L:function(){return-1},M:We,p:function(e){v&&ge.Fa[e>>>0].ref()},t:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getUTCSeconds(),a()[r+4>>2>>>0]=e.getUTCMinutes(),a()[r+8>>2>>>0]=e.getUTCHours(),a()[r+12>>2>>>0]=e.getUTCDate(),a()[r+16>>2>>>0]=e.getUTCMonth(),a()[r+20>>2>>>0]=e.getUTCFullYear()-1900,a()[r+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[r+28>>2>>>0]=e},u:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),a()[r>>2>>>0]=e.getSeconds(),a()[r+4>>2>>>0]=e.getMinutes(),a()[r+8>>2>>>0]=e.getHours(),a()[r+12>>2>>>0]=e.getDate(),a()[r+16>>2>>>0]=e.getMonth(),a()[r+20>>2>>>0]=e.getFullYear()-1900,a()[r+24>>2>>>0]=e.getDay(),t=(Ye(e.getFullYear())?je:ze)[e.getMonth()]+e.getDate()-1|0,a()[r+28>>2>>>0]=t,a()[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t)),a()[r+32>>2>>>0]=e},v:function(e){e>>>=0;var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),r=a()[e+32>>2>>>0],n=t.getTimezoneOffset(),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(s,o);return 0>r?a()[e+32>>2>>>0]=Number(o!=s&&i==n):0<r!=(i==n)&&(o=Math.max(s,o),t.setTime(t.getTime()+6e4*((0<r?i:o)-n))),a()[e+24>>2>>>0]=t.getDay(),r=(Ye(t.getFullYear())?je:ze)[t.getMonth()]+t.getDate()-1|0,a()[e+28>>2>>>0]=r,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,wt((J=e,1<=+Math.abs(J)?0<J?+Math.floor(J/4294967296)>>>0:~~+Math.ceil((J-+(~~J>>>0))/4294967296)>>>0:0)),e>>>0},r:Ge,s:Ne,z:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?e[1]:\"GMT\"}e>>>=0,t>>>=0,r>>>=0;var s=(new Date).getFullYear(),i=new Date(s,0,1),u=new Date(s,6,1);s=i.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(s,c);o()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(s!=c),e=n(i),t=n(u),e=Be(e),t=Be(t),c<s?(o()[r>>2>>>0]=e,o()[r+4>>2>>>0]=t):(o()[r>>2>>>0]=t,o()[r+4>>2>>>0]=e)},c:()=>{te(\"\")},l:function(){},i:function(){return Date.now()},V:()=>{throw $+=1,\"unwind\"},B:function(){return 4294901760},e:()=>performance.timeOrigin+performance.now(),f:function(){return v?r(37).cpus().length:navigator.hardwareConcurrency},K:function(e,t,r,n){for(ge.pb=t>>>0,Je.length=r,t=n>>>0>>3,n=0;n<r;n++)Je[n]=s()[t+n>>>0];return lt[e].apply(null,Je)},y:function(e){e>>>=0;var t=n().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a);e:{o=o.min.call(o,4294901760,a+(65536-a%65536)%65536)-k.buffer.byteLength+65535>>>16;try{k.grow(o),Y();var s=1;break e}catch(e){}s=void 0}if(s)return!0}return!1},O:Ze,P:Qe,j:pe,g:et,n:tt,w:rt,m:at,x:function(e,t){return e>>>=0,t>>>=0,ot(n().subarray(e>>>0,e+t>>>0)),0},a:k||c.wasmMemory,H:ct,d:function(e,t,r,n){return ct(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e,t){return e=e.exports,C=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.pthread_self=t(e.pthread_self),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),ge.Ta.push(C.sa),z=C.ta,N.unshift(C.W),x=t,ee(),e}var t={a:ft};if(Q(),c.instantiateWasm)try{return c.instantiateWasm(t,e)}catch(e){R(\"Module.instantiateWasm callback failed with error: \"+e),u(e)}(function(e,t){var r=V;return T||\"function\"!=typeof WebAssembly.instantiateStreaming||re(r)||r.startsWith(\"file://\")||v||\"function\"!=typeof fetch?ae(r,e,t):fetch(r,{credentials:\"same-origin\"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return R(\"wasm streaming compile failed: \"+n),R(\"falling back to ArrayBuffer instantiation\"),ae(r,e,t)}))))})(t,(function(t){e(t.instance,t.module)})).catch(u)}(),c._OrtInit=(e,t)=>(c._OrtInit=C.X)(e,t),c._OrtGetLastError=(e,t)=>(c._OrtGetLastError=C.Y)(e,t),c._OrtCreateSessionOptions=(e,t,r,n,a,o,s,i,u,l)=>(c._OrtCreateSessionOptions=C.Z)(e,t,r,n,a,o,s,i,u,l),c._OrtAppendExecutionProvider=(e,t)=>(c._OrtAppendExecutionProvider=C._)(e,t),c._OrtAddSessionConfigEntry=(e,t,r)=>(c._OrtAddSessionConfigEntry=C.$)(e,t,r),c._OrtReleaseSessionOptions=e=>(c._OrtReleaseSessionOptions=C.aa)(e),c._OrtCreateSession=(e,t,r)=>(c._OrtCreateSession=C.ba)(e,t,r),c._OrtReleaseSession=e=>(c._OrtReleaseSession=C.ca)(e),c._OrtGetInputOutputCount=(e,t,r)=>(c._OrtGetInputOutputCount=C.da)(e,t,r),c._OrtGetInputName=(e,t)=>(c._OrtGetInputName=C.ea)(e,t),c._OrtGetOutputName=(e,t)=>(c._OrtGetOutputName=C.fa)(e,t),c._OrtFree=e=>(c._OrtFree=C.ga)(e),c._OrtCreateTensor=(e,t,r,n,a)=>(c._OrtCreateTensor=C.ha)(e,t,r,n,a),c._OrtGetTensorData=(e,t,r,n,a)=>(c._OrtGetTensorData=C.ia)(e,t,r,n,a),c._OrtReleaseTensor=e=>(c._OrtReleaseTensor=C.ja)(e),c._OrtCreateRunOptions=(e,t,r,n)=>(c._OrtCreateRunOptions=C.ka)(e,t,r,n),c._OrtAddRunConfigEntry=(e,t,r)=>(c._OrtAddRunConfigEntry=C.la)(e,t,r),c._OrtReleaseRunOptions=e=>(c._OrtReleaseRunOptions=C.ma)(e),c._OrtRun=(e,t,r,n,a,o,s,i)=>(c._OrtRun=C.na)(e,t,r,n,a,o,s,i),c._OrtEndProfiling=e=>(c._OrtEndProfiling=C.oa)(e);var dt=c._pthread_self=()=>(dt=c._pthread_self=C.pa)(),pt=c._malloc=e=>(pt=c._malloc=C.qa)(e);c._free=e=>(c._free=C.ra)(e),c.__emscripten_tls_init=()=>(c.__emscripten_tls_init=C.sa)();var gt=c.__emscripten_thread_init=(e,t,r,n,a,o)=>(gt=c.__emscripten_thread_init=C.ua)(e,t,r,n,a,o);c.__emscripten_thread_crashed=()=>(c.__emscripten_thread_crashed=C.va)();var ht,mt=(e,t,r,n)=>(mt=C.wa)(e,t,r,n),yt=e=>(yt=C.xa)(e),vt=c.__emscripten_thread_exit=e=>(vt=c.__emscripten_thread_exit=C.ya)(e),bt=c.__emscripten_check_mailbox=()=>(bt=c.__emscripten_check_mailbox=C.za)(),wt=e=>(wt=C.Aa)(e),_t=(e,t)=>(_t=C.Ba)(e,t),Ot=()=>(Ot=C.Ca)(),St=e=>(St=C.Da)(e),Et=e=>(Et=C.Ea)(e);function At(){function e(){if(!ht&&(ht=!0,c.calledRun=!0,!H)&&(b||he(N),i(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),!b)){if(c.postRun)for(\"function\"==typeof c.postRun&&(c.postRun=[c.postRun]);c.postRun.length;){var e=c.postRun.shift();B.unshift(e)}he(B)}}if(!(0<X))if(b)i(c),b||he(N),startWorker(c);else{if(c.preRun)for(\"function\"==typeof c.preRun&&(c.preRun=[c.preRun]);c.preRun.length;)G.unshift(c.preRun.shift());he(G),0<X||(c.setStatus?(c.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){c.setStatus(\"\")}),1),e()}),1)):e())}}if(c.keepRuntimeAlive=q,c.wasmMemory=k,c.stackAlloc=Et,c.stackSave=Ot,c.stackRestore=St,c.UTF8ToString=fe,c.stringToUTF8=Ae,c.lengthBytesUTF8=Se,c.ExitStatus=oe,c.PThread=ge,Z=function e(){ht||At(),ht||(Z=e)},c.preInit)for(\"function\"==typeof c.preInit&&(c.preInit=[c.preInit]);0<c.preInit.length;)c.preInit.pop()();return At(),e.ready});e.exports=n},932:(e,t,r)=>{var _scriptDir,n=(_scriptDir=\"undefined\"!=typeof document&&document.currentScript?document.currentScript.src:void 0,\"undefined\"!=typeof __filename&&(_scriptDir=_scriptDir||__filename),function(e={}){var t,n,a=e;a.ready=new Promise(((e,r)=>{t=e,n=r}));var o,s,i,u=Object.assign({},a),c=\"./this.program\",l=(e,t)=>{throw t},f=\"object\"==typeof window,d=\"function\"==typeof importScripts,p=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node,g=\"\";if(p){var h=r(147),m=r(17);g=d?m.dirname(g)+\"/\":__dirname+\"/\",o=(e,t)=>(e=e.startsWith(\"file://\")?new URL(e):m.normalize(e),h.readFileSync(e,t?void 0:\"utf8\")),i=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),s=(e,t,r,n=!0)=>{e=e.startsWith(\"file://\")?new URL(e):m.normalize(e),h.readFile(e,n?void 0:\"utf8\",((e,a)=>{e?r(e):t(n?a.buffer:a)}))},!a.thisProgram&&1<process.argv.length&&(c=process.argv[1].replace(/\\\\\\\\/g,\"/\")),process.argv.slice(2),l=(e,t)=>{throw process.exitCode=e,t},a.inspect=()=>\"[Emscripten Module object]\"}else(f||d)&&(d?g=self.location.href:\"undefined\"!=typeof document&&document.currentScript&&(g=document.currentScript.src),_scriptDir&&(g=_scriptDir),g=0!==g.indexOf(\"blob:\")?g.substr(0,g.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1):\"\",o=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.send(null),t.responseText},d&&(i=e=>{var t=new XMLHttpRequest;return t.open(\"GET\",e,!1),t.responseType=\"arraybuffer\",t.send(null),new Uint8Array(t.response)}),s=(e,t,r)=>{var n=new XMLHttpRequest;n.open(\"GET\",e,!0),n.responseType=\"arraybuffer\",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var y,v=a.print||console.log.bind(console),b=a.printErr||console.error.bind(console);Object.assign(a,u),u=null,a.thisProgram&&(c=a.thisProgram),a.quit&&(l=a.quit),a.wasmBinary&&(y=a.wasmBinary);var w=a.noExitRuntime||!0;\"object\"!=typeof WebAssembly&&W(\"no native wasm support detected\");var _,O,S,E,A,T,M=!1;function R(){var e=_.buffer;a.HEAP8=S=new Int8Array(e),a.HEAP16=new Int16Array(e),a.HEAP32=A=new Int32Array(e),a.HEAPU8=E=new Uint8Array(e),a.HEAPU16=new Uint16Array(e),a.HEAPU32=T=new Uint32Array(e),a.HEAPF32=new Float32Array(e),a.HEAPF64=new Float64Array(e)}var F=[],k=[],C=[];function x(){var e=a.preRun.shift();F.unshift(e)}var P,D,I=0,U=null,L=null;function W(e){throw a.onAbort&&a.onAbort(e),b(e=\"Aborted(\"+e+\")\"),M=!0,e=new WebAssembly.RuntimeError(e+\". Build with -sASSERTIONS for more info.\"),n(e),e}function H(e){return e.startsWith(\"data:application/octet-stream;base64,\")}if(!H(P=\"ort-wasm.wasm\")){var Y=P;P=a.locateFile?a.locateFile(Y,g):g+Y}function j(e){if(e==P&&y)return new Uint8Array(y);if(i)return i(e);throw\"both async and sync fetching of the wasm failed\"}function z(e,t,r){return function(e){if(!y&&(f||d)){if(\"function\"==typeof fetch&&!e.startsWith(\"file://\"))return fetch(e,{credentials:\"same-origin\"}).then((t=>{if(!t.ok)throw\"failed to load wasm binary file at \\'\"+e+\"\\'\";return t.arrayBuffer()})).catch((()=>j(e)));if(s)return new Promise(((t,r)=>{s(e,(e=>t(new Uint8Array(e))),r)}))}return Promise.resolve().then((()=>j(e)))}(e).then((e=>WebAssembly.instantiate(e,t))).then((e=>e)).then(r,(e=>{b(\"failed to asynchronously prepare wasm: \"+e),W(e)}))}function G(e){this.name=\"ExitStatus\",this.message=`Program terminated with exit(${e})`,this.status=e}var N=e=>{for(;0<e.length;)e.shift()(a)};function B(e){this.qa=e-24,this.va=function(e){T[this.qa+4>>2>>>0]=e},this.ua=function(e){T[this.qa+8>>2>>>0]=e},this.sa=function(e,t){this.ta(),this.va(e),this.ua(t)},this.ta=function(){T[this.qa+16>>2>>>0]=0}}var $,q=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf8\"):void 0,V=(e,t,r)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&q)return q.decode(e.subarray(t,r));for(n=\"\";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var s=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|s:(7&a)<<18|o<<12|s<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},J=(e,t)=>(e>>>=0)?V(E,e,t):\"\",X=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},K=(e,t,r,n)=>{if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var s=e.charCodeAt(o);if(55296<=s&&57343>=s&&(s=65536+((1023&s)<<10)|1023&e.charCodeAt(++o)),127>=s){if(r>=n)break;t[r++>>>0]=s}else{if(2047>=s){if(r+1>=n)break;t[r++>>>0]=192|s>>6}else{if(65535>=s){if(r+2>=n)break;t[r++>>>0]=224|s>>12}else{if(r+3>=n)break;t[r++>>>0]=240|s>>18,t[r++>>>0]=128|s>>12&63}t[r++>>>0]=128|s>>6&63}t[r++>>>0]=128|63&s}}return t[r>>>0]=0,r-a},Z=e=>0==e%4&&(0!=e%100||0==e%400),Q=[0,31,60,91,121,152,182,213,244,274,305,335],ee=[0,31,59,90,120,151,181,212,243,273,304,334],te=e=>{var t=X(e)+1,r=le(t);return r&&K(e,E,r,t),r},re={},ne=()=>{if(!$){var e,t={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:c||\"./this.program\"};for(e in re)void 0===re[e]?delete t[e]:t[e]=re[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);$=r}return $},ae=[null,[],[]],oe=e=>(oe=(()=>{if(\"object\"==typeof crypto&&\"function\"==typeof crypto.getRandomValues)return e=>crypto.getRandomValues(e);if(p)try{var e=r(113);if(e.randomFillSync)return t=>e.randomFillSync(t);var t=e.randomBytes;return e=>(e.set(t(e.byteLength)),e)}catch(e){}W(\"initRandomDevice\")})())(e),se=[31,29,31,30,31,30,31,31,30,31,30,31],ie=[31,28,31,30,31,30,31,31,30,31,30,31];function ue(e,t,r,n){function a(e,t,r){for(e=\"number\"==typeof e?e.toString():e||\"\";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,\"0\")}function s(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function i(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.ma;for(e=new Date(new Date(e.na+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(Z(e.getFullYear())?se:ie)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=i(new Date(e.getFullYear(),0,4)),r=i(r),0>=s(t,e)?0>=s(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}e>>>=0,t>>>=0,r>>>=0;var c=A[40+(n>>>=0)>>2>>>0];for(var l in n={ya:A[n>>2>>>0],xa:A[n+4>>2>>>0],oa:A[n+8>>2>>>0],ra:A[n+12>>2>>>0],pa:A[n+16>>2>>>0],na:A[n+20>>2>>>0],ha:A[n+24>>2>>>0],ma:A[n+28>>2>>>0],Aa:A[n+32>>2>>>0],wa:A[n+36>>2>>>0],za:c?J(c):\"\"},r=J(r),c={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"})r=r.replace(new RegExp(l,\"g\"),c[l]);var f=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),d=\"January February March April May June July August September October November December\".split(\" \");for(l in c={\"%a\":e=>f[e.ha].substring(0,3),\"%A\":e=>f[e.ha],\"%b\":e=>d[e.pa].substring(0,3),\"%B\":e=>d[e.pa],\"%C\":e=>o((e.na+1900)/100|0,2),\"%d\":e=>o(e.ra,2),\"%e\":e=>a(e.ra,2,\" \"),\"%g\":e=>u(e).toString().substring(2),\"%G\":e=>u(e),\"%H\":e=>o(e.oa,2),\"%I\":e=>(0==(e=e.oa)?e=12:12<e&&(e-=12),o(e,2)),\"%j\":e=>{for(var t=0,r=0;r<=e.pa-1;t+=(Z(e.na+1900)?se:ie)[r++]);return o(e.ra+t,3)},\"%m\":e=>o(e.pa+1,2),\"%M\":e=>o(e.xa,2),\"%n\":()=>\"\\\\n\",\"%p\":e=>0<=e.oa&&12>e.oa?\"AM\":\"PM\",\"%S\":e=>o(e.ya,2),\"%t\":()=>\"\\\\t\",\"%u\":e=>e.ha||7,\"%U\":e=>o(Math.floor((e.ma+7-e.ha)/7),2),\"%V\":e=>{var t=Math.floor((e.ma+7-(e.ha+6)%7)/7);if(2>=(e.ha+371-e.ma-2)%7&&t++,t)53==t&&(4==(r=(e.ha+371-e.ma)%7)||3==r&&Z(e.na)||(t=1));else{t=52;var r=(e.ha+7-e.ma-1)%7;(4==r||5==r&&Z(e.na%400-1))&&t++}return o(t,2)},\"%w\":e=>e.ha,\"%W\":e=>o(Math.floor((e.ma+7-(e.ha+6)%7)/7),2),\"%y\":e=>(e.na+1900).toString().substring(2),\"%Y\":e=>e.na+1900,\"%z\":e=>{var t=0<=(e=e.wa);return e=Math.abs(e)/60,(t?\"+\":\"-\")+String(\"0000\"+(e/60*100+e%60)).slice(-4)},\"%Z\":e=>e.za,\"%%\":()=>\"%\"},r=r.replace(/%%/g,\"\\\\0\\\\0\"),c)r.includes(l)&&(r=r.replace(new RegExp(l,\"g\"),c[l](n)));return l=function(e){var t=Array(X(e)+1);return K(e,t,0,t.length),t}(r=r.replace(/\\\\0\\\\0/g,\"%\")),l.length>t?0:(S.set(l,e>>>0),l.length-1)}var ce={a:function(e,t,r){throw new B(e>>>=0).sa(t>>>0,r>>>0),e},e:function(){return 0},I:function(){},y:function(){},A:function(){},K:function(){return 0},G:function(){},B:function(){},F:function(){},g:function(){},z:function(){},w:function(){},H:function(){},x:function(){},k:()=>!0,n:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getUTCSeconds(),A[r+4>>2>>>0]=e.getUTCMinutes(),A[r+8>>2>>>0]=e.getUTCHours(),A[r+12>>2>>>0]=e.getUTCDate(),A[r+16>>2>>>0]=e.getUTCMonth(),A[r+20>>2>>>0]=e.getUTCFullYear()-1900,A[r+24>>2>>>0]=e.getUTCDay(),A[r+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},o:function(e,t,r){e=t+2097152>>>0<4194305-!!e?(e>>>0)+4294967296*t:NaN,r>>>=0,e=new Date(1e3*e),A[r>>2>>>0]=e.getSeconds(),A[r+4>>2>>>0]=e.getMinutes(),A[r+8>>2>>>0]=e.getHours(),A[r+12>>2>>>0]=e.getDate(),A[r+16>>2>>>0]=e.getMonth(),A[r+20>>2>>>0]=e.getFullYear()-1900,A[r+24>>2>>>0]=e.getDay(),A[r+28>>2>>>0]=(Z(e.getFullYear())?Q:ee)[e.getMonth()]+e.getDate()-1|0,A[r+36>>2>>>0]=-60*e.getTimezoneOffset(),t=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();A[r+32>>2>>>0]=0|(t!=n&&e.getTimezoneOffset()==Math.min(n,t))},p:function(e){e>>>=0;var t=new Date(A[e+20>>2>>>0]+1900,A[e+16>>2>>>0],A[e+12>>2>>>0],A[e+8>>2>>>0],A[e+4>>2>>>0],A[e>>2>>>0],0),r=A[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),s=Math.min(o,a);return 0>r?A[e+32>>2>>>0]=Number(a!=o&&s==n):0<r!=(s==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?s:a)-n))),A[e+24>>2>>>0]=t.getDay(),A[e+28>>2>>>0]=(Z(t.getFullYear())?Q:ee)[t.getMonth()]+t.getDate()-1|0,A[e>>2>>>0]=t.getSeconds(),A[e+4>>2>>>0]=t.getMinutes(),A[e+8>>2>>>0]=t.getHours(),A[e+12>>2>>>0]=t.getDate(),A[e+16>>2>>>0]=t.getMonth(),A[e+20>>2>>>0]=t.getYear(),e=t.getTime()/1e3,de((D=e,1<=+Math.abs(D)?0<D?+Math.floor(D/4294967296)>>>0:~~+Math.ceil((D-+(~~D>>>0))/4294967296)>>>0:0)),e>>>0},l:function(){return-52},m:function(){},u:function(e,t,r){function n(e){return(e=e.toTimeString().match(/\\\\(([A-Za-z ]+)\\\\)$/))?e[1]:\"GMT\"}r>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1),s=new Date(a,6,1);a=o.getTimezoneOffset();var i=s.getTimezoneOffset();T[e>>>0>>2>>>0]=60*Math.max(a,i),A[t>>>0>>2>>>0]=Number(a!=i),e=n(o),t=n(s),e=te(e),t=te(t),i<a?(T[r>>2>>>0]=e,T[r+4>>2>>>0]=t):(T[r>>2>>>0]=t,T[r+4>>2>>>0]=e)},d:()=>{W(\"\")},h:function(){return Date.now()},v:function(){return 4294901760},b:()=>performance.now(),J:function(e,t,r){return t>>>=0,E.copyWithin(e>>>0>>>0,t>>>0,t+(r>>>0)>>>0)},t:function(e){e>>>=0;var t=E.length;if(4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n);e:{a=a.min.call(a,4294901760,n+(65536-n%65536)%65536)-_.buffer.byteLength+65535>>>16;try{_.grow(a),R();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){e>>>=0,t>>>=0;var r=0;return ne().forEach((function(n,a){var o=t+r;for(a=T[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)S[a++>>0>>>0]=n.charCodeAt(o);S[a>>0>>>0]=0,r+=n.length+1})),0},E:function(e,t){e>>>=0,t>>>=0;var r=ne();T[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),T[t>>2>>>0]=n,0},s:e=>{w||(a.onExit&&a.onExit(e),M=!0),l(e,new G(e))},f:()=>52,j:function(){return 52},q:function(){return 70},i:function(e,t,r,n){t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var s=T[t>>2>>>0],i=T[t+4>>2>>>0];t+=8;for(var u=0;u<i;u++){var c=E[s+u>>>0],l=ae[e];0===c||10===c?((1===e?v:b)(V(l,0)),l.length=0):l.push(c)}a+=i}return T[n>>2>>>0]=a,0},r:function(e,t){return e>>>=0,oe(E.subarray(e>>>0,e+(t>>>0)>>>0)),0},C:ue,c:function(e,t,r,n){return ue(e>>>0,t>>>0,r>>>0,n>>>0)}};!function(){function e(e){if(e=e.exports,O=e=function(e){var t=e=>()=>e()>>>0,r=e=>t=>e(t)>>>0;return(e=Object.assign({},e)).__errno_location=t(e.__errno_location),e.malloc=r(e.malloc),e.stackSave=t(e.stackSave),e.stackAlloc=r(e.stackAlloc),e}(e),_=O.L,R(),k.unshift(O.M),I--,a.monitorRunDependencies&&a.monitorRunDependencies(I),0==I&&(null!==U&&(clearInterval(U),U=null),L)){var t=L;L=null,t()}return e}var t={a:ce};if(I++,a.monitorRunDependencies&&a.monitorRunDependencies(I),a.instantiateWasm)try{return a.instantiateWasm(t,e)}catch(e){b(\"Module.instantiateWasm callback failed with error: \"+e),n(e)}(function(e,t){var r=P;return y||\"function\"!=typeof WebAssembly.instantiateStreaming||H(r)||r.startsWith(\"file://\")||p||\"function\"!=typeof fetch?z(r,e,t):fetch(r,{credentials:\"same-origin\"}).then((n=>WebAssembly.instantiateStreaming(n,e).then(t,(function(n){return b(\"wasm streaming compile failed: \"+n),b(\"falling back to ArrayBuffer instantiation\"),z(r,e,t)}))))})(t,(function(t){e(t.instance)})).catch(n)}(),a._OrtInit=(e,t)=>(a._OrtInit=O.N)(e,t),a._OrtGetLastError=(e,t)=>(a._OrtGetLastError=O.O)(e,t),a._OrtCreateSessionOptions=(e,t,r,n,o,s,i,u,c,l)=>(a._OrtCreateSessionOptions=O.P)(e,t,r,n,o,s,i,u,c,l),a._OrtAppendExecutionProvider=(e,t)=>(a._OrtAppendExecutionProvider=O.Q)(e,t),a._OrtAddSessionConfigEntry=(e,t,r)=>(a._OrtAddSessionConfigEntry=O.R)(e,t,r),a._OrtReleaseSessionOptions=e=>(a._OrtReleaseSessionOptions=O.S)(e),a._OrtCreateSession=(e,t,r)=>(a._OrtCreateSession=O.T)(e,t,r),a._OrtReleaseSession=e=>(a._OrtReleaseSession=O.U)(e),a._OrtGetInputOutputCount=(e,t,r)=>(a._OrtGetInputOutputCount=O.V)(e,t,r),a._OrtGetInputName=(e,t)=>(a._OrtGetInputName=O.W)(e,t),a._OrtGetOutputName=(e,t)=>(a._OrtGetOutputName=O.X)(e,t),a._OrtFree=e=>(a._OrtFree=O.Y)(e),a._OrtCreateTensor=(e,t,r,n,o)=>(a._OrtCreateTensor=O.Z)(e,t,r,n,o),a._OrtGetTensorData=(e,t,r,n,o)=>(a._OrtGetTensorData=O._)(e,t,r,n,o),a._OrtReleaseTensor=e=>(a._OrtReleaseTensor=O.$)(e),a._OrtCreateRunOptions=(e,t,r,n)=>(a._OrtCreateRunOptions=O.aa)(e,t,r,n),a._OrtAddRunConfigEntry=(e,t,r)=>(a._OrtAddRunConfigEntry=O.ba)(e,t,r),a._OrtReleaseRunOptions=e=>(a._OrtReleaseRunOptions=O.ca)(e),a._OrtRun=(e,t,r,n,o,s,i,u)=>(a._OrtRun=O.da)(e,t,r,n,o,s,i,u),a._OrtEndProfiling=e=>(a._OrtEndProfiling=O.ea)(e);var le=a._malloc=e=>(le=a._malloc=O.fa)(e);a._free=e=>(a._free=O.ga)(e);var fe,de=e=>(de=O.ia)(e),pe=()=>(pe=O.ja)(),ge=e=>(ge=O.ka)(e),he=e=>(he=O.la)(e);function me(){function e(){if(!fe&&(fe=!0,a.calledRun=!0,!M)){if(N(k),t(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),a.postRun)for(\"function\"==typeof a.postRun&&(a.postRun=[a.postRun]);a.postRun.length;){var e=a.postRun.shift();C.unshift(e)}N(C)}}if(!(0<I)){if(a.preRun)for(\"function\"==typeof a.preRun&&(a.preRun=[a.preRun]);a.preRun.length;)x();N(F),0<I||(a.setStatus?(a.setStatus(\"Running...\"),setTimeout((function(){setTimeout((function(){a.setStatus(\"\")}),1),e()}),1)):e())}}if(a.stackAlloc=he,a.stackSave=pe,a.stackRestore=ge,a.UTF8ToString=J,a.stringToUTF8=(e,t,r)=>K(e,E,t,r),a.lengthBytesUTF8=X,L=function e(){fe||me(),fe||(L=e)},a.preInit)for(\"function\"==typeof a.preInit&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return me(),e.ready});e.exports=n},154:e=>{\"use strict\";e.exports=\\'\"use strict\";var e={},a=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(a){var r=require(\"worker_threads\"),t=r.parentPort;t.on(\"message\",(e=>onmessage({data:e})));var s=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,\"utf8\")+\"//# sourceURL=\"+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(\" \");a?s.writeSync(2,e+\"\\\\\\\\n\"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if(\"load\"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:\"loaded\"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:\"callHandler\",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if(\"run\"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if(\"unwind\"!=e)throw e}}else\"cancel\"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===r.data.target||(\"checkMailbox\"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d(\"worker.js received unknown command \"+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\\\n\\'},113:e=>{\"use strict\";e.exports=require(\"crypto\")},147:e=>{\"use strict\";e.exports=require(\"fs\")},37:e=>{\"use strict\";e.exports=require(\"os\")},17:e=>{\"use strict\";e.exports=require(\"path\")},74:e=>{\"use strict\";e.exports=require(\"perf_hooks\")},267:e=>{\"use strict\";e.exports=require(\"worker_threads\")}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var o=t[n]={exports:{}};return e[n].call(o.exports,o,o.exports,r),o.exports}(()=>{\"use strict\";const e=r(259),t=r(263);self.onmessage=r=>{switch(r.data.type){case\"init-wasm\":try{(0,t.initializeWebAssembly)(r.data.in).then((()=>postMessage({type:\"init-wasm\"})),(e=>postMessage({type:\"init-wasm\",err:e})))}catch(e){postMessage({type:\"init-wasm\",err:e})}break;case\"init-ort\":try{(0,e.initRuntime)(r.data.in).then((()=>postMessage({type:\"init-ort\"})),(e=>postMessage({type:\"init-ort\",err:e}))),postMessage({type:\"init-ort\"})}catch(e){postMessage({type:\"init-ort\",err:e})}break;case\"create_allocate\":try{const{model:t}=r.data.in,n=(0,e.createSessionAllocate)(t);postMessage({type:\"create_allocate\",out:n})}catch(e){postMessage({type:\"create_allocate\",err:e})}break;case\"create_finalize\":try{const{modeldata:t,options:n}=r.data.in,a=(0,e.createSessionFinalize)(t,n);postMessage({type:\"create_finalize\",out:a})}catch(e){postMessage({type:\"create_finalize\",err:e})}break;case\"create\":try{const{model:t,options:n}=r.data.in,a=(0,e.createSession)(t,n);postMessage({type:\"create\",out:a})}catch(e){postMessage({type:\"create\",err:e})}break;case\"release\":try{const t=r.data.in;(0,e.releaseSession)(t),postMessage({type:\"release\"})}catch(e){postMessage({type:\"release\",err:e})}break;case\"run\":try{const{sessionId:t,inputIndices:n,inputs:a,outputIndices:o,options:s}=r.data.in;(0,e.run)(t,n,a,o,s).then((t=>{postMessage({type:\"run\",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:\"run\",err:e})}))}catch(e){postMessage({type:\"run\",err:e})}break;case\"end-profiling\":try{const t=r.data.in;(0,e.endProfiling)(t),postMessage({type:\"end-profiling\"})}catch(e){postMessage({type:\"end-profiling\",err:e})}}}})()})();\\n', \"Worker\", void 0, void 0);\n            }\n        },\n        6614: (e1)=>{\n            \"use strict\";\n            e1.exports = function(e1, t1, n1, r1) {\n                var o1 = self || window;\n                try {\n                    try {\n                        var i1;\n                        try {\n                            i1 = new o1.Blob([\n                                e1\n                            ]);\n                        } catch (t1) {\n                            (i1 = new (o1.BlobBuilder || o1.WebKitBlobBuilder || o1.MozBlobBuilder || o1.MSBlobBuilder)).append(e1), i1 = i1.getBlob();\n                        }\n                        var s1 = o1.URL || o1.webkitURL, a1 = s1.createObjectURL(i1), u1 = new o1[t1](a1, n1);\n                        return s1.revokeObjectURL(a1), u1;\n                    } catch (r1) {\n                        return new o1[t1](\"data:application/javascript,\".concat(encodeURIComponent(e1)), n1);\n                    }\n                } catch (e1) {\n                    if (!r1) throw Error(\"Inline worker is not supported\");\n                    return new o1[t1](r1, n1);\n                }\n            };\n        },\n        2446: (e1, t1, n1)=>{\n            \"use strict\";\n            var r1, o1, i1, s1 = n1(2100), a1 = s1.Reader, u1 = s1.Writer, l1 = s1.util, c1 = s1.roots.default || (s1.roots.default = {});\n            c1.onnx = ((i1 = {}).Version = (r1 = {}, (o1 = Object.create(r1))[r1[0] = \"_START_VERSION\"] = 0, o1[r1[1] = \"IR_VERSION_2017_10_10\"] = 1, o1[r1[2] = \"IR_VERSION_2017_10_30\"] = 2, o1[r1[3] = \"IR_VERSION_2017_11_3\"] = 3, o1[r1[4] = \"IR_VERSION_2019_1_22\"] = 4, o1[r1[5] = \"IR_VERSION_2019_3_18\"] = 5, o1[r1[6] = \"IR_VERSION_2019_9_19\"] = 6, o1[r1[7] = \"IR_VERSION_2020_5_8\"] = 7, o1[r1[8] = \"IR_VERSION_2021_7_30\"] = 8, o1[r1[9] = \"IR_VERSION\"] = 9, o1), i1.AttributeProto = function() {\n                function e1(e1) {\n                    if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], this.sparseTensors = [], this.typeProtos = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.name = \"\", e1.prototype.refAttrName = \"\", e1.prototype.docString = \"\", e1.prototype.type = 0, e1.prototype.f = 0, e1.prototype.i = l1.Long ? l1.Long.fromBits(0, 0, !1) : 0, e1.prototype.s = l1.newBuffer([]), e1.prototype.t = null, e1.prototype.g = null, e1.prototype.sparseTensor = null, e1.prototype.tp = null, e1.prototype.floats = l1.emptyArray, e1.prototype.ints = l1.emptyArray, e1.prototype.strings = l1.emptyArray, e1.prototype.tensors = l1.emptyArray, e1.prototype.graphs = l1.emptyArray, e1.prototype.sparseTensors = l1.emptyArray, e1.prototype.typeProtos = l1.emptyArray, e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.name && Object.hasOwnProperty.call(e1, \"name\") && t1.uint32(10).string(e1.name), null != e1.f && Object.hasOwnProperty.call(e1, \"f\") && t1.uint32(21).float(e1.f), null != e1.i && Object.hasOwnProperty.call(e1, \"i\") && t1.uint32(24).int64(e1.i), null != e1.s && Object.hasOwnProperty.call(e1, \"s\") && t1.uint32(34).bytes(e1.s), null != e1.t && Object.hasOwnProperty.call(e1, \"t\") && c1.onnx.TensorProto.encode(e1.t, t1.uint32(42).fork()).ldelim(), null != e1.g && Object.hasOwnProperty.call(e1, \"g\") && c1.onnx.GraphProto.encode(e1.g, t1.uint32(50).fork()).ldelim(), null != e1.floats && e1.floats.length) {\n                        t1.uint32(58).fork();\n                        for(var n1 = 0; n1 < e1.floats.length; ++n1)t1.float(e1.floats[n1]);\n                        t1.ldelim();\n                    }\n                    if (null != e1.ints && e1.ints.length) {\n                        for(t1.uint32(66).fork(), n1 = 0; n1 < e1.ints.length; ++n1)t1.int64(e1.ints[n1]);\n                        t1.ldelim();\n                    }\n                    if (null != e1.strings && e1.strings.length) for(n1 = 0; n1 < e1.strings.length; ++n1)t1.uint32(74).bytes(e1.strings[n1]);\n                    if (null != e1.tensors && e1.tensors.length) for(n1 = 0; n1 < e1.tensors.length; ++n1)c1.onnx.TensorProto.encode(e1.tensors[n1], t1.uint32(82).fork()).ldelim();\n                    if (null != e1.graphs && e1.graphs.length) for(n1 = 0; n1 < e1.graphs.length; ++n1)c1.onnx.GraphProto.encode(e1.graphs[n1], t1.uint32(90).fork()).ldelim();\n                    if (null != e1.docString && Object.hasOwnProperty.call(e1, \"docString\") && t1.uint32(106).string(e1.docString), null != e1.tp && Object.hasOwnProperty.call(e1, \"tp\") && c1.onnx.TypeProto.encode(e1.tp, t1.uint32(114).fork()).ldelim(), null != e1.typeProtos && e1.typeProtos.length) for(n1 = 0; n1 < e1.typeProtos.length; ++n1)c1.onnx.TypeProto.encode(e1.typeProtos[n1], t1.uint32(122).fork()).ldelim();\n                    if (null != e1.type && Object.hasOwnProperty.call(e1, \"type\") && t1.uint32(160).int32(e1.type), null != e1.refAttrName && Object.hasOwnProperty.call(e1, \"refAttrName\") && t1.uint32(170).string(e1.refAttrName), null != e1.sparseTensor && Object.hasOwnProperty.call(e1, \"sparseTensor\") && c1.onnx.SparseTensorProto.encode(e1.sparseTensor, t1.uint32(178).fork()).ldelim(), null != e1.sparseTensors && e1.sparseTensors.length) for(n1 = 0; n1 < e1.sparseTensors.length; ++n1)c1.onnx.SparseTensorProto.encode(e1.sparseTensors[n1], t1.uint32(186).fork()).ldelim();\n                    return t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.AttributeProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.name = e1.string();\n                                break;\n                            case 21:\n                                r1.refAttrName = e1.string();\n                                break;\n                            case 13:\n                                r1.docString = e1.string();\n                                break;\n                            case 20:\n                                r1.type = e1.int32();\n                                break;\n                            case 2:\n                                r1.f = e1.float();\n                                break;\n                            case 3:\n                                r1.i = e1.int64();\n                                break;\n                            case 4:\n                                r1.s = e1.bytes();\n                                break;\n                            case 5:\n                                r1.t = c1.onnx.TensorProto.decode(e1, e1.uint32());\n                                break;\n                            case 6:\n                                r1.g = c1.onnx.GraphProto.decode(e1, e1.uint32());\n                                break;\n                            case 22:\n                                r1.sparseTensor = c1.onnx.SparseTensorProto.decode(e1, e1.uint32());\n                                break;\n                            case 14:\n                                r1.tp = c1.onnx.TypeProto.decode(e1, e1.uint32());\n                                break;\n                            case 7:\n                                if (r1.floats && r1.floats.length || (r1.floats = []), 2 == (7 & o1)) for(var i1 = e1.uint32() + e1.pos; e1.pos < i1;)r1.floats.push(e1.float());\n                                else r1.floats.push(e1.float());\n                                break;\n                            case 8:\n                                if (r1.ints && r1.ints.length || (r1.ints = []), 2 == (7 & o1)) for(i1 = e1.uint32() + e1.pos; e1.pos < i1;)r1.ints.push(e1.int64());\n                                else r1.ints.push(e1.int64());\n                                break;\n                            case 9:\n                                r1.strings && r1.strings.length || (r1.strings = []), r1.strings.push(e1.bytes());\n                                break;\n                            case 10:\n                                r1.tensors && r1.tensors.length || (r1.tensors = []), r1.tensors.push(c1.onnx.TensorProto.decode(e1, e1.uint32()));\n                                break;\n                            case 11:\n                                r1.graphs && r1.graphs.length || (r1.graphs = []), r1.graphs.push(c1.onnx.GraphProto.decode(e1, e1.uint32()));\n                                break;\n                            case 23:\n                                r1.sparseTensors && r1.sparseTensors.length || (r1.sparseTensors = []), r1.sparseTensors.push(c1.onnx.SparseTensorProto.decode(e1, e1.uint32()));\n                                break;\n                            case 15:\n                                r1.typeProtos && r1.typeProtos.length || (r1.typeProtos = []), r1.typeProtos.push(c1.onnx.TypeProto.decode(e1, e1.uint32()));\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && !l1.isString(e1.name)) return \"name: string expected\";\n                    if (null != e1.refAttrName && e1.hasOwnProperty(\"refAttrName\") && !l1.isString(e1.refAttrName)) return \"refAttrName: string expected\";\n                    if (null != e1.docString && e1.hasOwnProperty(\"docString\") && !l1.isString(e1.docString)) return \"docString: string expected\";\n                    if (null != e1.type && e1.hasOwnProperty(\"type\")) switch(e1.type){\n                        default:\n                            return \"type: enum value expected\";\n                        case 0:\n                        case 1:\n                        case 2:\n                        case 3:\n                        case 4:\n                        case 5:\n                        case 11:\n                        case 13:\n                        case 6:\n                        case 7:\n                        case 8:\n                        case 9:\n                        case 10:\n                        case 12:\n                        case 14:\n                    }\n                    if (null != e1.f && e1.hasOwnProperty(\"f\") && \"number\" != typeof e1.f) return \"f: number expected\";\n                    if (null != e1.i && e1.hasOwnProperty(\"i\") && !(l1.isInteger(e1.i) || e1.i && l1.isInteger(e1.i.low) && l1.isInteger(e1.i.high))) return \"i: integer|Long expected\";\n                    if (null != e1.s && e1.hasOwnProperty(\"s\") && !(e1.s && \"number\" == typeof e1.s.length || l1.isString(e1.s))) return \"s: buffer expected\";\n                    if (null != e1.t && e1.hasOwnProperty(\"t\") && (n1 = c1.onnx.TensorProto.verify(e1.t))) return \"t.\" + n1;\n                    if (null != e1.g && e1.hasOwnProperty(\"g\") && (n1 = c1.onnx.GraphProto.verify(e1.g))) return \"g.\" + n1;\n                    if (null != e1.sparseTensor && e1.hasOwnProperty(\"sparseTensor\") && (n1 = c1.onnx.SparseTensorProto.verify(e1.sparseTensor))) return \"sparseTensor.\" + n1;\n                    if (null != e1.tp && e1.hasOwnProperty(\"tp\") && (n1 = c1.onnx.TypeProto.verify(e1.tp))) return \"tp.\" + n1;\n                    if (null != e1.floats && e1.hasOwnProperty(\"floats\")) {\n                        if (!Array.isArray(e1.floats)) return \"floats: array expected\";\n                        for(var t1 = 0; t1 < e1.floats.length; ++t1)if (\"number\" != typeof e1.floats[t1]) return \"floats: number[] expected\";\n                    }\n                    if (null != e1.ints && e1.hasOwnProperty(\"ints\")) {\n                        if (!Array.isArray(e1.ints)) return \"ints: array expected\";\n                        for(t1 = 0; t1 < e1.ints.length; ++t1)if (!(l1.isInteger(e1.ints[t1]) || e1.ints[t1] && l1.isInteger(e1.ints[t1].low) && l1.isInteger(e1.ints[t1].high))) return \"ints: integer|Long[] expected\";\n                    }\n                    if (null != e1.strings && e1.hasOwnProperty(\"strings\")) {\n                        if (!Array.isArray(e1.strings)) return \"strings: array expected\";\n                        for(t1 = 0; t1 < e1.strings.length; ++t1)if (!(e1.strings[t1] && \"number\" == typeof e1.strings[t1].length || l1.isString(e1.strings[t1]))) return \"strings: buffer[] expected\";\n                    }\n                    if (null != e1.tensors && e1.hasOwnProperty(\"tensors\")) {\n                        if (!Array.isArray(e1.tensors)) return \"tensors: array expected\";\n                        for(t1 = 0; t1 < e1.tensors.length; ++t1)if (n1 = c1.onnx.TensorProto.verify(e1.tensors[t1])) return \"tensors.\" + n1;\n                    }\n                    if (null != e1.graphs && e1.hasOwnProperty(\"graphs\")) {\n                        if (!Array.isArray(e1.graphs)) return \"graphs: array expected\";\n                        for(t1 = 0; t1 < e1.graphs.length; ++t1)if (n1 = c1.onnx.GraphProto.verify(e1.graphs[t1])) return \"graphs.\" + n1;\n                    }\n                    if (null != e1.sparseTensors && e1.hasOwnProperty(\"sparseTensors\")) {\n                        if (!Array.isArray(e1.sparseTensors)) return \"sparseTensors: array expected\";\n                        for(t1 = 0; t1 < e1.sparseTensors.length; ++t1)if (n1 = c1.onnx.SparseTensorProto.verify(e1.sparseTensors[t1])) return \"sparseTensors.\" + n1;\n                    }\n                    if (null != e1.typeProtos && e1.hasOwnProperty(\"typeProtos\")) {\n                        if (!Array.isArray(e1.typeProtos)) return \"typeProtos: array expected\";\n                        for(t1 = 0; t1 < e1.typeProtos.length; ++t1){\n                            var n1;\n                            if (n1 = c1.onnx.TypeProto.verify(e1.typeProtos[t1])) return \"typeProtos.\" + n1;\n                        }\n                    }\n                    return null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.AttributeProto) return e1;\n                    var t1 = new c1.onnx.AttributeProto;\n                    switch(null != e1.name && (t1.name = String(e1.name)), null != e1.refAttrName && (t1.refAttrName = String(e1.refAttrName)), null != e1.docString && (t1.docString = String(e1.docString)), e1.type){\n                        default:\n                            if (\"number\" == typeof e1.type) {\n                                t1.type = e1.type;\n                                break;\n                            }\n                            break;\n                        case \"UNDEFINED\":\n                        case 0:\n                            t1.type = 0;\n                            break;\n                        case \"FLOAT\":\n                        case 1:\n                            t1.type = 1;\n                            break;\n                        case \"INT\":\n                        case 2:\n                            t1.type = 2;\n                            break;\n                        case \"STRING\":\n                        case 3:\n                            t1.type = 3;\n                            break;\n                        case \"TENSOR\":\n                        case 4:\n                            t1.type = 4;\n                            break;\n                        case \"GRAPH\":\n                        case 5:\n                            t1.type = 5;\n                            break;\n                        case \"SPARSE_TENSOR\":\n                        case 11:\n                            t1.type = 11;\n                            break;\n                        case \"TYPE_PROTO\":\n                        case 13:\n                            t1.type = 13;\n                            break;\n                        case \"FLOATS\":\n                        case 6:\n                            t1.type = 6;\n                            break;\n                        case \"INTS\":\n                        case 7:\n                            t1.type = 7;\n                            break;\n                        case \"STRINGS\":\n                        case 8:\n                            t1.type = 8;\n                            break;\n                        case \"TENSORS\":\n                        case 9:\n                            t1.type = 9;\n                            break;\n                        case \"GRAPHS\":\n                        case 10:\n                            t1.type = 10;\n                            break;\n                        case \"SPARSE_TENSORS\":\n                        case 12:\n                            t1.type = 12;\n                            break;\n                        case \"TYPE_PROTOS\":\n                        case 14:\n                            t1.type = 14;\n                    }\n                    if (null != e1.f && (t1.f = Number(e1.f)), null != e1.i && (l1.Long ? (t1.i = l1.Long.fromValue(e1.i)).unsigned = !1 : \"string\" == typeof e1.i ? t1.i = parseInt(e1.i, 10) : \"number\" == typeof e1.i ? t1.i = e1.i : \"object\" == typeof e1.i && (t1.i = new l1.LongBits(e1.i.low >>> 0, e1.i.high >>> 0).toNumber())), null != e1.s && (\"string\" == typeof e1.s ? l1.base64.decode(e1.s, t1.s = l1.newBuffer(l1.base64.length(e1.s)), 0) : e1.s.length >= 0 && (t1.s = e1.s)), null != e1.t) {\n                        if (\"object\" != typeof e1.t) throw TypeError(\".onnx.AttributeProto.t: object expected\");\n                        t1.t = c1.onnx.TensorProto.fromObject(e1.t);\n                    }\n                    if (null != e1.g) {\n                        if (\"object\" != typeof e1.g) throw TypeError(\".onnx.AttributeProto.g: object expected\");\n                        t1.g = c1.onnx.GraphProto.fromObject(e1.g);\n                    }\n                    if (null != e1.sparseTensor) {\n                        if (\"object\" != typeof e1.sparseTensor) throw TypeError(\".onnx.AttributeProto.sparseTensor: object expected\");\n                        t1.sparseTensor = c1.onnx.SparseTensorProto.fromObject(e1.sparseTensor);\n                    }\n                    if (null != e1.tp) {\n                        if (\"object\" != typeof e1.tp) throw TypeError(\".onnx.AttributeProto.tp: object expected\");\n                        t1.tp = c1.onnx.TypeProto.fromObject(e1.tp);\n                    }\n                    if (e1.floats) {\n                        if (!Array.isArray(e1.floats)) throw TypeError(\".onnx.AttributeProto.floats: array expected\");\n                        t1.floats = [];\n                        for(var n1 = 0; n1 < e1.floats.length; ++n1)t1.floats[n1] = Number(e1.floats[n1]);\n                    }\n                    if (e1.ints) {\n                        if (!Array.isArray(e1.ints)) throw TypeError(\".onnx.AttributeProto.ints: array expected\");\n                        for(t1.ints = [], n1 = 0; n1 < e1.ints.length; ++n1)l1.Long ? (t1.ints[n1] = l1.Long.fromValue(e1.ints[n1])).unsigned = !1 : \"string\" == typeof e1.ints[n1] ? t1.ints[n1] = parseInt(e1.ints[n1], 10) : \"number\" == typeof e1.ints[n1] ? t1.ints[n1] = e1.ints[n1] : \"object\" == typeof e1.ints[n1] && (t1.ints[n1] = new l1.LongBits(e1.ints[n1].low >>> 0, e1.ints[n1].high >>> 0).toNumber());\n                    }\n                    if (e1.strings) {\n                        if (!Array.isArray(e1.strings)) throw TypeError(\".onnx.AttributeProto.strings: array expected\");\n                        for(t1.strings = [], n1 = 0; n1 < e1.strings.length; ++n1)\"string\" == typeof e1.strings[n1] ? l1.base64.decode(e1.strings[n1], t1.strings[n1] = l1.newBuffer(l1.base64.length(e1.strings[n1])), 0) : e1.strings[n1].length >= 0 && (t1.strings[n1] = e1.strings[n1]);\n                    }\n                    if (e1.tensors) {\n                        if (!Array.isArray(e1.tensors)) throw TypeError(\".onnx.AttributeProto.tensors: array expected\");\n                        for(t1.tensors = [], n1 = 0; n1 < e1.tensors.length; ++n1){\n                            if (\"object\" != typeof e1.tensors[n1]) throw TypeError(\".onnx.AttributeProto.tensors: object expected\");\n                            t1.tensors[n1] = c1.onnx.TensorProto.fromObject(e1.tensors[n1]);\n                        }\n                    }\n                    if (e1.graphs) {\n                        if (!Array.isArray(e1.graphs)) throw TypeError(\".onnx.AttributeProto.graphs: array expected\");\n                        for(t1.graphs = [], n1 = 0; n1 < e1.graphs.length; ++n1){\n                            if (\"object\" != typeof e1.graphs[n1]) throw TypeError(\".onnx.AttributeProto.graphs: object expected\");\n                            t1.graphs[n1] = c1.onnx.GraphProto.fromObject(e1.graphs[n1]);\n                        }\n                    }\n                    if (e1.sparseTensors) {\n                        if (!Array.isArray(e1.sparseTensors)) throw TypeError(\".onnx.AttributeProto.sparseTensors: array expected\");\n                        for(t1.sparseTensors = [], n1 = 0; n1 < e1.sparseTensors.length; ++n1){\n                            if (\"object\" != typeof e1.sparseTensors[n1]) throw TypeError(\".onnx.AttributeProto.sparseTensors: object expected\");\n                            t1.sparseTensors[n1] = c1.onnx.SparseTensorProto.fromObject(e1.sparseTensors[n1]);\n                        }\n                    }\n                    if (e1.typeProtos) {\n                        if (!Array.isArray(e1.typeProtos)) throw TypeError(\".onnx.AttributeProto.typeProtos: array expected\");\n                        for(t1.typeProtos = [], n1 = 0; n1 < e1.typeProtos.length; ++n1){\n                            if (\"object\" != typeof e1.typeProtos[n1]) throw TypeError(\".onnx.AttributeProto.typeProtos: object expected\");\n                            t1.typeProtos[n1] = c1.onnx.TypeProto.fromObject(e1.typeProtos[n1]);\n                        }\n                    }\n                    return t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.floats = [], n1.ints = [], n1.strings = [], n1.tensors = [], n1.graphs = [], n1.typeProtos = [], n1.sparseTensors = []), t1.defaults) {\n                        if (n1.name = \"\", n1.f = 0, l1.Long) {\n                            var r1 = new l1.Long(0, 0, !1);\n                            n1.i = t1.longs === String ? r1.toString() : t1.longs === Number ? r1.toNumber() : r1;\n                        } else n1.i = t1.longs === String ? \"0\" : 0;\n                        t1.bytes === String ? n1.s = \"\" : (n1.s = [], t1.bytes !== Array && (n1.s = l1.newBuffer(n1.s))), n1.t = null, n1.g = null, n1.docString = \"\", n1.tp = null, n1.type = t1.enums === String ? \"UNDEFINED\" : 0, n1.refAttrName = \"\", n1.sparseTensor = null;\n                    }\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && (n1.name = e1.name), null != e1.f && e1.hasOwnProperty(\"f\") && (n1.f = t1.json && !isFinite(e1.f) ? String(e1.f) : e1.f), null != e1.i && e1.hasOwnProperty(\"i\") && (\"number\" == typeof e1.i ? n1.i = t1.longs === String ? String(e1.i) : e1.i : n1.i = t1.longs === String ? l1.Long.prototype.toString.call(e1.i) : t1.longs === Number ? new l1.LongBits(e1.i.low >>> 0, e1.i.high >>> 0).toNumber() : e1.i), null != e1.s && e1.hasOwnProperty(\"s\") && (n1.s = t1.bytes === String ? l1.base64.encode(e1.s, 0, e1.s.length) : t1.bytes === Array ? Array.prototype.slice.call(e1.s) : e1.s), null != e1.t && e1.hasOwnProperty(\"t\") && (n1.t = c1.onnx.TensorProto.toObject(e1.t, t1)), null != e1.g && e1.hasOwnProperty(\"g\") && (n1.g = c1.onnx.GraphProto.toObject(e1.g, t1)), e1.floats && e1.floats.length) {\n                        n1.floats = [];\n                        for(var o1 = 0; o1 < e1.floats.length; ++o1)n1.floats[o1] = t1.json && !isFinite(e1.floats[o1]) ? String(e1.floats[o1]) : e1.floats[o1];\n                    }\n                    if (e1.ints && e1.ints.length) for(n1.ints = [], o1 = 0; o1 < e1.ints.length; ++o1)\"number\" == typeof e1.ints[o1] ? n1.ints[o1] = t1.longs === String ? String(e1.ints[o1]) : e1.ints[o1] : n1.ints[o1] = t1.longs === String ? l1.Long.prototype.toString.call(e1.ints[o1]) : t1.longs === Number ? new l1.LongBits(e1.ints[o1].low >>> 0, e1.ints[o1].high >>> 0).toNumber() : e1.ints[o1];\n                    if (e1.strings && e1.strings.length) for(n1.strings = [], o1 = 0; o1 < e1.strings.length; ++o1)n1.strings[o1] = t1.bytes === String ? l1.base64.encode(e1.strings[o1], 0, e1.strings[o1].length) : t1.bytes === Array ? Array.prototype.slice.call(e1.strings[o1]) : e1.strings[o1];\n                    if (e1.tensors && e1.tensors.length) for(n1.tensors = [], o1 = 0; o1 < e1.tensors.length; ++o1)n1.tensors[o1] = c1.onnx.TensorProto.toObject(e1.tensors[o1], t1);\n                    if (e1.graphs && e1.graphs.length) for(n1.graphs = [], o1 = 0; o1 < e1.graphs.length; ++o1)n1.graphs[o1] = c1.onnx.GraphProto.toObject(e1.graphs[o1], t1);\n                    if (null != e1.docString && e1.hasOwnProperty(\"docString\") && (n1.docString = e1.docString), null != e1.tp && e1.hasOwnProperty(\"tp\") && (n1.tp = c1.onnx.TypeProto.toObject(e1.tp, t1)), e1.typeProtos && e1.typeProtos.length) for(n1.typeProtos = [], o1 = 0; o1 < e1.typeProtos.length; ++o1)n1.typeProtos[o1] = c1.onnx.TypeProto.toObject(e1.typeProtos[o1], t1);\n                    if (null != e1.type && e1.hasOwnProperty(\"type\") && (n1.type = t1.enums === String ? void 0 === c1.onnx.AttributeProto.AttributeType[e1.type] ? e1.type : c1.onnx.AttributeProto.AttributeType[e1.type] : e1.type), null != e1.refAttrName && e1.hasOwnProperty(\"refAttrName\") && (n1.refAttrName = e1.refAttrName), null != e1.sparseTensor && e1.hasOwnProperty(\"sparseTensor\") && (n1.sparseTensor = c1.onnx.SparseTensorProto.toObject(e1.sparseTensor, t1)), e1.sparseTensors && e1.sparseTensors.length) for(n1.sparseTensors = [], o1 = 0; o1 < e1.sparseTensors.length; ++o1)n1.sparseTensors[o1] = c1.onnx.SparseTensorProto.toObject(e1.sparseTensors[o1], t1);\n                    return n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.AttributeProto\";\n                }, e1.AttributeType = function() {\n                    var e1 = {}, t1 = Object.create(e1);\n                    return t1[e1[0] = \"UNDEFINED\"] = 0, t1[e1[1] = \"FLOAT\"] = 1, t1[e1[2] = \"INT\"] = 2, t1[e1[3] = \"STRING\"] = 3, t1[e1[4] = \"TENSOR\"] = 4, t1[e1[5] = \"GRAPH\"] = 5, t1[e1[11] = \"SPARSE_TENSOR\"] = 11, t1[e1[13] = \"TYPE_PROTO\"] = 13, t1[e1[6] = \"FLOATS\"] = 6, t1[e1[7] = \"INTS\"] = 7, t1[e1[8] = \"STRINGS\"] = 8, t1[e1[9] = \"TENSORS\"] = 9, t1[e1[10] = \"GRAPHS\"] = 10, t1[e1[12] = \"SPARSE_TENSORS\"] = 12, t1[e1[14] = \"TYPE_PROTOS\"] = 14, t1;\n                }(), e1;\n            }(), i1.ValueInfoProto = function() {\n                function e1(e1) {\n                    if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.name = \"\", e1.prototype.type = null, e1.prototype.docString = \"\", e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    return t1 || (t1 = u1.create()), null != e1.name && Object.hasOwnProperty.call(e1, \"name\") && t1.uint32(10).string(e1.name), null != e1.type && Object.hasOwnProperty.call(e1, \"type\") && c1.onnx.TypeProto.encode(e1.type, t1.uint32(18).fork()).ldelim(), null != e1.docString && Object.hasOwnProperty.call(e1, \"docString\") && t1.uint32(26).string(e1.docString), t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.ValueInfoProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.name = e1.string();\n                                break;\n                            case 2:\n                                r1.type = c1.onnx.TypeProto.decode(e1, e1.uint32());\n                                break;\n                            case 3:\n                                r1.docString = e1.string();\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && !l1.isString(e1.name)) return \"name: string expected\";\n                    if (null != e1.type && e1.hasOwnProperty(\"type\")) {\n                        var t1 = c1.onnx.TypeProto.verify(e1.type);\n                        if (t1) return \"type.\" + t1;\n                    }\n                    return null != e1.docString && e1.hasOwnProperty(\"docString\") && !l1.isString(e1.docString) ? \"docString: string expected\" : null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.ValueInfoProto) return e1;\n                    var t1 = new c1.onnx.ValueInfoProto;\n                    if (null != e1.name && (t1.name = String(e1.name)), null != e1.type) {\n                        if (\"object\" != typeof e1.type) throw TypeError(\".onnx.ValueInfoProto.type: object expected\");\n                        t1.type = c1.onnx.TypeProto.fromObject(e1.type);\n                    }\n                    return null != e1.docString && (t1.docString = String(e1.docString)), t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    return t1.defaults && (n1.name = \"\", n1.type = null, n1.docString = \"\"), null != e1.name && e1.hasOwnProperty(\"name\") && (n1.name = e1.name), null != e1.type && e1.hasOwnProperty(\"type\") && (n1.type = c1.onnx.TypeProto.toObject(e1.type, t1)), null != e1.docString && e1.hasOwnProperty(\"docString\") && (n1.docString = e1.docString), n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.ValueInfoProto\";\n                }, e1;\n            }(), i1.NodeProto = function() {\n                function e1(e1) {\n                    if (this.input = [], this.output = [], this.attribute = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.input = l1.emptyArray, e1.prototype.output = l1.emptyArray, e1.prototype.name = \"\", e1.prototype.opType = \"\", e1.prototype.domain = \"\", e1.prototype.attribute = l1.emptyArray, e1.prototype.docString = \"\", e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.input && e1.input.length) for(var n1 = 0; n1 < e1.input.length; ++n1)t1.uint32(10).string(e1.input[n1]);\n                    if (null != e1.output && e1.output.length) for(n1 = 0; n1 < e1.output.length; ++n1)t1.uint32(18).string(e1.output[n1]);\n                    if (null != e1.name && Object.hasOwnProperty.call(e1, \"name\") && t1.uint32(26).string(e1.name), null != e1.opType && Object.hasOwnProperty.call(e1, \"opType\") && t1.uint32(34).string(e1.opType), null != e1.attribute && e1.attribute.length) for(n1 = 0; n1 < e1.attribute.length; ++n1)c1.onnx.AttributeProto.encode(e1.attribute[n1], t1.uint32(42).fork()).ldelim();\n                    return null != e1.docString && Object.hasOwnProperty.call(e1, \"docString\") && t1.uint32(50).string(e1.docString), null != e1.domain && Object.hasOwnProperty.call(e1, \"domain\") && t1.uint32(58).string(e1.domain), t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.NodeProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.input && r1.input.length || (r1.input = []), r1.input.push(e1.string());\n                                break;\n                            case 2:\n                                r1.output && r1.output.length || (r1.output = []), r1.output.push(e1.string());\n                                break;\n                            case 3:\n                                r1.name = e1.string();\n                                break;\n                            case 4:\n                                r1.opType = e1.string();\n                                break;\n                            case 7:\n                                r1.domain = e1.string();\n                                break;\n                            case 5:\n                                r1.attribute && r1.attribute.length || (r1.attribute = []), r1.attribute.push(c1.onnx.AttributeProto.decode(e1, e1.uint32()));\n                                break;\n                            case 6:\n                                r1.docString = e1.string();\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.input && e1.hasOwnProperty(\"input\")) {\n                        if (!Array.isArray(e1.input)) return \"input: array expected\";\n                        for(var t1 = 0; t1 < e1.input.length; ++t1)if (!l1.isString(e1.input[t1])) return \"input: string[] expected\";\n                    }\n                    if (null != e1.output && e1.hasOwnProperty(\"output\")) {\n                        if (!Array.isArray(e1.output)) return \"output: array expected\";\n                        for(t1 = 0; t1 < e1.output.length; ++t1)if (!l1.isString(e1.output[t1])) return \"output: string[] expected\";\n                    }\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && !l1.isString(e1.name)) return \"name: string expected\";\n                    if (null != e1.opType && e1.hasOwnProperty(\"opType\") && !l1.isString(e1.opType)) return \"opType: string expected\";\n                    if (null != e1.domain && e1.hasOwnProperty(\"domain\") && !l1.isString(e1.domain)) return \"domain: string expected\";\n                    if (null != e1.attribute && e1.hasOwnProperty(\"attribute\")) {\n                        if (!Array.isArray(e1.attribute)) return \"attribute: array expected\";\n                        for(t1 = 0; t1 < e1.attribute.length; ++t1){\n                            var n1 = c1.onnx.AttributeProto.verify(e1.attribute[t1]);\n                            if (n1) return \"attribute.\" + n1;\n                        }\n                    }\n                    return null != e1.docString && e1.hasOwnProperty(\"docString\") && !l1.isString(e1.docString) ? \"docString: string expected\" : null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.NodeProto) return e1;\n                    var t1 = new c1.onnx.NodeProto;\n                    if (e1.input) {\n                        if (!Array.isArray(e1.input)) throw TypeError(\".onnx.NodeProto.input: array expected\");\n                        t1.input = [];\n                        for(var n1 = 0; n1 < e1.input.length; ++n1)t1.input[n1] = String(e1.input[n1]);\n                    }\n                    if (e1.output) {\n                        if (!Array.isArray(e1.output)) throw TypeError(\".onnx.NodeProto.output: array expected\");\n                        for(t1.output = [], n1 = 0; n1 < e1.output.length; ++n1)t1.output[n1] = String(e1.output[n1]);\n                    }\n                    if (null != e1.name && (t1.name = String(e1.name)), null != e1.opType && (t1.opType = String(e1.opType)), null != e1.domain && (t1.domain = String(e1.domain)), e1.attribute) {\n                        if (!Array.isArray(e1.attribute)) throw TypeError(\".onnx.NodeProto.attribute: array expected\");\n                        for(t1.attribute = [], n1 = 0; n1 < e1.attribute.length; ++n1){\n                            if (\"object\" != typeof e1.attribute[n1]) throw TypeError(\".onnx.NodeProto.attribute: object expected\");\n                            t1.attribute[n1] = c1.onnx.AttributeProto.fromObject(e1.attribute[n1]);\n                        }\n                    }\n                    return null != e1.docString && (t1.docString = String(e1.docString)), t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.input = [], n1.output = [], n1.attribute = []), t1.defaults && (n1.name = \"\", n1.opType = \"\", n1.docString = \"\", n1.domain = \"\"), e1.input && e1.input.length) {\n                        n1.input = [];\n                        for(var r1 = 0; r1 < e1.input.length; ++r1)n1.input[r1] = e1.input[r1];\n                    }\n                    if (e1.output && e1.output.length) for(n1.output = [], r1 = 0; r1 < e1.output.length; ++r1)n1.output[r1] = e1.output[r1];\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && (n1.name = e1.name), null != e1.opType && e1.hasOwnProperty(\"opType\") && (n1.opType = e1.opType), e1.attribute && e1.attribute.length) for(n1.attribute = [], r1 = 0; r1 < e1.attribute.length; ++r1)n1.attribute[r1] = c1.onnx.AttributeProto.toObject(e1.attribute[r1], t1);\n                    return null != e1.docString && e1.hasOwnProperty(\"docString\") && (n1.docString = e1.docString), null != e1.domain && e1.hasOwnProperty(\"domain\") && (n1.domain = e1.domain), n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.NodeProto\";\n                }, e1;\n            }(), i1.TrainingInfoProto = function() {\n                function e1(e1) {\n                    if (this.initializationBinding = [], this.updateBinding = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.initialization = null, e1.prototype.algorithm = null, e1.prototype.initializationBinding = l1.emptyArray, e1.prototype.updateBinding = l1.emptyArray, e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.initialization && Object.hasOwnProperty.call(e1, \"initialization\") && c1.onnx.GraphProto.encode(e1.initialization, t1.uint32(10).fork()).ldelim(), null != e1.algorithm && Object.hasOwnProperty.call(e1, \"algorithm\") && c1.onnx.GraphProto.encode(e1.algorithm, t1.uint32(18).fork()).ldelim(), null != e1.initializationBinding && e1.initializationBinding.length) for(var n1 = 0; n1 < e1.initializationBinding.length; ++n1)c1.onnx.StringStringEntryProto.encode(e1.initializationBinding[n1], t1.uint32(26).fork()).ldelim();\n                    if (null != e1.updateBinding && e1.updateBinding.length) for(n1 = 0; n1 < e1.updateBinding.length; ++n1)c1.onnx.StringStringEntryProto.encode(e1.updateBinding[n1], t1.uint32(34).fork()).ldelim();\n                    return t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TrainingInfoProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.initialization = c1.onnx.GraphProto.decode(e1, e1.uint32());\n                                break;\n                            case 2:\n                                r1.algorithm = c1.onnx.GraphProto.decode(e1, e1.uint32());\n                                break;\n                            case 3:\n                                r1.initializationBinding && r1.initializationBinding.length || (r1.initializationBinding = []), r1.initializationBinding.push(c1.onnx.StringStringEntryProto.decode(e1, e1.uint32()));\n                                break;\n                            case 4:\n                                r1.updateBinding && r1.updateBinding.length || (r1.updateBinding = []), r1.updateBinding.push(c1.onnx.StringStringEntryProto.decode(e1, e1.uint32()));\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.initialization && e1.hasOwnProperty(\"initialization\") && (n1 = c1.onnx.GraphProto.verify(e1.initialization))) return \"initialization.\" + n1;\n                    if (null != e1.algorithm && e1.hasOwnProperty(\"algorithm\") && (n1 = c1.onnx.GraphProto.verify(e1.algorithm))) return \"algorithm.\" + n1;\n                    if (null != e1.initializationBinding && e1.hasOwnProperty(\"initializationBinding\")) {\n                        if (!Array.isArray(e1.initializationBinding)) return \"initializationBinding: array expected\";\n                        for(var t1 = 0; t1 < e1.initializationBinding.length; ++t1)if (n1 = c1.onnx.StringStringEntryProto.verify(e1.initializationBinding[t1])) return \"initializationBinding.\" + n1;\n                    }\n                    if (null != e1.updateBinding && e1.hasOwnProperty(\"updateBinding\")) {\n                        if (!Array.isArray(e1.updateBinding)) return \"updateBinding: array expected\";\n                        for(t1 = 0; t1 < e1.updateBinding.length; ++t1){\n                            var n1;\n                            if (n1 = c1.onnx.StringStringEntryProto.verify(e1.updateBinding[t1])) return \"updateBinding.\" + n1;\n                        }\n                    }\n                    return null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.TrainingInfoProto) return e1;\n                    var t1 = new c1.onnx.TrainingInfoProto;\n                    if (null != e1.initialization) {\n                        if (\"object\" != typeof e1.initialization) throw TypeError(\".onnx.TrainingInfoProto.initialization: object expected\");\n                        t1.initialization = c1.onnx.GraphProto.fromObject(e1.initialization);\n                    }\n                    if (null != e1.algorithm) {\n                        if (\"object\" != typeof e1.algorithm) throw TypeError(\".onnx.TrainingInfoProto.algorithm: object expected\");\n                        t1.algorithm = c1.onnx.GraphProto.fromObject(e1.algorithm);\n                    }\n                    if (e1.initializationBinding) {\n                        if (!Array.isArray(e1.initializationBinding)) throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: array expected\");\n                        t1.initializationBinding = [];\n                        for(var n1 = 0; n1 < e1.initializationBinding.length; ++n1){\n                            if (\"object\" != typeof e1.initializationBinding[n1]) throw TypeError(\".onnx.TrainingInfoProto.initializationBinding: object expected\");\n                            t1.initializationBinding[n1] = c1.onnx.StringStringEntryProto.fromObject(e1.initializationBinding[n1]);\n                        }\n                    }\n                    if (e1.updateBinding) {\n                        if (!Array.isArray(e1.updateBinding)) throw TypeError(\".onnx.TrainingInfoProto.updateBinding: array expected\");\n                        for(t1.updateBinding = [], n1 = 0; n1 < e1.updateBinding.length; ++n1){\n                            if (\"object\" != typeof e1.updateBinding[n1]) throw TypeError(\".onnx.TrainingInfoProto.updateBinding: object expected\");\n                            t1.updateBinding[n1] = c1.onnx.StringStringEntryProto.fromObject(e1.updateBinding[n1]);\n                        }\n                    }\n                    return t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.initializationBinding = [], n1.updateBinding = []), t1.defaults && (n1.initialization = null, n1.algorithm = null), null != e1.initialization && e1.hasOwnProperty(\"initialization\") && (n1.initialization = c1.onnx.GraphProto.toObject(e1.initialization, t1)), null != e1.algorithm && e1.hasOwnProperty(\"algorithm\") && (n1.algorithm = c1.onnx.GraphProto.toObject(e1.algorithm, t1)), e1.initializationBinding && e1.initializationBinding.length) {\n                        n1.initializationBinding = [];\n                        for(var r1 = 0; r1 < e1.initializationBinding.length; ++r1)n1.initializationBinding[r1] = c1.onnx.StringStringEntryProto.toObject(e1.initializationBinding[r1], t1);\n                    }\n                    if (e1.updateBinding && e1.updateBinding.length) for(n1.updateBinding = [], r1 = 0; r1 < e1.updateBinding.length; ++r1)n1.updateBinding[r1] = c1.onnx.StringStringEntryProto.toObject(e1.updateBinding[r1], t1);\n                    return n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TrainingInfoProto\";\n                }, e1;\n            }(), i1.ModelProto = function() {\n                function e1(e1) {\n                    if (this.opsetImport = [], this.metadataProps = [], this.trainingInfo = [], this.functions = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.irVersion = l1.Long ? l1.Long.fromBits(0, 0, !1) : 0, e1.prototype.opsetImport = l1.emptyArray, e1.prototype.producerName = \"\", e1.prototype.producerVersion = \"\", e1.prototype.domain = \"\", e1.prototype.modelVersion = l1.Long ? l1.Long.fromBits(0, 0, !1) : 0, e1.prototype.docString = \"\", e1.prototype.graph = null, e1.prototype.metadataProps = l1.emptyArray, e1.prototype.trainingInfo = l1.emptyArray, e1.prototype.functions = l1.emptyArray, e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.irVersion && Object.hasOwnProperty.call(e1, \"irVersion\") && t1.uint32(8).int64(e1.irVersion), null != e1.producerName && Object.hasOwnProperty.call(e1, \"producerName\") && t1.uint32(18).string(e1.producerName), null != e1.producerVersion && Object.hasOwnProperty.call(e1, \"producerVersion\") && t1.uint32(26).string(e1.producerVersion), null != e1.domain && Object.hasOwnProperty.call(e1, \"domain\") && t1.uint32(34).string(e1.domain), null != e1.modelVersion && Object.hasOwnProperty.call(e1, \"modelVersion\") && t1.uint32(40).int64(e1.modelVersion), null != e1.docString && Object.hasOwnProperty.call(e1, \"docString\") && t1.uint32(50).string(e1.docString), null != e1.graph && Object.hasOwnProperty.call(e1, \"graph\") && c1.onnx.GraphProto.encode(e1.graph, t1.uint32(58).fork()).ldelim(), null != e1.opsetImport && e1.opsetImport.length) for(var n1 = 0; n1 < e1.opsetImport.length; ++n1)c1.onnx.OperatorSetIdProto.encode(e1.opsetImport[n1], t1.uint32(66).fork()).ldelim();\n                    if (null != e1.metadataProps && e1.metadataProps.length) for(n1 = 0; n1 < e1.metadataProps.length; ++n1)c1.onnx.StringStringEntryProto.encode(e1.metadataProps[n1], t1.uint32(114).fork()).ldelim();\n                    if (null != e1.trainingInfo && e1.trainingInfo.length) for(n1 = 0; n1 < e1.trainingInfo.length; ++n1)c1.onnx.TrainingInfoProto.encode(e1.trainingInfo[n1], t1.uint32(162).fork()).ldelim();\n                    if (null != e1.functions && e1.functions.length) for(n1 = 0; n1 < e1.functions.length; ++n1)c1.onnx.FunctionProto.encode(e1.functions[n1], t1.uint32(202).fork()).ldelim();\n                    return t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.ModelProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.irVersion = e1.int64();\n                                break;\n                            case 8:\n                                r1.opsetImport && r1.opsetImport.length || (r1.opsetImport = []), r1.opsetImport.push(c1.onnx.OperatorSetIdProto.decode(e1, e1.uint32()));\n                                break;\n                            case 2:\n                                r1.producerName = e1.string();\n                                break;\n                            case 3:\n                                r1.producerVersion = e1.string();\n                                break;\n                            case 4:\n                                r1.domain = e1.string();\n                                break;\n                            case 5:\n                                r1.modelVersion = e1.int64();\n                                break;\n                            case 6:\n                                r1.docString = e1.string();\n                                break;\n                            case 7:\n                                r1.graph = c1.onnx.GraphProto.decode(e1, e1.uint32());\n                                break;\n                            case 14:\n                                r1.metadataProps && r1.metadataProps.length || (r1.metadataProps = []), r1.metadataProps.push(c1.onnx.StringStringEntryProto.decode(e1, e1.uint32()));\n                                break;\n                            case 20:\n                                r1.trainingInfo && r1.trainingInfo.length || (r1.trainingInfo = []), r1.trainingInfo.push(c1.onnx.TrainingInfoProto.decode(e1, e1.uint32()));\n                                break;\n                            case 25:\n                                r1.functions && r1.functions.length || (r1.functions = []), r1.functions.push(c1.onnx.FunctionProto.decode(e1, e1.uint32()));\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.irVersion && e1.hasOwnProperty(\"irVersion\") && !(l1.isInteger(e1.irVersion) || e1.irVersion && l1.isInteger(e1.irVersion.low) && l1.isInteger(e1.irVersion.high))) return \"irVersion: integer|Long expected\";\n                    if (null != e1.opsetImport && e1.hasOwnProperty(\"opsetImport\")) {\n                        if (!Array.isArray(e1.opsetImport)) return \"opsetImport: array expected\";\n                        for(var t1 = 0; t1 < e1.opsetImport.length; ++t1)if (n1 = c1.onnx.OperatorSetIdProto.verify(e1.opsetImport[t1])) return \"opsetImport.\" + n1;\n                    }\n                    if (null != e1.producerName && e1.hasOwnProperty(\"producerName\") && !l1.isString(e1.producerName)) return \"producerName: string expected\";\n                    if (null != e1.producerVersion && e1.hasOwnProperty(\"producerVersion\") && !l1.isString(e1.producerVersion)) return \"producerVersion: string expected\";\n                    if (null != e1.domain && e1.hasOwnProperty(\"domain\") && !l1.isString(e1.domain)) return \"domain: string expected\";\n                    if (null != e1.modelVersion && e1.hasOwnProperty(\"modelVersion\") && !(l1.isInteger(e1.modelVersion) || e1.modelVersion && l1.isInteger(e1.modelVersion.low) && l1.isInteger(e1.modelVersion.high))) return \"modelVersion: integer|Long expected\";\n                    if (null != e1.docString && e1.hasOwnProperty(\"docString\") && !l1.isString(e1.docString)) return \"docString: string expected\";\n                    if (null != e1.graph && e1.hasOwnProperty(\"graph\") && (n1 = c1.onnx.GraphProto.verify(e1.graph))) return \"graph.\" + n1;\n                    if (null != e1.metadataProps && e1.hasOwnProperty(\"metadataProps\")) {\n                        if (!Array.isArray(e1.metadataProps)) return \"metadataProps: array expected\";\n                        for(t1 = 0; t1 < e1.metadataProps.length; ++t1)if (n1 = c1.onnx.StringStringEntryProto.verify(e1.metadataProps[t1])) return \"metadataProps.\" + n1;\n                    }\n                    if (null != e1.trainingInfo && e1.hasOwnProperty(\"trainingInfo\")) {\n                        if (!Array.isArray(e1.trainingInfo)) return \"trainingInfo: array expected\";\n                        for(t1 = 0; t1 < e1.trainingInfo.length; ++t1)if (n1 = c1.onnx.TrainingInfoProto.verify(e1.trainingInfo[t1])) return \"trainingInfo.\" + n1;\n                    }\n                    if (null != e1.functions && e1.hasOwnProperty(\"functions\")) {\n                        if (!Array.isArray(e1.functions)) return \"functions: array expected\";\n                        for(t1 = 0; t1 < e1.functions.length; ++t1){\n                            var n1;\n                            if (n1 = c1.onnx.FunctionProto.verify(e1.functions[t1])) return \"functions.\" + n1;\n                        }\n                    }\n                    return null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.ModelProto) return e1;\n                    var t1 = new c1.onnx.ModelProto;\n                    if (null != e1.irVersion && (l1.Long ? (t1.irVersion = l1.Long.fromValue(e1.irVersion)).unsigned = !1 : \"string\" == typeof e1.irVersion ? t1.irVersion = parseInt(e1.irVersion, 10) : \"number\" == typeof e1.irVersion ? t1.irVersion = e1.irVersion : \"object\" == typeof e1.irVersion && (t1.irVersion = new l1.LongBits(e1.irVersion.low >>> 0, e1.irVersion.high >>> 0).toNumber())), e1.opsetImport) {\n                        if (!Array.isArray(e1.opsetImport)) throw TypeError(\".onnx.ModelProto.opsetImport: array expected\");\n                        t1.opsetImport = [];\n                        for(var n1 = 0; n1 < e1.opsetImport.length; ++n1){\n                            if (\"object\" != typeof e1.opsetImport[n1]) throw TypeError(\".onnx.ModelProto.opsetImport: object expected\");\n                            t1.opsetImport[n1] = c1.onnx.OperatorSetIdProto.fromObject(e1.opsetImport[n1]);\n                        }\n                    }\n                    if (null != e1.producerName && (t1.producerName = String(e1.producerName)), null != e1.producerVersion && (t1.producerVersion = String(e1.producerVersion)), null != e1.domain && (t1.domain = String(e1.domain)), null != e1.modelVersion && (l1.Long ? (t1.modelVersion = l1.Long.fromValue(e1.modelVersion)).unsigned = !1 : \"string\" == typeof e1.modelVersion ? t1.modelVersion = parseInt(e1.modelVersion, 10) : \"number\" == typeof e1.modelVersion ? t1.modelVersion = e1.modelVersion : \"object\" == typeof e1.modelVersion && (t1.modelVersion = new l1.LongBits(e1.modelVersion.low >>> 0, e1.modelVersion.high >>> 0).toNumber())), null != e1.docString && (t1.docString = String(e1.docString)), null != e1.graph) {\n                        if (\"object\" != typeof e1.graph) throw TypeError(\".onnx.ModelProto.graph: object expected\");\n                        t1.graph = c1.onnx.GraphProto.fromObject(e1.graph);\n                    }\n                    if (e1.metadataProps) {\n                        if (!Array.isArray(e1.metadataProps)) throw TypeError(\".onnx.ModelProto.metadataProps: array expected\");\n                        for(t1.metadataProps = [], n1 = 0; n1 < e1.metadataProps.length; ++n1){\n                            if (\"object\" != typeof e1.metadataProps[n1]) throw TypeError(\".onnx.ModelProto.metadataProps: object expected\");\n                            t1.metadataProps[n1] = c1.onnx.StringStringEntryProto.fromObject(e1.metadataProps[n1]);\n                        }\n                    }\n                    if (e1.trainingInfo) {\n                        if (!Array.isArray(e1.trainingInfo)) throw TypeError(\".onnx.ModelProto.trainingInfo: array expected\");\n                        for(t1.trainingInfo = [], n1 = 0; n1 < e1.trainingInfo.length; ++n1){\n                            if (\"object\" != typeof e1.trainingInfo[n1]) throw TypeError(\".onnx.ModelProto.trainingInfo: object expected\");\n                            t1.trainingInfo[n1] = c1.onnx.TrainingInfoProto.fromObject(e1.trainingInfo[n1]);\n                        }\n                    }\n                    if (e1.functions) {\n                        if (!Array.isArray(e1.functions)) throw TypeError(\".onnx.ModelProto.functions: array expected\");\n                        for(t1.functions = [], n1 = 0; n1 < e1.functions.length; ++n1){\n                            if (\"object\" != typeof e1.functions[n1]) throw TypeError(\".onnx.ModelProto.functions: object expected\");\n                            t1.functions[n1] = c1.onnx.FunctionProto.fromObject(e1.functions[n1]);\n                        }\n                    }\n                    return t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.opsetImport = [], n1.metadataProps = [], n1.trainingInfo = [], n1.functions = []), t1.defaults) {\n                        if (l1.Long) {\n                            var r1 = new l1.Long(0, 0, !1);\n                            n1.irVersion = t1.longs === String ? r1.toString() : t1.longs === Number ? r1.toNumber() : r1;\n                        } else n1.irVersion = t1.longs === String ? \"0\" : 0;\n                        n1.producerName = \"\", n1.producerVersion = \"\", n1.domain = \"\", l1.Long ? (r1 = new l1.Long(0, 0, !1), n1.modelVersion = t1.longs === String ? r1.toString() : t1.longs === Number ? r1.toNumber() : r1) : n1.modelVersion = t1.longs === String ? \"0\" : 0, n1.docString = \"\", n1.graph = null;\n                    }\n                    if (null != e1.irVersion && e1.hasOwnProperty(\"irVersion\") && (\"number\" == typeof e1.irVersion ? n1.irVersion = t1.longs === String ? String(e1.irVersion) : e1.irVersion : n1.irVersion = t1.longs === String ? l1.Long.prototype.toString.call(e1.irVersion) : t1.longs === Number ? new l1.LongBits(e1.irVersion.low >>> 0, e1.irVersion.high >>> 0).toNumber() : e1.irVersion), null != e1.producerName && e1.hasOwnProperty(\"producerName\") && (n1.producerName = e1.producerName), null != e1.producerVersion && e1.hasOwnProperty(\"producerVersion\") && (n1.producerVersion = e1.producerVersion), null != e1.domain && e1.hasOwnProperty(\"domain\") && (n1.domain = e1.domain), null != e1.modelVersion && e1.hasOwnProperty(\"modelVersion\") && (\"number\" == typeof e1.modelVersion ? n1.modelVersion = t1.longs === String ? String(e1.modelVersion) : e1.modelVersion : n1.modelVersion = t1.longs === String ? l1.Long.prototype.toString.call(e1.modelVersion) : t1.longs === Number ? new l1.LongBits(e1.modelVersion.low >>> 0, e1.modelVersion.high >>> 0).toNumber() : e1.modelVersion), null != e1.docString && e1.hasOwnProperty(\"docString\") && (n1.docString = e1.docString), null != e1.graph && e1.hasOwnProperty(\"graph\") && (n1.graph = c1.onnx.GraphProto.toObject(e1.graph, t1)), e1.opsetImport && e1.opsetImport.length) {\n                        n1.opsetImport = [];\n                        for(var o1 = 0; o1 < e1.opsetImport.length; ++o1)n1.opsetImport[o1] = c1.onnx.OperatorSetIdProto.toObject(e1.opsetImport[o1], t1);\n                    }\n                    if (e1.metadataProps && e1.metadataProps.length) for(n1.metadataProps = [], o1 = 0; o1 < e1.metadataProps.length; ++o1)n1.metadataProps[o1] = c1.onnx.StringStringEntryProto.toObject(e1.metadataProps[o1], t1);\n                    if (e1.trainingInfo && e1.trainingInfo.length) for(n1.trainingInfo = [], o1 = 0; o1 < e1.trainingInfo.length; ++o1)n1.trainingInfo[o1] = c1.onnx.TrainingInfoProto.toObject(e1.trainingInfo[o1], t1);\n                    if (e1.functions && e1.functions.length) for(n1.functions = [], o1 = 0; o1 < e1.functions.length; ++o1)n1.functions[o1] = c1.onnx.FunctionProto.toObject(e1.functions[o1], t1);\n                    return n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.ModelProto\";\n                }, e1;\n            }(), i1.StringStringEntryProto = function() {\n                function e1(e1) {\n                    if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.key = \"\", e1.prototype.value = \"\", e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    return t1 || (t1 = u1.create()), null != e1.key && Object.hasOwnProperty.call(e1, \"key\") && t1.uint32(10).string(e1.key), null != e1.value && Object.hasOwnProperty.call(e1, \"value\") && t1.uint32(18).string(e1.value), t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.StringStringEntryProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.key = e1.string();\n                                break;\n                            case 2:\n                                r1.value = e1.string();\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    return \"object\" != typeof e1 || null === e1 ? \"object expected\" : null != e1.key && e1.hasOwnProperty(\"key\") && !l1.isString(e1.key) ? \"key: string expected\" : null != e1.value && e1.hasOwnProperty(\"value\") && !l1.isString(e1.value) ? \"value: string expected\" : null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.StringStringEntryProto) return e1;\n                    var t1 = new c1.onnx.StringStringEntryProto;\n                    return null != e1.key && (t1.key = String(e1.key)), null != e1.value && (t1.value = String(e1.value)), t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    return t1.defaults && (n1.key = \"\", n1.value = \"\"), null != e1.key && e1.hasOwnProperty(\"key\") && (n1.key = e1.key), null != e1.value && e1.hasOwnProperty(\"value\") && (n1.value = e1.value), n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.StringStringEntryProto\";\n                }, e1;\n            }(), i1.TensorAnnotation = function() {\n                function e1(e1) {\n                    if (this.quantParameterTensorNames = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.tensorName = \"\", e1.prototype.quantParameterTensorNames = l1.emptyArray, e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.tensorName && Object.hasOwnProperty.call(e1, \"tensorName\") && t1.uint32(10).string(e1.tensorName), null != e1.quantParameterTensorNames && e1.quantParameterTensorNames.length) for(var n1 = 0; n1 < e1.quantParameterTensorNames.length; ++n1)c1.onnx.StringStringEntryProto.encode(e1.quantParameterTensorNames[n1], t1.uint32(18).fork()).ldelim();\n                    return t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TensorAnnotation; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.tensorName = e1.string();\n                                break;\n                            case 2:\n                                r1.quantParameterTensorNames && r1.quantParameterTensorNames.length || (r1.quantParameterTensorNames = []), r1.quantParameterTensorNames.push(c1.onnx.StringStringEntryProto.decode(e1, e1.uint32()));\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.tensorName && e1.hasOwnProperty(\"tensorName\") && !l1.isString(e1.tensorName)) return \"tensorName: string expected\";\n                    if (null != e1.quantParameterTensorNames && e1.hasOwnProperty(\"quantParameterTensorNames\")) {\n                        if (!Array.isArray(e1.quantParameterTensorNames)) return \"quantParameterTensorNames: array expected\";\n                        for(var t1 = 0; t1 < e1.quantParameterTensorNames.length; ++t1){\n                            var n1 = c1.onnx.StringStringEntryProto.verify(e1.quantParameterTensorNames[t1]);\n                            if (n1) return \"quantParameterTensorNames.\" + n1;\n                        }\n                    }\n                    return null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.TensorAnnotation) return e1;\n                    var t1 = new c1.onnx.TensorAnnotation;\n                    if (null != e1.tensorName && (t1.tensorName = String(e1.tensorName)), e1.quantParameterTensorNames) {\n                        if (!Array.isArray(e1.quantParameterTensorNames)) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: array expected\");\n                        t1.quantParameterTensorNames = [];\n                        for(var n1 = 0; n1 < e1.quantParameterTensorNames.length; ++n1){\n                            if (\"object\" != typeof e1.quantParameterTensorNames[n1]) throw TypeError(\".onnx.TensorAnnotation.quantParameterTensorNames: object expected\");\n                            t1.quantParameterTensorNames[n1] = c1.onnx.StringStringEntryProto.fromObject(e1.quantParameterTensorNames[n1]);\n                        }\n                    }\n                    return t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.quantParameterTensorNames = []), t1.defaults && (n1.tensorName = \"\"), null != e1.tensorName && e1.hasOwnProperty(\"tensorName\") && (n1.tensorName = e1.tensorName), e1.quantParameterTensorNames && e1.quantParameterTensorNames.length) {\n                        n1.quantParameterTensorNames = [];\n                        for(var r1 = 0; r1 < e1.quantParameterTensorNames.length; ++r1)n1.quantParameterTensorNames[r1] = c1.onnx.StringStringEntryProto.toObject(e1.quantParameterTensorNames[r1], t1);\n                    }\n                    return n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TensorAnnotation\";\n                }, e1;\n            }(), i1.GraphProto = function() {\n                function e1(e1) {\n                    if (this.node = [], this.initializer = [], this.sparseInitializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.node = l1.emptyArray, e1.prototype.name = \"\", e1.prototype.initializer = l1.emptyArray, e1.prototype.sparseInitializer = l1.emptyArray, e1.prototype.docString = \"\", e1.prototype.input = l1.emptyArray, e1.prototype.output = l1.emptyArray, e1.prototype.valueInfo = l1.emptyArray, e1.prototype.quantizationAnnotation = l1.emptyArray, e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.node && e1.node.length) for(var n1 = 0; n1 < e1.node.length; ++n1)c1.onnx.NodeProto.encode(e1.node[n1], t1.uint32(10).fork()).ldelim();\n                    if (null != e1.name && Object.hasOwnProperty.call(e1, \"name\") && t1.uint32(18).string(e1.name), null != e1.initializer && e1.initializer.length) for(n1 = 0; n1 < e1.initializer.length; ++n1)c1.onnx.TensorProto.encode(e1.initializer[n1], t1.uint32(42).fork()).ldelim();\n                    if (null != e1.docString && Object.hasOwnProperty.call(e1, \"docString\") && t1.uint32(82).string(e1.docString), null != e1.input && e1.input.length) for(n1 = 0; n1 < e1.input.length; ++n1)c1.onnx.ValueInfoProto.encode(e1.input[n1], t1.uint32(90).fork()).ldelim();\n                    if (null != e1.output && e1.output.length) for(n1 = 0; n1 < e1.output.length; ++n1)c1.onnx.ValueInfoProto.encode(e1.output[n1], t1.uint32(98).fork()).ldelim();\n                    if (null != e1.valueInfo && e1.valueInfo.length) for(n1 = 0; n1 < e1.valueInfo.length; ++n1)c1.onnx.ValueInfoProto.encode(e1.valueInfo[n1], t1.uint32(106).fork()).ldelim();\n                    if (null != e1.quantizationAnnotation && e1.quantizationAnnotation.length) for(n1 = 0; n1 < e1.quantizationAnnotation.length; ++n1)c1.onnx.TensorAnnotation.encode(e1.quantizationAnnotation[n1], t1.uint32(114).fork()).ldelim();\n                    if (null != e1.sparseInitializer && e1.sparseInitializer.length) for(n1 = 0; n1 < e1.sparseInitializer.length; ++n1)c1.onnx.SparseTensorProto.encode(e1.sparseInitializer[n1], t1.uint32(122).fork()).ldelim();\n                    return t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.GraphProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.node && r1.node.length || (r1.node = []), r1.node.push(c1.onnx.NodeProto.decode(e1, e1.uint32()));\n                                break;\n                            case 2:\n                                r1.name = e1.string();\n                                break;\n                            case 5:\n                                r1.initializer && r1.initializer.length || (r1.initializer = []), r1.initializer.push(c1.onnx.TensorProto.decode(e1, e1.uint32()));\n                                break;\n                            case 15:\n                                r1.sparseInitializer && r1.sparseInitializer.length || (r1.sparseInitializer = []), r1.sparseInitializer.push(c1.onnx.SparseTensorProto.decode(e1, e1.uint32()));\n                                break;\n                            case 10:\n                                r1.docString = e1.string();\n                                break;\n                            case 11:\n                                r1.input && r1.input.length || (r1.input = []), r1.input.push(c1.onnx.ValueInfoProto.decode(e1, e1.uint32()));\n                                break;\n                            case 12:\n                                r1.output && r1.output.length || (r1.output = []), r1.output.push(c1.onnx.ValueInfoProto.decode(e1, e1.uint32()));\n                                break;\n                            case 13:\n                                r1.valueInfo && r1.valueInfo.length || (r1.valueInfo = []), r1.valueInfo.push(c1.onnx.ValueInfoProto.decode(e1, e1.uint32()));\n                                break;\n                            case 14:\n                                r1.quantizationAnnotation && r1.quantizationAnnotation.length || (r1.quantizationAnnotation = []), r1.quantizationAnnotation.push(c1.onnx.TensorAnnotation.decode(e1, e1.uint32()));\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.node && e1.hasOwnProperty(\"node\")) {\n                        if (!Array.isArray(e1.node)) return \"node: array expected\";\n                        for(var t1 = 0; t1 < e1.node.length; ++t1)if (n1 = c1.onnx.NodeProto.verify(e1.node[t1])) return \"node.\" + n1;\n                    }\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && !l1.isString(e1.name)) return \"name: string expected\";\n                    if (null != e1.initializer && e1.hasOwnProperty(\"initializer\")) {\n                        if (!Array.isArray(e1.initializer)) return \"initializer: array expected\";\n                        for(t1 = 0; t1 < e1.initializer.length; ++t1)if (n1 = c1.onnx.TensorProto.verify(e1.initializer[t1])) return \"initializer.\" + n1;\n                    }\n                    if (null != e1.sparseInitializer && e1.hasOwnProperty(\"sparseInitializer\")) {\n                        if (!Array.isArray(e1.sparseInitializer)) return \"sparseInitializer: array expected\";\n                        for(t1 = 0; t1 < e1.sparseInitializer.length; ++t1)if (n1 = c1.onnx.SparseTensorProto.verify(e1.sparseInitializer[t1])) return \"sparseInitializer.\" + n1;\n                    }\n                    if (null != e1.docString && e1.hasOwnProperty(\"docString\") && !l1.isString(e1.docString)) return \"docString: string expected\";\n                    if (null != e1.input && e1.hasOwnProperty(\"input\")) {\n                        if (!Array.isArray(e1.input)) return \"input: array expected\";\n                        for(t1 = 0; t1 < e1.input.length; ++t1)if (n1 = c1.onnx.ValueInfoProto.verify(e1.input[t1])) return \"input.\" + n1;\n                    }\n                    if (null != e1.output && e1.hasOwnProperty(\"output\")) {\n                        if (!Array.isArray(e1.output)) return \"output: array expected\";\n                        for(t1 = 0; t1 < e1.output.length; ++t1)if (n1 = c1.onnx.ValueInfoProto.verify(e1.output[t1])) return \"output.\" + n1;\n                    }\n                    if (null != e1.valueInfo && e1.hasOwnProperty(\"valueInfo\")) {\n                        if (!Array.isArray(e1.valueInfo)) return \"valueInfo: array expected\";\n                        for(t1 = 0; t1 < e1.valueInfo.length; ++t1)if (n1 = c1.onnx.ValueInfoProto.verify(e1.valueInfo[t1])) return \"valueInfo.\" + n1;\n                    }\n                    if (null != e1.quantizationAnnotation && e1.hasOwnProperty(\"quantizationAnnotation\")) {\n                        if (!Array.isArray(e1.quantizationAnnotation)) return \"quantizationAnnotation: array expected\";\n                        for(t1 = 0; t1 < e1.quantizationAnnotation.length; ++t1){\n                            var n1;\n                            if (n1 = c1.onnx.TensorAnnotation.verify(e1.quantizationAnnotation[t1])) return \"quantizationAnnotation.\" + n1;\n                        }\n                    }\n                    return null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.GraphProto) return e1;\n                    var t1 = new c1.onnx.GraphProto;\n                    if (e1.node) {\n                        if (!Array.isArray(e1.node)) throw TypeError(\".onnx.GraphProto.node: array expected\");\n                        t1.node = [];\n                        for(var n1 = 0; n1 < e1.node.length; ++n1){\n                            if (\"object\" != typeof e1.node[n1]) throw TypeError(\".onnx.GraphProto.node: object expected\");\n                            t1.node[n1] = c1.onnx.NodeProto.fromObject(e1.node[n1]);\n                        }\n                    }\n                    if (null != e1.name && (t1.name = String(e1.name)), e1.initializer) {\n                        if (!Array.isArray(e1.initializer)) throw TypeError(\".onnx.GraphProto.initializer: array expected\");\n                        for(t1.initializer = [], n1 = 0; n1 < e1.initializer.length; ++n1){\n                            if (\"object\" != typeof e1.initializer[n1]) throw TypeError(\".onnx.GraphProto.initializer: object expected\");\n                            t1.initializer[n1] = c1.onnx.TensorProto.fromObject(e1.initializer[n1]);\n                        }\n                    }\n                    if (e1.sparseInitializer) {\n                        if (!Array.isArray(e1.sparseInitializer)) throw TypeError(\".onnx.GraphProto.sparseInitializer: array expected\");\n                        for(t1.sparseInitializer = [], n1 = 0; n1 < e1.sparseInitializer.length; ++n1){\n                            if (\"object\" != typeof e1.sparseInitializer[n1]) throw TypeError(\".onnx.GraphProto.sparseInitializer: object expected\");\n                            t1.sparseInitializer[n1] = c1.onnx.SparseTensorProto.fromObject(e1.sparseInitializer[n1]);\n                        }\n                    }\n                    if (null != e1.docString && (t1.docString = String(e1.docString)), e1.input) {\n                        if (!Array.isArray(e1.input)) throw TypeError(\".onnx.GraphProto.input: array expected\");\n                        for(t1.input = [], n1 = 0; n1 < e1.input.length; ++n1){\n                            if (\"object\" != typeof e1.input[n1]) throw TypeError(\".onnx.GraphProto.input: object expected\");\n                            t1.input[n1] = c1.onnx.ValueInfoProto.fromObject(e1.input[n1]);\n                        }\n                    }\n                    if (e1.output) {\n                        if (!Array.isArray(e1.output)) throw TypeError(\".onnx.GraphProto.output: array expected\");\n                        for(t1.output = [], n1 = 0; n1 < e1.output.length; ++n1){\n                            if (\"object\" != typeof e1.output[n1]) throw TypeError(\".onnx.GraphProto.output: object expected\");\n                            t1.output[n1] = c1.onnx.ValueInfoProto.fromObject(e1.output[n1]);\n                        }\n                    }\n                    if (e1.valueInfo) {\n                        if (!Array.isArray(e1.valueInfo)) throw TypeError(\".onnx.GraphProto.valueInfo: array expected\");\n                        for(t1.valueInfo = [], n1 = 0; n1 < e1.valueInfo.length; ++n1){\n                            if (\"object\" != typeof e1.valueInfo[n1]) throw TypeError(\".onnx.GraphProto.valueInfo: object expected\");\n                            t1.valueInfo[n1] = c1.onnx.ValueInfoProto.fromObject(e1.valueInfo[n1]);\n                        }\n                    }\n                    if (e1.quantizationAnnotation) {\n                        if (!Array.isArray(e1.quantizationAnnotation)) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: array expected\");\n                        for(t1.quantizationAnnotation = [], n1 = 0; n1 < e1.quantizationAnnotation.length; ++n1){\n                            if (\"object\" != typeof e1.quantizationAnnotation[n1]) throw TypeError(\".onnx.GraphProto.quantizationAnnotation: object expected\");\n                            t1.quantizationAnnotation[n1] = c1.onnx.TensorAnnotation.fromObject(e1.quantizationAnnotation[n1]);\n                        }\n                    }\n                    return t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.node = [], n1.initializer = [], n1.input = [], n1.output = [], n1.valueInfo = [], n1.quantizationAnnotation = [], n1.sparseInitializer = []), t1.defaults && (n1.name = \"\", n1.docString = \"\"), e1.node && e1.node.length) {\n                        n1.node = [];\n                        for(var r1 = 0; r1 < e1.node.length; ++r1)n1.node[r1] = c1.onnx.NodeProto.toObject(e1.node[r1], t1);\n                    }\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && (n1.name = e1.name), e1.initializer && e1.initializer.length) for(n1.initializer = [], r1 = 0; r1 < e1.initializer.length; ++r1)n1.initializer[r1] = c1.onnx.TensorProto.toObject(e1.initializer[r1], t1);\n                    if (null != e1.docString && e1.hasOwnProperty(\"docString\") && (n1.docString = e1.docString), e1.input && e1.input.length) for(n1.input = [], r1 = 0; r1 < e1.input.length; ++r1)n1.input[r1] = c1.onnx.ValueInfoProto.toObject(e1.input[r1], t1);\n                    if (e1.output && e1.output.length) for(n1.output = [], r1 = 0; r1 < e1.output.length; ++r1)n1.output[r1] = c1.onnx.ValueInfoProto.toObject(e1.output[r1], t1);\n                    if (e1.valueInfo && e1.valueInfo.length) for(n1.valueInfo = [], r1 = 0; r1 < e1.valueInfo.length; ++r1)n1.valueInfo[r1] = c1.onnx.ValueInfoProto.toObject(e1.valueInfo[r1], t1);\n                    if (e1.quantizationAnnotation && e1.quantizationAnnotation.length) for(n1.quantizationAnnotation = [], r1 = 0; r1 < e1.quantizationAnnotation.length; ++r1)n1.quantizationAnnotation[r1] = c1.onnx.TensorAnnotation.toObject(e1.quantizationAnnotation[r1], t1);\n                    if (e1.sparseInitializer && e1.sparseInitializer.length) for(n1.sparseInitializer = [], r1 = 0; r1 < e1.sparseInitializer.length; ++r1)n1.sparseInitializer[r1] = c1.onnx.SparseTensorProto.toObject(e1.sparseInitializer[r1], t1);\n                    return n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.GraphProto\";\n                }, e1;\n            }(), i1.TensorProto = function() {\n                function e1(e1) {\n                    if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.dims = l1.emptyArray, e1.prototype.dataType = 0, e1.prototype.segment = null, e1.prototype.floatData = l1.emptyArray, e1.prototype.int32Data = l1.emptyArray, e1.prototype.stringData = l1.emptyArray, e1.prototype.int64Data = l1.emptyArray, e1.prototype.name = \"\", e1.prototype.docString = \"\", e1.prototype.rawData = l1.newBuffer([]), e1.prototype.externalData = l1.emptyArray, e1.prototype.dataLocation = 0, e1.prototype.doubleData = l1.emptyArray, e1.prototype.uint64Data = l1.emptyArray, e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.dims && e1.dims.length) {\n                        t1.uint32(10).fork();\n                        for(var n1 = 0; n1 < e1.dims.length; ++n1)t1.int64(e1.dims[n1]);\n                        t1.ldelim();\n                    }\n                    if (null != e1.dataType && Object.hasOwnProperty.call(e1, \"dataType\") && t1.uint32(16).int32(e1.dataType), null != e1.segment && Object.hasOwnProperty.call(e1, \"segment\") && c1.onnx.TensorProto.Segment.encode(e1.segment, t1.uint32(26).fork()).ldelim(), null != e1.floatData && e1.floatData.length) {\n                        for(t1.uint32(34).fork(), n1 = 0; n1 < e1.floatData.length; ++n1)t1.float(e1.floatData[n1]);\n                        t1.ldelim();\n                    }\n                    if (null != e1.int32Data && e1.int32Data.length) {\n                        for(t1.uint32(42).fork(), n1 = 0; n1 < e1.int32Data.length; ++n1)t1.int32(e1.int32Data[n1]);\n                        t1.ldelim();\n                    }\n                    if (null != e1.stringData && e1.stringData.length) for(n1 = 0; n1 < e1.stringData.length; ++n1)t1.uint32(50).bytes(e1.stringData[n1]);\n                    if (null != e1.int64Data && e1.int64Data.length) {\n                        for(t1.uint32(58).fork(), n1 = 0; n1 < e1.int64Data.length; ++n1)t1.int64(e1.int64Data[n1]);\n                        t1.ldelim();\n                    }\n                    if (null != e1.name && Object.hasOwnProperty.call(e1, \"name\") && t1.uint32(66).string(e1.name), null != e1.rawData && Object.hasOwnProperty.call(e1, \"rawData\") && t1.uint32(74).bytes(e1.rawData), null != e1.doubleData && e1.doubleData.length) {\n                        for(t1.uint32(82).fork(), n1 = 0; n1 < e1.doubleData.length; ++n1)t1.double(e1.doubleData[n1]);\n                        t1.ldelim();\n                    }\n                    if (null != e1.uint64Data && e1.uint64Data.length) {\n                        for(t1.uint32(90).fork(), n1 = 0; n1 < e1.uint64Data.length; ++n1)t1.uint64(e1.uint64Data[n1]);\n                        t1.ldelim();\n                    }\n                    if (null != e1.docString && Object.hasOwnProperty.call(e1, \"docString\") && t1.uint32(98).string(e1.docString), null != e1.externalData && e1.externalData.length) for(n1 = 0; n1 < e1.externalData.length; ++n1)c1.onnx.StringStringEntryProto.encode(e1.externalData[n1], t1.uint32(106).fork()).ldelim();\n                    return null != e1.dataLocation && Object.hasOwnProperty.call(e1, \"dataLocation\") && t1.uint32(112).int32(e1.dataLocation), t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TensorProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                if (r1.dims && r1.dims.length || (r1.dims = []), 2 == (7 & o1)) for(var i1 = e1.uint32() + e1.pos; e1.pos < i1;)r1.dims.push(e1.int64());\n                                else r1.dims.push(e1.int64());\n                                break;\n                            case 2:\n                                r1.dataType = e1.int32();\n                                break;\n                            case 3:\n                                r1.segment = c1.onnx.TensorProto.Segment.decode(e1, e1.uint32());\n                                break;\n                            case 4:\n                                if (r1.floatData && r1.floatData.length || (r1.floatData = []), 2 == (7 & o1)) for(i1 = e1.uint32() + e1.pos; e1.pos < i1;)r1.floatData.push(e1.float());\n                                else r1.floatData.push(e1.float());\n                                break;\n                            case 5:\n                                if (r1.int32Data && r1.int32Data.length || (r1.int32Data = []), 2 == (7 & o1)) for(i1 = e1.uint32() + e1.pos; e1.pos < i1;)r1.int32Data.push(e1.int32());\n                                else r1.int32Data.push(e1.int32());\n                                break;\n                            case 6:\n                                r1.stringData && r1.stringData.length || (r1.stringData = []), r1.stringData.push(e1.bytes());\n                                break;\n                            case 7:\n                                if (r1.int64Data && r1.int64Data.length || (r1.int64Data = []), 2 == (7 & o1)) for(i1 = e1.uint32() + e1.pos; e1.pos < i1;)r1.int64Data.push(e1.int64());\n                                else r1.int64Data.push(e1.int64());\n                                break;\n                            case 8:\n                                r1.name = e1.string();\n                                break;\n                            case 12:\n                                r1.docString = e1.string();\n                                break;\n                            case 9:\n                                r1.rawData = e1.bytes();\n                                break;\n                            case 13:\n                                r1.externalData && r1.externalData.length || (r1.externalData = []), r1.externalData.push(c1.onnx.StringStringEntryProto.decode(e1, e1.uint32()));\n                                break;\n                            case 14:\n                                r1.dataLocation = e1.int32();\n                                break;\n                            case 10:\n                                if (r1.doubleData && r1.doubleData.length || (r1.doubleData = []), 2 == (7 & o1)) for(i1 = e1.uint32() + e1.pos; e1.pos < i1;)r1.doubleData.push(e1.double());\n                                else r1.doubleData.push(e1.double());\n                                break;\n                            case 11:\n                                if (r1.uint64Data && r1.uint64Data.length || (r1.uint64Data = []), 2 == (7 & o1)) for(i1 = e1.uint32() + e1.pos; e1.pos < i1;)r1.uint64Data.push(e1.uint64());\n                                else r1.uint64Data.push(e1.uint64());\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.dims && e1.hasOwnProperty(\"dims\")) {\n                        if (!Array.isArray(e1.dims)) return \"dims: array expected\";\n                        for(var t1 = 0; t1 < e1.dims.length; ++t1)if (!(l1.isInteger(e1.dims[t1]) || e1.dims[t1] && l1.isInteger(e1.dims[t1].low) && l1.isInteger(e1.dims[t1].high))) return \"dims: integer|Long[] expected\";\n                    }\n                    if (null != e1.dataType && e1.hasOwnProperty(\"dataType\") && !l1.isInteger(e1.dataType)) return \"dataType: integer expected\";\n                    if (null != e1.segment && e1.hasOwnProperty(\"segment\") && (n1 = c1.onnx.TensorProto.Segment.verify(e1.segment))) return \"segment.\" + n1;\n                    if (null != e1.floatData && e1.hasOwnProperty(\"floatData\")) {\n                        if (!Array.isArray(e1.floatData)) return \"floatData: array expected\";\n                        for(t1 = 0; t1 < e1.floatData.length; ++t1)if (\"number\" != typeof e1.floatData[t1]) return \"floatData: number[] expected\";\n                    }\n                    if (null != e1.int32Data && e1.hasOwnProperty(\"int32Data\")) {\n                        if (!Array.isArray(e1.int32Data)) return \"int32Data: array expected\";\n                        for(t1 = 0; t1 < e1.int32Data.length; ++t1)if (!l1.isInteger(e1.int32Data[t1])) return \"int32Data: integer[] expected\";\n                    }\n                    if (null != e1.stringData && e1.hasOwnProperty(\"stringData\")) {\n                        if (!Array.isArray(e1.stringData)) return \"stringData: array expected\";\n                        for(t1 = 0; t1 < e1.stringData.length; ++t1)if (!(e1.stringData[t1] && \"number\" == typeof e1.stringData[t1].length || l1.isString(e1.stringData[t1]))) return \"stringData: buffer[] expected\";\n                    }\n                    if (null != e1.int64Data && e1.hasOwnProperty(\"int64Data\")) {\n                        if (!Array.isArray(e1.int64Data)) return \"int64Data: array expected\";\n                        for(t1 = 0; t1 < e1.int64Data.length; ++t1)if (!(l1.isInteger(e1.int64Data[t1]) || e1.int64Data[t1] && l1.isInteger(e1.int64Data[t1].low) && l1.isInteger(e1.int64Data[t1].high))) return \"int64Data: integer|Long[] expected\";\n                    }\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && !l1.isString(e1.name)) return \"name: string expected\";\n                    if (null != e1.docString && e1.hasOwnProperty(\"docString\") && !l1.isString(e1.docString)) return \"docString: string expected\";\n                    if (null != e1.rawData && e1.hasOwnProperty(\"rawData\") && !(e1.rawData && \"number\" == typeof e1.rawData.length || l1.isString(e1.rawData))) return \"rawData: buffer expected\";\n                    if (null != e1.externalData && e1.hasOwnProperty(\"externalData\")) {\n                        if (!Array.isArray(e1.externalData)) return \"externalData: array expected\";\n                        for(t1 = 0; t1 < e1.externalData.length; ++t1){\n                            var n1;\n                            if (n1 = c1.onnx.StringStringEntryProto.verify(e1.externalData[t1])) return \"externalData.\" + n1;\n                        }\n                    }\n                    if (null != e1.dataLocation && e1.hasOwnProperty(\"dataLocation\")) switch(e1.dataLocation){\n                        default:\n                            return \"dataLocation: enum value expected\";\n                        case 0:\n                        case 1:\n                    }\n                    if (null != e1.doubleData && e1.hasOwnProperty(\"doubleData\")) {\n                        if (!Array.isArray(e1.doubleData)) return \"doubleData: array expected\";\n                        for(t1 = 0; t1 < e1.doubleData.length; ++t1)if (\"number\" != typeof e1.doubleData[t1]) return \"doubleData: number[] expected\";\n                    }\n                    if (null != e1.uint64Data && e1.hasOwnProperty(\"uint64Data\")) {\n                        if (!Array.isArray(e1.uint64Data)) return \"uint64Data: array expected\";\n                        for(t1 = 0; t1 < e1.uint64Data.length; ++t1)if (!(l1.isInteger(e1.uint64Data[t1]) || e1.uint64Data[t1] && l1.isInteger(e1.uint64Data[t1].low) && l1.isInteger(e1.uint64Data[t1].high))) return \"uint64Data: integer|Long[] expected\";\n                    }\n                    return null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.TensorProto) return e1;\n                    var t1 = new c1.onnx.TensorProto;\n                    if (e1.dims) {\n                        if (!Array.isArray(e1.dims)) throw TypeError(\".onnx.TensorProto.dims: array expected\");\n                        t1.dims = [];\n                        for(var n1 = 0; n1 < e1.dims.length; ++n1)l1.Long ? (t1.dims[n1] = l1.Long.fromValue(e1.dims[n1])).unsigned = !1 : \"string\" == typeof e1.dims[n1] ? t1.dims[n1] = parseInt(e1.dims[n1], 10) : \"number\" == typeof e1.dims[n1] ? t1.dims[n1] = e1.dims[n1] : \"object\" == typeof e1.dims[n1] && (t1.dims[n1] = new l1.LongBits(e1.dims[n1].low >>> 0, e1.dims[n1].high >>> 0).toNumber());\n                    }\n                    if (null != e1.dataType && (t1.dataType = 0 | e1.dataType), null != e1.segment) {\n                        if (\"object\" != typeof e1.segment) throw TypeError(\".onnx.TensorProto.segment: object expected\");\n                        t1.segment = c1.onnx.TensorProto.Segment.fromObject(e1.segment);\n                    }\n                    if (e1.floatData) {\n                        if (!Array.isArray(e1.floatData)) throw TypeError(\".onnx.TensorProto.floatData: array expected\");\n                        for(t1.floatData = [], n1 = 0; n1 < e1.floatData.length; ++n1)t1.floatData[n1] = Number(e1.floatData[n1]);\n                    }\n                    if (e1.int32Data) {\n                        if (!Array.isArray(e1.int32Data)) throw TypeError(\".onnx.TensorProto.int32Data: array expected\");\n                        for(t1.int32Data = [], n1 = 0; n1 < e1.int32Data.length; ++n1)t1.int32Data[n1] = 0 | e1.int32Data[n1];\n                    }\n                    if (e1.stringData) {\n                        if (!Array.isArray(e1.stringData)) throw TypeError(\".onnx.TensorProto.stringData: array expected\");\n                        for(t1.stringData = [], n1 = 0; n1 < e1.stringData.length; ++n1)\"string\" == typeof e1.stringData[n1] ? l1.base64.decode(e1.stringData[n1], t1.stringData[n1] = l1.newBuffer(l1.base64.length(e1.stringData[n1])), 0) : e1.stringData[n1].length >= 0 && (t1.stringData[n1] = e1.stringData[n1]);\n                    }\n                    if (e1.int64Data) {\n                        if (!Array.isArray(e1.int64Data)) throw TypeError(\".onnx.TensorProto.int64Data: array expected\");\n                        for(t1.int64Data = [], n1 = 0; n1 < e1.int64Data.length; ++n1)l1.Long ? (t1.int64Data[n1] = l1.Long.fromValue(e1.int64Data[n1])).unsigned = !1 : \"string\" == typeof e1.int64Data[n1] ? t1.int64Data[n1] = parseInt(e1.int64Data[n1], 10) : \"number\" == typeof e1.int64Data[n1] ? t1.int64Data[n1] = e1.int64Data[n1] : \"object\" == typeof e1.int64Data[n1] && (t1.int64Data[n1] = new l1.LongBits(e1.int64Data[n1].low >>> 0, e1.int64Data[n1].high >>> 0).toNumber());\n                    }\n                    if (null != e1.name && (t1.name = String(e1.name)), null != e1.docString && (t1.docString = String(e1.docString)), null != e1.rawData && (\"string\" == typeof e1.rawData ? l1.base64.decode(e1.rawData, t1.rawData = l1.newBuffer(l1.base64.length(e1.rawData)), 0) : e1.rawData.length >= 0 && (t1.rawData = e1.rawData)), e1.externalData) {\n                        if (!Array.isArray(e1.externalData)) throw TypeError(\".onnx.TensorProto.externalData: array expected\");\n                        for(t1.externalData = [], n1 = 0; n1 < e1.externalData.length; ++n1){\n                            if (\"object\" != typeof e1.externalData[n1]) throw TypeError(\".onnx.TensorProto.externalData: object expected\");\n                            t1.externalData[n1] = c1.onnx.StringStringEntryProto.fromObject(e1.externalData[n1]);\n                        }\n                    }\n                    switch(e1.dataLocation){\n                        default:\n                            if (\"number\" == typeof e1.dataLocation) {\n                                t1.dataLocation = e1.dataLocation;\n                                break;\n                            }\n                            break;\n                        case \"DEFAULT\":\n                        case 0:\n                            t1.dataLocation = 0;\n                            break;\n                        case \"EXTERNAL\":\n                        case 1:\n                            t1.dataLocation = 1;\n                    }\n                    if (e1.doubleData) {\n                        if (!Array.isArray(e1.doubleData)) throw TypeError(\".onnx.TensorProto.doubleData: array expected\");\n                        for(t1.doubleData = [], n1 = 0; n1 < e1.doubleData.length; ++n1)t1.doubleData[n1] = Number(e1.doubleData[n1]);\n                    }\n                    if (e1.uint64Data) {\n                        if (!Array.isArray(e1.uint64Data)) throw TypeError(\".onnx.TensorProto.uint64Data: array expected\");\n                        for(t1.uint64Data = [], n1 = 0; n1 < e1.uint64Data.length; ++n1)l1.Long ? (t1.uint64Data[n1] = l1.Long.fromValue(e1.uint64Data[n1])).unsigned = !0 : \"string\" == typeof e1.uint64Data[n1] ? t1.uint64Data[n1] = parseInt(e1.uint64Data[n1], 10) : \"number\" == typeof e1.uint64Data[n1] ? t1.uint64Data[n1] = e1.uint64Data[n1] : \"object\" == typeof e1.uint64Data[n1] && (t1.uint64Data[n1] = new l1.LongBits(e1.uint64Data[n1].low >>> 0, e1.uint64Data[n1].high >>> 0).toNumber(!0));\n                    }\n                    return t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.dims = [], n1.floatData = [], n1.int32Data = [], n1.stringData = [], n1.int64Data = [], n1.doubleData = [], n1.uint64Data = [], n1.externalData = []), t1.defaults && (n1.dataType = 0, n1.segment = null, n1.name = \"\", t1.bytes === String ? n1.rawData = \"\" : (n1.rawData = [], t1.bytes !== Array && (n1.rawData = l1.newBuffer(n1.rawData))), n1.docString = \"\", n1.dataLocation = t1.enums === String ? \"DEFAULT\" : 0), e1.dims && e1.dims.length) {\n                        n1.dims = [];\n                        for(var r1 = 0; r1 < e1.dims.length; ++r1)\"number\" == typeof e1.dims[r1] ? n1.dims[r1] = t1.longs === String ? String(e1.dims[r1]) : e1.dims[r1] : n1.dims[r1] = t1.longs === String ? l1.Long.prototype.toString.call(e1.dims[r1]) : t1.longs === Number ? new l1.LongBits(e1.dims[r1].low >>> 0, e1.dims[r1].high >>> 0).toNumber() : e1.dims[r1];\n                    }\n                    if (null != e1.dataType && e1.hasOwnProperty(\"dataType\") && (n1.dataType = e1.dataType), null != e1.segment && e1.hasOwnProperty(\"segment\") && (n1.segment = c1.onnx.TensorProto.Segment.toObject(e1.segment, t1)), e1.floatData && e1.floatData.length) for(n1.floatData = [], r1 = 0; r1 < e1.floatData.length; ++r1)n1.floatData[r1] = t1.json && !isFinite(e1.floatData[r1]) ? String(e1.floatData[r1]) : e1.floatData[r1];\n                    if (e1.int32Data && e1.int32Data.length) for(n1.int32Data = [], r1 = 0; r1 < e1.int32Data.length; ++r1)n1.int32Data[r1] = e1.int32Data[r1];\n                    if (e1.stringData && e1.stringData.length) for(n1.stringData = [], r1 = 0; r1 < e1.stringData.length; ++r1)n1.stringData[r1] = t1.bytes === String ? l1.base64.encode(e1.stringData[r1], 0, e1.stringData[r1].length) : t1.bytes === Array ? Array.prototype.slice.call(e1.stringData[r1]) : e1.stringData[r1];\n                    if (e1.int64Data && e1.int64Data.length) for(n1.int64Data = [], r1 = 0; r1 < e1.int64Data.length; ++r1)\"number\" == typeof e1.int64Data[r1] ? n1.int64Data[r1] = t1.longs === String ? String(e1.int64Data[r1]) : e1.int64Data[r1] : n1.int64Data[r1] = t1.longs === String ? l1.Long.prototype.toString.call(e1.int64Data[r1]) : t1.longs === Number ? new l1.LongBits(e1.int64Data[r1].low >>> 0, e1.int64Data[r1].high >>> 0).toNumber() : e1.int64Data[r1];\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && (n1.name = e1.name), null != e1.rawData && e1.hasOwnProperty(\"rawData\") && (n1.rawData = t1.bytes === String ? l1.base64.encode(e1.rawData, 0, e1.rawData.length) : t1.bytes === Array ? Array.prototype.slice.call(e1.rawData) : e1.rawData), e1.doubleData && e1.doubleData.length) for(n1.doubleData = [], r1 = 0; r1 < e1.doubleData.length; ++r1)n1.doubleData[r1] = t1.json && !isFinite(e1.doubleData[r1]) ? String(e1.doubleData[r1]) : e1.doubleData[r1];\n                    if (e1.uint64Data && e1.uint64Data.length) for(n1.uint64Data = [], r1 = 0; r1 < e1.uint64Data.length; ++r1)\"number\" == typeof e1.uint64Data[r1] ? n1.uint64Data[r1] = t1.longs === String ? String(e1.uint64Data[r1]) : e1.uint64Data[r1] : n1.uint64Data[r1] = t1.longs === String ? l1.Long.prototype.toString.call(e1.uint64Data[r1]) : t1.longs === Number ? new l1.LongBits(e1.uint64Data[r1].low >>> 0, e1.uint64Data[r1].high >>> 0).toNumber(!0) : e1.uint64Data[r1];\n                    if (null != e1.docString && e1.hasOwnProperty(\"docString\") && (n1.docString = e1.docString), e1.externalData && e1.externalData.length) for(n1.externalData = [], r1 = 0; r1 < e1.externalData.length; ++r1)n1.externalData[r1] = c1.onnx.StringStringEntryProto.toObject(e1.externalData[r1], t1);\n                    return null != e1.dataLocation && e1.hasOwnProperty(\"dataLocation\") && (n1.dataLocation = t1.enums === String ? void 0 === c1.onnx.TensorProto.DataLocation[e1.dataLocation] ? e1.dataLocation : c1.onnx.TensorProto.DataLocation[e1.dataLocation] : e1.dataLocation), n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TensorProto\";\n                }, e1.DataType = function() {\n                    var e1 = {}, t1 = Object.create(e1);\n                    return t1[e1[0] = \"UNDEFINED\"] = 0, t1[e1[1] = \"FLOAT\"] = 1, t1[e1[2] = \"UINT8\"] = 2, t1[e1[3] = \"INT8\"] = 3, t1[e1[4] = \"UINT16\"] = 4, t1[e1[5] = \"INT16\"] = 5, t1[e1[6] = \"INT32\"] = 6, t1[e1[7] = \"INT64\"] = 7, t1[e1[8] = \"STRING\"] = 8, t1[e1[9] = \"BOOL\"] = 9, t1[e1[10] = \"FLOAT16\"] = 10, t1[e1[11] = \"DOUBLE\"] = 11, t1[e1[12] = \"UINT32\"] = 12, t1[e1[13] = \"UINT64\"] = 13, t1[e1[14] = \"COMPLEX64\"] = 14, t1[e1[15] = \"COMPLEX128\"] = 15, t1[e1[16] = \"BFLOAT16\"] = 16, t1[e1[17] = \"FLOAT8E4M3FN\"] = 17, t1[e1[18] = \"FLOAT8E4M3FNUZ\"] = 18, t1[e1[19] = \"FLOAT8E5M2\"] = 19, t1[e1[20] = \"FLOAT8E5M2FNUZ\"] = 20, t1;\n                }(), e1.Segment = function() {\n                    function e1(e1) {\n                        if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                    }\n                    return e1.prototype.begin = l1.Long ? l1.Long.fromBits(0, 0, !1) : 0, e1.prototype.end = l1.Long ? l1.Long.fromBits(0, 0, !1) : 0, e1.create = function(t1) {\n                        return new e1(t1);\n                    }, e1.encode = function(e1, t1) {\n                        return t1 || (t1 = u1.create()), null != e1.begin && Object.hasOwnProperty.call(e1, \"begin\") && t1.uint32(8).int64(e1.begin), null != e1.end && Object.hasOwnProperty.call(e1, \"end\") && t1.uint32(16).int64(e1.end), t1;\n                    }, e1.encodeDelimited = function(e1, t1) {\n                        return this.encode(e1, t1).ldelim();\n                    }, e1.decode = function(e1, t1) {\n                        e1 instanceof a1 || (e1 = a1.create(e1));\n                        for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TensorProto.Segment; e1.pos < n1;){\n                            var o1 = e1.uint32();\n                            switch(o1 >>> 3){\n                                case 1:\n                                    r1.begin = e1.int64();\n                                    break;\n                                case 2:\n                                    r1.end = e1.int64();\n                                    break;\n                                default:\n                                    e1.skipType(7 & o1);\n                            }\n                        }\n                        return r1;\n                    }, e1.decodeDelimited = function(e1) {\n                        return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                    }, e1.verify = function(e1) {\n                        return \"object\" != typeof e1 || null === e1 ? \"object expected\" : null != e1.begin && e1.hasOwnProperty(\"begin\") && !(l1.isInteger(e1.begin) || e1.begin && l1.isInteger(e1.begin.low) && l1.isInteger(e1.begin.high)) ? \"begin: integer|Long expected\" : null != e1.end && e1.hasOwnProperty(\"end\") && !(l1.isInteger(e1.end) || e1.end && l1.isInteger(e1.end.low) && l1.isInteger(e1.end.high)) ? \"end: integer|Long expected\" : null;\n                    }, e1.fromObject = function(e1) {\n                        if (e1 instanceof c1.onnx.TensorProto.Segment) return e1;\n                        var t1 = new c1.onnx.TensorProto.Segment;\n                        return null != e1.begin && (l1.Long ? (t1.begin = l1.Long.fromValue(e1.begin)).unsigned = !1 : \"string\" == typeof e1.begin ? t1.begin = parseInt(e1.begin, 10) : \"number\" == typeof e1.begin ? t1.begin = e1.begin : \"object\" == typeof e1.begin && (t1.begin = new l1.LongBits(e1.begin.low >>> 0, e1.begin.high >>> 0).toNumber())), null != e1.end && (l1.Long ? (t1.end = l1.Long.fromValue(e1.end)).unsigned = !1 : \"string\" == typeof e1.end ? t1.end = parseInt(e1.end, 10) : \"number\" == typeof e1.end ? t1.end = e1.end : \"object\" == typeof e1.end && (t1.end = new l1.LongBits(e1.end.low >>> 0, e1.end.high >>> 0).toNumber())), t1;\n                    }, e1.toObject = function(e1, t1) {\n                        t1 || (t1 = {});\n                        var n1 = {};\n                        if (t1.defaults) {\n                            if (l1.Long) {\n                                var r1 = new l1.Long(0, 0, !1);\n                                n1.begin = t1.longs === String ? r1.toString() : t1.longs === Number ? r1.toNumber() : r1;\n                            } else n1.begin = t1.longs === String ? \"0\" : 0;\n                            l1.Long ? (r1 = new l1.Long(0, 0, !1), n1.end = t1.longs === String ? r1.toString() : t1.longs === Number ? r1.toNumber() : r1) : n1.end = t1.longs === String ? \"0\" : 0;\n                        }\n                        return null != e1.begin && e1.hasOwnProperty(\"begin\") && (\"number\" == typeof e1.begin ? n1.begin = t1.longs === String ? String(e1.begin) : e1.begin : n1.begin = t1.longs === String ? l1.Long.prototype.toString.call(e1.begin) : t1.longs === Number ? new l1.LongBits(e1.begin.low >>> 0, e1.begin.high >>> 0).toNumber() : e1.begin), null != e1.end && e1.hasOwnProperty(\"end\") && (\"number\" == typeof e1.end ? n1.end = t1.longs === String ? String(e1.end) : e1.end : n1.end = t1.longs === String ? l1.Long.prototype.toString.call(e1.end) : t1.longs === Number ? new l1.LongBits(e1.end.low >>> 0, e1.end.high >>> 0).toNumber() : e1.end), n1;\n                    }, e1.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, s1.util.toJSONOptions);\n                    }, e1.getTypeUrl = function(e1) {\n                        return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TensorProto.Segment\";\n                    }, e1;\n                }(), e1.DataLocation = function() {\n                    var e1 = {}, t1 = Object.create(e1);\n                    return t1[e1[0] = \"DEFAULT\"] = 0, t1[e1[1] = \"EXTERNAL\"] = 1, t1;\n                }(), e1;\n            }(), i1.SparseTensorProto = function() {\n                function e1(e1) {\n                    if (this.dims = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.values = null, e1.prototype.indices = null, e1.prototype.dims = l1.emptyArray, e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.values && Object.hasOwnProperty.call(e1, \"values\") && c1.onnx.TensorProto.encode(e1.values, t1.uint32(10).fork()).ldelim(), null != e1.indices && Object.hasOwnProperty.call(e1, \"indices\") && c1.onnx.TensorProto.encode(e1.indices, t1.uint32(18).fork()).ldelim(), null != e1.dims && e1.dims.length) {\n                        t1.uint32(26).fork();\n                        for(var n1 = 0; n1 < e1.dims.length; ++n1)t1.int64(e1.dims[n1]);\n                        t1.ldelim();\n                    }\n                    return t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.SparseTensorProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.values = c1.onnx.TensorProto.decode(e1, e1.uint32());\n                                break;\n                            case 2:\n                                r1.indices = c1.onnx.TensorProto.decode(e1, e1.uint32());\n                                break;\n                            case 3:\n                                if (r1.dims && r1.dims.length || (r1.dims = []), 2 == (7 & o1)) for(var i1 = e1.uint32() + e1.pos; e1.pos < i1;)r1.dims.push(e1.int64());\n                                else r1.dims.push(e1.int64());\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    var t1;\n                    if (null != e1.values && e1.hasOwnProperty(\"values\") && (t1 = c1.onnx.TensorProto.verify(e1.values))) return \"values.\" + t1;\n                    if (null != e1.indices && e1.hasOwnProperty(\"indices\") && (t1 = c1.onnx.TensorProto.verify(e1.indices))) return \"indices.\" + t1;\n                    if (null != e1.dims && e1.hasOwnProperty(\"dims\")) {\n                        if (!Array.isArray(e1.dims)) return \"dims: array expected\";\n                        for(var n1 = 0; n1 < e1.dims.length; ++n1)if (!(l1.isInteger(e1.dims[n1]) || e1.dims[n1] && l1.isInteger(e1.dims[n1].low) && l1.isInteger(e1.dims[n1].high))) return \"dims: integer|Long[] expected\";\n                    }\n                    return null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.SparseTensorProto) return e1;\n                    var t1 = new c1.onnx.SparseTensorProto;\n                    if (null != e1.values) {\n                        if (\"object\" != typeof e1.values) throw TypeError(\".onnx.SparseTensorProto.values: object expected\");\n                        t1.values = c1.onnx.TensorProto.fromObject(e1.values);\n                    }\n                    if (null != e1.indices) {\n                        if (\"object\" != typeof e1.indices) throw TypeError(\".onnx.SparseTensorProto.indices: object expected\");\n                        t1.indices = c1.onnx.TensorProto.fromObject(e1.indices);\n                    }\n                    if (e1.dims) {\n                        if (!Array.isArray(e1.dims)) throw TypeError(\".onnx.SparseTensorProto.dims: array expected\");\n                        t1.dims = [];\n                        for(var n1 = 0; n1 < e1.dims.length; ++n1)l1.Long ? (t1.dims[n1] = l1.Long.fromValue(e1.dims[n1])).unsigned = !1 : \"string\" == typeof e1.dims[n1] ? t1.dims[n1] = parseInt(e1.dims[n1], 10) : \"number\" == typeof e1.dims[n1] ? t1.dims[n1] = e1.dims[n1] : \"object\" == typeof e1.dims[n1] && (t1.dims[n1] = new l1.LongBits(e1.dims[n1].low >>> 0, e1.dims[n1].high >>> 0).toNumber());\n                    }\n                    return t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.dims = []), t1.defaults && (n1.values = null, n1.indices = null), null != e1.values && e1.hasOwnProperty(\"values\") && (n1.values = c1.onnx.TensorProto.toObject(e1.values, t1)), null != e1.indices && e1.hasOwnProperty(\"indices\") && (n1.indices = c1.onnx.TensorProto.toObject(e1.indices, t1)), e1.dims && e1.dims.length) {\n                        n1.dims = [];\n                        for(var r1 = 0; r1 < e1.dims.length; ++r1)\"number\" == typeof e1.dims[r1] ? n1.dims[r1] = t1.longs === String ? String(e1.dims[r1]) : e1.dims[r1] : n1.dims[r1] = t1.longs === String ? l1.Long.prototype.toString.call(e1.dims[r1]) : t1.longs === Number ? new l1.LongBits(e1.dims[r1].low >>> 0, e1.dims[r1].high >>> 0).toNumber() : e1.dims[r1];\n                    }\n                    return n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.SparseTensorProto\";\n                }, e1;\n            }(), i1.TensorShapeProto = function() {\n                function e1(e1) {\n                    if (this.dim = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.dim = l1.emptyArray, e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.dim && e1.dim.length) for(var n1 = 0; n1 < e1.dim.length; ++n1)c1.onnx.TensorShapeProto.Dimension.encode(e1.dim[n1], t1.uint32(10).fork()).ldelim();\n                    return t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TensorShapeProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        o1 >>> 3 == 1 ? (r1.dim && r1.dim.length || (r1.dim = []), r1.dim.push(c1.onnx.TensorShapeProto.Dimension.decode(e1, e1.uint32()))) : e1.skipType(7 & o1);\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.dim && e1.hasOwnProperty(\"dim\")) {\n                        if (!Array.isArray(e1.dim)) return \"dim: array expected\";\n                        for(var t1 = 0; t1 < e1.dim.length; ++t1){\n                            var n1 = c1.onnx.TensorShapeProto.Dimension.verify(e1.dim[t1]);\n                            if (n1) return \"dim.\" + n1;\n                        }\n                    }\n                    return null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.TensorShapeProto) return e1;\n                    var t1 = new c1.onnx.TensorShapeProto;\n                    if (e1.dim) {\n                        if (!Array.isArray(e1.dim)) throw TypeError(\".onnx.TensorShapeProto.dim: array expected\");\n                        t1.dim = [];\n                        for(var n1 = 0; n1 < e1.dim.length; ++n1){\n                            if (\"object\" != typeof e1.dim[n1]) throw TypeError(\".onnx.TensorShapeProto.dim: object expected\");\n                            t1.dim[n1] = c1.onnx.TensorShapeProto.Dimension.fromObject(e1.dim[n1]);\n                        }\n                    }\n                    return t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.dim = []), e1.dim && e1.dim.length) {\n                        n1.dim = [];\n                        for(var r1 = 0; r1 < e1.dim.length; ++r1)n1.dim[r1] = c1.onnx.TensorShapeProto.Dimension.toObject(e1.dim[r1], t1);\n                    }\n                    return n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TensorShapeProto\";\n                }, e1.Dimension = function() {\n                    function e1(e1) {\n                        if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                    }\n                    var t1;\n                    return e1.prototype.dimValue = null, e1.prototype.dimParam = null, e1.prototype.denotation = \"\", Object.defineProperty(e1.prototype, \"value\", {\n                        get: l1.oneOfGetter(t1 = [\n                            \"dimValue\",\n                            \"dimParam\"\n                        ]),\n                        set: l1.oneOfSetter(t1)\n                    }), e1.create = function(t1) {\n                        return new e1(t1);\n                    }, e1.encode = function(e1, t1) {\n                        return t1 || (t1 = u1.create()), null != e1.dimValue && Object.hasOwnProperty.call(e1, \"dimValue\") && t1.uint32(8).int64(e1.dimValue), null != e1.dimParam && Object.hasOwnProperty.call(e1, \"dimParam\") && t1.uint32(18).string(e1.dimParam), null != e1.denotation && Object.hasOwnProperty.call(e1, \"denotation\") && t1.uint32(26).string(e1.denotation), t1;\n                    }, e1.encodeDelimited = function(e1, t1) {\n                        return this.encode(e1, t1).ldelim();\n                    }, e1.decode = function(e1, t1) {\n                        e1 instanceof a1 || (e1 = a1.create(e1));\n                        for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TensorShapeProto.Dimension; e1.pos < n1;){\n                            var o1 = e1.uint32();\n                            switch(o1 >>> 3){\n                                case 1:\n                                    r1.dimValue = e1.int64();\n                                    break;\n                                case 2:\n                                    r1.dimParam = e1.string();\n                                    break;\n                                case 3:\n                                    r1.denotation = e1.string();\n                                    break;\n                                default:\n                                    e1.skipType(7 & o1);\n                            }\n                        }\n                        return r1;\n                    }, e1.decodeDelimited = function(e1) {\n                        return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                    }, e1.verify = function(e1) {\n                        if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                        var t1 = {};\n                        if (null != e1.dimValue && e1.hasOwnProperty(\"dimValue\") && (t1.value = 1, !(l1.isInteger(e1.dimValue) || e1.dimValue && l1.isInteger(e1.dimValue.low) && l1.isInteger(e1.dimValue.high)))) return \"dimValue: integer|Long expected\";\n                        if (null != e1.dimParam && e1.hasOwnProperty(\"dimParam\")) {\n                            if (1 === t1.value) return \"value: multiple values\";\n                            if (t1.value = 1, !l1.isString(e1.dimParam)) return \"dimParam: string expected\";\n                        }\n                        return null != e1.denotation && e1.hasOwnProperty(\"denotation\") && !l1.isString(e1.denotation) ? \"denotation: string expected\" : null;\n                    }, e1.fromObject = function(e1) {\n                        if (e1 instanceof c1.onnx.TensorShapeProto.Dimension) return e1;\n                        var t1 = new c1.onnx.TensorShapeProto.Dimension;\n                        return null != e1.dimValue && (l1.Long ? (t1.dimValue = l1.Long.fromValue(e1.dimValue)).unsigned = !1 : \"string\" == typeof e1.dimValue ? t1.dimValue = parseInt(e1.dimValue, 10) : \"number\" == typeof e1.dimValue ? t1.dimValue = e1.dimValue : \"object\" == typeof e1.dimValue && (t1.dimValue = new l1.LongBits(e1.dimValue.low >>> 0, e1.dimValue.high >>> 0).toNumber())), null != e1.dimParam && (t1.dimParam = String(e1.dimParam)), null != e1.denotation && (t1.denotation = String(e1.denotation)), t1;\n                    }, e1.toObject = function(e1, t1) {\n                        t1 || (t1 = {});\n                        var n1 = {};\n                        return t1.defaults && (n1.denotation = \"\"), null != e1.dimValue && e1.hasOwnProperty(\"dimValue\") && (\"number\" == typeof e1.dimValue ? n1.dimValue = t1.longs === String ? String(e1.dimValue) : e1.dimValue : n1.dimValue = t1.longs === String ? l1.Long.prototype.toString.call(e1.dimValue) : t1.longs === Number ? new l1.LongBits(e1.dimValue.low >>> 0, e1.dimValue.high >>> 0).toNumber() : e1.dimValue, t1.oneofs && (n1.value = \"dimValue\")), null != e1.dimParam && e1.hasOwnProperty(\"dimParam\") && (n1.dimParam = e1.dimParam, t1.oneofs && (n1.value = \"dimParam\")), null != e1.denotation && e1.hasOwnProperty(\"denotation\") && (n1.denotation = e1.denotation), n1;\n                    }, e1.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, s1.util.toJSONOptions);\n                    }, e1.getTypeUrl = function(e1) {\n                        return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TensorShapeProto.Dimension\";\n                    }, e1;\n                }(), e1;\n            }(), i1.TypeProto = function() {\n                function e1(e1) {\n                    if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                var t1;\n                return e1.prototype.tensorType = null, e1.prototype.sequenceType = null, e1.prototype.mapType = null, e1.prototype.optionalType = null, e1.prototype.sparseTensorType = null, e1.prototype.denotation = \"\", Object.defineProperty(e1.prototype, \"value\", {\n                    get: l1.oneOfGetter(t1 = [\n                        \"tensorType\",\n                        \"sequenceType\",\n                        \"mapType\",\n                        \"optionalType\",\n                        \"sparseTensorType\"\n                    ]),\n                    set: l1.oneOfSetter(t1)\n                }), e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    return t1 || (t1 = u1.create()), null != e1.tensorType && Object.hasOwnProperty.call(e1, \"tensorType\") && c1.onnx.TypeProto.Tensor.encode(e1.tensorType, t1.uint32(10).fork()).ldelim(), null != e1.sequenceType && Object.hasOwnProperty.call(e1, \"sequenceType\") && c1.onnx.TypeProto.Sequence.encode(e1.sequenceType, t1.uint32(34).fork()).ldelim(), null != e1.mapType && Object.hasOwnProperty.call(e1, \"mapType\") && c1.onnx.TypeProto.Map.encode(e1.mapType, t1.uint32(42).fork()).ldelim(), null != e1.denotation && Object.hasOwnProperty.call(e1, \"denotation\") && t1.uint32(50).string(e1.denotation), null != e1.sparseTensorType && Object.hasOwnProperty.call(e1, \"sparseTensorType\") && c1.onnx.TypeProto.SparseTensor.encode(e1.sparseTensorType, t1.uint32(66).fork()).ldelim(), null != e1.optionalType && Object.hasOwnProperty.call(e1, \"optionalType\") && c1.onnx.TypeProto.Optional.encode(e1.optionalType, t1.uint32(74).fork()).ldelim(), t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TypeProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.tensorType = c1.onnx.TypeProto.Tensor.decode(e1, e1.uint32());\n                                break;\n                            case 4:\n                                r1.sequenceType = c1.onnx.TypeProto.Sequence.decode(e1, e1.uint32());\n                                break;\n                            case 5:\n                                r1.mapType = c1.onnx.TypeProto.Map.decode(e1, e1.uint32());\n                                break;\n                            case 9:\n                                r1.optionalType = c1.onnx.TypeProto.Optional.decode(e1, e1.uint32());\n                                break;\n                            case 8:\n                                r1.sparseTensorType = c1.onnx.TypeProto.SparseTensor.decode(e1, e1.uint32());\n                                break;\n                            case 6:\n                                r1.denotation = e1.string();\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    var t1 = {};\n                    if (null != e1.tensorType && e1.hasOwnProperty(\"tensorType\") && (t1.value = 1, n1 = c1.onnx.TypeProto.Tensor.verify(e1.tensorType))) return \"tensorType.\" + n1;\n                    if (null != e1.sequenceType && e1.hasOwnProperty(\"sequenceType\")) {\n                        if (1 === t1.value) return \"value: multiple values\";\n                        if (t1.value = 1, n1 = c1.onnx.TypeProto.Sequence.verify(e1.sequenceType)) return \"sequenceType.\" + n1;\n                    }\n                    if (null != e1.mapType && e1.hasOwnProperty(\"mapType\")) {\n                        if (1 === t1.value) return \"value: multiple values\";\n                        if (t1.value = 1, n1 = c1.onnx.TypeProto.Map.verify(e1.mapType)) return \"mapType.\" + n1;\n                    }\n                    if (null != e1.optionalType && e1.hasOwnProperty(\"optionalType\")) {\n                        if (1 === t1.value) return \"value: multiple values\";\n                        if (t1.value = 1, n1 = c1.onnx.TypeProto.Optional.verify(e1.optionalType)) return \"optionalType.\" + n1;\n                    }\n                    if (null != e1.sparseTensorType && e1.hasOwnProperty(\"sparseTensorType\")) {\n                        if (1 === t1.value) return \"value: multiple values\";\n                        var n1;\n                        if (t1.value = 1, n1 = c1.onnx.TypeProto.SparseTensor.verify(e1.sparseTensorType)) return \"sparseTensorType.\" + n1;\n                    }\n                    return null != e1.denotation && e1.hasOwnProperty(\"denotation\") && !l1.isString(e1.denotation) ? \"denotation: string expected\" : null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.TypeProto) return e1;\n                    var t1 = new c1.onnx.TypeProto;\n                    if (null != e1.tensorType) {\n                        if (\"object\" != typeof e1.tensorType) throw TypeError(\".onnx.TypeProto.tensorType: object expected\");\n                        t1.tensorType = c1.onnx.TypeProto.Tensor.fromObject(e1.tensorType);\n                    }\n                    if (null != e1.sequenceType) {\n                        if (\"object\" != typeof e1.sequenceType) throw TypeError(\".onnx.TypeProto.sequenceType: object expected\");\n                        t1.sequenceType = c1.onnx.TypeProto.Sequence.fromObject(e1.sequenceType);\n                    }\n                    if (null != e1.mapType) {\n                        if (\"object\" != typeof e1.mapType) throw TypeError(\".onnx.TypeProto.mapType: object expected\");\n                        t1.mapType = c1.onnx.TypeProto.Map.fromObject(e1.mapType);\n                    }\n                    if (null != e1.optionalType) {\n                        if (\"object\" != typeof e1.optionalType) throw TypeError(\".onnx.TypeProto.optionalType: object expected\");\n                        t1.optionalType = c1.onnx.TypeProto.Optional.fromObject(e1.optionalType);\n                    }\n                    if (null != e1.sparseTensorType) {\n                        if (\"object\" != typeof e1.sparseTensorType) throw TypeError(\".onnx.TypeProto.sparseTensorType: object expected\");\n                        t1.sparseTensorType = c1.onnx.TypeProto.SparseTensor.fromObject(e1.sparseTensorType);\n                    }\n                    return null != e1.denotation && (t1.denotation = String(e1.denotation)), t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    return t1.defaults && (n1.denotation = \"\"), null != e1.tensorType && e1.hasOwnProperty(\"tensorType\") && (n1.tensorType = c1.onnx.TypeProto.Tensor.toObject(e1.tensorType, t1), t1.oneofs && (n1.value = \"tensorType\")), null != e1.sequenceType && e1.hasOwnProperty(\"sequenceType\") && (n1.sequenceType = c1.onnx.TypeProto.Sequence.toObject(e1.sequenceType, t1), t1.oneofs && (n1.value = \"sequenceType\")), null != e1.mapType && e1.hasOwnProperty(\"mapType\") && (n1.mapType = c1.onnx.TypeProto.Map.toObject(e1.mapType, t1), t1.oneofs && (n1.value = \"mapType\")), null != e1.denotation && e1.hasOwnProperty(\"denotation\") && (n1.denotation = e1.denotation), null != e1.sparseTensorType && e1.hasOwnProperty(\"sparseTensorType\") && (n1.sparseTensorType = c1.onnx.TypeProto.SparseTensor.toObject(e1.sparseTensorType, t1), t1.oneofs && (n1.value = \"sparseTensorType\")), null != e1.optionalType && e1.hasOwnProperty(\"optionalType\") && (n1.optionalType = c1.onnx.TypeProto.Optional.toObject(e1.optionalType, t1), t1.oneofs && (n1.value = \"optionalType\")), n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TypeProto\";\n                }, e1.Tensor = function() {\n                    function e1(e1) {\n                        if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                    }\n                    return e1.prototype.elemType = 0, e1.prototype.shape = null, e1.create = function(t1) {\n                        return new e1(t1);\n                    }, e1.encode = function(e1, t1) {\n                        return t1 || (t1 = u1.create()), null != e1.elemType && Object.hasOwnProperty.call(e1, \"elemType\") && t1.uint32(8).int32(e1.elemType), null != e1.shape && Object.hasOwnProperty.call(e1, \"shape\") && c1.onnx.TensorShapeProto.encode(e1.shape, t1.uint32(18).fork()).ldelim(), t1;\n                    }, e1.encodeDelimited = function(e1, t1) {\n                        return this.encode(e1, t1).ldelim();\n                    }, e1.decode = function(e1, t1) {\n                        e1 instanceof a1 || (e1 = a1.create(e1));\n                        for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TypeProto.Tensor; e1.pos < n1;){\n                            var o1 = e1.uint32();\n                            switch(o1 >>> 3){\n                                case 1:\n                                    r1.elemType = e1.int32();\n                                    break;\n                                case 2:\n                                    r1.shape = c1.onnx.TensorShapeProto.decode(e1, e1.uint32());\n                                    break;\n                                default:\n                                    e1.skipType(7 & o1);\n                            }\n                        }\n                        return r1;\n                    }, e1.decodeDelimited = function(e1) {\n                        return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                    }, e1.verify = function(e1) {\n                        if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                        if (null != e1.elemType && e1.hasOwnProperty(\"elemType\") && !l1.isInteger(e1.elemType)) return \"elemType: integer expected\";\n                        if (null != e1.shape && e1.hasOwnProperty(\"shape\")) {\n                            var t1 = c1.onnx.TensorShapeProto.verify(e1.shape);\n                            if (t1) return \"shape.\" + t1;\n                        }\n                        return null;\n                    }, e1.fromObject = function(e1) {\n                        if (e1 instanceof c1.onnx.TypeProto.Tensor) return e1;\n                        var t1 = new c1.onnx.TypeProto.Tensor;\n                        if (null != e1.elemType && (t1.elemType = 0 | e1.elemType), null != e1.shape) {\n                            if (\"object\" != typeof e1.shape) throw TypeError(\".onnx.TypeProto.Tensor.shape: object expected\");\n                            t1.shape = c1.onnx.TensorShapeProto.fromObject(e1.shape);\n                        }\n                        return t1;\n                    }, e1.toObject = function(e1, t1) {\n                        t1 || (t1 = {});\n                        var n1 = {};\n                        return t1.defaults && (n1.elemType = 0, n1.shape = null), null != e1.elemType && e1.hasOwnProperty(\"elemType\") && (n1.elemType = e1.elemType), null != e1.shape && e1.hasOwnProperty(\"shape\") && (n1.shape = c1.onnx.TensorShapeProto.toObject(e1.shape, t1)), n1;\n                    }, e1.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, s1.util.toJSONOptions);\n                    }, e1.getTypeUrl = function(e1) {\n                        return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TypeProto.Tensor\";\n                    }, e1;\n                }(), e1.Sequence = function() {\n                    function e1(e1) {\n                        if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                    }\n                    return e1.prototype.elemType = null, e1.create = function(t1) {\n                        return new e1(t1);\n                    }, e1.encode = function(e1, t1) {\n                        return t1 || (t1 = u1.create()), null != e1.elemType && Object.hasOwnProperty.call(e1, \"elemType\") && c1.onnx.TypeProto.encode(e1.elemType, t1.uint32(10).fork()).ldelim(), t1;\n                    }, e1.encodeDelimited = function(e1, t1) {\n                        return this.encode(e1, t1).ldelim();\n                    }, e1.decode = function(e1, t1) {\n                        e1 instanceof a1 || (e1 = a1.create(e1));\n                        for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TypeProto.Sequence; e1.pos < n1;){\n                            var o1 = e1.uint32();\n                            o1 >>> 3 == 1 ? r1.elemType = c1.onnx.TypeProto.decode(e1, e1.uint32()) : e1.skipType(7 & o1);\n                        }\n                        return r1;\n                    }, e1.decodeDelimited = function(e1) {\n                        return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                    }, e1.verify = function(e1) {\n                        if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                        if (null != e1.elemType && e1.hasOwnProperty(\"elemType\")) {\n                            var t1 = c1.onnx.TypeProto.verify(e1.elemType);\n                            if (t1) return \"elemType.\" + t1;\n                        }\n                        return null;\n                    }, e1.fromObject = function(e1) {\n                        if (e1 instanceof c1.onnx.TypeProto.Sequence) return e1;\n                        var t1 = new c1.onnx.TypeProto.Sequence;\n                        if (null != e1.elemType) {\n                            if (\"object\" != typeof e1.elemType) throw TypeError(\".onnx.TypeProto.Sequence.elemType: object expected\");\n                            t1.elemType = c1.onnx.TypeProto.fromObject(e1.elemType);\n                        }\n                        return t1;\n                    }, e1.toObject = function(e1, t1) {\n                        t1 || (t1 = {});\n                        var n1 = {};\n                        return t1.defaults && (n1.elemType = null), null != e1.elemType && e1.hasOwnProperty(\"elemType\") && (n1.elemType = c1.onnx.TypeProto.toObject(e1.elemType, t1)), n1;\n                    }, e1.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, s1.util.toJSONOptions);\n                    }, e1.getTypeUrl = function(e1) {\n                        return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TypeProto.Sequence\";\n                    }, e1;\n                }(), e1.Map = function() {\n                    function e1(e1) {\n                        if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                    }\n                    return e1.prototype.keyType = 0, e1.prototype.valueType = null, e1.create = function(t1) {\n                        return new e1(t1);\n                    }, e1.encode = function(e1, t1) {\n                        return t1 || (t1 = u1.create()), null != e1.keyType && Object.hasOwnProperty.call(e1, \"keyType\") && t1.uint32(8).int32(e1.keyType), null != e1.valueType && Object.hasOwnProperty.call(e1, \"valueType\") && c1.onnx.TypeProto.encode(e1.valueType, t1.uint32(18).fork()).ldelim(), t1;\n                    }, e1.encodeDelimited = function(e1, t1) {\n                        return this.encode(e1, t1).ldelim();\n                    }, e1.decode = function(e1, t1) {\n                        e1 instanceof a1 || (e1 = a1.create(e1));\n                        for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TypeProto.Map; e1.pos < n1;){\n                            var o1 = e1.uint32();\n                            switch(o1 >>> 3){\n                                case 1:\n                                    r1.keyType = e1.int32();\n                                    break;\n                                case 2:\n                                    r1.valueType = c1.onnx.TypeProto.decode(e1, e1.uint32());\n                                    break;\n                                default:\n                                    e1.skipType(7 & o1);\n                            }\n                        }\n                        return r1;\n                    }, e1.decodeDelimited = function(e1) {\n                        return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                    }, e1.verify = function(e1) {\n                        if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                        if (null != e1.keyType && e1.hasOwnProperty(\"keyType\") && !l1.isInteger(e1.keyType)) return \"keyType: integer expected\";\n                        if (null != e1.valueType && e1.hasOwnProperty(\"valueType\")) {\n                            var t1 = c1.onnx.TypeProto.verify(e1.valueType);\n                            if (t1) return \"valueType.\" + t1;\n                        }\n                        return null;\n                    }, e1.fromObject = function(e1) {\n                        if (e1 instanceof c1.onnx.TypeProto.Map) return e1;\n                        var t1 = new c1.onnx.TypeProto.Map;\n                        if (null != e1.keyType && (t1.keyType = 0 | e1.keyType), null != e1.valueType) {\n                            if (\"object\" != typeof e1.valueType) throw TypeError(\".onnx.TypeProto.Map.valueType: object expected\");\n                            t1.valueType = c1.onnx.TypeProto.fromObject(e1.valueType);\n                        }\n                        return t1;\n                    }, e1.toObject = function(e1, t1) {\n                        t1 || (t1 = {});\n                        var n1 = {};\n                        return t1.defaults && (n1.keyType = 0, n1.valueType = null), null != e1.keyType && e1.hasOwnProperty(\"keyType\") && (n1.keyType = e1.keyType), null != e1.valueType && e1.hasOwnProperty(\"valueType\") && (n1.valueType = c1.onnx.TypeProto.toObject(e1.valueType, t1)), n1;\n                    }, e1.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, s1.util.toJSONOptions);\n                    }, e1.getTypeUrl = function(e1) {\n                        return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TypeProto.Map\";\n                    }, e1;\n                }(), e1.Optional = function() {\n                    function e1(e1) {\n                        if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                    }\n                    return e1.prototype.elemType = null, e1.create = function(t1) {\n                        return new e1(t1);\n                    }, e1.encode = function(e1, t1) {\n                        return t1 || (t1 = u1.create()), null != e1.elemType && Object.hasOwnProperty.call(e1, \"elemType\") && c1.onnx.TypeProto.encode(e1.elemType, t1.uint32(10).fork()).ldelim(), t1;\n                    }, e1.encodeDelimited = function(e1, t1) {\n                        return this.encode(e1, t1).ldelim();\n                    }, e1.decode = function(e1, t1) {\n                        e1 instanceof a1 || (e1 = a1.create(e1));\n                        for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TypeProto.Optional; e1.pos < n1;){\n                            var o1 = e1.uint32();\n                            o1 >>> 3 == 1 ? r1.elemType = c1.onnx.TypeProto.decode(e1, e1.uint32()) : e1.skipType(7 & o1);\n                        }\n                        return r1;\n                    }, e1.decodeDelimited = function(e1) {\n                        return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                    }, e1.verify = function(e1) {\n                        if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                        if (null != e1.elemType && e1.hasOwnProperty(\"elemType\")) {\n                            var t1 = c1.onnx.TypeProto.verify(e1.elemType);\n                            if (t1) return \"elemType.\" + t1;\n                        }\n                        return null;\n                    }, e1.fromObject = function(e1) {\n                        if (e1 instanceof c1.onnx.TypeProto.Optional) return e1;\n                        var t1 = new c1.onnx.TypeProto.Optional;\n                        if (null != e1.elemType) {\n                            if (\"object\" != typeof e1.elemType) throw TypeError(\".onnx.TypeProto.Optional.elemType: object expected\");\n                            t1.elemType = c1.onnx.TypeProto.fromObject(e1.elemType);\n                        }\n                        return t1;\n                    }, e1.toObject = function(e1, t1) {\n                        t1 || (t1 = {});\n                        var n1 = {};\n                        return t1.defaults && (n1.elemType = null), null != e1.elemType && e1.hasOwnProperty(\"elemType\") && (n1.elemType = c1.onnx.TypeProto.toObject(e1.elemType, t1)), n1;\n                    }, e1.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, s1.util.toJSONOptions);\n                    }, e1.getTypeUrl = function(e1) {\n                        return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TypeProto.Optional\";\n                    }, e1;\n                }(), e1.SparseTensor = function() {\n                    function e1(e1) {\n                        if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                    }\n                    return e1.prototype.elemType = 0, e1.prototype.shape = null, e1.create = function(t1) {\n                        return new e1(t1);\n                    }, e1.encode = function(e1, t1) {\n                        return t1 || (t1 = u1.create()), null != e1.elemType && Object.hasOwnProperty.call(e1, \"elemType\") && t1.uint32(8).int32(e1.elemType), null != e1.shape && Object.hasOwnProperty.call(e1, \"shape\") && c1.onnx.TensorShapeProto.encode(e1.shape, t1.uint32(18).fork()).ldelim(), t1;\n                    }, e1.encodeDelimited = function(e1, t1) {\n                        return this.encode(e1, t1).ldelim();\n                    }, e1.decode = function(e1, t1) {\n                        e1 instanceof a1 || (e1 = a1.create(e1));\n                        for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.TypeProto.SparseTensor; e1.pos < n1;){\n                            var o1 = e1.uint32();\n                            switch(o1 >>> 3){\n                                case 1:\n                                    r1.elemType = e1.int32();\n                                    break;\n                                case 2:\n                                    r1.shape = c1.onnx.TensorShapeProto.decode(e1, e1.uint32());\n                                    break;\n                                default:\n                                    e1.skipType(7 & o1);\n                            }\n                        }\n                        return r1;\n                    }, e1.decodeDelimited = function(e1) {\n                        return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                    }, e1.verify = function(e1) {\n                        if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                        if (null != e1.elemType && e1.hasOwnProperty(\"elemType\") && !l1.isInteger(e1.elemType)) return \"elemType: integer expected\";\n                        if (null != e1.shape && e1.hasOwnProperty(\"shape\")) {\n                            var t1 = c1.onnx.TensorShapeProto.verify(e1.shape);\n                            if (t1) return \"shape.\" + t1;\n                        }\n                        return null;\n                    }, e1.fromObject = function(e1) {\n                        if (e1 instanceof c1.onnx.TypeProto.SparseTensor) return e1;\n                        var t1 = new c1.onnx.TypeProto.SparseTensor;\n                        if (null != e1.elemType && (t1.elemType = 0 | e1.elemType), null != e1.shape) {\n                            if (\"object\" != typeof e1.shape) throw TypeError(\".onnx.TypeProto.SparseTensor.shape: object expected\");\n                            t1.shape = c1.onnx.TensorShapeProto.fromObject(e1.shape);\n                        }\n                        return t1;\n                    }, e1.toObject = function(e1, t1) {\n                        t1 || (t1 = {});\n                        var n1 = {};\n                        return t1.defaults && (n1.elemType = 0, n1.shape = null), null != e1.elemType && e1.hasOwnProperty(\"elemType\") && (n1.elemType = e1.elemType), null != e1.shape && e1.hasOwnProperty(\"shape\") && (n1.shape = c1.onnx.TensorShapeProto.toObject(e1.shape, t1)), n1;\n                    }, e1.prototype.toJSON = function() {\n                        return this.constructor.toObject(this, s1.util.toJSONOptions);\n                    }, e1.getTypeUrl = function(e1) {\n                        return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.TypeProto.SparseTensor\";\n                    }, e1;\n                }(), e1;\n            }(), i1.OperatorSetIdProto = function() {\n                function e1(e1) {\n                    if (e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.domain = \"\", e1.prototype.version = l1.Long ? l1.Long.fromBits(0, 0, !1) : 0, e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    return t1 || (t1 = u1.create()), null != e1.domain && Object.hasOwnProperty.call(e1, \"domain\") && t1.uint32(10).string(e1.domain), null != e1.version && Object.hasOwnProperty.call(e1, \"version\") && t1.uint32(16).int64(e1.version), t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.OperatorSetIdProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.domain = e1.string();\n                                break;\n                            case 2:\n                                r1.version = e1.int64();\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    return \"object\" != typeof e1 || null === e1 ? \"object expected\" : null != e1.domain && e1.hasOwnProperty(\"domain\") && !l1.isString(e1.domain) ? \"domain: string expected\" : null != e1.version && e1.hasOwnProperty(\"version\") && !(l1.isInteger(e1.version) || e1.version && l1.isInteger(e1.version.low) && l1.isInteger(e1.version.high)) ? \"version: integer|Long expected\" : null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.OperatorSetIdProto) return e1;\n                    var t1 = new c1.onnx.OperatorSetIdProto;\n                    return null != e1.domain && (t1.domain = String(e1.domain)), null != e1.version && (l1.Long ? (t1.version = l1.Long.fromValue(e1.version)).unsigned = !1 : \"string\" == typeof e1.version ? t1.version = parseInt(e1.version, 10) : \"number\" == typeof e1.version ? t1.version = e1.version : \"object\" == typeof e1.version && (t1.version = new l1.LongBits(e1.version.low >>> 0, e1.version.high >>> 0).toNumber())), t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if (t1.defaults) if (n1.domain = \"\", l1.Long) {\n                        var r1 = new l1.Long(0, 0, !1);\n                        n1.version = t1.longs === String ? r1.toString() : t1.longs === Number ? r1.toNumber() : r1;\n                    } else n1.version = t1.longs === String ? \"0\" : 0;\n                    return null != e1.domain && e1.hasOwnProperty(\"domain\") && (n1.domain = e1.domain), null != e1.version && e1.hasOwnProperty(\"version\") && (\"number\" == typeof e1.version ? n1.version = t1.longs === String ? String(e1.version) : e1.version : n1.version = t1.longs === String ? l1.Long.prototype.toString.call(e1.version) : t1.longs === Number ? new l1.LongBits(e1.version.low >>> 0, e1.version.high >>> 0).toNumber() : e1.version), n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.OperatorSetIdProto\";\n                }, e1;\n            }(), i1.OperatorStatus = function() {\n                var e1 = {}, t1 = Object.create(e1);\n                return t1[e1[0] = \"EXPERIMENTAL\"] = 0, t1[e1[1] = \"STABLE\"] = 1, t1;\n            }(), i1.FunctionProto = function() {\n                function e1(e1) {\n                    if (this.input = [], this.output = [], this.attribute = [], this.attributeProto = [], this.node = [], this.opsetImport = [], e1) for(var t1 = Object.keys(e1), n1 = 0; n1 < t1.length; ++n1)null != e1[t1[n1]] && (this[t1[n1]] = e1[t1[n1]]);\n                }\n                return e1.prototype.name = \"\", e1.prototype.input = l1.emptyArray, e1.prototype.output = l1.emptyArray, e1.prototype.attribute = l1.emptyArray, e1.prototype.attributeProto = l1.emptyArray, e1.prototype.node = l1.emptyArray, e1.prototype.docString = \"\", e1.prototype.opsetImport = l1.emptyArray, e1.prototype.domain = \"\", e1.create = function(t1) {\n                    return new e1(t1);\n                }, e1.encode = function(e1, t1) {\n                    if (t1 || (t1 = u1.create()), null != e1.name && Object.hasOwnProperty.call(e1, \"name\") && t1.uint32(10).string(e1.name), null != e1.input && e1.input.length) for(var n1 = 0; n1 < e1.input.length; ++n1)t1.uint32(34).string(e1.input[n1]);\n                    if (null != e1.output && e1.output.length) for(n1 = 0; n1 < e1.output.length; ++n1)t1.uint32(42).string(e1.output[n1]);\n                    if (null != e1.attribute && e1.attribute.length) for(n1 = 0; n1 < e1.attribute.length; ++n1)t1.uint32(50).string(e1.attribute[n1]);\n                    if (null != e1.node && e1.node.length) for(n1 = 0; n1 < e1.node.length; ++n1)c1.onnx.NodeProto.encode(e1.node[n1], t1.uint32(58).fork()).ldelim();\n                    if (null != e1.docString && Object.hasOwnProperty.call(e1, \"docString\") && t1.uint32(66).string(e1.docString), null != e1.opsetImport && e1.opsetImport.length) for(n1 = 0; n1 < e1.opsetImport.length; ++n1)c1.onnx.OperatorSetIdProto.encode(e1.opsetImport[n1], t1.uint32(74).fork()).ldelim();\n                    if (null != e1.domain && Object.hasOwnProperty.call(e1, \"domain\") && t1.uint32(82).string(e1.domain), null != e1.attributeProto && e1.attributeProto.length) for(n1 = 0; n1 < e1.attributeProto.length; ++n1)c1.onnx.AttributeProto.encode(e1.attributeProto[n1], t1.uint32(90).fork()).ldelim();\n                    return t1;\n                }, e1.encodeDelimited = function(e1, t1) {\n                    return this.encode(e1, t1).ldelim();\n                }, e1.decode = function(e1, t1) {\n                    e1 instanceof a1 || (e1 = a1.create(e1));\n                    for(var n1 = void 0 === t1 ? e1.len : e1.pos + t1, r1 = new c1.onnx.FunctionProto; e1.pos < n1;){\n                        var o1 = e1.uint32();\n                        switch(o1 >>> 3){\n                            case 1:\n                                r1.name = e1.string();\n                                break;\n                            case 4:\n                                r1.input && r1.input.length || (r1.input = []), r1.input.push(e1.string());\n                                break;\n                            case 5:\n                                r1.output && r1.output.length || (r1.output = []), r1.output.push(e1.string());\n                                break;\n                            case 6:\n                                r1.attribute && r1.attribute.length || (r1.attribute = []), r1.attribute.push(e1.string());\n                                break;\n                            case 11:\n                                r1.attributeProto && r1.attributeProto.length || (r1.attributeProto = []), r1.attributeProto.push(c1.onnx.AttributeProto.decode(e1, e1.uint32()));\n                                break;\n                            case 7:\n                                r1.node && r1.node.length || (r1.node = []), r1.node.push(c1.onnx.NodeProto.decode(e1, e1.uint32()));\n                                break;\n                            case 8:\n                                r1.docString = e1.string();\n                                break;\n                            case 9:\n                                r1.opsetImport && r1.opsetImport.length || (r1.opsetImport = []), r1.opsetImport.push(c1.onnx.OperatorSetIdProto.decode(e1, e1.uint32()));\n                                break;\n                            case 10:\n                                r1.domain = e1.string();\n                                break;\n                            default:\n                                e1.skipType(7 & o1);\n                        }\n                    }\n                    return r1;\n                }, e1.decodeDelimited = function(e1) {\n                    return e1 instanceof a1 || (e1 = new a1(e1)), this.decode(e1, e1.uint32());\n                }, e1.verify = function(e1) {\n                    if (\"object\" != typeof e1 || null === e1) return \"object expected\";\n                    if (null != e1.name && e1.hasOwnProperty(\"name\") && !l1.isString(e1.name)) return \"name: string expected\";\n                    if (null != e1.input && e1.hasOwnProperty(\"input\")) {\n                        if (!Array.isArray(e1.input)) return \"input: array expected\";\n                        for(var t1 = 0; t1 < e1.input.length; ++t1)if (!l1.isString(e1.input[t1])) return \"input: string[] expected\";\n                    }\n                    if (null != e1.output && e1.hasOwnProperty(\"output\")) {\n                        if (!Array.isArray(e1.output)) return \"output: array expected\";\n                        for(t1 = 0; t1 < e1.output.length; ++t1)if (!l1.isString(e1.output[t1])) return \"output: string[] expected\";\n                    }\n                    if (null != e1.attribute && e1.hasOwnProperty(\"attribute\")) {\n                        if (!Array.isArray(e1.attribute)) return \"attribute: array expected\";\n                        for(t1 = 0; t1 < e1.attribute.length; ++t1)if (!l1.isString(e1.attribute[t1])) return \"attribute: string[] expected\";\n                    }\n                    if (null != e1.attributeProto && e1.hasOwnProperty(\"attributeProto\")) {\n                        if (!Array.isArray(e1.attributeProto)) return \"attributeProto: array expected\";\n                        for(t1 = 0; t1 < e1.attributeProto.length; ++t1)if (n1 = c1.onnx.AttributeProto.verify(e1.attributeProto[t1])) return \"attributeProto.\" + n1;\n                    }\n                    if (null != e1.node && e1.hasOwnProperty(\"node\")) {\n                        if (!Array.isArray(e1.node)) return \"node: array expected\";\n                        for(t1 = 0; t1 < e1.node.length; ++t1)if (n1 = c1.onnx.NodeProto.verify(e1.node[t1])) return \"node.\" + n1;\n                    }\n                    if (null != e1.docString && e1.hasOwnProperty(\"docString\") && !l1.isString(e1.docString)) return \"docString: string expected\";\n                    if (null != e1.opsetImport && e1.hasOwnProperty(\"opsetImport\")) {\n                        if (!Array.isArray(e1.opsetImport)) return \"opsetImport: array expected\";\n                        for(t1 = 0; t1 < e1.opsetImport.length; ++t1){\n                            var n1;\n                            if (n1 = c1.onnx.OperatorSetIdProto.verify(e1.opsetImport[t1])) return \"opsetImport.\" + n1;\n                        }\n                    }\n                    return null != e1.domain && e1.hasOwnProperty(\"domain\") && !l1.isString(e1.domain) ? \"domain: string expected\" : null;\n                }, e1.fromObject = function(e1) {\n                    if (e1 instanceof c1.onnx.FunctionProto) return e1;\n                    var t1 = new c1.onnx.FunctionProto;\n                    if (null != e1.name && (t1.name = String(e1.name)), e1.input) {\n                        if (!Array.isArray(e1.input)) throw TypeError(\".onnx.FunctionProto.input: array expected\");\n                        t1.input = [];\n                        for(var n1 = 0; n1 < e1.input.length; ++n1)t1.input[n1] = String(e1.input[n1]);\n                    }\n                    if (e1.output) {\n                        if (!Array.isArray(e1.output)) throw TypeError(\".onnx.FunctionProto.output: array expected\");\n                        for(t1.output = [], n1 = 0; n1 < e1.output.length; ++n1)t1.output[n1] = String(e1.output[n1]);\n                    }\n                    if (e1.attribute) {\n                        if (!Array.isArray(e1.attribute)) throw TypeError(\".onnx.FunctionProto.attribute: array expected\");\n                        for(t1.attribute = [], n1 = 0; n1 < e1.attribute.length; ++n1)t1.attribute[n1] = String(e1.attribute[n1]);\n                    }\n                    if (e1.attributeProto) {\n                        if (!Array.isArray(e1.attributeProto)) throw TypeError(\".onnx.FunctionProto.attributeProto: array expected\");\n                        for(t1.attributeProto = [], n1 = 0; n1 < e1.attributeProto.length; ++n1){\n                            if (\"object\" != typeof e1.attributeProto[n1]) throw TypeError(\".onnx.FunctionProto.attributeProto: object expected\");\n                            t1.attributeProto[n1] = c1.onnx.AttributeProto.fromObject(e1.attributeProto[n1]);\n                        }\n                    }\n                    if (e1.node) {\n                        if (!Array.isArray(e1.node)) throw TypeError(\".onnx.FunctionProto.node: array expected\");\n                        for(t1.node = [], n1 = 0; n1 < e1.node.length; ++n1){\n                            if (\"object\" != typeof e1.node[n1]) throw TypeError(\".onnx.FunctionProto.node: object expected\");\n                            t1.node[n1] = c1.onnx.NodeProto.fromObject(e1.node[n1]);\n                        }\n                    }\n                    if (null != e1.docString && (t1.docString = String(e1.docString)), e1.opsetImport) {\n                        if (!Array.isArray(e1.opsetImport)) throw TypeError(\".onnx.FunctionProto.opsetImport: array expected\");\n                        for(t1.opsetImport = [], n1 = 0; n1 < e1.opsetImport.length; ++n1){\n                            if (\"object\" != typeof e1.opsetImport[n1]) throw TypeError(\".onnx.FunctionProto.opsetImport: object expected\");\n                            t1.opsetImport[n1] = c1.onnx.OperatorSetIdProto.fromObject(e1.opsetImport[n1]);\n                        }\n                    }\n                    return null != e1.domain && (t1.domain = String(e1.domain)), t1;\n                }, e1.toObject = function(e1, t1) {\n                    t1 || (t1 = {});\n                    var n1 = {};\n                    if ((t1.arrays || t1.defaults) && (n1.input = [], n1.output = [], n1.attribute = [], n1.node = [], n1.opsetImport = [], n1.attributeProto = []), t1.defaults && (n1.name = \"\", n1.docString = \"\", n1.domain = \"\"), null != e1.name && e1.hasOwnProperty(\"name\") && (n1.name = e1.name), e1.input && e1.input.length) {\n                        n1.input = [];\n                        for(var r1 = 0; r1 < e1.input.length; ++r1)n1.input[r1] = e1.input[r1];\n                    }\n                    if (e1.output && e1.output.length) for(n1.output = [], r1 = 0; r1 < e1.output.length; ++r1)n1.output[r1] = e1.output[r1];\n                    if (e1.attribute && e1.attribute.length) for(n1.attribute = [], r1 = 0; r1 < e1.attribute.length; ++r1)n1.attribute[r1] = e1.attribute[r1];\n                    if (e1.node && e1.node.length) for(n1.node = [], r1 = 0; r1 < e1.node.length; ++r1)n1.node[r1] = c1.onnx.NodeProto.toObject(e1.node[r1], t1);\n                    if (null != e1.docString && e1.hasOwnProperty(\"docString\") && (n1.docString = e1.docString), e1.opsetImport && e1.opsetImport.length) for(n1.opsetImport = [], r1 = 0; r1 < e1.opsetImport.length; ++r1)n1.opsetImport[r1] = c1.onnx.OperatorSetIdProto.toObject(e1.opsetImport[r1], t1);\n                    if (null != e1.domain && e1.hasOwnProperty(\"domain\") && (n1.domain = e1.domain), e1.attributeProto && e1.attributeProto.length) for(n1.attributeProto = [], r1 = 0; r1 < e1.attributeProto.length; ++r1)n1.attributeProto[r1] = c1.onnx.AttributeProto.toObject(e1.attributeProto[r1], t1);\n                    return n1;\n                }, e1.prototype.toJSON = function() {\n                    return this.constructor.toObject(this, s1.util.toJSONOptions);\n                }, e1.getTypeUrl = function(e1) {\n                    return void 0 === e1 && (e1 = \"type.googleapis.com\"), e1 + \"/onnx.FunctionProto\";\n                }, e1;\n            }(), i1), e1.exports = c1;\n        },\n        3474: (e1, t1, n1)=>{\n            var _scriptDir1, r1 = (_scriptDir1 = \"undefined\" != typeof document && document.currentScript ? document.currentScript.src : void 0,  true && (_scriptDir1 = _scriptDir1 || __filename), function(e1 = {}) {\n                function t1() {\n                    return D1.buffer != N1.buffer && U1(), N1;\n                }\n                function r1() {\n                    return D1.buffer != N1.buffer && U1(), L1;\n                }\n                function o1() {\n                    return D1.buffer != N1.buffer && U1(), C1;\n                }\n                function i1() {\n                    return D1.buffer != N1.buffer && U1(), R1;\n                }\n                function s1() {\n                    return D1.buffer != N1.buffer && U1(), j1;\n                }\n                var a1, u1, l1 = e1;\n                l1.ready = new Promise((e1, t1)=>{\n                    a1 = e1, u1 = t1;\n                });\n                var c1, p1, d1, f1 = Object.assign({}, l1), h1 = \"./this.program\", g1 = (e1, t1)=>{\n                    throw t1;\n                }, b1 = \"object\" == \"undefined\", m1 = \"function\" == typeof importScripts, y1 = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node, _1 = l1.ENVIRONMENT_IS_PTHREAD || !1, v1 = \"\";\n                function T1(e1) {\n                    return l1.locateFile ? l1.locateFile(e1, v1) : v1 + e1;\n                }\n                if (y1) {\n                    var x1 = n1(6231), w1 = n1(1423);\n                    let t1;\n                    v1 = m1 ? w1.dirname(v1) + \"/\" : __dirname + \"/\", c1 = (e1, t1)=>(e1 = e1.startsWith(\"file://\") ? new URL(e1) : w1.normalize(e1), x1.readFileSync(e1, t1 ? void 0 : \"utf8\")), d1 = (e1)=>((e1 = c1(e1, !0)).buffer || (e1 = new Uint8Array(e1)), e1), p1 = (e1, t1, n1, r1 = !0)=>{\n                        e1 = e1.startsWith(\"file://\") ? new URL(e1) : w1.normalize(e1), x1.readFile(e1, r1 ? void 0 : \"utf8\", (e1, o1)=>{\n                            e1 ? n1(e1) : t1(r1 ? o1.buffer : o1);\n                        });\n                    }, !l1.thisProgram && 1 < process.argv.length && (h1 = process.argv[1].replace(/\\\\/g, \"/\")), process.argv.slice(2), g1 = (e1, t1)=>{\n                        throw process.exitCode = e1, t1;\n                    }, l1.inspect = ()=>\"[Emscripten Module object]\";\n                    try {\n                        t1 = n1(4564);\n                    } catch (e1) {\n                        throw console.error('The \"worker_threads\" module is not supported in this node.js build - perhaps a newer version is needed?'), e1;\n                    }\n                    global.Worker = t1.Worker;\n                } else (b1 || m1) && (m1 ? v1 = self.location.href : \"undefined\" != typeof document && document.currentScript && (v1 = document.currentScript.src), _scriptDir1 && (v1 = _scriptDir1), v1 = 0 !== v1.indexOf(\"blob:\") ? v1.substr(0, v1.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : \"\", y1 || (c1 = (e1)=>{\n                    var t1 = new XMLHttpRequest;\n                    return t1.open(\"GET\", e1, !1), t1.send(null), t1.responseText;\n                }, m1 && (d1 = (e1)=>{\n                    var t1 = new XMLHttpRequest;\n                    return t1.open(\"GET\", e1, !1), t1.responseType = \"arraybuffer\", t1.send(null), new Uint8Array(t1.response);\n                }), p1 = (e1, t1, n1)=>{\n                    var r1 = new XMLHttpRequest;\n                    r1.open(\"GET\", e1, !0), r1.responseType = \"arraybuffer\", r1.onload = ()=>{\n                        200 == r1.status || 0 == r1.status && r1.response ? t1(r1.response) : n1();\n                    }, r1.onerror = n1, r1.send(null);\n                }));\n                y1 && \"undefined\" == typeof performance && (global.performance = n1(498).performance);\n                var O1 = console.log.bind(console), S1 = console.error.bind(console);\n                y1 && (O1 = (...e1)=>x1.writeSync(1, e1.join(\" \") + \"\\n\"), S1 = (...e1)=>x1.writeSync(2, e1.join(\" \") + \"\\n\"));\n                var A1, P1 = l1.print || O1, I1 = l1.printErr || S1;\n                Object.assign(l1, f1), f1 = null, l1.thisProgram && (h1 = l1.thisProgram), l1.quit && (g1 = l1.quit), l1.wasmBinary && (A1 = l1.wasmBinary);\n                var E1 = l1.noExitRuntime || !0;\n                \"object\" != typeof WebAssembly && te1(\"no native wasm support detected\");\n                var D1, $1, k1, F1, N1, L1, C1, R1, j1, M1 = !1;\n                function U1() {\n                    var e1 = D1.buffer;\n                    l1.HEAP8 = N1 = new Int8Array(e1), l1.HEAP16 = new Int16Array(e1), l1.HEAP32 = C1 = new Int32Array(e1), l1.HEAPU8 = L1 = new Uint8Array(e1), l1.HEAPU16 = new Uint16Array(e1), l1.HEAPU32 = R1 = new Uint32Array(e1), l1.HEAPF32 = new Float32Array(e1), l1.HEAPF64 = j1 = new Float64Array(e1);\n                }\n                var B1 = l1.INITIAL_MEMORY || 16777216;\n                if (5242880 <= B1 || te1(\"INITIAL_MEMORY should be larger than STACK_SIZE, was \" + B1 + \"! (STACK_SIZE=5242880)\"), _1) D1 = l1.wasmMemory;\n                else if (l1.wasmMemory) D1 = l1.wasmMemory;\n                else if (!((D1 = new WebAssembly.Memory({\n                    initial: B1 / 65536,\n                    maximum: 65536,\n                    shared: !0\n                })).buffer instanceof SharedArrayBuffer)) throw I1(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"), y1 && I1(\"(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)\"), Error(\"bad memory\");\n                U1(), B1 = D1.buffer.byteLength;\n                var V1, z1 = [], G1 = [], H1 = [], q1 = 0;\n                function W1() {\n                    return E1 || 0 < q1;\n                }\n                var X1, Y1, K1 = 0, J1 = null, Z1 = null;\n                function Q1() {\n                    K1++, l1.monitorRunDependencies && l1.monitorRunDependencies(K1);\n                }\n                function ee1() {\n                    if (K1--, l1.monitorRunDependencies && l1.monitorRunDependencies(K1), 0 == K1 && (null !== J1 && (clearInterval(J1), J1 = null), Z1)) {\n                        var e1 = Z1;\n                        Z1 = null, e1();\n                    }\n                }\n                function te1(e1) {\n                    throw l1.onAbort && l1.onAbort(e1), I1(e1 = \"Aborted(\" + e1 + \")\"), M1 = !0, F1 = 1, e1 = new WebAssembly.RuntimeError(e1 + \". Build with -sASSERTIONS for more info.\"), u1(e1), e1;\n                }\n                function ne1(e1) {\n                    return e1.startsWith(\"data:application/octet-stream;base64,\");\n                }\n                function re1(e1) {\n                    if (e1 == X1 && A1) return new Uint8Array(A1);\n                    if (d1) return d1(e1);\n                    throw \"both async and sync fetching of the wasm failed\";\n                }\n                function oe1(e1, t1, n1) {\n                    return (function(e1) {\n                        if (!A1 && (b1 || m1)) {\n                            if (\"function\" == typeof fetch && !e1.startsWith(\"file://\")) return fetch(e1, {\n                                credentials: \"same-origin\"\n                            }).then((t1)=>{\n                                if (!t1.ok) throw \"failed to load wasm binary file at '\" + e1 + \"'\";\n                                return t1.arrayBuffer();\n                            }).catch(()=>re1(e1));\n                            if (p1) return new Promise((t1, n1)=>{\n                                p1(e1, (e1)=>t1(new Uint8Array(e1)), n1);\n                            });\n                        }\n                        return Promise.resolve().then(()=>re1(e1));\n                    })(e1).then((e1)=>WebAssembly.instantiate(e1, t1)).then((e1)=>e1).then(n1, (e1)=>{\n                        I1(\"failed to asynchronously prepare wasm: \" + e1), te1(e1);\n                    });\n                }\n                function ie1(e1) {\n                    this.name = \"ExitStatus\", this.message = `Program terminated with exit(${e1})`, this.status = e1;\n                }\n                function se1(e1) {\n                    e1.terminate(), e1.onmessage = ()=>{};\n                }\n                function ae1(e1) {\n                    (e1 = he1.Fa[e1]) || te1(), he1.fb(e1);\n                }\n                function ue1(e1) {\n                    var t1 = he1.Za();\n                    if (!t1) return 6;\n                    he1.Ia.push(t1), he1.Fa[e1.Ha] = t1, t1.Ha = e1.Ha;\n                    var n1 = {\n                        cmd: \"run\",\n                        start_routine: e1.gb,\n                        arg: e1.Ya,\n                        pthread_ptr: e1.Ha\n                    };\n                    return y1 && t1.unref(), t1.postMessage(n1, e1.mb), 0;\n                }\n                ne1(X1 = \"ort-wasm-threaded.wasm\") || (X1 = T1(X1));\n                var le1 = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0, ce1 = (e1, t1, n1)=>{\n                    var r1 = (t1 >>>= 0) + n1;\n                    for(n1 = t1; e1[n1] && !(n1 >= r1);)++n1;\n                    if (16 < n1 - t1 && e1.buffer && le1) return le1.decode(e1.buffer instanceof SharedArrayBuffer ? e1.slice(t1, n1) : e1.subarray(t1, n1));\n                    for(r1 = \"\"; t1 < n1;){\n                        var o1 = e1[t1++];\n                        if (128 & o1) {\n                            var i1 = 63 & e1[t1++];\n                            if (192 == (224 & o1)) r1 += String.fromCharCode((31 & o1) << 6 | i1);\n                            else {\n                                var s1 = 63 & e1[t1++];\n                                65536 > (o1 = 224 == (240 & o1) ? (15 & o1) << 12 | i1 << 6 | s1 : (7 & o1) << 18 | i1 << 12 | s1 << 6 | 63 & e1[t1++]) ? r1 += String.fromCharCode(o1) : (o1 -= 65536, r1 += String.fromCharCode(55296 | o1 >> 10, 56320 | 1023 & o1));\n                            }\n                        } else r1 += String.fromCharCode(o1);\n                    }\n                    return r1;\n                }, pe1 = (e1, t1)=>(e1 >>>= 0) ? ce1(r1(), e1, t1) : \"\";\n                function de1(e1) {\n                    if (_1) return We1(1, 1, e1);\n                    F1 = e1, W1() || (he1.hb(), l1.onExit && l1.onExit(e1), M1 = !0), g1(e1, new ie1(e1));\n                }\n                var fe1 = (e1)=>{\n                    if (F1 = e1, _1) throw be1(e1), \"unwind\";\n                    de1(e1);\n                }, he1 = {\n                    La: [],\n                    Ia: [],\n                    Ta: [],\n                    Fa: {},\n                    Pa: function() {\n                        _1 ? he1.ab() : he1.$a();\n                    },\n                    $a: function() {\n                        z1.unshift(()=>{\n                            Q1(), he1.bb(()=>ee1());\n                        });\n                    },\n                    ab: function() {\n                        he1.receiveObjectTransfer = he1.eb, he1.threadInitTLS = he1.Sa, he1.setExitStatus = he1.Ra, E1 = !1;\n                    },\n                    Ra: function(e1) {\n                        F1 = e1;\n                    },\n                    rb: [\n                        \"$terminateWorker\"\n                    ],\n                    hb: function() {\n                        for (var e1 of he1.Ia)se1(e1);\n                        for (e1 of he1.La)se1(e1);\n                        he1.La = [], he1.Ia = [], he1.Fa = [];\n                    },\n                    fb: function(e1) {\n                        var t1 = e1.Ha;\n                        delete he1.Fa[t1], he1.La.push(e1), he1.Ia.splice(he1.Ia.indexOf(e1), 1), e1.Ha = 0, mt1(t1);\n                    },\n                    eb: function() {},\n                    Sa: function() {\n                        he1.Ta.forEach((e1)=>e1());\n                    },\n                    cb: (e1)=>new Promise((t1)=>{\n                            e1.onmessage = (n1)=>{\n                                var r1 = (n1 = n1.data).cmd;\n                                if (n1.targetThread && n1.targetThread != dt1()) {\n                                    var o1 = he1.Fa[n1.qb];\n                                    o1 ? o1.postMessage(n1, n1.transferList) : I1('Internal error! Worker sent a message \"' + r1 + '\" to target pthread ' + n1.targetThread + \", but that thread no longer exists!\");\n                                } else \"checkMailbox\" === r1 ? Me1() : \"spawnThread\" === r1 ? ue1(n1) : \"cleanupThread\" === r1 ? ae1(n1.thread) : \"killThread\" === r1 ? (n1 = n1.thread, r1 = he1.Fa[n1], delete he1.Fa[n1], se1(r1), mt1(n1), he1.Ia.splice(he1.Ia.indexOf(r1), 1), r1.Ha = 0) : \"cancelThread\" === r1 ? he1.Fa[n1.thread].postMessage({\n                                    cmd: \"cancel\"\n                                }) : \"loaded\" === r1 ? (e1.loaded = !0, t1(e1)) : \"alert\" === r1 ? alert(\"Thread \" + n1.threadId + \": \" + n1.text) : \"setimmediate\" === n1.target ? e1.postMessage(n1) : \"callHandler\" === r1 ? l1[n1.handler](...n1.args) : r1 && I1(\"worker sent an unknown command \" + r1);\n                            }, e1.onerror = (e1)=>{\n                                throw I1(\"worker sent an error! \" + e1.filename + \":\" + e1.lineno + \": \" + e1.message), e1;\n                            }, y1 && (e1.on(\"message\", function(t1) {\n                                e1.onmessage({\n                                    data: t1\n                                });\n                            }), e1.on(\"error\", function(t1) {\n                                e1.onerror(t1);\n                            }));\n                            var n1, r1 = [];\n                            for (n1 of [\n                                \"onExit\",\n                                \"onAbort\",\n                                \"print\",\n                                \"printErr\"\n                            ])l1.hasOwnProperty(n1) && r1.push(n1);\n                            e1.postMessage({\n                                cmd: \"load\",\n                                handlers: r1,\n                                urlOrBlob: l1.mainScriptUrlOrBlob || _scriptDir1,\n                                wasmMemory: D1,\n                                wasmModule: k1\n                            });\n                        }),\n                    bb: function(e1) {\n                        e1();\n                    },\n                    Xa: function() {\n                        var e1 = T1(\"ort-wasm-threaded.worker.js\");\n                        e1 = new Worker(e1), he1.La.push(e1);\n                    },\n                    Za: function() {\n                        return 0 == he1.La.length && (he1.Xa(), he1.cb(he1.La[0])), he1.La.pop();\n                    }\n                };\n                l1.PThread = he1;\n                var ge1 = (e1)=>{\n                    for(; 0 < e1.length;)e1.shift()(l1);\n                };\n                function be1(e1) {\n                    if (_1) return We1(2, 0, e1);\n                    fe1(e1);\n                }\n                l1.establishStackSpace = function() {\n                    var e1 = dt1(), t1 = o1()[e1 + 52 >> 2 >>> 0];\n                    e1 = o1()[e1 + 56 >> 2 >>> 0], Tt1(t1, t1 - e1), wt1(t1);\n                };\n                var me1 = [];\n                function ye1(e1) {\n                    this.Oa = e1 - 24, this.Wa = function(e1) {\n                        i1()[this.Oa + 4 >> 2 >>> 0] = e1;\n                    }, this.Va = function(e1) {\n                        i1()[this.Oa + 8 >> 2 >>> 0] = e1;\n                    }, this.Pa = function(e1, t1) {\n                        this.Ua(), this.Wa(e1), this.Va(t1);\n                    }, this.Ua = function() {\n                        i1()[this.Oa + 16 >> 2 >>> 0] = 0;\n                    };\n                }\n                function _e1(e1, t1, n1, r1) {\n                    return _1 ? We1(3, 1, e1, t1, n1, r1) : ve1(e1, t1, n1, r1);\n                }\n                function ve1(e1, t1, n1, r1) {\n                    if (e1 >>>= 0, t1 >>>= 0, n1 >>>= 0, r1 >>>= 0, \"undefined\" == typeof SharedArrayBuffer) return I1(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"), 6;\n                    var o1 = [];\n                    return _1 && 0 === o1.length ? _e1(e1, t1, n1, r1) : (e1 = {\n                        gb: n1,\n                        Ha: e1,\n                        Ya: r1,\n                        mb: o1\n                    }, _1 ? (e1.ob = \"spawnThread\", postMessage(e1, o1), 0) : ue1(e1));\n                }\n                function Te1(e1, t1, n1) {\n                    return _1 ? We1(4, 1, e1, t1, n1) : 0;\n                }\n                function xe1(e1, t1) {\n                    if (_1) return We1(5, 1, e1, t1);\n                }\n                l1.invokeEntryPoint = function(e1, t1) {\n                    var n1 = me1[e1];\n                    n1 || (e1 >= me1.length && (me1.length = e1 + 1), me1[e1] = n1 = V1.get(e1)), e1 = n1(t1), W1() ? he1.Ra(e1) : yt1(e1);\n                };\n                var we1 = (e1)=>{\n                    for(var t1 = 0, n1 = 0; n1 < e1.length; ++n1){\n                        var r1 = e1.charCodeAt(n1);\n                        127 >= r1 ? t1++ : 2047 >= r1 ? t1 += 2 : 55296 <= r1 && 57343 >= r1 ? (t1 += 4, ++n1) : t1 += 3;\n                    }\n                    return t1;\n                }, Oe1 = (e1, t1, n1, r1)=>{\n                    if (!(0 < r1)) return 0;\n                    var o1 = n1 >>>= 0;\n                    r1 = n1 + r1 - 1;\n                    for(var i1 = 0; i1 < e1.length; ++i1){\n                        var s1 = e1.charCodeAt(i1);\n                        if (55296 <= s1 && 57343 >= s1 && (s1 = 65536 + ((1023 & s1) << 10) | 1023 & e1.charCodeAt(++i1)), 127 >= s1) {\n                            if (n1 >= r1) break;\n                            t1[n1++ >>> 0] = s1;\n                        } else {\n                            if (2047 >= s1) {\n                                if (n1 + 1 >= r1) break;\n                                t1[n1++ >>> 0] = 192 | s1 >> 6;\n                            } else {\n                                if (65535 >= s1) {\n                                    if (n1 + 2 >= r1) break;\n                                    t1[n1++ >>> 0] = 224 | s1 >> 12;\n                                } else {\n                                    if (n1 + 3 >= r1) break;\n                                    t1[n1++ >>> 0] = 240 | s1 >> 18, t1[n1++ >>> 0] = 128 | s1 >> 12 & 63;\n                                }\n                                t1[n1++ >>> 0] = 128 | s1 >> 6 & 63;\n                            }\n                            t1[n1++ >>> 0] = 128 | 63 & s1;\n                        }\n                    }\n                    return t1[n1 >>> 0] = 0, n1 - o1;\n                }, Se1 = (e1, t1, n1)=>Oe1(e1, r1(), t1, n1);\n                function Ae1(e1, t1) {\n                    if (_1) return We1(6, 1, e1, t1);\n                }\n                function Pe1(e1, t1, n1) {\n                    if (_1) return We1(7, 1, e1, t1, n1);\n                }\n                function Ie1(e1, t1, n1) {\n                    return _1 ? We1(8, 1, e1, t1, n1) : 0;\n                }\n                function Ee1(e1, t1) {\n                    if (_1) return We1(9, 1, e1, t1);\n                }\n                function De1(e1, t1, n1) {\n                    if (_1) return We1(10, 1, e1, t1, n1);\n                }\n                function $e1(e1, t1, n1, r1) {\n                    if (_1) return We1(11, 1, e1, t1, n1, r1);\n                }\n                function ke1(e1, t1, n1, r1) {\n                    if (_1) return We1(12, 1, e1, t1, n1, r1);\n                }\n                function Fe1(e1, t1, n1, r1) {\n                    if (_1) return We1(13, 1, e1, t1, n1, r1);\n                }\n                function Ne1(e1) {\n                    if (_1) return We1(14, 1, e1);\n                }\n                function Le1(e1, t1) {\n                    if (_1) return We1(15, 1, e1, t1);\n                }\n                function Ce1(e1, t1, n1) {\n                    if (_1) return We1(16, 1, e1, t1, n1);\n                }\n                var Re1 = (e1)=>{\n                    if (!M1) try {\n                        if (e1(), !W1()) try {\n                            _1 ? yt1(F1) : fe1(F1);\n                        } catch (e1) {\n                            e1 instanceof ie1 || \"unwind\" == e1 || g1(1, e1);\n                        }\n                    } catch (e1) {\n                        e1 instanceof ie1 || \"unwind\" == e1 || g1(1, e1);\n                    }\n                };\n                function je1(e1) {\n                    e1 >>>= 0, \"function\" == typeof Atomics.nb && (Atomics.nb(o1(), e1 >> 2, e1).value.then(Me1), e1 += 128, Atomics.store(o1(), e1 >> 2, 1));\n                }\n                function Me1() {\n                    var e1 = dt1();\n                    e1 && (je1(e1), Re1(()=>_t1()));\n                }\n                l1.__emscripten_thread_mailbox_await = je1, l1.checkMailbox = Me1;\n                var Ue1 = (e1)=>0 == e1 % 4 && (0 != e1 % 100 || 0 == e1 % 400), Be1 = [\n                    0,\n                    31,\n                    60,\n                    91,\n                    121,\n                    152,\n                    182,\n                    213,\n                    244,\n                    274,\n                    305,\n                    335\n                ], Ve1 = [\n                    0,\n                    31,\n                    59,\n                    90,\n                    120,\n                    151,\n                    181,\n                    212,\n                    243,\n                    273,\n                    304,\n                    334\n                ];\n                function ze1(e1, t1, n1, r1, o1, i1, s1, a1) {\n                    return _1 ? We1(17, 1, e1, t1, n1, r1, o1, i1, s1, a1) : -52;\n                }\n                function Ge1(e1, t1, n1, r1, o1, i1, s1) {\n                    if (_1) return We1(18, 1, e1, t1, n1, r1, o1, i1, s1);\n                }\n                var He1 = (e1)=>{\n                    var t1 = we1(e1) + 1, n1 = ft1(t1);\n                    return n1 && Se1(e1, n1, t1), n1;\n                }, qe1 = (e1)=>{\n                    var t1 = xt1();\n                    return e1 = e1(), wt1(t1), e1;\n                };\n                function We1(e1, t1) {\n                    var n1 = arguments.length - 2, r1 = arguments;\n                    return qe1(()=>{\n                        for(var o1 = Ot1(8 * n1), i1 = o1 >> 3, a1 = 0; a1 < n1; a1++){\n                            var u1 = r1[2 + a1];\n                            s1()[i1 + a1 >>> 0] = u1;\n                        }\n                        return bt1(e1, n1, o1, t1);\n                    });\n                }\n                var Xe1, Ye1 = [], Ke1 = {}, Je1 = ()=>{\n                    if (!Xe1) {\n                        var e1, t1 = {\n                            USER: \"web_user\",\n                            LOGNAME: \"web_user\",\n                            PATH: \"/\",\n                            PWD: \"/\",\n                            HOME: \"/home/web_user\",\n                            LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                            _: h1 || \"./this.program\"\n                        };\n                        for(e1 in Ke1)void 0 === Ke1[e1] ? delete t1[e1] : t1[e1] = Ke1[e1];\n                        var n1 = [];\n                        for(e1 in t1)n1.push(`${e1}=${t1[e1]}`);\n                        Xe1 = n1;\n                    }\n                    return Xe1;\n                };\n                function Ze1(e1, n1) {\n                    if (_1) return We1(19, 1, e1, n1);\n                    e1 >>>= 0, n1 >>>= 0;\n                    var r1 = 0;\n                    return Je1().forEach(function(o1, s1) {\n                        var a1 = n1 + r1;\n                        for(s1 = i1()[e1 + 4 * s1 >> 2 >>> 0] = a1, a1 = 0; a1 < o1.length; ++a1)t1()[s1++ >> 0 >>> 0] = o1.charCodeAt(a1);\n                        t1()[s1 >> 0 >>> 0] = 0, r1 += o1.length + 1;\n                    }), 0;\n                }\n                function Qe1(e1, t1) {\n                    if (_1) return We1(20, 1, e1, t1);\n                    e1 >>>= 0, t1 >>>= 0;\n                    var n1 = Je1();\n                    i1()[e1 >> 2 >>> 0] = n1.length;\n                    var r1 = 0;\n                    return n1.forEach(function(e1) {\n                        r1 += e1.length + 1;\n                    }), i1()[t1 >> 2 >>> 0] = r1, 0;\n                }\n                function et1(e1) {\n                    return _1 ? We1(21, 1, e1) : 52;\n                }\n                function tt1(e1, t1, n1, r1) {\n                    return _1 ? We1(22, 1, e1, t1, n1, r1) : 52;\n                }\n                function nt1(e1, t1, n1, r1, o1) {\n                    return _1 ? We1(23, 1, e1, t1, n1, r1, o1) : 70;\n                }\n                var rt1 = [\n                    null,\n                    [],\n                    []\n                ];\n                function ot1(e1, t1, n1, o1) {\n                    if (_1) return We1(24, 1, e1, t1, n1, o1);\n                    t1 >>>= 0, n1 >>>= 0, o1 >>>= 0;\n                    for(var s1 = 0, a1 = 0; a1 < n1; a1++){\n                        var u1 = i1()[t1 >> 2 >>> 0], l1 = i1()[t1 + 4 >> 2 >>> 0];\n                        t1 += 8;\n                        for(var c1 = 0; c1 < l1; c1++){\n                            var p1 = r1()[u1 + c1 >>> 0], d1 = rt1[e1];\n                            0 === p1 || 10 === p1 ? ((1 === e1 ? P1 : I1)(ce1(d1, 0)), d1.length = 0) : d1.push(p1);\n                        }\n                        s1 += l1;\n                    }\n                    return i1()[o1 >> 2 >>> 0] = s1, 0;\n                }\n                var it1 = (e1)=>(it1 = (()=>{\n                        if (\"object\" == typeof crypto && \"function\" == typeof crypto.getRandomValues) return (e1)=>(e1.set(crypto.getRandomValues(new Uint8Array(e1.byteLength))), e1);\n                        if (y1) try {\n                            var e1 = n1(6113);\n                            if (e1.randomFillSync) return (t1)=>e1.randomFillSync(t1);\n                            var t1 = e1.randomBytes;\n                            return (e1)=>(e1.set(t1(e1.byteLength)), e1);\n                        } catch (e1) {}\n                        te1(\"initRandomDevice\");\n                    })())(e1), st1 = [\n                    31,\n                    29,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31\n                ], at1 = [\n                    31,\n                    28,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31\n                ], ut1 = (e1, n1)=>{\n                    t1().set(e1, n1 >>> 0);\n                };\n                function lt1(e1, t1, n1, r1) {\n                    function i1(e1, t1, n1) {\n                        for(e1 = \"number\" == typeof e1 ? e1.toString() : e1 || \"\"; e1.length < t1;)e1 = n1[0] + e1;\n                        return e1;\n                    }\n                    function s1(e1, t1) {\n                        return i1(e1, t1, \"0\");\n                    }\n                    function a1(e1, t1) {\n                        function n1(e1) {\n                            return 0 > e1 ? -1 : 0 < e1 ? 1 : 0;\n                        }\n                        var r1;\n                        return 0 === (r1 = n1(e1.getFullYear() - t1.getFullYear())) && 0 === (r1 = n1(e1.getMonth() - t1.getMonth())) && (r1 = n1(e1.getDate() - t1.getDate())), r1;\n                    }\n                    function u1(e1) {\n                        switch(e1.getDay()){\n                            case 0:\n                                return new Date(e1.getFullYear() - 1, 11, 29);\n                            case 1:\n                                return e1;\n                            case 2:\n                                return new Date(e1.getFullYear(), 0, 3);\n                            case 3:\n                                return new Date(e1.getFullYear(), 0, 2);\n                            case 4:\n                                return new Date(e1.getFullYear(), 0, 1);\n                            case 5:\n                                return new Date(e1.getFullYear() - 1, 11, 31);\n                            case 6:\n                                return new Date(e1.getFullYear() - 1, 11, 30);\n                        }\n                    }\n                    function l1(e1) {\n                        var t1 = e1.Ja;\n                        for(e1 = new Date(new Date(e1.Ka + 1900, 0, 1).getTime()); 0 < t1;){\n                            var n1 = e1.getMonth(), r1 = (Ue1(e1.getFullYear()) ? st1 : at1)[n1];\n                            if (!(t1 > r1 - e1.getDate())) {\n                                e1.setDate(e1.getDate() + t1);\n                                break;\n                            }\n                            t1 -= r1 - e1.getDate() + 1, e1.setDate(1), 11 > n1 ? e1.setMonth(n1 + 1) : (e1.setMonth(0), e1.setFullYear(e1.getFullYear() + 1));\n                        }\n                        return n1 = new Date(e1.getFullYear() + 1, 0, 4), t1 = u1(new Date(e1.getFullYear(), 0, 4)), n1 = u1(n1), 0 >= a1(t1, e1) ? 0 >= a1(n1, e1) ? e1.getFullYear() + 1 : e1.getFullYear() : e1.getFullYear() - 1;\n                    }\n                    e1 >>>= 0, t1 >>>= 0, n1 >>>= 0, r1 >>>= 0;\n                    var c1 = o1()[r1 + 40 >> 2 >>> 0];\n                    for(var p1 in r1 = {\n                        kb: o1()[r1 >> 2 >>> 0],\n                        jb: o1()[r1 + 4 >> 2 >>> 0],\n                        Ma: o1()[r1 + 8 >> 2 >>> 0],\n                        Qa: o1()[r1 + 12 >> 2 >>> 0],\n                        Na: o1()[r1 + 16 >> 2 >>> 0],\n                        Ka: o1()[r1 + 20 >> 2 >>> 0],\n                        Ga: o1()[r1 + 24 >> 2 >>> 0],\n                        Ja: o1()[r1 + 28 >> 2 >>> 0],\n                        sb: o1()[r1 + 32 >> 2 >>> 0],\n                        ib: o1()[r1 + 36 >> 2 >>> 0],\n                        lb: c1 ? pe1(c1) : \"\"\n                    }, n1 = pe1(n1), c1 = {\n                        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                        \"%D\": \"%m/%d/%y\",\n                        \"%F\": \"%Y-%m-%d\",\n                        \"%h\": \"%b\",\n                        \"%r\": \"%I:%M:%S %p\",\n                        \"%R\": \"%H:%M\",\n                        \"%T\": \"%H:%M:%S\",\n                        \"%x\": \"%m/%d/%y\",\n                        \"%X\": \"%H:%M:%S\",\n                        \"%Ec\": \"%c\",\n                        \"%EC\": \"%C\",\n                        \"%Ex\": \"%m/%d/%y\",\n                        \"%EX\": \"%H:%M:%S\",\n                        \"%Ey\": \"%y\",\n                        \"%EY\": \"%Y\",\n                        \"%Od\": \"%d\",\n                        \"%Oe\": \"%e\",\n                        \"%OH\": \"%H\",\n                        \"%OI\": \"%I\",\n                        \"%Om\": \"%m\",\n                        \"%OM\": \"%M\",\n                        \"%OS\": \"%S\",\n                        \"%Ou\": \"%u\",\n                        \"%OU\": \"%U\",\n                        \"%OV\": \"%V\",\n                        \"%Ow\": \"%w\",\n                        \"%OW\": \"%W\",\n                        \"%Oy\": \"%y\"\n                    })n1 = n1.replace(new RegExp(p1, \"g\"), c1[p1]);\n                    var d1 = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), f1 = \"January February March April May June July August September October November December\".split(\" \");\n                    for(p1 in c1 = {\n                        \"%a\": (e1)=>d1[e1.Ga].substring(0, 3),\n                        \"%A\": (e1)=>d1[e1.Ga],\n                        \"%b\": (e1)=>f1[e1.Na].substring(0, 3),\n                        \"%B\": (e1)=>f1[e1.Na],\n                        \"%C\": (e1)=>s1((e1.Ka + 1900) / 100 | 0, 2),\n                        \"%d\": (e1)=>s1(e1.Qa, 2),\n                        \"%e\": (e1)=>i1(e1.Qa, 2, \" \"),\n                        \"%g\": (e1)=>l1(e1).toString().substring(2),\n                        \"%G\": (e1)=>l1(e1),\n                        \"%H\": (e1)=>s1(e1.Ma, 2),\n                        \"%I\": (e1)=>(0 == (e1 = e1.Ma) ? e1 = 12 : 12 < e1 && (e1 -= 12), s1(e1, 2)),\n                        \"%j\": (e1)=>{\n                            for(var t1 = 0, n1 = 0; n1 <= e1.Na - 1; t1 += (Ue1(e1.Ka + 1900) ? st1 : at1)[n1++]);\n                            return s1(e1.Qa + t1, 3);\n                        },\n                        \"%m\": (e1)=>s1(e1.Na + 1, 2),\n                        \"%M\": (e1)=>s1(e1.jb, 2),\n                        \"%n\": ()=>\"\\n\",\n                        \"%p\": (e1)=>0 <= e1.Ma && 12 > e1.Ma ? \"AM\" : \"PM\",\n                        \"%S\": (e1)=>s1(e1.kb, 2),\n                        \"%t\": ()=>\"\t\",\n                        \"%u\": (e1)=>e1.Ga || 7,\n                        \"%U\": (e1)=>s1(Math.floor((e1.Ja + 7 - e1.Ga) / 7), 2),\n                        \"%V\": (e1)=>{\n                            var t1 = Math.floor((e1.Ja + 7 - (e1.Ga + 6) % 7) / 7);\n                            if (2 >= (e1.Ga + 371 - e1.Ja - 2) % 7 && t1++, t1) 53 == t1 && (4 == (n1 = (e1.Ga + 371 - e1.Ja) % 7) || 3 == n1 && Ue1(e1.Ka) || (t1 = 1));\n                            else {\n                                t1 = 52;\n                                var n1 = (e1.Ga + 7 - e1.Ja - 1) % 7;\n                                (4 == n1 || 5 == n1 && Ue1(e1.Ka % 400 - 1)) && t1++;\n                            }\n                            return s1(t1, 2);\n                        },\n                        \"%w\": (e1)=>e1.Ga,\n                        \"%W\": (e1)=>s1(Math.floor((e1.Ja + 7 - (e1.Ga + 6) % 7) / 7), 2),\n                        \"%y\": (e1)=>(e1.Ka + 1900).toString().substring(2),\n                        \"%Y\": (e1)=>e1.Ka + 1900,\n                        \"%z\": (e1)=>{\n                            var t1 = 0 <= (e1 = e1.ib);\n                            return e1 = Math.abs(e1) / 60, (t1 ? \"+\" : \"-\") + String(\"0000\" + (e1 / 60 * 100 + e1 % 60)).slice(-4);\n                        },\n                        \"%Z\": (e1)=>e1.lb,\n                        \"%%\": ()=>\"%\"\n                    }, n1 = n1.replace(/%%/g, \"\\x00\\x00\"), c1)n1.includes(p1) && (n1 = n1.replace(new RegExp(p1, \"g\"), c1[p1](r1)));\n                    return p1 = function(e1) {\n                        var t1 = Array(we1(e1) + 1);\n                        return Oe1(e1, t1, 0, t1.length), t1;\n                    }(n1 = n1.replace(/\\0\\0/g, \"%\")), p1.length > t1 ? 0 : (ut1(p1, e1), p1.length - 1);\n                }\n                he1.Pa();\n                var ct1 = [\n                    null,\n                    de1,\n                    be1,\n                    _e1,\n                    Te1,\n                    xe1,\n                    Ae1,\n                    Pe1,\n                    Ie1,\n                    Ee1,\n                    De1,\n                    $e1,\n                    ke1,\n                    Fe1,\n                    Ne1,\n                    Le1,\n                    Ce1,\n                    ze1,\n                    Ge1,\n                    Ze1,\n                    Qe1,\n                    et1,\n                    tt1,\n                    nt1,\n                    ot1\n                ], pt1 = {\n                    b: function(e1, t1, n1) {\n                        throw new ye1(e1 >>>= 0).Pa(t1 >>> 0, n1 >>> 0), e1;\n                    },\n                    N: function(e1) {\n                        ht1(e1 >>> 0, !m1, 1, !b1, 131072, !1), he1.Sa();\n                    },\n                    k: function(e1) {\n                        e1 >>>= 0, _1 ? postMessage({\n                            cmd: \"cleanupThread\",\n                            thread: e1\n                        }) : ae1(e1);\n                    },\n                    I: ve1,\n                    h: Te1,\n                    T: xe1,\n                    E: Ae1,\n                    G: Pe1,\n                    U: Ie1,\n                    R: Ee1,\n                    J: De1,\n                    Q: $e1,\n                    o: ke1,\n                    F: Fe1,\n                    C: Ne1,\n                    S: Le1,\n                    D: Ce1,\n                    q: ()=>!0,\n                    A: function(e1, t1) {\n                        (e1 >>>= 0) == t1 >>> 0 ? setTimeout(()=>Me1()) : _1 ? postMessage({\n                            targetThread: e1,\n                            cmd: \"checkMailbox\"\n                        }) : (e1 = he1.Fa[e1]) && e1.postMessage({\n                            cmd: \"checkMailbox\"\n                        });\n                    },\n                    L: function() {\n                        return -1;\n                    },\n                    M: je1,\n                    p: function(e1) {\n                        y1 && he1.Fa[e1 >>> 0].ref();\n                    },\n                    t: function(e1, t1, n1) {\n                        e1 = t1 + 2097152 >>> 0 < 4194305 - !!e1 ? (e1 >>> 0) + 4294967296 * t1 : NaN, n1 >>>= 0, e1 = new Date(1e3 * e1), o1()[n1 >> 2 >>> 0] = e1.getUTCSeconds(), o1()[n1 + 4 >> 2 >>> 0] = e1.getUTCMinutes(), o1()[n1 + 8 >> 2 >>> 0] = e1.getUTCHours(), o1()[n1 + 12 >> 2 >>> 0] = e1.getUTCDate(), o1()[n1 + 16 >> 2 >>> 0] = e1.getUTCMonth(), o1()[n1 + 20 >> 2 >>> 0] = e1.getUTCFullYear() - 1900, o1()[n1 + 24 >> 2 >>> 0] = e1.getUTCDay(), e1 = (e1.getTime() - Date.UTC(e1.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, o1()[n1 + 28 >> 2 >>> 0] = e1;\n                    },\n                    u: function(e1, t1, n1) {\n                        e1 = t1 + 2097152 >>> 0 < 4194305 - !!e1 ? (e1 >>> 0) + 4294967296 * t1 : NaN, n1 >>>= 0, e1 = new Date(1e3 * e1), o1()[n1 >> 2 >>> 0] = e1.getSeconds(), o1()[n1 + 4 >> 2 >>> 0] = e1.getMinutes(), o1()[n1 + 8 >> 2 >>> 0] = e1.getHours(), o1()[n1 + 12 >> 2 >>> 0] = e1.getDate(), o1()[n1 + 16 >> 2 >>> 0] = e1.getMonth(), o1()[n1 + 20 >> 2 >>> 0] = e1.getFullYear() - 1900, o1()[n1 + 24 >> 2 >>> 0] = e1.getDay(), t1 = (Ue1(e1.getFullYear()) ? Be1 : Ve1)[e1.getMonth()] + e1.getDate() - 1 | 0, o1()[n1 + 28 >> 2 >>> 0] = t1, o1()[n1 + 36 >> 2 >>> 0] = -60 * e1.getTimezoneOffset(), t1 = new Date(e1.getFullYear(), 6, 1).getTimezoneOffset();\n                        var r1 = new Date(e1.getFullYear(), 0, 1).getTimezoneOffset();\n                        e1 = 0 | (t1 != r1 && e1.getTimezoneOffset() == Math.min(r1, t1)), o1()[n1 + 32 >> 2 >>> 0] = e1;\n                    },\n                    v: function(e1) {\n                        e1 >>>= 0;\n                        var t1 = new Date(o1()[e1 + 20 >> 2 >>> 0] + 1900, o1()[e1 + 16 >> 2 >>> 0], o1()[e1 + 12 >> 2 >>> 0], o1()[e1 + 8 >> 2 >>> 0], o1()[e1 + 4 >> 2 >>> 0], o1()[e1 >> 2 >>> 0], 0), n1 = o1()[e1 + 32 >> 2 >>> 0], r1 = t1.getTimezoneOffset(), i1 = new Date(t1.getFullYear(), 6, 1).getTimezoneOffset(), s1 = new Date(t1.getFullYear(), 0, 1).getTimezoneOffset(), a1 = Math.min(s1, i1);\n                        return 0 > n1 ? o1()[e1 + 32 >> 2 >>> 0] = Number(i1 != s1 && a1 == r1) : 0 < n1 != (a1 == r1) && (i1 = Math.max(s1, i1), t1.setTime(t1.getTime() + 6e4 * ((0 < n1 ? a1 : i1) - r1))), o1()[e1 + 24 >> 2 >>> 0] = t1.getDay(), n1 = (Ue1(t1.getFullYear()) ? Be1 : Ve1)[t1.getMonth()] + t1.getDate() - 1 | 0, o1()[e1 + 28 >> 2 >>> 0] = n1, o1()[e1 >> 2 >>> 0] = t1.getSeconds(), o1()[e1 + 4 >> 2 >>> 0] = t1.getMinutes(), o1()[e1 + 8 >> 2 >>> 0] = t1.getHours(), o1()[e1 + 12 >> 2 >>> 0] = t1.getDate(), o1()[e1 + 16 >> 2 >>> 0] = t1.getMonth(), o1()[e1 + 20 >> 2 >>> 0] = t1.getYear(), e1 = t1.getTime() / 1e3, vt1((Y1 = e1, 1 <= +Math.abs(Y1) ? 0 < Y1 ? +Math.floor(Y1 / 4294967296) >>> 0 : ~~+Math.ceil((Y1 - +(~~Y1 >>> 0)) / 4294967296) >>> 0 : 0)), e1 >>> 0;\n                    },\n                    r: ze1,\n                    s: Ge1,\n                    z: function(e1, t1, n1) {\n                        function r1(e1) {\n                            return (e1 = e1.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? e1[1] : \"GMT\";\n                        }\n                        e1 >>>= 0, t1 >>>= 0, n1 >>>= 0;\n                        var s1 = (new Date).getFullYear(), a1 = new Date(s1, 0, 1), u1 = new Date(s1, 6, 1);\n                        s1 = a1.getTimezoneOffset();\n                        var l1 = u1.getTimezoneOffset(), c1 = Math.max(s1, l1);\n                        i1()[e1 >> 2 >>> 0] = 60 * c1, o1()[t1 >> 2 >>> 0] = Number(s1 != l1), e1 = r1(a1), t1 = r1(u1), e1 = He1(e1), t1 = He1(t1), l1 < s1 ? (i1()[n1 >> 2 >>> 0] = e1, i1()[n1 + 4 >> 2 >>> 0] = t1) : (i1()[n1 >> 2 >>> 0] = t1, i1()[n1 + 4 >> 2 >>> 0] = e1);\n                    },\n                    c: ()=>{\n                        te1(\"\");\n                    },\n                    l: function() {},\n                    i: function() {\n                        return Date.now();\n                    },\n                    V: ()=>{\n                        throw q1 += 1, \"unwind\";\n                    },\n                    B: function() {\n                        return 4294901760;\n                    },\n                    e: ()=>performance.timeOrigin + performance.now(),\n                    f: function() {\n                        return y1 ? n1(9719).cpus().length : navigator.hardwareConcurrency;\n                    },\n                    K: function(e1, t1, n1, r1) {\n                        for(he1.pb = t1 >>> 0, Ye1.length = n1, t1 = r1 >>> 0 >> 3, r1 = 0; r1 < n1; r1++)Ye1[r1] = s1()[t1 + r1 >>> 0];\n                        return ct1[e1].apply(null, Ye1);\n                    },\n                    y: function(e1) {\n                        e1 >>>= 0;\n                        var t1 = r1().length;\n                        if (e1 <= t1 || 4294901760 < e1) return !1;\n                        for(var n1 = 1; 4 >= n1; n1 *= 2){\n                            var o1 = t1 * (1 + .2 / n1);\n                            o1 = Math.min(o1, e1 + 100663296);\n                            var i1 = Math;\n                            o1 = Math.max(e1, o1);\n                            e: {\n                                i1 = i1.min.call(i1, 4294901760, o1 + (65536 - o1 % 65536) % 65536) - D1.buffer.byteLength + 65535 >>> 16;\n                                try {\n                                    D1.grow(i1), U1();\n                                    var s1 = 1;\n                                    break e;\n                                } catch (e1) {}\n                                s1 = void 0;\n                            }\n                            if (s1) return !0;\n                        }\n                        return !1;\n                    },\n                    O: Ze1,\n                    P: Qe1,\n                    j: fe1,\n                    g: et1,\n                    n: tt1,\n                    w: nt1,\n                    m: ot1,\n                    x: function(e1, t1) {\n                        return e1 >>>= 0, t1 >>>= 0, it1(r1().subarray(e1 >>> 0, e1 + t1 >>> 0)), 0;\n                    },\n                    a: D1 || l1.wasmMemory,\n                    H: lt1,\n                    d: function(e1, t1, n1, r1) {\n                        return lt1(e1 >>> 0, t1 >>> 0, n1 >>> 0, r1 >>> 0);\n                    }\n                };\n                !function() {\n                    function e1(e1, t1) {\n                        return e1 = e1.exports, $1 = e1 = function(e1) {\n                            var t1 = (e1)=>()=>e1() >>> 0, n1 = (e1)=>(t1)=>e1(t1) >>> 0;\n                            return (e1 = Object.assign({}, e1)).__errno_location = t1(e1.__errno_location), e1.pthread_self = t1(e1.pthread_self), e1.malloc = n1(e1.malloc), e1.stackSave = t1(e1.stackSave), e1.stackAlloc = n1(e1.stackAlloc), e1;\n                        }(e1), he1.Ta.push($1.sa), V1 = $1.ta, G1.unshift($1.W), k1 = t1, ee1(), e1;\n                    }\n                    var t1 = {\n                        a: pt1\n                    };\n                    if (Q1(), l1.instantiateWasm) try {\n                        return l1.instantiateWasm(t1, e1);\n                    } catch (e1) {\n                        I1(\"Module.instantiateWasm callback failed with error: \" + e1), u1(e1);\n                    }\n                    (function(e1, t1) {\n                        var n1 = X1;\n                        return A1 || \"function\" != typeof WebAssembly.instantiateStreaming || ne1(n1) || n1.startsWith(\"file://\") || y1 || \"function\" != typeof fetch ? oe1(n1, e1, t1) : fetch(n1, {\n                            credentials: \"same-origin\"\n                        }).then((r1)=>WebAssembly.instantiateStreaming(r1, e1).then(t1, function(r1) {\n                                return I1(\"wasm streaming compile failed: \" + r1), I1(\"falling back to ArrayBuffer instantiation\"), oe1(n1, e1, t1);\n                            }));\n                    })(t1, function(t1) {\n                        e1(t1.instance, t1.module);\n                    }).catch(u1);\n                }(), l1._OrtInit = (e1, t1)=>(l1._OrtInit = $1.X)(e1, t1), l1._OrtGetLastError = (e1, t1)=>(l1._OrtGetLastError = $1.Y)(e1, t1), l1._OrtCreateSessionOptions = (e1, t1, n1, r1, o1, i1, s1, a1, u1, c1)=>(l1._OrtCreateSessionOptions = $1.Z)(e1, t1, n1, r1, o1, i1, s1, a1, u1, c1), l1._OrtAppendExecutionProvider = (e1, t1)=>(l1._OrtAppendExecutionProvider = $1._)(e1, t1), l1._OrtAddSessionConfigEntry = (e1, t1, n1)=>(l1._OrtAddSessionConfigEntry = $1.$)(e1, t1, n1), l1._OrtReleaseSessionOptions = (e1)=>(l1._OrtReleaseSessionOptions = $1.aa)(e1), l1._OrtCreateSession = (e1, t1, n1)=>(l1._OrtCreateSession = $1.ba)(e1, t1, n1), l1._OrtReleaseSession = (e1)=>(l1._OrtReleaseSession = $1.ca)(e1), l1._OrtGetInputOutputCount = (e1, t1, n1)=>(l1._OrtGetInputOutputCount = $1.da)(e1, t1, n1), l1._OrtGetInputName = (e1, t1)=>(l1._OrtGetInputName = $1.ea)(e1, t1), l1._OrtGetOutputName = (e1, t1)=>(l1._OrtGetOutputName = $1.fa)(e1, t1), l1._OrtFree = (e1)=>(l1._OrtFree = $1.ga)(e1), l1._OrtCreateTensor = (e1, t1, n1, r1, o1)=>(l1._OrtCreateTensor = $1.ha)(e1, t1, n1, r1, o1), l1._OrtGetTensorData = (e1, t1, n1, r1, o1)=>(l1._OrtGetTensorData = $1.ia)(e1, t1, n1, r1, o1), l1._OrtReleaseTensor = (e1)=>(l1._OrtReleaseTensor = $1.ja)(e1), l1._OrtCreateRunOptions = (e1, t1, n1, r1)=>(l1._OrtCreateRunOptions = $1.ka)(e1, t1, n1, r1), l1._OrtAddRunConfigEntry = (e1, t1, n1)=>(l1._OrtAddRunConfigEntry = $1.la)(e1, t1, n1), l1._OrtReleaseRunOptions = (e1)=>(l1._OrtReleaseRunOptions = $1.ma)(e1), l1._OrtRun = (e1, t1, n1, r1, o1, i1, s1, a1)=>(l1._OrtRun = $1.na)(e1, t1, n1, r1, o1, i1, s1, a1), l1._OrtEndProfiling = (e1)=>(l1._OrtEndProfiling = $1.oa)(e1);\n                var dt1 = l1._pthread_self = ()=>(dt1 = l1._pthread_self = $1.pa)(), ft1 = l1._malloc = (e1)=>(ft1 = l1._malloc = $1.qa)(e1);\n                l1._free = (e1)=>(l1._free = $1.ra)(e1), l1.__emscripten_tls_init = ()=>(l1.__emscripten_tls_init = $1.sa)();\n                var ht1 = l1.__emscripten_thread_init = (e1, t1, n1, r1, o1, i1)=>(ht1 = l1.__emscripten_thread_init = $1.ua)(e1, t1, n1, r1, o1, i1);\n                l1.__emscripten_thread_crashed = ()=>(l1.__emscripten_thread_crashed = $1.va)();\n                var gt1, bt1 = (e1, t1, n1, r1)=>(bt1 = $1.wa)(e1, t1, n1, r1), mt1 = (e1)=>(mt1 = $1.xa)(e1), yt1 = l1.__emscripten_thread_exit = (e1)=>(yt1 = l1.__emscripten_thread_exit = $1.ya)(e1), _t1 = l1.__emscripten_check_mailbox = ()=>(_t1 = l1.__emscripten_check_mailbox = $1.za)(), vt1 = (e1)=>(vt1 = $1.Aa)(e1), Tt1 = (e1, t1)=>(Tt1 = $1.Ba)(e1, t1), xt1 = ()=>(xt1 = $1.Ca)(), wt1 = (e1)=>(wt1 = $1.Da)(e1), Ot1 = (e1)=>(Ot1 = $1.Ea)(e1);\n                function St1() {\n                    function e1() {\n                        if (!gt1 && (gt1 = !0, l1.calledRun = !0, !M1) && (_1 || ge1(G1), a1(l1), l1.onRuntimeInitialized && l1.onRuntimeInitialized(), !_1)) {\n                            if (l1.postRun) for(\"function\" == typeof l1.postRun && (l1.postRun = [\n                                l1.postRun\n                            ]); l1.postRun.length;){\n                                var e1 = l1.postRun.shift();\n                                H1.unshift(e1);\n                            }\n                            ge1(H1);\n                        }\n                    }\n                    if (!(0 < K1)) if (_1) a1(l1), _1 || ge1(G1), startWorker(l1);\n                    else {\n                        if (l1.preRun) for(\"function\" == typeof l1.preRun && (l1.preRun = [\n                            l1.preRun\n                        ]); l1.preRun.length;)z1.unshift(l1.preRun.shift());\n                        ge1(z1), 0 < K1 || (l1.setStatus ? (l1.setStatus(\"Running...\"), setTimeout(function() {\n                            setTimeout(function() {\n                                l1.setStatus(\"\");\n                            }, 1), e1();\n                        }, 1)) : e1());\n                    }\n                }\n                if (l1.keepRuntimeAlive = W1, l1.wasmMemory = D1, l1.stackAlloc = Ot1, l1.stackSave = xt1, l1.stackRestore = wt1, l1.UTF8ToString = pe1, l1.stringToUTF8 = Se1, l1.lengthBytesUTF8 = we1, l1.ExitStatus = ie1, l1.PThread = he1, Z1 = function e1() {\n                    gt1 || St1(), gt1 || (Z1 = e1);\n                }, l1.preInit) for(\"function\" == typeof l1.preInit && (l1.preInit = [\n                    l1.preInit\n                ]); 0 < l1.preInit.length;)l1.preInit.pop()();\n                return St1(), e1.ready;\n            });\n            e1.exports = r1;\n        },\n        932: (e1, t1, n1)=>{\n            var _scriptDir1, r1 = (_scriptDir1 = \"undefined\" != typeof document && document.currentScript ? document.currentScript.src : void 0,  true && (_scriptDir1 = _scriptDir1 || __filename), function(e1 = {}) {\n                var t1, r1, o1 = e1;\n                o1.ready = new Promise((e1, n1)=>{\n                    t1 = e1, r1 = n1;\n                });\n                var i1, s1, a1, u1 = Object.assign({}, o1), l1 = \"./this.program\", c1 = (e1, t1)=>{\n                    throw t1;\n                }, p1 = \"object\" == \"undefined\", d1 = \"function\" == typeof importScripts, f1 = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node, h1 = \"\";\n                if (f1) {\n                    var g1 = n1(6231), b1 = n1(1423);\n                    h1 = d1 ? b1.dirname(h1) + \"/\" : __dirname + \"/\", i1 = (e1, t1)=>(e1 = e1.startsWith(\"file://\") ? new URL(e1) : b1.normalize(e1), g1.readFileSync(e1, t1 ? void 0 : \"utf8\")), a1 = (e1)=>((e1 = i1(e1, !0)).buffer || (e1 = new Uint8Array(e1)), e1), s1 = (e1, t1, n1, r1 = !0)=>{\n                        e1 = e1.startsWith(\"file://\") ? new URL(e1) : b1.normalize(e1), g1.readFile(e1, r1 ? void 0 : \"utf8\", (e1, o1)=>{\n                            e1 ? n1(e1) : t1(r1 ? o1.buffer : o1);\n                        });\n                    }, !o1.thisProgram && 1 < process.argv.length && (l1 = process.argv[1].replace(/\\\\/g, \"/\")), process.argv.slice(2), c1 = (e1, t1)=>{\n                        throw process.exitCode = e1, t1;\n                    }, o1.inspect = ()=>\"[Emscripten Module object]\";\n                } else (p1 || d1) && (d1 ? h1 = self.location.href : \"undefined\" != typeof document && document.currentScript && (h1 = document.currentScript.src), _scriptDir1 && (h1 = _scriptDir1), h1 = 0 !== h1.indexOf(\"blob:\") ? h1.substr(0, h1.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : \"\", i1 = (e1)=>{\n                    var t1 = new XMLHttpRequest;\n                    return t1.open(\"GET\", e1, !1), t1.send(null), t1.responseText;\n                }, d1 && (a1 = (e1)=>{\n                    var t1 = new XMLHttpRequest;\n                    return t1.open(\"GET\", e1, !1), t1.responseType = \"arraybuffer\", t1.send(null), new Uint8Array(t1.response);\n                }), s1 = (e1, t1, n1)=>{\n                    var r1 = new XMLHttpRequest;\n                    r1.open(\"GET\", e1, !0), r1.responseType = \"arraybuffer\", r1.onload = ()=>{\n                        200 == r1.status || 0 == r1.status && r1.response ? t1(r1.response) : n1();\n                    }, r1.onerror = n1, r1.send(null);\n                });\n                var m1, y1 = o1.print || console.log.bind(console), _1 = o1.printErr || console.error.bind(console);\n                Object.assign(o1, u1), u1 = null, o1.thisProgram && (l1 = o1.thisProgram), o1.quit && (c1 = o1.quit), o1.wasmBinary && (m1 = o1.wasmBinary);\n                var v1 = o1.noExitRuntime || !0;\n                \"object\" != typeof WebAssembly && j1(\"no native wasm support detected\");\n                var T1, x1, w1, O1, S1, A1, P1 = !1;\n                function I1() {\n                    var e1 = T1.buffer;\n                    o1.HEAP8 = w1 = new Int8Array(e1), o1.HEAP16 = new Int16Array(e1), o1.HEAP32 = S1 = new Int32Array(e1), o1.HEAPU8 = O1 = new Uint8Array(e1), o1.HEAPU16 = new Uint16Array(e1), o1.HEAPU32 = A1 = new Uint32Array(e1), o1.HEAPF32 = new Float32Array(e1), o1.HEAPF64 = new Float64Array(e1);\n                }\n                var E1 = [], D1 = [], $1 = [];\n                function k1() {\n                    var e1 = o1.preRun.shift();\n                    E1.unshift(e1);\n                }\n                var F1, N1, L1 = 0, C1 = null, R1 = null;\n                function j1(e1) {\n                    throw o1.onAbort && o1.onAbort(e1), _1(e1 = \"Aborted(\" + e1 + \")\"), P1 = !0, e1 = new WebAssembly.RuntimeError(e1 + \". Build with -sASSERTIONS for more info.\"), r1(e1), e1;\n                }\n                function M1(e1) {\n                    return e1.startsWith(\"data:application/octet-stream;base64,\");\n                }\n                if (!M1(F1 = \"ort-wasm.wasm\")) {\n                    var U1 = F1;\n                    F1 = o1.locateFile ? o1.locateFile(U1, h1) : h1 + U1;\n                }\n                function B1(e1) {\n                    if (e1 == F1 && m1) return new Uint8Array(m1);\n                    if (a1) return a1(e1);\n                    throw \"both async and sync fetching of the wasm failed\";\n                }\n                function V1(e1, t1, n1) {\n                    return (function(e1) {\n                        if (!m1 && (p1 || d1)) {\n                            if (\"function\" == typeof fetch && !e1.startsWith(\"file://\")) return fetch(e1, {\n                                credentials: \"same-origin\"\n                            }).then((t1)=>{\n                                if (!t1.ok) throw \"failed to load wasm binary file at '\" + e1 + \"'\";\n                                return t1.arrayBuffer();\n                            }).catch(()=>B1(e1));\n                            if (s1) return new Promise((t1, n1)=>{\n                                s1(e1, (e1)=>t1(new Uint8Array(e1)), n1);\n                            });\n                        }\n                        return Promise.resolve().then(()=>B1(e1));\n                    })(e1).then((e1)=>WebAssembly.instantiate(e1, t1)).then((e1)=>e1).then(n1, (e1)=>{\n                        _1(\"failed to asynchronously prepare wasm: \" + e1), j1(e1);\n                    });\n                }\n                function z1(e1) {\n                    this.name = \"ExitStatus\", this.message = `Program terminated with exit(${e1})`, this.status = e1;\n                }\n                var G1 = (e1)=>{\n                    for(; 0 < e1.length;)e1.shift()(o1);\n                };\n                function H1(e1) {\n                    this.qa = e1 - 24, this.va = function(e1) {\n                        A1[this.qa + 4 >> 2 >>> 0] = e1;\n                    }, this.ua = function(e1) {\n                        A1[this.qa + 8 >> 2 >>> 0] = e1;\n                    }, this.sa = function(e1, t1) {\n                        this.ta(), this.va(e1), this.ua(t1);\n                    }, this.ta = function() {\n                        A1[this.qa + 16 >> 2 >>> 0] = 0;\n                    };\n                }\n                var q1, W1 = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0, X1 = (e1, t1, n1)=>{\n                    var r1 = (t1 >>>= 0) + n1;\n                    for(n1 = t1; e1[n1] && !(n1 >= r1);)++n1;\n                    if (16 < n1 - t1 && e1.buffer && W1) return W1.decode(e1.subarray(t1, n1));\n                    for(r1 = \"\"; t1 < n1;){\n                        var o1 = e1[t1++];\n                        if (128 & o1) {\n                            var i1 = 63 & e1[t1++];\n                            if (192 == (224 & o1)) r1 += String.fromCharCode((31 & o1) << 6 | i1);\n                            else {\n                                var s1 = 63 & e1[t1++];\n                                65536 > (o1 = 224 == (240 & o1) ? (15 & o1) << 12 | i1 << 6 | s1 : (7 & o1) << 18 | i1 << 12 | s1 << 6 | 63 & e1[t1++]) ? r1 += String.fromCharCode(o1) : (o1 -= 65536, r1 += String.fromCharCode(55296 | o1 >> 10, 56320 | 1023 & o1));\n                            }\n                        } else r1 += String.fromCharCode(o1);\n                    }\n                    return r1;\n                }, Y1 = (e1, t1)=>(e1 >>>= 0) ? X1(O1, e1, t1) : \"\", K1 = (e1)=>{\n                    for(var t1 = 0, n1 = 0; n1 < e1.length; ++n1){\n                        var r1 = e1.charCodeAt(n1);\n                        127 >= r1 ? t1++ : 2047 >= r1 ? t1 += 2 : 55296 <= r1 && 57343 >= r1 ? (t1 += 4, ++n1) : t1 += 3;\n                    }\n                    return t1;\n                }, J1 = (e1, t1, n1, r1)=>{\n                    if (!(0 < r1)) return 0;\n                    var o1 = n1 >>>= 0;\n                    r1 = n1 + r1 - 1;\n                    for(var i1 = 0; i1 < e1.length; ++i1){\n                        var s1 = e1.charCodeAt(i1);\n                        if (55296 <= s1 && 57343 >= s1 && (s1 = 65536 + ((1023 & s1) << 10) | 1023 & e1.charCodeAt(++i1)), 127 >= s1) {\n                            if (n1 >= r1) break;\n                            t1[n1++ >>> 0] = s1;\n                        } else {\n                            if (2047 >= s1) {\n                                if (n1 + 1 >= r1) break;\n                                t1[n1++ >>> 0] = 192 | s1 >> 6;\n                            } else {\n                                if (65535 >= s1) {\n                                    if (n1 + 2 >= r1) break;\n                                    t1[n1++ >>> 0] = 224 | s1 >> 12;\n                                } else {\n                                    if (n1 + 3 >= r1) break;\n                                    t1[n1++ >>> 0] = 240 | s1 >> 18, t1[n1++ >>> 0] = 128 | s1 >> 12 & 63;\n                                }\n                                t1[n1++ >>> 0] = 128 | s1 >> 6 & 63;\n                            }\n                            t1[n1++ >>> 0] = 128 | 63 & s1;\n                        }\n                    }\n                    return t1[n1 >>> 0] = 0, n1 - o1;\n                }, Z1 = (e1)=>0 == e1 % 4 && (0 != e1 % 100 || 0 == e1 % 400), Q1 = [\n                    0,\n                    31,\n                    60,\n                    91,\n                    121,\n                    152,\n                    182,\n                    213,\n                    244,\n                    274,\n                    305,\n                    335\n                ], ee1 = [\n                    0,\n                    31,\n                    59,\n                    90,\n                    120,\n                    151,\n                    181,\n                    212,\n                    243,\n                    273,\n                    304,\n                    334\n                ], te1 = (e1)=>{\n                    var t1 = K1(e1) + 1, n1 = ce1(t1);\n                    return n1 && J1(e1, O1, n1, t1), n1;\n                }, ne1 = {}, re1 = ()=>{\n                    if (!q1) {\n                        var e1, t1 = {\n                            USER: \"web_user\",\n                            LOGNAME: \"web_user\",\n                            PATH: \"/\",\n                            PWD: \"/\",\n                            HOME: \"/home/web_user\",\n                            LANG: (\"object\" == typeof navigator && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                            _: l1 || \"./this.program\"\n                        };\n                        for(e1 in ne1)void 0 === ne1[e1] ? delete t1[e1] : t1[e1] = ne1[e1];\n                        var n1 = [];\n                        for(e1 in t1)n1.push(`${e1}=${t1[e1]}`);\n                        q1 = n1;\n                    }\n                    return q1;\n                }, oe1 = [\n                    null,\n                    [],\n                    []\n                ], ie1 = (e1)=>(ie1 = (()=>{\n                        if (\"object\" == typeof crypto && \"function\" == typeof crypto.getRandomValues) return (e1)=>crypto.getRandomValues(e1);\n                        if (f1) try {\n                            var e1 = n1(6113);\n                            if (e1.randomFillSync) return (t1)=>e1.randomFillSync(t1);\n                            var t1 = e1.randomBytes;\n                            return (e1)=>(e1.set(t1(e1.byteLength)), e1);\n                        } catch (e1) {}\n                        j1(\"initRandomDevice\");\n                    })())(e1), se1 = [\n                    31,\n                    29,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31\n                ], ae1 = [\n                    31,\n                    28,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31,\n                    31,\n                    30,\n                    31,\n                    30,\n                    31\n                ];\n                function ue1(e1, t1, n1, r1) {\n                    function o1(e1, t1, n1) {\n                        for(e1 = \"number\" == typeof e1 ? e1.toString() : e1 || \"\"; e1.length < t1;)e1 = n1[0] + e1;\n                        return e1;\n                    }\n                    function i1(e1, t1) {\n                        return o1(e1, t1, \"0\");\n                    }\n                    function s1(e1, t1) {\n                        function n1(e1) {\n                            return 0 > e1 ? -1 : 0 < e1 ? 1 : 0;\n                        }\n                        var r1;\n                        return 0 === (r1 = n1(e1.getFullYear() - t1.getFullYear())) && 0 === (r1 = n1(e1.getMonth() - t1.getMonth())) && (r1 = n1(e1.getDate() - t1.getDate())), r1;\n                    }\n                    function a1(e1) {\n                        switch(e1.getDay()){\n                            case 0:\n                                return new Date(e1.getFullYear() - 1, 11, 29);\n                            case 1:\n                                return e1;\n                            case 2:\n                                return new Date(e1.getFullYear(), 0, 3);\n                            case 3:\n                                return new Date(e1.getFullYear(), 0, 2);\n                            case 4:\n                                return new Date(e1.getFullYear(), 0, 1);\n                            case 5:\n                                return new Date(e1.getFullYear() - 1, 11, 31);\n                            case 6:\n                                return new Date(e1.getFullYear() - 1, 11, 30);\n                        }\n                    }\n                    function u1(e1) {\n                        var t1 = e1.ma;\n                        for(e1 = new Date(new Date(e1.na + 1900, 0, 1).getTime()); 0 < t1;){\n                            var n1 = e1.getMonth(), r1 = (Z1(e1.getFullYear()) ? se1 : ae1)[n1];\n                            if (!(t1 > r1 - e1.getDate())) {\n                                e1.setDate(e1.getDate() + t1);\n                                break;\n                            }\n                            t1 -= r1 - e1.getDate() + 1, e1.setDate(1), 11 > n1 ? e1.setMonth(n1 + 1) : (e1.setMonth(0), e1.setFullYear(e1.getFullYear() + 1));\n                        }\n                        return n1 = new Date(e1.getFullYear() + 1, 0, 4), t1 = a1(new Date(e1.getFullYear(), 0, 4)), n1 = a1(n1), 0 >= s1(t1, e1) ? 0 >= s1(n1, e1) ? e1.getFullYear() + 1 : e1.getFullYear() : e1.getFullYear() - 1;\n                    }\n                    e1 >>>= 0, t1 >>>= 0, n1 >>>= 0;\n                    var l1 = S1[40 + (r1 >>>= 0) >> 2 >>> 0];\n                    for(var c1 in r1 = {\n                        ya: S1[r1 >> 2 >>> 0],\n                        xa: S1[r1 + 4 >> 2 >>> 0],\n                        oa: S1[r1 + 8 >> 2 >>> 0],\n                        ra: S1[r1 + 12 >> 2 >>> 0],\n                        pa: S1[r1 + 16 >> 2 >>> 0],\n                        na: S1[r1 + 20 >> 2 >>> 0],\n                        ha: S1[r1 + 24 >> 2 >>> 0],\n                        ma: S1[r1 + 28 >> 2 >>> 0],\n                        Aa: S1[r1 + 32 >> 2 >>> 0],\n                        wa: S1[r1 + 36 >> 2 >>> 0],\n                        za: l1 ? Y1(l1) : \"\"\n                    }, n1 = Y1(n1), l1 = {\n                        \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                        \"%D\": \"%m/%d/%y\",\n                        \"%F\": \"%Y-%m-%d\",\n                        \"%h\": \"%b\",\n                        \"%r\": \"%I:%M:%S %p\",\n                        \"%R\": \"%H:%M\",\n                        \"%T\": \"%H:%M:%S\",\n                        \"%x\": \"%m/%d/%y\",\n                        \"%X\": \"%H:%M:%S\",\n                        \"%Ec\": \"%c\",\n                        \"%EC\": \"%C\",\n                        \"%Ex\": \"%m/%d/%y\",\n                        \"%EX\": \"%H:%M:%S\",\n                        \"%Ey\": \"%y\",\n                        \"%EY\": \"%Y\",\n                        \"%Od\": \"%d\",\n                        \"%Oe\": \"%e\",\n                        \"%OH\": \"%H\",\n                        \"%OI\": \"%I\",\n                        \"%Om\": \"%m\",\n                        \"%OM\": \"%M\",\n                        \"%OS\": \"%S\",\n                        \"%Ou\": \"%u\",\n                        \"%OU\": \"%U\",\n                        \"%OV\": \"%V\",\n                        \"%Ow\": \"%w\",\n                        \"%OW\": \"%W\",\n                        \"%Oy\": \"%y\"\n                    })n1 = n1.replace(new RegExp(c1, \"g\"), l1[c1]);\n                    var p1 = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), d1 = \"January February March April May June July August September October November December\".split(\" \");\n                    for(c1 in l1 = {\n                        \"%a\": (e1)=>p1[e1.ha].substring(0, 3),\n                        \"%A\": (e1)=>p1[e1.ha],\n                        \"%b\": (e1)=>d1[e1.pa].substring(0, 3),\n                        \"%B\": (e1)=>d1[e1.pa],\n                        \"%C\": (e1)=>i1((e1.na + 1900) / 100 | 0, 2),\n                        \"%d\": (e1)=>i1(e1.ra, 2),\n                        \"%e\": (e1)=>o1(e1.ra, 2, \" \"),\n                        \"%g\": (e1)=>u1(e1).toString().substring(2),\n                        \"%G\": (e1)=>u1(e1),\n                        \"%H\": (e1)=>i1(e1.oa, 2),\n                        \"%I\": (e1)=>(0 == (e1 = e1.oa) ? e1 = 12 : 12 < e1 && (e1 -= 12), i1(e1, 2)),\n                        \"%j\": (e1)=>{\n                            for(var t1 = 0, n1 = 0; n1 <= e1.pa - 1; t1 += (Z1(e1.na + 1900) ? se1 : ae1)[n1++]);\n                            return i1(e1.ra + t1, 3);\n                        },\n                        \"%m\": (e1)=>i1(e1.pa + 1, 2),\n                        \"%M\": (e1)=>i1(e1.xa, 2),\n                        \"%n\": ()=>\"\\n\",\n                        \"%p\": (e1)=>0 <= e1.oa && 12 > e1.oa ? \"AM\" : \"PM\",\n                        \"%S\": (e1)=>i1(e1.ya, 2),\n                        \"%t\": ()=>\"\t\",\n                        \"%u\": (e1)=>e1.ha || 7,\n                        \"%U\": (e1)=>i1(Math.floor((e1.ma + 7 - e1.ha) / 7), 2),\n                        \"%V\": (e1)=>{\n                            var t1 = Math.floor((e1.ma + 7 - (e1.ha + 6) % 7) / 7);\n                            if (2 >= (e1.ha + 371 - e1.ma - 2) % 7 && t1++, t1) 53 == t1 && (4 == (n1 = (e1.ha + 371 - e1.ma) % 7) || 3 == n1 && Z1(e1.na) || (t1 = 1));\n                            else {\n                                t1 = 52;\n                                var n1 = (e1.ha + 7 - e1.ma - 1) % 7;\n                                (4 == n1 || 5 == n1 && Z1(e1.na % 400 - 1)) && t1++;\n                            }\n                            return i1(t1, 2);\n                        },\n                        \"%w\": (e1)=>e1.ha,\n                        \"%W\": (e1)=>i1(Math.floor((e1.ma + 7 - (e1.ha + 6) % 7) / 7), 2),\n                        \"%y\": (e1)=>(e1.na + 1900).toString().substring(2),\n                        \"%Y\": (e1)=>e1.na + 1900,\n                        \"%z\": (e1)=>{\n                            var t1 = 0 <= (e1 = e1.wa);\n                            return e1 = Math.abs(e1) / 60, (t1 ? \"+\" : \"-\") + String(\"0000\" + (e1 / 60 * 100 + e1 % 60)).slice(-4);\n                        },\n                        \"%Z\": (e1)=>e1.za,\n                        \"%%\": ()=>\"%\"\n                    }, n1 = n1.replace(/%%/g, \"\\x00\\x00\"), l1)n1.includes(c1) && (n1 = n1.replace(new RegExp(c1, \"g\"), l1[c1](r1)));\n                    return c1 = function(e1) {\n                        var t1 = Array(K1(e1) + 1);\n                        return J1(e1, t1, 0, t1.length), t1;\n                    }(n1 = n1.replace(/\\0\\0/g, \"%\")), c1.length > t1 ? 0 : (w1.set(c1, e1 >>> 0), c1.length - 1);\n                }\n                var le1 = {\n                    a: function(e1, t1, n1) {\n                        throw new H1(e1 >>>= 0).sa(t1 >>> 0, n1 >>> 0), e1;\n                    },\n                    e: function() {\n                        return 0;\n                    },\n                    I: function() {},\n                    y: function() {},\n                    A: function() {},\n                    K: function() {\n                        return 0;\n                    },\n                    G: function() {},\n                    B: function() {},\n                    F: function() {},\n                    g: function() {},\n                    z: function() {},\n                    w: function() {},\n                    H: function() {},\n                    x: function() {},\n                    k: ()=>!0,\n                    n: function(e1, t1, n1) {\n                        e1 = t1 + 2097152 >>> 0 < 4194305 - !!e1 ? (e1 >>> 0) + 4294967296 * t1 : NaN, n1 >>>= 0, e1 = new Date(1e3 * e1), S1[n1 >> 2 >>> 0] = e1.getUTCSeconds(), S1[n1 + 4 >> 2 >>> 0] = e1.getUTCMinutes(), S1[n1 + 8 >> 2 >>> 0] = e1.getUTCHours(), S1[n1 + 12 >> 2 >>> 0] = e1.getUTCDate(), S1[n1 + 16 >> 2 >>> 0] = e1.getUTCMonth(), S1[n1 + 20 >> 2 >>> 0] = e1.getUTCFullYear() - 1900, S1[n1 + 24 >> 2 >>> 0] = e1.getUTCDay(), S1[n1 + 28 >> 2 >>> 0] = (e1.getTime() - Date.UTC(e1.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;\n                    },\n                    o: function(e1, t1, n1) {\n                        e1 = t1 + 2097152 >>> 0 < 4194305 - !!e1 ? (e1 >>> 0) + 4294967296 * t1 : NaN, n1 >>>= 0, e1 = new Date(1e3 * e1), S1[n1 >> 2 >>> 0] = e1.getSeconds(), S1[n1 + 4 >> 2 >>> 0] = e1.getMinutes(), S1[n1 + 8 >> 2 >>> 0] = e1.getHours(), S1[n1 + 12 >> 2 >>> 0] = e1.getDate(), S1[n1 + 16 >> 2 >>> 0] = e1.getMonth(), S1[n1 + 20 >> 2 >>> 0] = e1.getFullYear() - 1900, S1[n1 + 24 >> 2 >>> 0] = e1.getDay(), S1[n1 + 28 >> 2 >>> 0] = (Z1(e1.getFullYear()) ? Q1 : ee1)[e1.getMonth()] + e1.getDate() - 1 | 0, S1[n1 + 36 >> 2 >>> 0] = -60 * e1.getTimezoneOffset(), t1 = new Date(e1.getFullYear(), 6, 1).getTimezoneOffset();\n                        var r1 = new Date(e1.getFullYear(), 0, 1).getTimezoneOffset();\n                        S1[n1 + 32 >> 2 >>> 0] = 0 | (t1 != r1 && e1.getTimezoneOffset() == Math.min(r1, t1));\n                    },\n                    p: function(e1) {\n                        e1 >>>= 0;\n                        var t1 = new Date(S1[e1 + 20 >> 2 >>> 0] + 1900, S1[e1 + 16 >> 2 >>> 0], S1[e1 + 12 >> 2 >>> 0], S1[e1 + 8 >> 2 >>> 0], S1[e1 + 4 >> 2 >>> 0], S1[e1 >> 2 >>> 0], 0), n1 = S1[e1 + 32 >> 2 >>> 0], r1 = t1.getTimezoneOffset(), o1 = new Date(t1.getFullYear(), 6, 1).getTimezoneOffset(), i1 = new Date(t1.getFullYear(), 0, 1).getTimezoneOffset(), s1 = Math.min(i1, o1);\n                        return 0 > n1 ? S1[e1 + 32 >> 2 >>> 0] = Number(o1 != i1 && s1 == r1) : 0 < n1 != (s1 == r1) && (o1 = Math.max(i1, o1), t1.setTime(t1.getTime() + 6e4 * ((0 < n1 ? s1 : o1) - r1))), S1[e1 + 24 >> 2 >>> 0] = t1.getDay(), S1[e1 + 28 >> 2 >>> 0] = (Z1(t1.getFullYear()) ? Q1 : ee1)[t1.getMonth()] + t1.getDate() - 1 | 0, S1[e1 >> 2 >>> 0] = t1.getSeconds(), S1[e1 + 4 >> 2 >>> 0] = t1.getMinutes(), S1[e1 + 8 >> 2 >>> 0] = t1.getHours(), S1[e1 + 12 >> 2 >>> 0] = t1.getDate(), S1[e1 + 16 >> 2 >>> 0] = t1.getMonth(), S1[e1 + 20 >> 2 >>> 0] = t1.getYear(), e1 = t1.getTime() / 1e3, de1((N1 = e1, 1 <= +Math.abs(N1) ? 0 < N1 ? +Math.floor(N1 / 4294967296) >>> 0 : ~~+Math.ceil((N1 - +(~~N1 >>> 0)) / 4294967296) >>> 0 : 0)), e1 >>> 0;\n                    },\n                    l: function() {\n                        return -52;\n                    },\n                    m: function() {},\n                    u: function(e1, t1, n1) {\n                        function r1(e1) {\n                            return (e1 = e1.toTimeString().match(/\\(([A-Za-z ]+)\\)$/)) ? e1[1] : \"GMT\";\n                        }\n                        n1 >>>= 0;\n                        var o1 = (new Date).getFullYear(), i1 = new Date(o1, 0, 1), s1 = new Date(o1, 6, 1);\n                        o1 = i1.getTimezoneOffset();\n                        var a1 = s1.getTimezoneOffset();\n                        A1[e1 >>> 0 >> 2 >>> 0] = 60 * Math.max(o1, a1), S1[t1 >>> 0 >> 2 >>> 0] = Number(o1 != a1), e1 = r1(i1), t1 = r1(s1), e1 = te1(e1), t1 = te1(t1), a1 < o1 ? (A1[n1 >> 2 >>> 0] = e1, A1[n1 + 4 >> 2 >>> 0] = t1) : (A1[n1 >> 2 >>> 0] = t1, A1[n1 + 4 >> 2 >>> 0] = e1);\n                    },\n                    d: ()=>{\n                        j1(\"\");\n                    },\n                    h: function() {\n                        return Date.now();\n                    },\n                    v: function() {\n                        return 4294901760;\n                    },\n                    b: ()=>performance.now(),\n                    J: function(e1, t1, n1) {\n                        return t1 >>>= 0, O1.copyWithin(e1 >>> 0 >>> 0, t1 >>> 0, t1 + (n1 >>> 0) >>> 0);\n                    },\n                    t: function(e1) {\n                        e1 >>>= 0;\n                        var t1 = O1.length;\n                        if (4294901760 < e1) return !1;\n                        for(var n1 = 1; 4 >= n1; n1 *= 2){\n                            var r1 = t1 * (1 + .2 / n1);\n                            r1 = Math.min(r1, e1 + 100663296);\n                            var o1 = Math;\n                            r1 = Math.max(e1, r1);\n                            e: {\n                                o1 = o1.min.call(o1, 4294901760, r1 + (65536 - r1 % 65536) % 65536) - T1.buffer.byteLength + 65535 >>> 16;\n                                try {\n                                    T1.grow(o1), I1();\n                                    var i1 = 1;\n                                    break e;\n                                } catch (e1) {}\n                                i1 = void 0;\n                            }\n                            if (i1) return !0;\n                        }\n                        return !1;\n                    },\n                    D: function(e1, t1) {\n                        e1 >>>= 0, t1 >>>= 0;\n                        var n1 = 0;\n                        return re1().forEach(function(r1, o1) {\n                            var i1 = t1 + n1;\n                            for(o1 = A1[e1 + 4 * o1 >> 2 >>> 0] = i1, i1 = 0; i1 < r1.length; ++i1)w1[o1++ >> 0 >>> 0] = r1.charCodeAt(i1);\n                            w1[o1 >> 0 >>> 0] = 0, n1 += r1.length + 1;\n                        }), 0;\n                    },\n                    E: function(e1, t1) {\n                        e1 >>>= 0, t1 >>>= 0;\n                        var n1 = re1();\n                        A1[e1 >> 2 >>> 0] = n1.length;\n                        var r1 = 0;\n                        return n1.forEach(function(e1) {\n                            r1 += e1.length + 1;\n                        }), A1[t1 >> 2 >>> 0] = r1, 0;\n                    },\n                    s: (e1)=>{\n                        v1 || (o1.onExit && o1.onExit(e1), P1 = !0), c1(e1, new z1(e1));\n                    },\n                    f: ()=>52,\n                    j: function() {\n                        return 52;\n                    },\n                    q: function() {\n                        return 70;\n                    },\n                    i: function(e1, t1, n1, r1) {\n                        t1 >>>= 0, n1 >>>= 0, r1 >>>= 0;\n                        for(var o1 = 0, i1 = 0; i1 < n1; i1++){\n                            var s1 = A1[t1 >> 2 >>> 0], a1 = A1[t1 + 4 >> 2 >>> 0];\n                            t1 += 8;\n                            for(var u1 = 0; u1 < a1; u1++){\n                                var l1 = O1[s1 + u1 >>> 0], c1 = oe1[e1];\n                                0 === l1 || 10 === l1 ? ((1 === e1 ? y1 : _1)(X1(c1, 0)), c1.length = 0) : c1.push(l1);\n                            }\n                            o1 += a1;\n                        }\n                        return A1[r1 >> 2 >>> 0] = o1, 0;\n                    },\n                    r: function(e1, t1) {\n                        return e1 >>>= 0, ie1(O1.subarray(e1 >>> 0, e1 + (t1 >>> 0) >>> 0)), 0;\n                    },\n                    C: ue1,\n                    c: function(e1, t1, n1, r1) {\n                        return ue1(e1 >>> 0, t1 >>> 0, n1 >>> 0, r1 >>> 0);\n                    }\n                };\n                !function() {\n                    function e1(e1) {\n                        if (e1 = e1.exports, x1 = e1 = function(e1) {\n                            var t1 = (e1)=>()=>e1() >>> 0, n1 = (e1)=>(t1)=>e1(t1) >>> 0;\n                            return (e1 = Object.assign({}, e1)).__errno_location = t1(e1.__errno_location), e1.malloc = n1(e1.malloc), e1.stackSave = t1(e1.stackSave), e1.stackAlloc = n1(e1.stackAlloc), e1;\n                        }(e1), T1 = x1.L, I1(), D1.unshift(x1.M), L1--, o1.monitorRunDependencies && o1.monitorRunDependencies(L1), 0 == L1 && (null !== C1 && (clearInterval(C1), C1 = null), R1)) {\n                            var t1 = R1;\n                            R1 = null, t1();\n                        }\n                        return e1;\n                    }\n                    var t1 = {\n                        a: le1\n                    };\n                    if (L1++, o1.monitorRunDependencies && o1.monitorRunDependencies(L1), o1.instantiateWasm) try {\n                        return o1.instantiateWasm(t1, e1);\n                    } catch (e1) {\n                        _1(\"Module.instantiateWasm callback failed with error: \" + e1), r1(e1);\n                    }\n                    (function(e1, t1) {\n                        var n1 = F1;\n                        return m1 || \"function\" != typeof WebAssembly.instantiateStreaming || M1(n1) || n1.startsWith(\"file://\") || f1 || \"function\" != typeof fetch ? V1(n1, e1, t1) : fetch(n1, {\n                            credentials: \"same-origin\"\n                        }).then((r1)=>WebAssembly.instantiateStreaming(r1, e1).then(t1, function(r1) {\n                                return _1(\"wasm streaming compile failed: \" + r1), _1(\"falling back to ArrayBuffer instantiation\"), V1(n1, e1, t1);\n                            }));\n                    })(t1, function(t1) {\n                        e1(t1.instance);\n                    }).catch(r1);\n                }(), o1._OrtInit = (e1, t1)=>(o1._OrtInit = x1.N)(e1, t1), o1._OrtGetLastError = (e1, t1)=>(o1._OrtGetLastError = x1.O)(e1, t1), o1._OrtCreateSessionOptions = (e1, t1, n1, r1, i1, s1, a1, u1, l1, c1)=>(o1._OrtCreateSessionOptions = x1.P)(e1, t1, n1, r1, i1, s1, a1, u1, l1, c1), o1._OrtAppendExecutionProvider = (e1, t1)=>(o1._OrtAppendExecutionProvider = x1.Q)(e1, t1), o1._OrtAddSessionConfigEntry = (e1, t1, n1)=>(o1._OrtAddSessionConfigEntry = x1.R)(e1, t1, n1), o1._OrtReleaseSessionOptions = (e1)=>(o1._OrtReleaseSessionOptions = x1.S)(e1), o1._OrtCreateSession = (e1, t1, n1)=>(o1._OrtCreateSession = x1.T)(e1, t1, n1), o1._OrtReleaseSession = (e1)=>(o1._OrtReleaseSession = x1.U)(e1), o1._OrtGetInputOutputCount = (e1, t1, n1)=>(o1._OrtGetInputOutputCount = x1.V)(e1, t1, n1), o1._OrtGetInputName = (e1, t1)=>(o1._OrtGetInputName = x1.W)(e1, t1), o1._OrtGetOutputName = (e1, t1)=>(o1._OrtGetOutputName = x1.X)(e1, t1), o1._OrtFree = (e1)=>(o1._OrtFree = x1.Y)(e1), o1._OrtCreateTensor = (e1, t1, n1, r1, i1)=>(o1._OrtCreateTensor = x1.Z)(e1, t1, n1, r1, i1), o1._OrtGetTensorData = (e1, t1, n1, r1, i1)=>(o1._OrtGetTensorData = x1._)(e1, t1, n1, r1, i1), o1._OrtReleaseTensor = (e1)=>(o1._OrtReleaseTensor = x1.$)(e1), o1._OrtCreateRunOptions = (e1, t1, n1, r1)=>(o1._OrtCreateRunOptions = x1.aa)(e1, t1, n1, r1), o1._OrtAddRunConfigEntry = (e1, t1, n1)=>(o1._OrtAddRunConfigEntry = x1.ba)(e1, t1, n1), o1._OrtReleaseRunOptions = (e1)=>(o1._OrtReleaseRunOptions = x1.ca)(e1), o1._OrtRun = (e1, t1, n1, r1, i1, s1, a1, u1)=>(o1._OrtRun = x1.da)(e1, t1, n1, r1, i1, s1, a1, u1), o1._OrtEndProfiling = (e1)=>(o1._OrtEndProfiling = x1.ea)(e1);\n                var ce1 = o1._malloc = (e1)=>(ce1 = o1._malloc = x1.fa)(e1);\n                o1._free = (e1)=>(o1._free = x1.ga)(e1);\n                var pe1, de1 = (e1)=>(de1 = x1.ia)(e1), fe1 = ()=>(fe1 = x1.ja)(), he1 = (e1)=>(he1 = x1.ka)(e1), ge1 = (e1)=>(ge1 = x1.la)(e1);\n                function be1() {\n                    function e1() {\n                        if (!pe1 && (pe1 = !0, o1.calledRun = !0, !P1)) {\n                            if (G1(D1), t1(o1), o1.onRuntimeInitialized && o1.onRuntimeInitialized(), o1.postRun) for(\"function\" == typeof o1.postRun && (o1.postRun = [\n                                o1.postRun\n                            ]); o1.postRun.length;){\n                                var e1 = o1.postRun.shift();\n                                $1.unshift(e1);\n                            }\n                            G1($1);\n                        }\n                    }\n                    if (!(0 < L1)) {\n                        if (o1.preRun) for(\"function\" == typeof o1.preRun && (o1.preRun = [\n                            o1.preRun\n                        ]); o1.preRun.length;)k1();\n                        G1(E1), 0 < L1 || (o1.setStatus ? (o1.setStatus(\"Running...\"), setTimeout(function() {\n                            setTimeout(function() {\n                                o1.setStatus(\"\");\n                            }, 1), e1();\n                        }, 1)) : e1());\n                    }\n                }\n                if (o1.stackAlloc = ge1, o1.stackSave = fe1, o1.stackRestore = he1, o1.UTF8ToString = Y1, o1.stringToUTF8 = (e1, t1, n1)=>J1(e1, O1, t1, n1), o1.lengthBytesUTF8 = K1, R1 = function e1() {\n                    pe1 || be1(), pe1 || (R1 = e1);\n                }, o1.preInit) for(\"function\" == typeof o1.preInit && (o1.preInit = [\n                    o1.preInit\n                ]); 0 < o1.preInit.length;)o1.preInit.pop()();\n                return be1(), e1.ready;\n            });\n            e1.exports = r1;\n        },\n        4537: (e1)=>{\n            \"use strict\";\n            e1.exports = function(e1, t1) {\n                for(var n1 = new Array(arguments.length - 1), r1 = 0, o1 = 2, i1 = !0; o1 < arguments.length;)n1[r1++] = arguments[o1++];\n                return new Promise(function(o1, s1) {\n                    n1[r1] = function(e1) {\n                        if (i1) if (i1 = !1, e1) s1(e1);\n                        else {\n                            for(var t1 = new Array(arguments.length - 1), n1 = 0; n1 < t1.length;)t1[n1++] = arguments[n1];\n                            o1.apply(null, t1);\n                        }\n                    };\n                    try {\n                        e1.apply(t1 || null, n1);\n                    } catch (e1) {\n                        i1 && (i1 = !1, s1(e1));\n                    }\n                });\n            };\n        },\n        7419: (e1, t1)=>{\n            \"use strict\";\n            var n1 = t1;\n            n1.length = function(e1) {\n                var t1 = e1.length;\n                if (!t1) return 0;\n                for(var n1 = 0; --t1 % 4 > 1 && \"=\" === e1.charAt(t1);)++n1;\n                return Math.ceil(3 * e1.length) / 4 - n1;\n            };\n            for(var r1 = new Array(64), o1 = new Array(123), i1 = 0; i1 < 64;)o1[r1[i1] = i1 < 26 ? i1 + 65 : i1 < 52 ? i1 + 71 : i1 < 62 ? i1 - 4 : i1 - 59 | 43] = i1++;\n            n1.encode = function(e1, t1, n1) {\n                for(var o1, i1 = null, s1 = [], a1 = 0, u1 = 0; t1 < n1;){\n                    var l1 = e1[t1++];\n                    switch(u1){\n                        case 0:\n                            s1[a1++] = r1[l1 >> 2], o1 = (3 & l1) << 4, u1 = 1;\n                            break;\n                        case 1:\n                            s1[a1++] = r1[o1 | l1 >> 4], o1 = (15 & l1) << 2, u1 = 2;\n                            break;\n                        case 2:\n                            s1[a1++] = r1[o1 | l1 >> 6], s1[a1++] = r1[63 & l1], u1 = 0;\n                    }\n                    a1 > 8191 && ((i1 || (i1 = [])).push(String.fromCharCode.apply(String, s1)), a1 = 0);\n                }\n                return u1 && (s1[a1++] = r1[o1], s1[a1++] = 61, 1 === u1 && (s1[a1++] = 61)), i1 ? (a1 && i1.push(String.fromCharCode.apply(String, s1.slice(0, a1))), i1.join(\"\")) : String.fromCharCode.apply(String, s1.slice(0, a1));\n            };\n            var s1 = \"invalid encoding\";\n            n1.decode = function(e1, t1, n1) {\n                for(var r1, i1 = n1, a1 = 0, u1 = 0; u1 < e1.length;){\n                    var l1 = e1.charCodeAt(u1++);\n                    if (61 === l1 && a1 > 1) break;\n                    if (void 0 === (l1 = o1[l1])) throw Error(s1);\n                    switch(a1){\n                        case 0:\n                            r1 = l1, a1 = 1;\n                            break;\n                        case 1:\n                            t1[n1++] = r1 << 2 | (48 & l1) >> 4, r1 = l1, a1 = 2;\n                            break;\n                        case 2:\n                            t1[n1++] = (15 & r1) << 4 | (60 & l1) >> 2, r1 = l1, a1 = 3;\n                            break;\n                        case 3:\n                            t1[n1++] = (3 & r1) << 6 | l1, a1 = 0;\n                    }\n                }\n                if (1 === a1) throw Error(s1);\n                return n1 - i1;\n            }, n1.test = function(e1) {\n                return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e1);\n            };\n        },\n        9211: (e1)=>{\n            \"use strict\";\n            function t1() {\n                this._listeners = {};\n            }\n            e1.exports = t1, t1.prototype.on = function(e1, t1, n1) {\n                return (this._listeners[e1] || (this._listeners[e1] = [])).push({\n                    fn: t1,\n                    ctx: n1 || this\n                }), this;\n            }, t1.prototype.off = function(e1, t1) {\n                if (void 0 === e1) this._listeners = {};\n                else if (void 0 === t1) this._listeners[e1] = [];\n                else for(var n1 = this._listeners[e1], r1 = 0; r1 < n1.length;)n1[r1].fn === t1 ? n1.splice(r1, 1) : ++r1;\n                return this;\n            }, t1.prototype.emit = function(e1) {\n                var t1 = this._listeners[e1];\n                if (t1) {\n                    for(var n1 = [], r1 = 1; r1 < arguments.length;)n1.push(arguments[r1++]);\n                    for(r1 = 0; r1 < t1.length;)t1[r1].fn.apply(t1[r1++].ctx, n1);\n                }\n                return this;\n            };\n        },\n        945: (e1)=>{\n            \"use strict\";\n            function t1(e1) {\n                return \"undefined\" != typeof Float32Array ? function() {\n                    var t1 = new Float32Array([\n                        -0\n                    ]), n1 = new Uint8Array(t1.buffer), r1 = 128 === n1[3];\n                    function o1(e1, r1, o1) {\n                        t1[0] = e1, r1[o1] = n1[0], r1[o1 + 1] = n1[1], r1[o1 + 2] = n1[2], r1[o1 + 3] = n1[3];\n                    }\n                    function i1(e1, r1, o1) {\n                        t1[0] = e1, r1[o1] = n1[3], r1[o1 + 1] = n1[2], r1[o1 + 2] = n1[1], r1[o1 + 3] = n1[0];\n                    }\n                    function s1(e1, r1) {\n                        return n1[0] = e1[r1], n1[1] = e1[r1 + 1], n1[2] = e1[r1 + 2], n1[3] = e1[r1 + 3], t1[0];\n                    }\n                    function a1(e1, r1) {\n                        return n1[3] = e1[r1], n1[2] = e1[r1 + 1], n1[1] = e1[r1 + 2], n1[0] = e1[r1 + 3], t1[0];\n                    }\n                    e1.writeFloatLE = r1 ? o1 : i1, e1.writeFloatBE = r1 ? i1 : o1, e1.readFloatLE = r1 ? s1 : a1, e1.readFloatBE = r1 ? a1 : s1;\n                }() : function() {\n                    function t1(e1, t1, n1, r1) {\n                        var o1 = t1 < 0 ? 1 : 0;\n                        if (o1 && (t1 = -t1), 0 === t1) e1(1 / t1 > 0 ? 0 : 2147483648, n1, r1);\n                        else if (isNaN(t1)) e1(2143289344, n1, r1);\n                        else if (t1 > 34028234663852886e22) e1((o1 << 31 | 2139095040) >>> 0, n1, r1);\n                        else if (t1 < 11754943508222875e-54) e1((o1 << 31 | Math.round(t1 / 1401298464324817e-60)) >>> 0, n1, r1);\n                        else {\n                            var i1 = Math.floor(Math.log(t1) / Math.LN2);\n                            e1((o1 << 31 | i1 + 127 << 23 | 8388607 & Math.round(t1 * Math.pow(2, -i1) * 8388608)) >>> 0, n1, r1);\n                        }\n                    }\n                    function s1(e1, t1, n1) {\n                        var r1 = e1(t1, n1), o1 = 2 * (r1 >> 31) + 1, i1 = r1 >>> 23 & 255, s1 = 8388607 & r1;\n                        return 255 === i1 ? s1 ? NaN : o1 * (1 / 0) : 0 === i1 ? 1401298464324817e-60 * o1 * s1 : o1 * Math.pow(2, i1 - 150) * (s1 + 8388608);\n                    }\n                    e1.writeFloatLE = t1.bind(null, n1), e1.writeFloatBE = t1.bind(null, r1), e1.readFloatLE = s1.bind(null, o1), e1.readFloatBE = s1.bind(null, i1);\n                }(), \"undefined\" != typeof Float64Array ? function() {\n                    var t1 = new Float64Array([\n                        -0\n                    ]), n1 = new Uint8Array(t1.buffer), r1 = 128 === n1[7];\n                    function o1(e1, r1, o1) {\n                        t1[0] = e1, r1[o1] = n1[0], r1[o1 + 1] = n1[1], r1[o1 + 2] = n1[2], r1[o1 + 3] = n1[3], r1[o1 + 4] = n1[4], r1[o1 + 5] = n1[5], r1[o1 + 6] = n1[6], r1[o1 + 7] = n1[7];\n                    }\n                    function i1(e1, r1, o1) {\n                        t1[0] = e1, r1[o1] = n1[7], r1[o1 + 1] = n1[6], r1[o1 + 2] = n1[5], r1[o1 + 3] = n1[4], r1[o1 + 4] = n1[3], r1[o1 + 5] = n1[2], r1[o1 + 6] = n1[1], r1[o1 + 7] = n1[0];\n                    }\n                    function s1(e1, r1) {\n                        return n1[0] = e1[r1], n1[1] = e1[r1 + 1], n1[2] = e1[r1 + 2], n1[3] = e1[r1 + 3], n1[4] = e1[r1 + 4], n1[5] = e1[r1 + 5], n1[6] = e1[r1 + 6], n1[7] = e1[r1 + 7], t1[0];\n                    }\n                    function a1(e1, r1) {\n                        return n1[7] = e1[r1], n1[6] = e1[r1 + 1], n1[5] = e1[r1 + 2], n1[4] = e1[r1 + 3], n1[3] = e1[r1 + 4], n1[2] = e1[r1 + 5], n1[1] = e1[r1 + 6], n1[0] = e1[r1 + 7], t1[0];\n                    }\n                    e1.writeDoubleLE = r1 ? o1 : i1, e1.writeDoubleBE = r1 ? i1 : o1, e1.readDoubleLE = r1 ? s1 : a1, e1.readDoubleBE = r1 ? a1 : s1;\n                }() : function() {\n                    function t1(e1, t1, n1, r1, o1, i1) {\n                        var s1 = r1 < 0 ? 1 : 0;\n                        if (s1 && (r1 = -r1), 0 === r1) e1(0, o1, i1 + t1), e1(1 / r1 > 0 ? 0 : 2147483648, o1, i1 + n1);\n                        else if (isNaN(r1)) e1(0, o1, i1 + t1), e1(2146959360, o1, i1 + n1);\n                        else if (r1 > 17976931348623157e292) e1(0, o1, i1 + t1), e1((s1 << 31 | 2146435072) >>> 0, o1, i1 + n1);\n                        else {\n                            var a1;\n                            if (r1 < 22250738585072014e-324) e1((a1 = r1 / 5e-324) >>> 0, o1, i1 + t1), e1((s1 << 31 | a1 / 4294967296) >>> 0, o1, i1 + n1);\n                            else {\n                                var u1 = Math.floor(Math.log(r1) / Math.LN2);\n                                1024 === u1 && (u1 = 1023), e1(4503599627370496 * (a1 = r1 * Math.pow(2, -u1)) >>> 0, o1, i1 + t1), e1((s1 << 31 | u1 + 1023 << 20 | 1048576 * a1 & 1048575) >>> 0, o1, i1 + n1);\n                            }\n                        }\n                    }\n                    function s1(e1, t1, n1, r1, o1) {\n                        var i1 = e1(r1, o1 + t1), s1 = e1(r1, o1 + n1), a1 = 2 * (s1 >> 31) + 1, u1 = s1 >>> 20 & 2047, l1 = 4294967296 * (1048575 & s1) + i1;\n                        return 2047 === u1 ? l1 ? NaN : a1 * (1 / 0) : 0 === u1 ? 5e-324 * a1 * l1 : a1 * Math.pow(2, u1 - 1075) * (l1 + 4503599627370496);\n                    }\n                    e1.writeDoubleLE = t1.bind(null, n1, 0, 4), e1.writeDoubleBE = t1.bind(null, r1, 4, 0), e1.readDoubleLE = s1.bind(null, o1, 0, 4), e1.readDoubleBE = s1.bind(null, i1, 4, 0);\n                }(), e1;\n            }\n            function n1(e1, t1, n1) {\n                t1[n1] = 255 & e1, t1[n1 + 1] = e1 >>> 8 & 255, t1[n1 + 2] = e1 >>> 16 & 255, t1[n1 + 3] = e1 >>> 24;\n            }\n            function r1(e1, t1, n1) {\n                t1[n1] = e1 >>> 24, t1[n1 + 1] = e1 >>> 16 & 255, t1[n1 + 2] = e1 >>> 8 & 255, t1[n1 + 3] = 255 & e1;\n            }\n            function o1(e1, t1) {\n                return (e1[t1] | e1[t1 + 1] << 8 | e1[t1 + 2] << 16 | e1[t1 + 3] << 24) >>> 0;\n            }\n            function i1(e1, t1) {\n                return (e1[t1] << 24 | e1[t1 + 1] << 16 | e1[t1 + 2] << 8 | e1[t1 + 3]) >>> 0;\n            }\n            e1.exports = t1(t1);\n        },\n        7199: (module)=>{\n            \"use strict\";\n            function inquire(moduleName) {\n                try {\n                    var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n                    if (mod && (mod.length || Object.keys(mod).length)) return mod;\n                } catch (e) {}\n                return null;\n            }\n            module.exports = inquire;\n        },\n        6662: (e1)=>{\n            \"use strict\";\n            e1.exports = function(e1, t1, n1) {\n                var r1 = n1 || 8192, o1 = r1 >>> 1, i1 = null, s1 = r1;\n                return function(n1) {\n                    if (n1 < 1 || n1 > o1) return e1(n1);\n                    s1 + n1 > r1 && (i1 = e1(r1), s1 = 0);\n                    var a1 = t1.call(i1, s1, s1 += n1);\n                    return 7 & s1 && (s1 = 1 + (7 | s1)), a1;\n                };\n            };\n        },\n        4997: (e1, t1)=>{\n            \"use strict\";\n            var n1 = t1;\n            n1.length = function(e1) {\n                for(var t1 = 0, n1 = 0, r1 = 0; r1 < e1.length; ++r1)(n1 = e1.charCodeAt(r1)) < 128 ? t1 += 1 : n1 < 2048 ? t1 += 2 : 55296 == (64512 & n1) && 56320 == (64512 & e1.charCodeAt(r1 + 1)) ? (++r1, t1 += 4) : t1 += 3;\n                return t1;\n            }, n1.read = function(e1, t1, n1) {\n                if (n1 - t1 < 1) return \"\";\n                for(var r1, o1 = null, i1 = [], s1 = 0; t1 < n1;)(r1 = e1[t1++]) < 128 ? i1[s1++] = r1 : r1 > 191 && r1 < 224 ? i1[s1++] = (31 & r1) << 6 | 63 & e1[t1++] : r1 > 239 && r1 < 365 ? (r1 = ((7 & r1) << 18 | (63 & e1[t1++]) << 12 | (63 & e1[t1++]) << 6 | 63 & e1[t1++]) - 65536, i1[s1++] = 55296 + (r1 >> 10), i1[s1++] = 56320 + (1023 & r1)) : i1[s1++] = (15 & r1) << 12 | (63 & e1[t1++]) << 6 | 63 & e1[t1++], s1 > 8191 && ((o1 || (o1 = [])).push(String.fromCharCode.apply(String, i1)), s1 = 0);\n                return o1 ? (s1 && o1.push(String.fromCharCode.apply(String, i1.slice(0, s1))), o1.join(\"\")) : String.fromCharCode.apply(String, i1.slice(0, s1));\n            }, n1.write = function(e1, t1, n1) {\n                for(var r1, o1, i1 = n1, s1 = 0; s1 < e1.length; ++s1)(r1 = e1.charCodeAt(s1)) < 128 ? t1[n1++] = r1 : r1 < 2048 ? (t1[n1++] = r1 >> 6 | 192, t1[n1++] = 63 & r1 | 128) : 55296 == (64512 & r1) && 56320 == (64512 & (o1 = e1.charCodeAt(s1 + 1))) ? (r1 = 65536 + ((1023 & r1) << 10) + (1023 & o1), ++s1, t1[n1++] = r1 >> 18 | 240, t1[n1++] = r1 >> 12 & 63 | 128, t1[n1++] = r1 >> 6 & 63 | 128, t1[n1++] = 63 & r1 | 128) : (t1[n1++] = r1 >> 12 | 224, t1[n1++] = r1 >> 6 & 63 | 128, t1[n1++] = 63 & r1 | 128);\n                return n1 - i1;\n            };\n        },\n        3442: (e1, t1)=>{\n            \"use strict\";\n            t1.__esModule = !0;\n            var n1 = function() {\n                function e1(t1) {\n                    if (!t1) throw new TypeError(\"Invalid argument; `value` has no value.\");\n                    this.value = e1.EMPTY, t1 && e1.isGuid(t1) && (this.value = t1);\n                }\n                return e1.isGuid = function(t1) {\n                    var n1 = t1.toString();\n                    return t1 && (t1 instanceof e1 || e1.validator.test(n1));\n                }, e1.create = function() {\n                    return new e1([\n                        e1.gen(2),\n                        e1.gen(1),\n                        e1.gen(1),\n                        e1.gen(1),\n                        e1.gen(3)\n                    ].join(\"-\"));\n                }, e1.createEmpty = function() {\n                    return new e1(\"emptyguid\");\n                }, e1.parse = function(t1) {\n                    return new e1(t1);\n                }, e1.raw = function() {\n                    return [\n                        e1.gen(2),\n                        e1.gen(1),\n                        e1.gen(1),\n                        e1.gen(1),\n                        e1.gen(3)\n                    ].join(\"-\");\n                }, e1.gen = function(e1) {\n                    for(var t1 = \"\", n1 = 0; n1 < e1; n1++)t1 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);\n                    return t1;\n                }, e1.prototype.equals = function(t1) {\n                    return e1.isGuid(t1) && this.value === t1.toString();\n                }, e1.prototype.isEmpty = function() {\n                    return this.value === e1.EMPTY;\n                }, e1.prototype.toString = function() {\n                    return this.value;\n                }, e1.prototype.toJSON = function() {\n                    return {\n                        value: this.value\n                    };\n                }, e1.validator = new RegExp(\"^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$\", \"i\"), e1.EMPTY = \"00000000-0000-0000-0000-000000000000\", e1;\n            }();\n            t1.Guid = n1;\n        },\n        2100: (e1, t1, n1)=>{\n            \"use strict\";\n            e1.exports = n1(9482);\n        },\n        9482: (e1, t1, n1)=>{\n            \"use strict\";\n            var r1 = t1;\n            function o1() {\n                r1.util._configure(), r1.Writer._configure(r1.BufferWriter), r1.Reader._configure(r1.BufferReader);\n            }\n            r1.build = \"minimal\", r1.Writer = n1(1173), r1.BufferWriter = n1(3155), r1.Reader = n1(1408), r1.BufferReader = n1(593), r1.util = n1(9693), r1.rpc = n1(5994), r1.roots = n1(5054), r1.configure = o1, o1();\n        },\n        1408: (e1, t1, n1)=>{\n            \"use strict\";\n            e1.exports = u1;\n            var r1, o1 = n1(9693), i1 = o1.LongBits, s1 = o1.utf8;\n            function a1(e1, t1) {\n                return RangeError(\"index out of range: \" + e1.pos + \" + \" + (t1 || 1) + \" > \" + e1.len);\n            }\n            function u1(e1) {\n                this.buf = e1, this.pos = 0, this.len = e1.length;\n            }\n            var l1, c1 = \"undefined\" != typeof Uint8Array ? function(e1) {\n                if (e1 instanceof Uint8Array || Array.isArray(e1)) return new u1(e1);\n                throw Error(\"illegal buffer\");\n            } : function(e1) {\n                if (Array.isArray(e1)) return new u1(e1);\n                throw Error(\"illegal buffer\");\n            }, p1 = function() {\n                return o1.Buffer ? function(e1) {\n                    return (u1.create = function(e1) {\n                        return o1.Buffer.isBuffer(e1) ? new r1(e1) : c1(e1);\n                    })(e1);\n                } : c1;\n            };\n            function d1() {\n                var e1 = new i1(0, 0), t1 = 0;\n                if (!(this.len - this.pos > 4)) {\n                    for(; t1 < 3; ++t1){\n                        if (this.pos >= this.len) throw a1(this);\n                        if (e1.lo = (e1.lo | (127 & this.buf[this.pos]) << 7 * t1) >>> 0, this.buf[this.pos++] < 128) return e1;\n                    }\n                    return e1.lo = (e1.lo | (127 & this.buf[this.pos++]) << 7 * t1) >>> 0, e1;\n                }\n                for(; t1 < 4; ++t1)if (e1.lo = (e1.lo | (127 & this.buf[this.pos]) << 7 * t1) >>> 0, this.buf[this.pos++] < 128) return e1;\n                if (e1.lo = (e1.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e1.hi = (e1.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e1;\n                if (t1 = 0, this.len - this.pos > 4) {\n                    for(; t1 < 5; ++t1)if (e1.hi = (e1.hi | (127 & this.buf[this.pos]) << 7 * t1 + 3) >>> 0, this.buf[this.pos++] < 128) return e1;\n                } else for(; t1 < 5; ++t1){\n                    if (this.pos >= this.len) throw a1(this);\n                    if (e1.hi = (e1.hi | (127 & this.buf[this.pos]) << 7 * t1 + 3) >>> 0, this.buf[this.pos++] < 128) return e1;\n                }\n                throw Error(\"invalid varint encoding\");\n            }\n            function f1(e1, t1) {\n                return (e1[t1 - 4] | e1[t1 - 3] << 8 | e1[t1 - 2] << 16 | e1[t1 - 1] << 24) >>> 0;\n            }\n            function h1() {\n                if (this.pos + 8 > this.len) throw a1(this, 8);\n                return new i1(f1(this.buf, this.pos += 4), f1(this.buf, this.pos += 4));\n            }\n            u1.create = p1(), u1.prototype._slice = o1.Array.prototype.subarray || o1.Array.prototype.slice, u1.prototype.uint32 = (l1 = 4294967295, function() {\n                if (l1 = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return l1;\n                if (l1 = (l1 | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return l1;\n                if (l1 = (l1 | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return l1;\n                if (l1 = (l1 | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return l1;\n                if (l1 = (l1 | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return l1;\n                if ((this.pos += 5) > this.len) throw this.pos = this.len, a1(this, 10);\n                return l1;\n            }), u1.prototype.int32 = function() {\n                return 0 | this.uint32();\n            }, u1.prototype.sint32 = function() {\n                var e1 = this.uint32();\n                return e1 >>> 1 ^ -(1 & e1) | 0;\n            }, u1.prototype.bool = function() {\n                return 0 !== this.uint32();\n            }, u1.prototype.fixed32 = function() {\n                if (this.pos + 4 > this.len) throw a1(this, 4);\n                return f1(this.buf, this.pos += 4);\n            }, u1.prototype.sfixed32 = function() {\n                if (this.pos + 4 > this.len) throw a1(this, 4);\n                return 0 | f1(this.buf, this.pos += 4);\n            }, u1.prototype.float = function() {\n                if (this.pos + 4 > this.len) throw a1(this, 4);\n                var e1 = o1.float.readFloatLE(this.buf, this.pos);\n                return this.pos += 4, e1;\n            }, u1.prototype.double = function() {\n                if (this.pos + 8 > this.len) throw a1(this, 4);\n                var e1 = o1.float.readDoubleLE(this.buf, this.pos);\n                return this.pos += 8, e1;\n            }, u1.prototype.bytes = function() {\n                var e1 = this.uint32(), t1 = this.pos, n1 = this.pos + e1;\n                if (n1 > this.len) throw a1(this, e1);\n                return this.pos += e1, Array.isArray(this.buf) ? this.buf.slice(t1, n1) : t1 === n1 ? new this.buf.constructor(0) : this._slice.call(this.buf, t1, n1);\n            }, u1.prototype.string = function() {\n                var e1 = this.bytes();\n                return s1.read(e1, 0, e1.length);\n            }, u1.prototype.skip = function(e1) {\n                if (\"number\" == typeof e1) {\n                    if (this.pos + e1 > this.len) throw a1(this, e1);\n                    this.pos += e1;\n                } else do {\n                    if (this.pos >= this.len) throw a1(this);\n                }while (128 & this.buf[this.pos++]);\n                return this;\n            }, u1.prototype.skipType = function(e1) {\n                switch(e1){\n                    case 0:\n                        this.skip();\n                        break;\n                    case 1:\n                        this.skip(8);\n                        break;\n                    case 2:\n                        this.skip(this.uint32());\n                        break;\n                    case 3:\n                        for(; 4 != (e1 = 7 & this.uint32());)this.skipType(e1);\n                        break;\n                    case 5:\n                        this.skip(4);\n                        break;\n                    default:\n                        throw Error(\"invalid wire type \" + e1 + \" at offset \" + this.pos);\n                }\n                return this;\n            }, u1._configure = function(e1) {\n                r1 = e1, u1.create = p1(), r1._configure();\n                var t1 = o1.Long ? \"toLong\" : \"toNumber\";\n                o1.merge(u1.prototype, {\n                    int64: function() {\n                        return d1.call(this)[t1](!1);\n                    },\n                    uint64: function() {\n                        return d1.call(this)[t1](!0);\n                    },\n                    sint64: function() {\n                        return d1.call(this).zzDecode()[t1](!1);\n                    },\n                    fixed64: function() {\n                        return h1.call(this)[t1](!0);\n                    },\n                    sfixed64: function() {\n                        return h1.call(this)[t1](!1);\n                    }\n                });\n            };\n        },\n        593: (e1, t1, n1)=>{\n            \"use strict\";\n            e1.exports = i1;\n            var r1 = n1(1408);\n            (i1.prototype = Object.create(r1.prototype)).constructor = i1;\n            var o1 = n1(9693);\n            function i1(e1) {\n                r1.call(this, e1);\n            }\n            i1._configure = function() {\n                o1.Buffer && (i1.prototype._slice = o1.Buffer.prototype.slice);\n            }, i1.prototype.string = function() {\n                var e1 = this.uint32();\n                return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e1, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + e1, this.len));\n            }, i1._configure();\n        },\n        5054: (e1)=>{\n            \"use strict\";\n            e1.exports = {};\n        },\n        5994: (e1, t1, n1)=>{\n            \"use strict\";\n            t1.Service = n1(7948);\n        },\n        7948: (e1, t1, n1)=>{\n            \"use strict\";\n            e1.exports = o1;\n            var r1 = n1(9693);\n            function o1(e1, t1, n1) {\n                if (\"function\" != typeof e1) throw TypeError(\"rpcImpl must be a function\");\n                r1.EventEmitter.call(this), this.rpcImpl = e1, this.requestDelimited = Boolean(t1), this.responseDelimited = Boolean(n1);\n            }\n            (o1.prototype = Object.create(r1.EventEmitter.prototype)).constructor = o1, o1.prototype.rpcCall = function e1(t1, n1, o1, i1, s1) {\n                if (!i1) throw TypeError(\"request must be specified\");\n                var a1 = this;\n                if (!s1) return r1.asPromise(e1, a1, t1, n1, o1, i1);\n                if (a1.rpcImpl) try {\n                    return a1.rpcImpl(t1, n1[a1.requestDelimited ? \"encodeDelimited\" : \"encode\"](i1).finish(), function(e1, n1) {\n                        if (e1) return a1.emit(\"error\", e1, t1), s1(e1);\n                        if (null !== n1) {\n                            if (!(n1 instanceof o1)) try {\n                                n1 = o1[a1.responseDelimited ? \"decodeDelimited\" : \"decode\"](n1);\n                            } catch (e1) {\n                                return a1.emit(\"error\", e1, t1), s1(e1);\n                            }\n                            return a1.emit(\"data\", n1, t1), s1(null, n1);\n                        }\n                        a1.end(!0);\n                    });\n                } catch (e1) {\n                    return a1.emit(\"error\", e1, t1), void setTimeout(function() {\n                        s1(e1);\n                    }, 0);\n                }\n                else setTimeout(function() {\n                    s1(Error(\"already ended\"));\n                }, 0);\n            }, o1.prototype.end = function(e1) {\n                return this.rpcImpl && (e1 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n            };\n        },\n        1945: (e1, t1, n1)=>{\n            \"use strict\";\n            e1.exports = o1;\n            var r1 = n1(9693);\n            function o1(e1, t1) {\n                this.lo = e1 >>> 0, this.hi = t1 >>> 0;\n            }\n            var i1 = o1.zero = new o1(0, 0);\n            i1.toNumber = function() {\n                return 0;\n            }, i1.zzEncode = i1.zzDecode = function() {\n                return this;\n            }, i1.length = function() {\n                return 1;\n            };\n            var s1 = o1.zeroHash = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n            o1.fromNumber = function(e1) {\n                if (0 === e1) return i1;\n                var t1 = e1 < 0;\n                t1 && (e1 = -e1);\n                var n1 = e1 >>> 0, r1 = (e1 - n1) / 4294967296 >>> 0;\n                return t1 && (r1 = ~r1 >>> 0, n1 = ~n1 >>> 0, ++n1 > 4294967295 && (n1 = 0, ++r1 > 4294967295 && (r1 = 0))), new o1(n1, r1);\n            }, o1.from = function(e1) {\n                if (\"number\" == typeof e1) return o1.fromNumber(e1);\n                if (r1.isString(e1)) {\n                    if (!r1.Long) return o1.fromNumber(parseInt(e1, 10));\n                    e1 = r1.Long.fromString(e1);\n                }\n                return e1.low || e1.high ? new o1(e1.low >>> 0, e1.high >>> 0) : i1;\n            }, o1.prototype.toNumber = function(e1) {\n                if (!e1 && this.hi >>> 31) {\n                    var t1 = 1 + ~this.lo >>> 0, n1 = ~this.hi >>> 0;\n                    return t1 || (n1 = n1 + 1 >>> 0), -(t1 + 4294967296 * n1);\n                }\n                return this.lo + 4294967296 * this.hi;\n            }, o1.prototype.toLong = function(e1) {\n                return r1.Long ? new r1.Long(0 | this.lo, 0 | this.hi, Boolean(e1)) : {\n                    low: 0 | this.lo,\n                    high: 0 | this.hi,\n                    unsigned: Boolean(e1)\n                };\n            };\n            var a1 = String.prototype.charCodeAt;\n            o1.fromHash = function(e1) {\n                return e1 === s1 ? i1 : new o1((a1.call(e1, 0) | a1.call(e1, 1) << 8 | a1.call(e1, 2) << 16 | a1.call(e1, 3) << 24) >>> 0, (a1.call(e1, 4) | a1.call(e1, 5) << 8 | a1.call(e1, 6) << 16 | a1.call(e1, 7) << 24) >>> 0);\n            }, o1.prototype.toHash = function() {\n                return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n            }, o1.prototype.zzEncode = function() {\n                var e1 = this.hi >> 31;\n                return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e1) >>> 0, this.lo = (this.lo << 1 ^ e1) >>> 0, this;\n            }, o1.prototype.zzDecode = function() {\n                var e1 = -(1 & this.lo);\n                return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e1) >>> 0, this.hi = (this.hi >>> 1 ^ e1) >>> 0, this;\n            }, o1.prototype.length = function() {\n                var e1 = this.lo, t1 = (this.lo >>> 28 | this.hi << 4) >>> 0, n1 = this.hi >>> 24;\n                return 0 === n1 ? 0 === t1 ? e1 < 16384 ? e1 < 128 ? 1 : 2 : e1 < 2097152 ? 3 : 4 : t1 < 16384 ? t1 < 128 ? 5 : 6 : t1 < 2097152 ? 7 : 8 : n1 < 128 ? 9 : 10;\n            };\n        },\n        9693: function(e1, t1, n1) {\n            \"use strict\";\n            var r1 = t1;\n            function o1(e1, t1, n1) {\n                for(var r1 = Object.keys(t1), o1 = 0; o1 < r1.length; ++o1)void 0 !== e1[r1[o1]] && n1 || (e1[r1[o1]] = t1[r1[o1]]);\n                return e1;\n            }\n            function i1(e1) {\n                function t1(e1, n1) {\n                    if (!(this instanceof t1)) return new t1(e1, n1);\n                    Object.defineProperty(this, \"message\", {\n                        get: function() {\n                            return e1;\n                        }\n                    }), Error.captureStackTrace ? Error.captureStackTrace(this, t1) : Object.defineProperty(this, \"stack\", {\n                        value: (new Error).stack || \"\"\n                    }), n1 && o1(this, n1);\n                }\n                return t1.prototype = Object.create(Error.prototype, {\n                    constructor: {\n                        value: t1,\n                        writable: !0,\n                        enumerable: !1,\n                        configurable: !0\n                    },\n                    name: {\n                        get: function() {\n                            return e1;\n                        },\n                        set: void 0,\n                        enumerable: !1,\n                        configurable: !0\n                    },\n                    toString: {\n                        value: function() {\n                            return this.name + \": \" + this.message;\n                        },\n                        writable: !0,\n                        enumerable: !1,\n                        configurable: !0\n                    }\n                }), t1;\n            }\n            r1.asPromise = n1(4537), r1.base64 = n1(7419), r1.EventEmitter = n1(9211), r1.float = n1(945), r1.inquire = n1(7199), r1.utf8 = n1(4997), r1.pool = n1(6662), r1.LongBits = n1(1945), r1.isNode = Boolean(\"undefined\" != typeof global && global && global.process && global.process.versions && global.process.versions.node), r1.global = r1.isNode && global ||  false && 0 || \"undefined\" != typeof self && self || this, r1.emptyArray = Object.freeze ? Object.freeze([]) : [], r1.emptyObject = Object.freeze ? Object.freeze({}) : {}, r1.isInteger = Number.isInteger || function(e1) {\n                return \"number\" == typeof e1 && isFinite(e1) && Math.floor(e1) === e1;\n            }, r1.isString = function(e1) {\n                return \"string\" == typeof e1 || e1 instanceof String;\n            }, r1.isObject = function(e1) {\n                return e1 && \"object\" == typeof e1;\n            }, r1.isset = r1.isSet = function(e1, t1) {\n                var n1 = e1[t1];\n                return !(null == n1 || !e1.hasOwnProperty(t1)) && (\"object\" != typeof n1 || (Array.isArray(n1) ? n1.length : Object.keys(n1).length) > 0);\n            }, r1.Buffer = function() {\n                try {\n                    var e1 = r1.inquire(\"buffer\").Buffer;\n                    return e1.prototype.utf8Write ? e1 : null;\n                } catch (e1) {\n                    return null;\n                }\n            }(), r1._Buffer_from = null, r1._Buffer_allocUnsafe = null, r1.newBuffer = function(e1) {\n                return \"number\" == typeof e1 ? r1.Buffer ? r1._Buffer_allocUnsafe(e1) : new r1.Array(e1) : r1.Buffer ? r1._Buffer_from(e1) : \"undefined\" == typeof Uint8Array ? e1 : new Uint8Array(e1);\n            }, r1.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, r1.Long = r1.global.dcodeIO && r1.global.dcodeIO.Long || r1.global.Long || r1.inquire(\"long\"), r1.key2Re = /^true|false|0|1$/, r1.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r1.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r1.longToHash = function(e1) {\n                return e1 ? r1.LongBits.from(e1).toHash() : r1.LongBits.zeroHash;\n            }, r1.longFromHash = function(e1, t1) {\n                var n1 = r1.LongBits.fromHash(e1);\n                return r1.Long ? r1.Long.fromBits(n1.lo, n1.hi, t1) : n1.toNumber(Boolean(t1));\n            }, r1.merge = o1, r1.lcFirst = function(e1) {\n                return e1.charAt(0).toLowerCase() + e1.substring(1);\n            }, r1.newError = i1, r1.ProtocolError = i1(\"ProtocolError\"), r1.oneOfGetter = function(e1) {\n                for(var t1 = {}, n1 = 0; n1 < e1.length; ++n1)t1[e1[n1]] = 1;\n                return function() {\n                    for(var e1 = Object.keys(this), n1 = e1.length - 1; n1 > -1; --n1)if (1 === t1[e1[n1]] && void 0 !== this[e1[n1]] && null !== this[e1[n1]]) return e1[n1];\n                };\n            }, r1.oneOfSetter = function(e1) {\n                return function(t1) {\n                    for(var n1 = 0; n1 < e1.length; ++n1)e1[n1] !== t1 && delete this[e1[n1]];\n                };\n            }, r1.toJSONOptions = {\n                longs: String,\n                enums: String,\n                bytes: String,\n                json: !0\n            }, r1._configure = function() {\n                var e1 = r1.Buffer;\n                e1 ? (r1._Buffer_from = e1.from !== Uint8Array.from && e1.from || function(t1, n1) {\n                    return new e1(t1, n1);\n                }, r1._Buffer_allocUnsafe = e1.allocUnsafe || function(t1) {\n                    return new e1(t1);\n                }) : r1._Buffer_from = r1._Buffer_allocUnsafe = null;\n            };\n        },\n        1173: (e1, t1, n1)=>{\n            \"use strict\";\n            e1.exports = p1;\n            var r1, o1 = n1(9693), i1 = o1.LongBits, s1 = o1.base64, a1 = o1.utf8;\n            function u1(e1, t1, n1) {\n                this.fn = e1, this.len = t1, this.next = void 0, this.val = n1;\n            }\n            function l1() {}\n            function c1(e1) {\n                this.head = e1.head, this.tail = e1.tail, this.len = e1.len, this.next = e1.states;\n            }\n            function p1() {\n                this.len = 0, this.head = new u1(l1, 0, 0), this.tail = this.head, this.states = null;\n            }\n            var d1 = function() {\n                return o1.Buffer ? function() {\n                    return (p1.create = function() {\n                        return new r1;\n                    })();\n                } : function() {\n                    return new p1;\n                };\n            };\n            function f1(e1, t1, n1) {\n                t1[n1] = 255 & e1;\n            }\n            function h1(e1, t1) {\n                this.len = e1, this.next = void 0, this.val = t1;\n            }\n            function g1(e1, t1, n1) {\n                for(; e1.hi;)t1[n1++] = 127 & e1.lo | 128, e1.lo = (e1.lo >>> 7 | e1.hi << 25) >>> 0, e1.hi >>>= 7;\n                for(; e1.lo > 127;)t1[n1++] = 127 & e1.lo | 128, e1.lo = e1.lo >>> 7;\n                t1[n1++] = e1.lo;\n            }\n            function b1(e1, t1, n1) {\n                t1[n1] = 255 & e1, t1[n1 + 1] = e1 >>> 8 & 255, t1[n1 + 2] = e1 >>> 16 & 255, t1[n1 + 3] = e1 >>> 24;\n            }\n            p1.create = d1(), p1.alloc = function(e1) {\n                return new o1.Array(e1);\n            }, o1.Array !== Array && (p1.alloc = o1.pool(p1.alloc, o1.Array.prototype.subarray)), p1.prototype._push = function(e1, t1, n1) {\n                return this.tail = this.tail.next = new u1(e1, t1, n1), this.len += t1, this;\n            }, h1.prototype = Object.create(u1.prototype), h1.prototype.fn = function(e1, t1, n1) {\n                for(; e1 > 127;)t1[n1++] = 127 & e1 | 128, e1 >>>= 7;\n                t1[n1] = e1;\n            }, p1.prototype.uint32 = function(e1) {\n                return this.len += (this.tail = this.tail.next = new h1((e1 >>>= 0) < 128 ? 1 : e1 < 16384 ? 2 : e1 < 2097152 ? 3 : e1 < 268435456 ? 4 : 5, e1)).len, this;\n            }, p1.prototype.int32 = function(e1) {\n                return e1 < 0 ? this._push(g1, 10, i1.fromNumber(e1)) : this.uint32(e1);\n            }, p1.prototype.sint32 = function(e1) {\n                return this.uint32((e1 << 1 ^ e1 >> 31) >>> 0);\n            }, p1.prototype.uint64 = function(e1) {\n                var t1 = i1.from(e1);\n                return this._push(g1, t1.length(), t1);\n            }, p1.prototype.int64 = p1.prototype.uint64, p1.prototype.sint64 = function(e1) {\n                var t1 = i1.from(e1).zzEncode();\n                return this._push(g1, t1.length(), t1);\n            }, p1.prototype.bool = function(e1) {\n                return this._push(f1, 1, e1 ? 1 : 0);\n            }, p1.prototype.fixed32 = function(e1) {\n                return this._push(b1, 4, e1 >>> 0);\n            }, p1.prototype.sfixed32 = p1.prototype.fixed32, p1.prototype.fixed64 = function(e1) {\n                var t1 = i1.from(e1);\n                return this._push(b1, 4, t1.lo)._push(b1, 4, t1.hi);\n            }, p1.prototype.sfixed64 = p1.prototype.fixed64, p1.prototype.float = function(e1) {\n                return this._push(o1.float.writeFloatLE, 4, e1);\n            }, p1.prototype.double = function(e1) {\n                return this._push(o1.float.writeDoubleLE, 8, e1);\n            };\n            var m1 = o1.Array.prototype.set ? function(e1, t1, n1) {\n                t1.set(e1, n1);\n            } : function(e1, t1, n1) {\n                for(var r1 = 0; r1 < e1.length; ++r1)t1[n1 + r1] = e1[r1];\n            };\n            p1.prototype.bytes = function(e1) {\n                var t1 = e1.length >>> 0;\n                if (!t1) return this._push(f1, 1, 0);\n                if (o1.isString(e1)) {\n                    var n1 = p1.alloc(t1 = s1.length(e1));\n                    s1.decode(e1, n1, 0), e1 = n1;\n                }\n                return this.uint32(t1)._push(m1, t1, e1);\n            }, p1.prototype.string = function(e1) {\n                var t1 = a1.length(e1);\n                return t1 ? this.uint32(t1)._push(a1.write, t1, e1) : this._push(f1, 1, 0);\n            }, p1.prototype.fork = function() {\n                return this.states = new c1(this), this.head = this.tail = new u1(l1, 0, 0), this.len = 0, this;\n            }, p1.prototype.reset = function() {\n                return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u1(l1, 0, 0), this.len = 0), this;\n            }, p1.prototype.ldelim = function() {\n                var e1 = this.head, t1 = this.tail, n1 = this.len;\n                return this.reset().uint32(n1), n1 && (this.tail.next = e1.next, this.tail = t1, this.len += n1), this;\n            }, p1.prototype.finish = function() {\n                for(var e1 = this.head.next, t1 = this.constructor.alloc(this.len), n1 = 0; e1;)e1.fn(e1.val, t1, n1), n1 += e1.len, e1 = e1.next;\n                return t1;\n            }, p1._configure = function(e1) {\n                r1 = e1, p1.create = d1(), r1._configure();\n            };\n        },\n        3155: (e1, t1, n1)=>{\n            \"use strict\";\n            e1.exports = i1;\n            var r1 = n1(1173);\n            (i1.prototype = Object.create(r1.prototype)).constructor = i1;\n            var o1 = n1(9693);\n            function i1() {\n                r1.call(this);\n            }\n            function s1(e1, t1, n1) {\n                e1.length < 40 ? o1.utf8.write(e1, t1, n1) : t1.utf8Write ? t1.utf8Write(e1, n1) : t1.write(e1, n1);\n            }\n            i1._configure = function() {\n                i1.alloc = o1._Buffer_allocUnsafe, i1.writeBytesBuffer = o1.Buffer && o1.Buffer.prototype instanceof Uint8Array && \"set\" === o1.Buffer.prototype.set.name ? function(e1, t1, n1) {\n                    t1.set(e1, n1);\n                } : function(e1, t1, n1) {\n                    if (e1.copy) e1.copy(t1, n1, 0, e1.length);\n                    else for(var r1 = 0; r1 < e1.length;)t1[n1++] = e1[r1++];\n                };\n            }, i1.prototype.bytes = function(e1) {\n                o1.isString(e1) && (e1 = o1._Buffer_from(e1, \"base64\"));\n                var t1 = e1.length >>> 0;\n                return this.uint32(t1), t1 && this._push(i1.writeBytesBuffer, t1, e1), this;\n            }, i1.prototype.string = function(e1) {\n                var t1 = o1.Buffer.byteLength(e1);\n                return this.uint32(t1), t1 && this._push(s1, t1, e1), this;\n            }, i1._configure();\n        },\n        4154: (e1)=>{\n            \"use strict\";\n            e1.exports = '\"use strict\";var e={},a=\"object\"==typeof process&&\"object\"==typeof process.versions&&\"string\"==typeof process.versions.node;if(a){var r=require(\"worker_threads\"),t=r.parentPort;t.on(\"message\",(e=>onmessage({data:e})));var s=require(\"fs\");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:e=>(0,eval)(s.readFileSync(e,\"utf8\")+\"//# sourceURL=\"+e),postMessage:e=>t.postMessage(e),performance:global.performance||{now:Date.now}})}var o=!1,d=function(){var e=Array.prototype.slice.call(arguments).join(\" \");a?s.writeSync(2,e+\"\\\\n\"):console.error(e)};self.alert=function(){var a=Array.prototype.slice.call(arguments).join(\" \");postMessage({cmd:\"alert\",text:a,threadId:e._pthread_self()})},e.instantiateWasm=(a,r)=>{var t=e.wasmModule;return e.wasmModule=null,r(new WebAssembly.Instance(t,a))},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=function a(r){try{if(\"load\"===r.data.cmd){let s=[];self.onmessage=e=>s.push(e),self.startWorker=r=>{e=r,postMessage({cmd:\"loaded\"});for(let e of s)a(e);self.onmessage=a},e.wasmModule=r.data.wasmModule;for(const a of r.data.handlers)e[a]=(...e)=>{postMessage({cmd:\"callHandler\",handler:a,args:e})};if(e.wasmMemory=r.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,\"string\"==typeof r.data.urlOrBlob)importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(e)}else if(\"run\"===r.data.cmd){e.__emscripten_thread_init(r.data.pthread_ptr,0,0,1),e.__emscripten_thread_mailbox_await(r.data.pthread_ptr),e.establishStackSpace(),e.PThread.receiveObjectTransfer(r.data),e.PThread.threadInitTLS(),o||(o=!0);try{e.invokeEntryPoint(r.data.start_routine,r.data.arg)}catch(e){if(\"unwind\"!=e)throw e}}else\"cancel\"===r.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):\"setimmediate\"===r.data.target||(\"checkMailbox\"===r.data.cmd?o&&e.checkMailbox():r.data.cmd&&(d(\"worker.js received unknown command \"+r.data.cmd),d(r.data)))}catch(a){throw e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),a}};\\n';\n        },\n        6231: (e1)=>{\n            \"use strict\";\n            e1.exports = __webpack_require__(/*! fs */ \"fs\");\n        },\n        9719: (e1)=>{\n            \"use strict\";\n            e1.exports = __webpack_require__(/*! os */ \"os\");\n        },\n        1423: (e1)=>{\n            \"use strict\";\n            e1.exports = __webpack_require__(/*! path */ \"path\");\n        },\n        498: (e1)=>{\n            \"use strict\";\n            e1.exports = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\n        },\n        6464: (e1)=>{\n            \"use strict\";\n            e1.exports = __webpack_require__(/*! util */ \"util\");\n        },\n        4564: (e1)=>{\n            \"use strict\";\n            e1.exports = __webpack_require__(/*! worker_threads */ \"worker_threads\");\n        },\n        6207: (e1)=>{\n            \"use strict\";\n            e1.exports = __webpack_require__(/*! onnxruntime-common */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/index.js\");\n        },\n        6113: (e1)=>{\n            \"use strict\";\n            e1.exports = __webpack_require__(/*! crypto */ \"crypto\");\n        },\n        1583: (e1, t1)=>{\n            var n1, r1 = function(e1) {\n                \"use strict\";\n                Object.defineProperty(e1, \"__esModule\", {\n                    value: !0\n                }), e1.default = void 0;\n                var t1 = null;\n                try {\n                    t1 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n                        0,\n                        97,\n                        115,\n                        109,\n                        1,\n                        0,\n                        0,\n                        0,\n                        1,\n                        13,\n                        2,\n                        96,\n                        0,\n                        1,\n                        127,\n                        96,\n                        4,\n                        127,\n                        127,\n                        127,\n                        127,\n                        1,\n                        127,\n                        3,\n                        7,\n                        6,\n                        0,\n                        1,\n                        1,\n                        1,\n                        1,\n                        1,\n                        6,\n                        6,\n                        1,\n                        127,\n                        1,\n                        65,\n                        0,\n                        11,\n                        7,\n                        50,\n                        6,\n                        3,\n                        109,\n                        117,\n                        108,\n                        0,\n                        1,\n                        5,\n                        100,\n                        105,\n                        118,\n                        95,\n                        115,\n                        0,\n                        2,\n                        5,\n                        100,\n                        105,\n                        118,\n                        95,\n                        117,\n                        0,\n                        3,\n                        5,\n                        114,\n                        101,\n                        109,\n                        95,\n                        115,\n                        0,\n                        4,\n                        5,\n                        114,\n                        101,\n                        109,\n                        95,\n                        117,\n                        0,\n                        5,\n                        8,\n                        103,\n                        101,\n                        116,\n                        95,\n                        104,\n                        105,\n                        103,\n                        104,\n                        0,\n                        0,\n                        10,\n                        191,\n                        1,\n                        6,\n                        4,\n                        0,\n                        35,\n                        0,\n                        11,\n                        36,\n                        1,\n                        1,\n                        126,\n                        32,\n                        0,\n                        173,\n                        32,\n                        1,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        32,\n                        2,\n                        173,\n                        32,\n                        3,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        126,\n                        34,\n                        4,\n                        66,\n                        32,\n                        135,\n                        167,\n                        36,\n                        0,\n                        32,\n                        4,\n                        167,\n                        11,\n                        36,\n                        1,\n                        1,\n                        126,\n                        32,\n                        0,\n                        173,\n                        32,\n                        1,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        32,\n                        2,\n                        173,\n                        32,\n                        3,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        127,\n                        34,\n                        4,\n                        66,\n                        32,\n                        135,\n                        167,\n                        36,\n                        0,\n                        32,\n                        4,\n                        167,\n                        11,\n                        36,\n                        1,\n                        1,\n                        126,\n                        32,\n                        0,\n                        173,\n                        32,\n                        1,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        32,\n                        2,\n                        173,\n                        32,\n                        3,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        128,\n                        34,\n                        4,\n                        66,\n                        32,\n                        135,\n                        167,\n                        36,\n                        0,\n                        32,\n                        4,\n                        167,\n                        11,\n                        36,\n                        1,\n                        1,\n                        126,\n                        32,\n                        0,\n                        173,\n                        32,\n                        1,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        32,\n                        2,\n                        173,\n                        32,\n                        3,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        129,\n                        34,\n                        4,\n                        66,\n                        32,\n                        135,\n                        167,\n                        36,\n                        0,\n                        32,\n                        4,\n                        167,\n                        11,\n                        36,\n                        1,\n                        1,\n                        126,\n                        32,\n                        0,\n                        173,\n                        32,\n                        1,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        32,\n                        2,\n                        173,\n                        32,\n                        3,\n                        173,\n                        66,\n                        32,\n                        134,\n                        132,\n                        130,\n                        34,\n                        4,\n                        66,\n                        32,\n                        135,\n                        167,\n                        36,\n                        0,\n                        32,\n                        4,\n                        167,\n                        11\n                    ])), {}).exports;\n                } catch (e1) {}\n                function n1(e1, t1, n1) {\n                    this.low = 0 | e1, this.high = 0 | t1, this.unsigned = !!n1;\n                }\n                function r1(e1) {\n                    return !0 === (e1 && e1.__isLong__);\n                }\n                function o1(e1) {\n                    var t1 = Math.clz32(e1 & -e1);\n                    return e1 ? 31 - t1 : t1;\n                }\n                n1.prototype.__isLong__, Object.defineProperty(n1.prototype, \"__isLong__\", {\n                    value: !0\n                }), n1.isLong = r1;\n                var i1 = {}, s1 = {};\n                function a1(e1, t1) {\n                    var n1, r1, o1;\n                    return t1 ? (o1 = 0 <= (e1 >>>= 0) && e1 < 256) && (r1 = s1[e1]) ? r1 : (n1 = l1(e1, 0, !0), o1 && (s1[e1] = n1), n1) : (o1 = -128 <= (e1 |= 0) && e1 < 128) && (r1 = i1[e1]) ? r1 : (n1 = l1(e1, e1 < 0 ? -1 : 0, !1), o1 && (i1[e1] = n1), n1);\n                }\n                function u1(e1, t1) {\n                    if (isNaN(e1)) return t1 ? y1 : m1;\n                    if (t1) {\n                        if (e1 < 0) return y1;\n                        if (e1 >= h1) return w1;\n                    } else {\n                        if (e1 <= -g1) return O1;\n                        if (e1 + 1 >= g1) return x1;\n                    }\n                    return e1 < 0 ? u1(-e1, t1).neg() : l1(e1 % f1 | 0, e1 / f1 | 0, t1);\n                }\n                function l1(e1, t1, r1) {\n                    return new n1(e1, t1, r1);\n                }\n                n1.fromInt = a1, n1.fromNumber = u1, n1.fromBits = l1;\n                var c1 = Math.pow;\n                function p1(e1, t1, n1) {\n                    if (0 === e1.length) throw Error(\"empty string\");\n                    if (\"number\" == typeof t1 ? (n1 = t1, t1 = !1) : t1 = !!t1, \"NaN\" === e1 || \"Infinity\" === e1 || \"+Infinity\" === e1 || \"-Infinity\" === e1) return t1 ? y1 : m1;\n                    if ((n1 = n1 || 10) < 2 || 36 < n1) throw RangeError(\"radix\");\n                    var r1;\n                    if ((r1 = e1.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n                    if (0 === r1) return p1(e1.substring(1), t1, n1).neg();\n                    for(var o1 = u1(c1(n1, 8)), i1 = m1, s1 = 0; s1 < e1.length; s1 += 8){\n                        var a1 = Math.min(8, e1.length - s1), l1 = parseInt(e1.substring(s1, s1 + a1), n1);\n                        if (a1 < 8) {\n                            var d1 = u1(c1(n1, a1));\n                            i1 = i1.mul(d1).add(u1(l1));\n                        } else i1 = (i1 = i1.mul(o1)).add(u1(l1));\n                    }\n                    return i1.unsigned = t1, i1;\n                }\n                function d1(e1, t1) {\n                    return \"number\" == typeof e1 ? u1(e1, t1) : \"string\" == typeof e1 ? p1(e1, t1) : l1(e1.low, e1.high, \"boolean\" == typeof t1 ? t1 : e1.unsigned);\n                }\n                n1.fromString = p1, n1.fromValue = d1;\n                var f1 = 4294967296, h1 = f1 * f1, g1 = h1 / 2, b1 = a1(1 << 24), m1 = a1(0);\n                n1.ZERO = m1;\n                var y1 = a1(0, !0);\n                n1.UZERO = y1;\n                var _1 = a1(1);\n                n1.ONE = _1;\n                var v1 = a1(1, !0);\n                n1.UONE = v1;\n                var T1 = a1(-1);\n                n1.NEG_ONE = T1;\n                var x1 = l1(-1, 2147483647, !1);\n                n1.MAX_VALUE = x1;\n                var w1 = l1(-1, -1, !0);\n                n1.MAX_UNSIGNED_VALUE = w1;\n                var O1 = l1(0, -2147483648, !1);\n                n1.MIN_VALUE = O1;\n                var S1 = n1.prototype;\n                S1.toInt = function() {\n                    return this.unsigned ? this.low >>> 0 : this.low;\n                }, S1.toNumber = function() {\n                    return this.unsigned ? (this.high >>> 0) * f1 + (this.low >>> 0) : this.high * f1 + (this.low >>> 0);\n                }, S1.toString = function(e1) {\n                    if ((e1 = e1 || 10) < 2 || 36 < e1) throw RangeError(\"radix\");\n                    if (this.isZero()) return \"0\";\n                    if (this.isNegative()) {\n                        if (this.eq(O1)) {\n                            var t1 = u1(e1), n1 = this.div(t1), r1 = n1.mul(t1).sub(this);\n                            return n1.toString(e1) + r1.toInt().toString(e1);\n                        }\n                        return \"-\" + this.neg().toString(e1);\n                    }\n                    for(var o1 = u1(c1(e1, 6), this.unsigned), i1 = this, s1 = \"\";;){\n                        var a1 = i1.div(o1), l1 = (i1.sub(a1.mul(o1)).toInt() >>> 0).toString(e1);\n                        if ((i1 = a1).isZero()) return l1 + s1;\n                        for(; l1.length < 6;)l1 = \"0\" + l1;\n                        s1 = \"\" + l1 + s1;\n                    }\n                }, S1.getHighBits = function() {\n                    return this.high;\n                }, S1.getHighBitsUnsigned = function() {\n                    return this.high >>> 0;\n                }, S1.getLowBits = function() {\n                    return this.low;\n                }, S1.getLowBitsUnsigned = function() {\n                    return this.low >>> 0;\n                }, S1.getNumBitsAbs = function() {\n                    if (this.isNegative()) return this.eq(O1) ? 64 : this.neg().getNumBitsAbs();\n                    for(var e1 = 0 != this.high ? this.high : this.low, t1 = 31; t1 > 0 && 0 == (e1 & 1 << t1); t1--);\n                    return 0 != this.high ? t1 + 33 : t1 + 1;\n                }, S1.isZero = function() {\n                    return 0 === this.high && 0 === this.low;\n                }, S1.eqz = S1.isZero, S1.isNegative = function() {\n                    return !this.unsigned && this.high < 0;\n                }, S1.isPositive = function() {\n                    return this.unsigned || this.high >= 0;\n                }, S1.isOdd = function() {\n                    return 1 == (1 & this.low);\n                }, S1.isEven = function() {\n                    return 0 == (1 & this.low);\n                }, S1.equals = function(e1) {\n                    return r1(e1) || (e1 = d1(e1)), (this.unsigned === e1.unsigned || this.high >>> 31 != 1 || e1.high >>> 31 != 1) && this.high === e1.high && this.low === e1.low;\n                }, S1.eq = S1.equals, S1.notEquals = function(e1) {\n                    return !this.eq(e1);\n                }, S1.neq = S1.notEquals, S1.ne = S1.notEquals, S1.lessThan = function(e1) {\n                    return this.comp(e1) < 0;\n                }, S1.lt = S1.lessThan, S1.lessThanOrEqual = function(e1) {\n                    return this.comp(e1) <= 0;\n                }, S1.lte = S1.lessThanOrEqual, S1.le = S1.lessThanOrEqual, S1.greaterThan = function(e1) {\n                    return this.comp(e1) > 0;\n                }, S1.gt = S1.greaterThan, S1.greaterThanOrEqual = function(e1) {\n                    return this.comp(e1) >= 0;\n                }, S1.gte = S1.greaterThanOrEqual, S1.ge = S1.greaterThanOrEqual, S1.compare = function(e1) {\n                    if (r1(e1) || (e1 = d1(e1)), this.eq(e1)) return 0;\n                    var t1 = this.isNegative(), n1 = e1.isNegative();\n                    return t1 && !n1 ? -1 : !t1 && n1 ? 1 : this.unsigned ? e1.high >>> 0 > this.high >>> 0 || e1.high === this.high && e1.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e1).isNegative() ? -1 : 1;\n                }, S1.comp = S1.compare, S1.negate = function() {\n                    return !this.unsigned && this.eq(O1) ? O1 : this.not().add(_1);\n                }, S1.neg = S1.negate, S1.add = function(e1) {\n                    r1(e1) || (e1 = d1(e1));\n                    var t1 = this.high >>> 16, n1 = 65535 & this.high, o1 = this.low >>> 16, i1 = 65535 & this.low, s1 = e1.high >>> 16, a1 = 65535 & e1.high, u1 = e1.low >>> 16, c1 = 0, p1 = 0, f1 = 0, h1 = 0;\n                    return f1 += (h1 += i1 + (65535 & e1.low)) >>> 16, p1 += (f1 += o1 + u1) >>> 16, c1 += (p1 += n1 + a1) >>> 16, c1 += t1 + s1, l1((f1 &= 65535) << 16 | (h1 &= 65535), (c1 &= 65535) << 16 | (p1 &= 65535), this.unsigned);\n                }, S1.subtract = function(e1) {\n                    return r1(e1) || (e1 = d1(e1)), this.add(e1.neg());\n                }, S1.sub = S1.subtract, S1.multiply = function(e1) {\n                    if (this.isZero()) return this;\n                    if (r1(e1) || (e1 = d1(e1)), t1) return l1(t1.mul(this.low, this.high, e1.low, e1.high), t1.get_high(), this.unsigned);\n                    if (e1.isZero()) return this.unsigned ? y1 : m1;\n                    if (this.eq(O1)) return e1.isOdd() ? O1 : m1;\n                    if (e1.eq(O1)) return this.isOdd() ? O1 : m1;\n                    if (this.isNegative()) return e1.isNegative() ? this.neg().mul(e1.neg()) : this.neg().mul(e1).neg();\n                    if (e1.isNegative()) return this.mul(e1.neg()).neg();\n                    if (this.lt(b1) && e1.lt(b1)) return u1(this.toNumber() * e1.toNumber(), this.unsigned);\n                    var n1 = this.high >>> 16, o1 = 65535 & this.high, i1 = this.low >>> 16, s1 = 65535 & this.low, a1 = e1.high >>> 16, c1 = 65535 & e1.high, p1 = e1.low >>> 16, f1 = 65535 & e1.low, h1 = 0, g1 = 0, _1 = 0, v1 = 0;\n                    return _1 += (v1 += s1 * f1) >>> 16, g1 += (_1 += i1 * f1) >>> 16, _1 &= 65535, g1 += (_1 += s1 * p1) >>> 16, h1 += (g1 += o1 * f1) >>> 16, g1 &= 65535, h1 += (g1 += i1 * p1) >>> 16, g1 &= 65535, h1 += (g1 += s1 * c1) >>> 16, h1 += n1 * f1 + o1 * p1 + i1 * c1 + s1 * a1, l1((_1 &= 65535) << 16 | (v1 &= 65535), (h1 &= 65535) << 16 | (g1 &= 65535), this.unsigned);\n                }, S1.mul = S1.multiply, S1.divide = function(e1) {\n                    if (r1(e1) || (e1 = d1(e1)), e1.isZero()) throw Error(\"division by zero\");\n                    var n1, o1, i1;\n                    if (t1) return this.unsigned || -2147483648 !== this.high || -1 !== e1.low || -1 !== e1.high ? l1((this.unsigned ? t1.div_u : t1.div_s)(this.low, this.high, e1.low, e1.high), t1.get_high(), this.unsigned) : this;\n                    if (this.isZero()) return this.unsigned ? y1 : m1;\n                    if (this.unsigned) {\n                        if (e1.unsigned || (e1 = e1.toUnsigned()), e1.gt(this)) return y1;\n                        if (e1.gt(this.shru(1))) return v1;\n                        i1 = y1;\n                    } else {\n                        if (this.eq(O1)) return e1.eq(_1) || e1.eq(T1) ? O1 : e1.eq(O1) ? _1 : (n1 = this.shr(1).div(e1).shl(1)).eq(m1) ? e1.isNegative() ? _1 : T1 : (o1 = this.sub(e1.mul(n1)), i1 = n1.add(o1.div(e1)));\n                        if (e1.eq(O1)) return this.unsigned ? y1 : m1;\n                        if (this.isNegative()) return e1.isNegative() ? this.neg().div(e1.neg()) : this.neg().div(e1).neg();\n                        if (e1.isNegative()) return this.div(e1.neg()).neg();\n                        i1 = m1;\n                    }\n                    for(o1 = this; o1.gte(e1);){\n                        n1 = Math.max(1, Math.floor(o1.toNumber() / e1.toNumber()));\n                        for(var s1 = Math.ceil(Math.log(n1) / Math.LN2), a1 = s1 <= 48 ? 1 : c1(2, s1 - 48), p1 = u1(n1), f1 = p1.mul(e1); f1.isNegative() || f1.gt(o1);)f1 = (p1 = u1(n1 -= a1, this.unsigned)).mul(e1);\n                        p1.isZero() && (p1 = _1), i1 = i1.add(p1), o1 = o1.sub(f1);\n                    }\n                    return i1;\n                }, S1.div = S1.divide, S1.modulo = function(e1) {\n                    return r1(e1) || (e1 = d1(e1)), t1 ? l1((this.unsigned ? t1.rem_u : t1.rem_s)(this.low, this.high, e1.low, e1.high), t1.get_high(), this.unsigned) : this.sub(this.div(e1).mul(e1));\n                }, S1.mod = S1.modulo, S1.rem = S1.modulo, S1.not = function() {\n                    return l1(~this.low, ~this.high, this.unsigned);\n                }, S1.countLeadingZeros = function() {\n                    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n                }, S1.clz = S1.countLeadingZeros, S1.countTrailingZeros = function() {\n                    return this.low ? o1(this.low) : o1(this.high) + 32;\n                }, S1.ctz = S1.countTrailingZeros, S1.and = function(e1) {\n                    return r1(e1) || (e1 = d1(e1)), l1(this.low & e1.low, this.high & e1.high, this.unsigned);\n                }, S1.or = function(e1) {\n                    return r1(e1) || (e1 = d1(e1)), l1(this.low | e1.low, this.high | e1.high, this.unsigned);\n                }, S1.xor = function(e1) {\n                    return r1(e1) || (e1 = d1(e1)), l1(this.low ^ e1.low, this.high ^ e1.high, this.unsigned);\n                }, S1.shiftLeft = function(e1) {\n                    return r1(e1) && (e1 = e1.toInt()), 0 == (e1 &= 63) ? this : e1 < 32 ? l1(this.low << e1, this.high << e1 | this.low >>> 32 - e1, this.unsigned) : l1(0, this.low << e1 - 32, this.unsigned);\n                }, S1.shl = S1.shiftLeft, S1.shiftRight = function(e1) {\n                    return r1(e1) && (e1 = e1.toInt()), 0 == (e1 &= 63) ? this : e1 < 32 ? l1(this.low >>> e1 | this.high << 32 - e1, this.high >> e1, this.unsigned) : l1(this.high >> e1 - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n                }, S1.shr = S1.shiftRight, S1.shiftRightUnsigned = function(e1) {\n                    return r1(e1) && (e1 = e1.toInt()), 0 == (e1 &= 63) ? this : e1 < 32 ? l1(this.low >>> e1 | this.high << 32 - e1, this.high >>> e1, this.unsigned) : l1(32 === e1 ? this.high : this.high >>> e1 - 32, 0, this.unsigned);\n                }, S1.shru = S1.shiftRightUnsigned, S1.shr_u = S1.shiftRightUnsigned, S1.rotateLeft = function(e1) {\n                    var t1;\n                    return r1(e1) && (e1 = e1.toInt()), 0 == (e1 &= 63) ? this : 32 === e1 ? l1(this.high, this.low, this.unsigned) : e1 < 32 ? (t1 = 32 - e1, l1(this.low << e1 | this.high >>> t1, this.high << e1 | this.low >>> t1, this.unsigned)) : (t1 = 32 - (e1 -= 32), l1(this.high << e1 | this.low >>> t1, this.low << e1 | this.high >>> t1, this.unsigned));\n                }, S1.rotl = S1.rotateLeft, S1.rotateRight = function(e1) {\n                    var t1;\n                    return r1(e1) && (e1 = e1.toInt()), 0 == (e1 &= 63) ? this : 32 === e1 ? l1(this.high, this.low, this.unsigned) : e1 < 32 ? (t1 = 32 - e1, l1(this.high << t1 | this.low >>> e1, this.low << t1 | this.high >>> e1, this.unsigned)) : (t1 = 32 - (e1 -= 32), l1(this.low << t1 | this.high >>> e1, this.high << t1 | this.low >>> e1, this.unsigned));\n                }, S1.rotr = S1.rotateRight, S1.toSigned = function() {\n                    return this.unsigned ? l1(this.low, this.high, !1) : this;\n                }, S1.toUnsigned = function() {\n                    return this.unsigned ? this : l1(this.low, this.high, !0);\n                }, S1.toBytes = function(e1) {\n                    return e1 ? this.toBytesLE() : this.toBytesBE();\n                }, S1.toBytesLE = function() {\n                    var e1 = this.high, t1 = this.low;\n                    return [\n                        255 & t1,\n                        t1 >>> 8 & 255,\n                        t1 >>> 16 & 255,\n                        t1 >>> 24,\n                        255 & e1,\n                        e1 >>> 8 & 255,\n                        e1 >>> 16 & 255,\n                        e1 >>> 24\n                    ];\n                }, S1.toBytesBE = function() {\n                    var e1 = this.high, t1 = this.low;\n                    return [\n                        e1 >>> 24,\n                        e1 >>> 16 & 255,\n                        e1 >>> 8 & 255,\n                        255 & e1,\n                        t1 >>> 24,\n                        t1 >>> 16 & 255,\n                        t1 >>> 8 & 255,\n                        255 & t1\n                    ];\n                }, n1.fromBytes = function(e1, t1, r1) {\n                    return r1 ? n1.fromBytesLE(e1, t1) : n1.fromBytesBE(e1, t1);\n                }, n1.fromBytesLE = function(e1, t1) {\n                    return new n1(e1[0] | e1[1] << 8 | e1[2] << 16 | e1[3] << 24, e1[4] | e1[5] << 8 | e1[6] << 16 | e1[7] << 24, t1);\n                }, n1.fromBytesBE = function(e1, t1) {\n                    return new n1(e1[4] << 24 | e1[5] << 16 | e1[6] << 8 | e1[7], e1[0] << 24 | e1[1] << 16 | e1[2] << 8 | e1[3], t1);\n                };\n                var A1 = n1;\n                return e1.default = A1, \"default\" in e1 ? e1.default : e1;\n            }({});\n            void 0 === (n1 = (function() {\n                return r1;\n            }).apply(t1, [])) || (e1.exports = n1);\n        },\n        5686: (e1, t1, n1)=>{\n            \"use strict\";\n            n1.r(t1), n1.d(t1, {\n                flatbuffers: ()=>r1\n            });\n            var r1 = {};\n            r1.Offset, r1.Table, r1.SIZEOF_SHORT = 2, r1.SIZEOF_INT = 4, r1.FILE_IDENTIFIER_LENGTH = 4, r1.SIZE_PREFIX_LENGTH = 4, r1.Encoding = {\n                UTF8_BYTES: 1,\n                UTF16_STRING: 2\n            }, r1.int32 = new Int32Array(2), r1.float32 = new Float32Array(r1.int32.buffer), r1.float64 = new Float64Array(r1.int32.buffer), r1.isLittleEndian = 1 === new Uint16Array(new Uint8Array([\n                1,\n                0\n            ]).buffer)[0], r1.Long = function(e1, t1) {\n                this.low = 0 | e1, this.high = 0 | t1;\n            }, r1.Long.create = function(e1, t1) {\n                return 0 == e1 && 0 == t1 ? r1.Long.ZERO : new r1.Long(e1, t1);\n            }, r1.Long.prototype.toFloat64 = function() {\n                return (this.low >>> 0) + 4294967296 * this.high;\n            }, r1.Long.prototype.equals = function(e1) {\n                return this.low == e1.low && this.high == e1.high;\n            }, r1.Long.ZERO = new r1.Long(0, 0), r1.Builder = function(e1) {\n                if (e1) t1 = e1;\n                else var t1 = 1024;\n                this.bb = r1.ByteBuffer.allocate(t1), this.space = t1, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n            }, r1.Builder.prototype.clear = function() {\n                this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1;\n            }, r1.Builder.prototype.forceDefaults = function(e1) {\n                this.force_defaults = e1;\n            }, r1.Builder.prototype.dataBuffer = function() {\n                return this.bb;\n            }, r1.Builder.prototype.asUint8Array = function() {\n                return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\n            }, r1.Builder.prototype.prep = function(e1, t1) {\n                e1 > this.minalign && (this.minalign = e1);\n                for(var n1 = 1 + ~(this.bb.capacity() - this.space + t1) & e1 - 1; this.space < n1 + e1 + t1;){\n                    var o1 = this.bb.capacity();\n                    this.bb = r1.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - o1;\n                }\n                this.pad(n1);\n            }, r1.Builder.prototype.pad = function(e1) {\n                for(var t1 = 0; t1 < e1; t1++)this.bb.writeInt8(--this.space, 0);\n            }, r1.Builder.prototype.writeInt8 = function(e1) {\n                this.bb.writeInt8(this.space -= 1, e1);\n            }, r1.Builder.prototype.writeInt16 = function(e1) {\n                this.bb.writeInt16(this.space -= 2, e1);\n            }, r1.Builder.prototype.writeInt32 = function(e1) {\n                this.bb.writeInt32(this.space -= 4, e1);\n            }, r1.Builder.prototype.writeInt64 = function(e1) {\n                this.bb.writeInt64(this.space -= 8, e1);\n            }, r1.Builder.prototype.writeFloat32 = function(e1) {\n                this.bb.writeFloat32(this.space -= 4, e1);\n            }, r1.Builder.prototype.writeFloat64 = function(e1) {\n                this.bb.writeFloat64(this.space -= 8, e1);\n            }, r1.Builder.prototype.addInt8 = function(e1) {\n                this.prep(1, 0), this.writeInt8(e1);\n            }, r1.Builder.prototype.addInt16 = function(e1) {\n                this.prep(2, 0), this.writeInt16(e1);\n            }, r1.Builder.prototype.addInt32 = function(e1) {\n                this.prep(4, 0), this.writeInt32(e1);\n            }, r1.Builder.prototype.addInt64 = function(e1) {\n                this.prep(8, 0), this.writeInt64(e1);\n            }, r1.Builder.prototype.addFloat32 = function(e1) {\n                this.prep(4, 0), this.writeFloat32(e1);\n            }, r1.Builder.prototype.addFloat64 = function(e1) {\n                this.prep(8, 0), this.writeFloat64(e1);\n            }, r1.Builder.prototype.addFieldInt8 = function(e1, t1, n1) {\n                (this.force_defaults || t1 != n1) && (this.addInt8(t1), this.slot(e1));\n            }, r1.Builder.prototype.addFieldInt16 = function(e1, t1, n1) {\n                (this.force_defaults || t1 != n1) && (this.addInt16(t1), this.slot(e1));\n            }, r1.Builder.prototype.addFieldInt32 = function(e1, t1, n1) {\n                (this.force_defaults || t1 != n1) && (this.addInt32(t1), this.slot(e1));\n            }, r1.Builder.prototype.addFieldInt64 = function(e1, t1, n1) {\n                !this.force_defaults && t1.equals(n1) || (this.addInt64(t1), this.slot(e1));\n            }, r1.Builder.prototype.addFieldFloat32 = function(e1, t1, n1) {\n                (this.force_defaults || t1 != n1) && (this.addFloat32(t1), this.slot(e1));\n            }, r1.Builder.prototype.addFieldFloat64 = function(e1, t1, n1) {\n                (this.force_defaults || t1 != n1) && (this.addFloat64(t1), this.slot(e1));\n            }, r1.Builder.prototype.addFieldOffset = function(e1, t1, n1) {\n                (this.force_defaults || t1 != n1) && (this.addOffset(t1), this.slot(e1));\n            }, r1.Builder.prototype.addFieldStruct = function(e1, t1, n1) {\n                t1 != n1 && (this.nested(t1), this.slot(e1));\n            }, r1.Builder.prototype.nested = function(e1) {\n                if (e1 != this.offset()) throw new Error(\"FlatBuffers: struct must be serialized inline.\");\n            }, r1.Builder.prototype.notNested = function() {\n                if (this.isNested) throw new Error(\"FlatBuffers: object serialization must not be nested.\");\n            }, r1.Builder.prototype.slot = function(e1) {\n                this.vtable[e1] = this.offset();\n            }, r1.Builder.prototype.offset = function() {\n                return this.bb.capacity() - this.space;\n            }, r1.Builder.growByteBuffer = function(e1) {\n                var t1 = e1.capacity();\n                if (3221225472 & t1) throw new Error(\"FlatBuffers: cannot grow buffer beyond 2 gigabytes.\");\n                var n1 = t1 << 1, o1 = r1.ByteBuffer.allocate(n1);\n                return o1.setPosition(n1 - t1), o1.bytes().set(e1.bytes(), n1 - t1), o1;\n            }, r1.Builder.prototype.addOffset = function(e1) {\n                this.prep(r1.SIZEOF_INT, 0), this.writeInt32(this.offset() - e1 + r1.SIZEOF_INT);\n            }, r1.Builder.prototype.startObject = function(e1) {\n                this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = e1;\n                for(var t1 = 0; t1 < e1; t1++)this.vtable[t1] = 0;\n                this.isNested = !0, this.object_start = this.offset();\n            }, r1.Builder.prototype.endObject = function() {\n                if (null == this.vtable || !this.isNested) throw new Error(\"FlatBuffers: endObject called without startObject\");\n                this.addInt32(0);\n                for(var e1 = this.offset(), t1 = this.vtable_in_use - 1; t1 >= 0 && 0 == this.vtable[t1]; t1--);\n                for(var n1 = t1 + 1; t1 >= 0; t1--)this.addInt16(0 != this.vtable[t1] ? e1 - this.vtable[t1] : 0);\n                this.addInt16(e1 - this.object_start);\n                var o1 = (n1 + 2) * r1.SIZEOF_SHORT;\n                this.addInt16(o1);\n                var i1 = 0, s1 = this.space;\n                e: for(t1 = 0; t1 < this.vtables.length; t1++){\n                    var a1 = this.bb.capacity() - this.vtables[t1];\n                    if (o1 == this.bb.readInt16(a1)) {\n                        for(var u1 = r1.SIZEOF_SHORT; u1 < o1; u1 += r1.SIZEOF_SHORT)if (this.bb.readInt16(s1 + u1) != this.bb.readInt16(a1 + u1)) continue e;\n                        i1 = this.vtables[t1];\n                        break;\n                    }\n                }\n                return i1 ? (this.space = this.bb.capacity() - e1, this.bb.writeInt32(this.space, i1 - e1)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - e1, this.offset() - e1)), this.isNested = !1, e1;\n            }, r1.Builder.prototype.finish = function(e1, t1, n1) {\n                var o1 = n1 ? r1.SIZE_PREFIX_LENGTH : 0;\n                if (t1) {\n                    var i1 = t1;\n                    if (this.prep(this.minalign, r1.SIZEOF_INT + r1.FILE_IDENTIFIER_LENGTH + o1), i1.length != r1.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + r1.FILE_IDENTIFIER_LENGTH);\n                    for(var s1 = r1.FILE_IDENTIFIER_LENGTH - 1; s1 >= 0; s1--)this.writeInt8(i1.charCodeAt(s1));\n                }\n                this.prep(this.minalign, r1.SIZEOF_INT + o1), this.addOffset(e1), o1 && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);\n            }, r1.Builder.prototype.finishSizePrefixed = function(e1, t1) {\n                this.finish(e1, t1, !0);\n            }, r1.Builder.prototype.requiredField = function(e1, t1) {\n                var n1 = this.bb.capacity() - e1, r1 = n1 - this.bb.readInt32(n1);\n                if (0 == this.bb.readInt16(r1 + t1)) throw new Error(\"FlatBuffers: field \" + t1 + \" must be set\");\n            }, r1.Builder.prototype.startVector = function(e1, t1, n1) {\n                this.notNested(), this.vector_num_elems = t1, this.prep(r1.SIZEOF_INT, e1 * t1), this.prep(n1, e1 * t1);\n            }, r1.Builder.prototype.endVector = function() {\n                return this.writeInt32(this.vector_num_elems), this.offset();\n            }, r1.Builder.prototype.createString = function(e1) {\n                if (e1 instanceof Uint8Array) var t1 = e1;\n                else {\n                    t1 = [];\n                    for(var n1 = 0; n1 < e1.length;){\n                        var r1, o1 = e1.charCodeAt(n1++);\n                        (r1 = o1 < 55296 || o1 >= 56320 ? o1 : (o1 << 10) + e1.charCodeAt(n1++) + -56613888) < 128 ? t1.push(r1) : (r1 < 2048 ? t1.push(r1 >> 6 & 31 | 192) : (r1 < 65536 ? t1.push(r1 >> 12 & 15 | 224) : t1.push(r1 >> 18 & 7 | 240, r1 >> 12 & 63 | 128), t1.push(r1 >> 6 & 63 | 128)), t1.push(63 & r1 | 128));\n                    }\n                }\n                this.addInt8(0), this.startVector(1, t1.length, 1), this.bb.setPosition(this.space -= t1.length), n1 = 0;\n                for(var i1 = this.space, s1 = this.bb.bytes(); n1 < t1.length; n1++)s1[i1++] = t1[n1];\n                return this.endVector();\n            }, r1.Builder.prototype.createLong = function(e1, t1) {\n                return r1.Long.create(e1, t1);\n            }, r1.ByteBuffer = function(e1) {\n                this.bytes_ = e1, this.position_ = 0;\n            }, r1.ByteBuffer.allocate = function(e1) {\n                return new r1.ByteBuffer(new Uint8Array(e1));\n            }, r1.ByteBuffer.prototype.clear = function() {\n                this.position_ = 0;\n            }, r1.ByteBuffer.prototype.bytes = function() {\n                return this.bytes_;\n            }, r1.ByteBuffer.prototype.position = function() {\n                return this.position_;\n            }, r1.ByteBuffer.prototype.setPosition = function(e1) {\n                this.position_ = e1;\n            }, r1.ByteBuffer.prototype.capacity = function() {\n                return this.bytes_.length;\n            }, r1.ByteBuffer.prototype.readInt8 = function(e1) {\n                return this.readUint8(e1) << 24 >> 24;\n            }, r1.ByteBuffer.prototype.readUint8 = function(e1) {\n                return this.bytes_[e1];\n            }, r1.ByteBuffer.prototype.readInt16 = function(e1) {\n                return this.readUint16(e1) << 16 >> 16;\n            }, r1.ByteBuffer.prototype.readUint16 = function(e1) {\n                return this.bytes_[e1] | this.bytes_[e1 + 1] << 8;\n            }, r1.ByteBuffer.prototype.readInt32 = function(e1) {\n                return this.bytes_[e1] | this.bytes_[e1 + 1] << 8 | this.bytes_[e1 + 2] << 16 | this.bytes_[e1 + 3] << 24;\n            }, r1.ByteBuffer.prototype.readUint32 = function(e1) {\n                return this.readInt32(e1) >>> 0;\n            }, r1.ByteBuffer.prototype.readInt64 = function(e1) {\n                return new r1.Long(this.readInt32(e1), this.readInt32(e1 + 4));\n            }, r1.ByteBuffer.prototype.readUint64 = function(e1) {\n                return new r1.Long(this.readUint32(e1), this.readUint32(e1 + 4));\n            }, r1.ByteBuffer.prototype.readFloat32 = function(e1) {\n                return r1.int32[0] = this.readInt32(e1), r1.float32[0];\n            }, r1.ByteBuffer.prototype.readFloat64 = function(e1) {\n                return r1.int32[r1.isLittleEndian ? 0 : 1] = this.readInt32(e1), r1.int32[r1.isLittleEndian ? 1 : 0] = this.readInt32(e1 + 4), r1.float64[0];\n            }, r1.ByteBuffer.prototype.writeInt8 = function(e1, t1) {\n                this.bytes_[e1] = t1;\n            }, r1.ByteBuffer.prototype.writeUint8 = function(e1, t1) {\n                this.bytes_[e1] = t1;\n            }, r1.ByteBuffer.prototype.writeInt16 = function(e1, t1) {\n                this.bytes_[e1] = t1, this.bytes_[e1 + 1] = t1 >> 8;\n            }, r1.ByteBuffer.prototype.writeUint16 = function(e1, t1) {\n                this.bytes_[e1] = t1, this.bytes_[e1 + 1] = t1 >> 8;\n            }, r1.ByteBuffer.prototype.writeInt32 = function(e1, t1) {\n                this.bytes_[e1] = t1, this.bytes_[e1 + 1] = t1 >> 8, this.bytes_[e1 + 2] = t1 >> 16, this.bytes_[e1 + 3] = t1 >> 24;\n            }, r1.ByteBuffer.prototype.writeUint32 = function(e1, t1) {\n                this.bytes_[e1] = t1, this.bytes_[e1 + 1] = t1 >> 8, this.bytes_[e1 + 2] = t1 >> 16, this.bytes_[e1 + 3] = t1 >> 24;\n            }, r1.ByteBuffer.prototype.writeInt64 = function(e1, t1) {\n                this.writeInt32(e1, t1.low), this.writeInt32(e1 + 4, t1.high);\n            }, r1.ByteBuffer.prototype.writeUint64 = function(e1, t1) {\n                this.writeUint32(e1, t1.low), this.writeUint32(e1 + 4, t1.high);\n            }, r1.ByteBuffer.prototype.writeFloat32 = function(e1, t1) {\n                r1.float32[0] = t1, this.writeInt32(e1, r1.int32[0]);\n            }, r1.ByteBuffer.prototype.writeFloat64 = function(e1, t1) {\n                r1.float64[0] = t1, this.writeInt32(e1, r1.int32[r1.isLittleEndian ? 0 : 1]), this.writeInt32(e1 + 4, r1.int32[r1.isLittleEndian ? 1 : 0]);\n            }, r1.ByteBuffer.prototype.getBufferIdentifier = function() {\n                if (this.bytes_.length < this.position_ + r1.SIZEOF_INT + r1.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: ByteBuffer is too short to contain an identifier.\");\n                for(var e1 = \"\", t1 = 0; t1 < r1.FILE_IDENTIFIER_LENGTH; t1++)e1 += String.fromCharCode(this.readInt8(this.position_ + r1.SIZEOF_INT + t1));\n                return e1;\n            }, r1.ByteBuffer.prototype.__offset = function(e1, t1) {\n                var n1 = e1 - this.readInt32(e1);\n                return t1 < this.readInt16(n1) ? this.readInt16(n1 + t1) : 0;\n            }, r1.ByteBuffer.prototype.__union = function(e1, t1) {\n                return e1.bb_pos = t1 + this.readInt32(t1), e1.bb = this, e1;\n            }, r1.ByteBuffer.prototype.__string = function(e1, t1) {\n                e1 += this.readInt32(e1);\n                var n1 = this.readInt32(e1), o1 = \"\", i1 = 0;\n                if (e1 += r1.SIZEOF_INT, t1 === r1.Encoding.UTF8_BYTES) return this.bytes_.subarray(e1, e1 + n1);\n                for(; i1 < n1;){\n                    var s1, a1 = this.readUint8(e1 + i1++);\n                    if (a1 < 192) s1 = a1;\n                    else {\n                        var u1 = this.readUint8(e1 + i1++);\n                        if (a1 < 224) s1 = (31 & a1) << 6 | 63 & u1;\n                        else {\n                            var l1 = this.readUint8(e1 + i1++);\n                            s1 = a1 < 240 ? (15 & a1) << 12 | (63 & u1) << 6 | 63 & l1 : (7 & a1) << 18 | (63 & u1) << 12 | (63 & l1) << 6 | 63 & this.readUint8(e1 + i1++);\n                        }\n                    }\n                    s1 < 65536 ? o1 += String.fromCharCode(s1) : (s1 -= 65536, o1 += String.fromCharCode(55296 + (s1 >> 10), 56320 + (1023 & s1)));\n                }\n                return o1;\n            }, r1.ByteBuffer.prototype.__indirect = function(e1) {\n                return e1 + this.readInt32(e1);\n            }, r1.ByteBuffer.prototype.__vector = function(e1) {\n                return e1 + this.readInt32(e1) + r1.SIZEOF_INT;\n            }, r1.ByteBuffer.prototype.__vector_len = function(e1) {\n                return this.readInt32(e1 + this.readInt32(e1));\n            }, r1.ByteBuffer.prototype.__has_identifier = function(e1) {\n                if (e1.length != r1.FILE_IDENTIFIER_LENGTH) throw new Error(\"FlatBuffers: file identifier must be length \" + r1.FILE_IDENTIFIER_LENGTH);\n                for(var t1 = 0; t1 < r1.FILE_IDENTIFIER_LENGTH; t1++)if (e1.charCodeAt(t1) != this.readInt8(this.position_ + r1.SIZEOF_INT + t1)) return !1;\n                return !0;\n            }, r1.ByteBuffer.prototype.createLong = function(e1, t1) {\n                return r1.Long.create(e1, t1);\n            };\n        }\n    }, __webpack_module_cache__ = {};\n    function __nested_webpack_require_971500__(e1) {\n        var t1 = __webpack_module_cache__[e1];\n        if (void 0 !== t1) return t1.exports;\n        var n1 = __webpack_module_cache__[e1] = {\n            exports: {}\n        };\n        return __webpack_modules__[e1].call(n1.exports, n1, n1.exports, __nested_webpack_require_971500__), n1.exports;\n    }\n    __nested_webpack_require_971500__.n = (e1)=>{\n        var t1 = e1 && e1.__esModule ? ()=>e1.default : ()=>e1;\n        return __nested_webpack_require_971500__.d(t1, {\n            a: t1\n        }), t1;\n    }, __nested_webpack_require_971500__.d = (e1, t1)=>{\n        for(var n1 in t1)__nested_webpack_require_971500__.o(t1, n1) && !__nested_webpack_require_971500__.o(e1, n1) && Object.defineProperty(e1, n1, {\n            enumerable: !0,\n            get: t1[n1]\n        });\n    }, __nested_webpack_require_971500__.o = (e1, t1)=>Object.prototype.hasOwnProperty.call(e1, t1), __nested_webpack_require_971500__.r = (e1)=>{\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e1, Symbol.toStringTag, {\n            value: \"Module\"\n        }), Object.defineProperty(e1, \"__esModule\", {\n            value: !0\n        });\n    };\n    var __nested_webpack_exports__ = __nested_webpack_require_971500__(1057), __webpack_export_target__ = exports;\n    for(var i in __nested_webpack_exports__)__webpack_export_target__[i] = __nested_webpack_exports__[i];\n    __nested_webpack_exports__.__esModule && Object.defineProperty(__webpack_export_target__, \"__esModule\", {\n        value: !0\n    });\n})(); //# sourceMappingURL=ort-web.node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LXdlYi5ub2RlLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBOzs7O0FBSUEsR0FDQztJQUFLLElBQUlBLHNCQUFvQjtRQUFDLE1BQUssQ0FBQ0MsSUFBRUMsSUFBRUM7WUFBSztZQUFhRCxHQUFFRSxDQUFDLEdBQUMsS0FBSztZQUFFLE1BQU1DLEtBQUVGLEdBQUUsT0FBTUcsS0FBRUgsR0FBRTtZQUFNRCxHQUFFRSxDQUFDLEdBQUMsSUFBSTtnQkFBTSxNQUFNRyxPQUFNLENBQUM7Z0JBQUMsTUFBTUMscUJBQXFCUCxFQUFDLEVBQUNDLEVBQUMsRUFBQztvQkFBQyxNQUFNQyxLQUFFLElBQUlFLEdBQUVJLE9BQU8sQ0FBQ1A7b0JBQUcsT0FBTyxNQUFNQyxHQUFFTyxTQUFTLENBQUNULEtBQUcsSUFBSUssR0FBRUssb0JBQW9CLENBQUNSO2dCQUFFO1lBQUM7UUFBQztRQUFFLE1BQUssQ0FBQ0YsSUFBRUMsSUFBRUM7WUFBSztZQUFhRCxHQUFFVSxFQUFFLEdBQUNWLEdBQUVXLEVBQUUsR0FBQyxLQUFLO1lBQUUsTUFBTVIsS0FBRUYsR0FBRSxPQUFNRyxLQUFFSCxHQUFFLE9BQU1XLEtBQUVYLEdBQUUsT0FBTVksS0FBRVosR0FBRTtZQUFNRCxHQUFFVyxFQUFFLEdBQUM7Z0JBQUssSUFBRyxDQUFDLFlBQVUsT0FBT1IsR0FBRVcsR0FBRyxDQUFDQyxJQUFJLENBQUNDLFdBQVcsSUFBRWIsR0FBRVcsR0FBRyxDQUFDQyxJQUFJLENBQUNDLFdBQVcsR0FBQyxNQUFLYixDQUFBQSxHQUFFVyxHQUFHLENBQUNDLElBQUksQ0FBQ0MsV0FBVyxHQUFDLElBQUcsYUFBVyxPQUFPYixHQUFFVyxHQUFHLENBQUNDLElBQUksQ0FBQ0UsSUFBSSxJQUFHZCxDQUFBQSxHQUFFVyxHQUFHLENBQUNDLElBQUksQ0FBQ0UsSUFBSSxHQUFDLENBQUMsSUFBRyxhQUFXLE9BQU9kLEdBQUVXLEdBQUcsQ0FB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RCxVQUFVLEdBQUMsU0FBUzlqRCxFQUFDO29CQUFFLE9BQU8sS0FBSyxNQUFJQSxNQUFJQSxDQUFBQSxLQUFFLHFCQUFvQixHQUFHQSxLQUFFO2dCQUFtQixHQUFFQSxHQUFFazNDLFFBQVEsR0FBQztvQkFBVyxJQUFJbDNDLEtBQUUsQ0FBQyxHQUFFQyxLQUFFa0MsT0FBT0MsTUFBTSxDQUFDcEM7b0JBQUcsT0FBT0MsRUFBQyxDQUFDRCxFQUFDLENBQUMsRUFBRSxHQUFDLFlBQVksR0FBQyxHQUFFQyxFQUFDLENBQUNELEVBQUMsQ0FBQyxFQUFFLEdBQUMsUUFBUSxHQUFDLEdBQUVDLEVBQUMsQ0FBQ0QsRUFBQyxDQUFDLEVBQUUsR0FBQyxRQUFRLEdBQUMsR0FBRUMsRUFBQyxDQUFDRCxFQUFDLENBQUMsRUFBRSxHQUFDLE9BQU8sR0FBQyxHQUFFQyxFQUFDLENBQUNELEVBQUMsQ0FBQyxFQUFFLEdBQUMsU0FBUyxHQUFDLEdBQUVDLEVBQUMsQ0FBQ0QsRUFBQyxDQUFDLEVBQUUsR0FBQyxRQUFRLEdBQUMsR0FBRUMsRUFBQyxDQUFDRCxFQUFDLENBQUMsRUFBRSxHQUFDLFFBQVEsR0FBQyxHQUFFQyxFQUFDLENBQUNELEVBQUMsQ0FBQyxFQUFFLEdBQUMsUUFBUSxHQUFDLEdBQUVDLEVBQUMsQ0FBQ0QsRUFBQyxDQUFDLEVBQUUsR0FBQyxTQUFTLEdBQUMsR0FBRUMsRUFBQyxDQUFDRCxFQUFDLENBQUMsRUFBRSxHQUFDLE9BQU8sR0FBQyxHQUFFQyxFQUFDLENBQUNELEVBQUMsQ0FBQyxHQUFHLEdBQUMsVUFBVSxHQUFDLElBQUdDLEVBQUMsQ0FBQ0QsRUFBQyxDQUFDLEdBQUcsR0FBQyxTQUFTLEdBQUMsSUFBR0MsRUFBQyxDQUFDRCxFQUFDLENBQUMsR0FBRyxHQUFDLFNBQVMsR0FBQyxJQUFHQyxFQUFDLENBQUNELEVBQUMsQ0FBQyxHQUFHLEdBQUMsU0FBUyxHQUFDLElBQUdDLEVBQUMsQ0FBQ0QsRUFBQyxDQUFDLEdBQUcsR0FBQyxZQUFZLEdBQUMsSUFBR0MsRUFBQyxDQUFDRCxFQUFD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TSxHQUFFenJCLEtBQUUsUUFBTUYsRUFBQyxDQUFDLEVBQUU7b0JBQUMsU0FBU0csR0FBRUwsRUFBQyxFQUFDSSxFQUFDLEVBQUNDLEVBQUM7d0JBQUVKLEVBQUMsQ0FBQyxFQUFFLEdBQUNELElBQUVJLEVBQUMsQ0FBQ0MsR0FBRSxHQUFDSCxFQUFDLENBQUMsRUFBRSxFQUFDRSxFQUFDLENBQUNDLEtBQUUsRUFBRSxHQUFDSCxFQUFDLENBQUMsRUFBRSxFQUFDRSxFQUFDLENBQUNDLEtBQUUsRUFBRSxHQUFDSCxFQUFDLENBQUMsRUFBRSxFQUFDRSxFQUFDLENBQUNDLEtBQUUsRUFBRSxHQUFDSCxFQUFDLENBQUMsRUFBRSxFQUFDRSxFQUFDLENBQUNDLEtBQUUsRUFBRSxHQUFDSCxFQUFDLENBQUMsRUFBRSxFQUFDRSxFQUFDLENBQUNDLEtBQUUsRUFBRSxHQUFDSCxFQUFDLENBQUMsRUFBRSxFQUFDRSxFQUFDLENBQUNDLEtBQUUsRUFBRSxHQUFDSCxFQUFDLENBQUMsRUFBRSxFQUFDRSxFQUFDLENBQUNDLEtBQUUsRUFBRSxHQUFDSCxFQUFDLENBQUMsRUFBRTtvQkFBQTtvQkFBQyxTQUFTVyxHQUFFYixFQUFDLEVBQUNJLEVBQUMsRUFBQ0MsRUFBQzt3QkFBRUosRUFBQyxDQUFDLEVBQUUsR0FBQ0QsSUFBRUksRUFBQyxDQUFDQyxHQUFFLEdBQUNILEVBQUMsQ0FBQyxFQUFFLEVBQUNFLEVBQUMsQ0FBQ0MsS0FBRSxFQUFFLEdBQUNILEVBQUMsQ0FBQyxFQUFFLEVBQUNFLEVBQUMsQ0FBQ0MsS0FBRSxFQUFFLEdBQUNILEVBQUMsQ0FBQyxFQUFFLEVBQUNFLEVBQUMsQ0FBQ0MsS0FBRSxFQUFFLEdBQUNILEVBQUMsQ0FBQyxFQUFFLEVBQUNFLEVBQUMsQ0FBQ0MsS0FBRSxFQUFFLEdBQUNILEVBQUMsQ0FBQyxFQUFFLEVBQUNFLEVBQUMsQ0FBQ0MsS0FBRSxFQUFFLEdBQUNILEVBQUMsQ0FBQyxFQUFFLEVBQUNFLEVBQUMsQ0FBQ0MsS0FBRSxFQUFFLEdBQUNILEVBQUMsQ0FBQyxFQUFFLEVBQUNFLEVBQUMsQ0FBQ0MsS0FBRSxFQUFFLEdBQUNILEVBQUMsQ0FBQyxFQUFFO29CQUFBO29CQUFDLFNBQVNZLEdBQUVkLEVBQUMsRUFBQ0ksRUFBQzt3QkFBRSxPQUFPRixFQUFDLENBQUMsRUFBRSxHQUFDRixFQUFDLENBQUNJLEdBQUUsRUFBQ0YsRUFBQyxDQUFDLEVBQUUsR0FBQ0YsRUFBQyxDQUFDSSxLQUFFLEVBQUUsRUFBQ0YsRUFBQyxDQUFDLEVBQUUsR0FBQ0YsRUFBQyxDQUFDSSxLQUFFLEVBQUUsRUFBQ0YsRUFBQyxDQUFDLEVBQUUsR0FBQ0YsRUFBQyxDQUFDSSxLQUFFLEVBQUUsRUFBQ0YsRUFBQyxDQUFDLEVBQUUsR0FBQ0YsRUFBQyxDQUFDSSxLQUFFLEVBQUUsRUFBQ0YsRUFBQyxDQUFDLEVBQUUsR0FBQ0YsRUFBQyxDQUFDSSxLQUFFLEVBQUUsRUFBQ0YsRUFBQyxDQUFDLEVBQUUsR0FBQ0YsRUFBQyxDQUFDSSxLQUFFLEVBQUUsRUFBQ0YsRUFBQyxDQUFDLEVBQUUsR0FBQ0YsRUFBQyxDQUFDSSxLQUFFLEVBQUUsRUFBQ0gsRUFBQyxDQUFDLEVBQUU7b0JBQUE7b0JBQUMsU0FBUzhELEdBQUUvRCxFQUFDLEVBQUNJLEVBQUM7d0JBQUUsT0FBT0YsRUFBQyxDQUFDLEVBQUUsR0FBQ0YsRUFBQyxDQUFDSSxHQUFFLEVBQUNGLEVBQUMsQ0FBQyxFQUFFLEdBQUNGLEVBQUMsQ0FBQ0ksS0FBRSxFQUFFLEVBQUNGLEVBQUMsQ0FBQyxFQUFFLEdBQUNGLEVBQUMsQ0FBQ0ksS0FBRSxFQUFFLEVBQUNGLEVBQUMsQ0FBQyxFQUFFLEdBQUNGLEVBQUMsQ0FBQ0ksS0FBRSxFQUFFLEVBQUNGLEVBQUMsQ0FBQyxFQUFFLEdBQUNGLEVBQUMsQ0FBQ0ksS0FBRSxFQUFFLEVBQUNGLEVBQUMsQ0FBQyxFQUFFLEdBQUNGLEVBQUMsQ0FBQ0ksS0FBRSxFQUFFLEVBQUNGLEVBQUMsQ0FBQyxFQUFFLEdBQUNGLEVBQUMsQ0FBQ0ksS0FBRSxFQUFFLEVBQUNGLEVBQUMsQ0FBQyxFQUFFLEdBQUNGLEVB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QUk7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUk7d0JBQUU7d0JBQUU7d0JBQUU7d0JBQUk7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUk7d0JBQUk7d0JBQUU7d0JBQUU7d0JBQUc7d0JBQUk7d0JBQUU7d0JBQUU7d0JBQUU7d0JBQUU7d0JBQUc7d0JBQUU7d0JBQUc7d0JBQUc7d0JBQUU7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUc7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JBQUU7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUc7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JBQUU7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUc7d0JBQUc7d0JBQUk7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JBQUU7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUU7d0JBQUk7d0JBQUc7d0JBQUc7d0JB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anMvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LXdlYi5ub2RlLmpzPzQ3MzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIE9OTlggUnVudGltZSBXZWIgdjEuMTYuM1xuKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cbigoKT0+e3ZhciBfX3dlYnBhY2tfbW9kdWxlc19fPXs1NzE2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjt0LlI9dm9pZCAwO2NvbnN0IHI9big2MDI3KSxvPW4oMTcyMyk7dC5SPW5ldyBjbGFzc3thc3luYyBpbml0KCl7fWFzeW5jIGNyZWF0ZVNlc3Npb25IYW5kbGVyKGUsdCl7Y29uc3Qgbj1uZXcgci5TZXNzaW9uKHQpO3JldHVybiBhd2FpdCBuLmxvYWRNb2RlbChlKSxuZXcgby5Pbm54anNTZXNzaW9uSGFuZGxlcihuKX19fSwyODE4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjt0LmM4PXQuclg9dm9pZCAwO2NvbnN0IHI9big2MjA3KSxvPW4oOTcxOSksaT1uKDk1NDQpLHM9big2NjQwKTt0LnJYPSgpPT57aWYoKFwibnVtYmVyXCIhPXR5cGVvZiByLmVudi53YXNtLmluaXRUaW1lb3V0fHxyLmVudi53YXNtLmluaXRUaW1lb3V0PDApJiYoci5lbnYud2FzbS5pbml0VGltZW91dD0wKSxcImJvb2xlYW5cIiE9dHlwZW9mIHIuZW52Lndhc20uc2ltZCYmKHIuZW52Lndhc20uc2ltZD0hMCksXCJib29sZWFuXCIhPXR5cGVvZiByLmVudi53YXNtLnByb3h5JiYoci5lbnYud2FzbS5wcm94eT0hMSksXCJudW1iZXJcIiE9dHlwZW9mIHIuZW52Lndhc20ubnVtVGhyZWFkc3x8IU51bWJlci5pc0ludGVnZXIoci5lbnYud2FzbS5udW1UaHJlYWRzKXx8ci5lbnYud2FzbS5udW1UaHJlYWRzPD0wKXtjb25zdCBlPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBuYXZpZ2F0b3I/KDAsby5jcHVzKSgpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtyLmVudi53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKGV8fDEpLzIpKX19LHQuYzg9bmV3IGNsYXNze2FzeW5jIGluaXQoKXsoMCx0LnJYKSgpLGF3YWl0KDAsaS5pbml0aWFsaXplV2ViQXNzZW1ibHlJbnN0YW5jZSkoKX1hc3luYyBjcmVhdGVTZXNzaW9uSGFuZGxlcihlLHQpe2NvbnN0IG49bmV3IHMuT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyO3JldHVybiBhd2FpdCBuLmxvYWRNb2RlbChlLHQpLFByb21pc2UucmVzb2x2ZShuKX19fSwxMDU3OmZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG4pO28mJiEoXCJnZXRcImluIG8/IXQuX19lc01vZHVsZTpvLndyaXRhYmxlfHxvLmNvbmZpZ3VyYWJsZSl8fChvPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsbyl9OmZ1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pLGVbcl09dFtuXX0pLG89dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuIGluIGUpXCJkZWZhdWx0XCI9PT1ufHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKXx8cih0LGUsbil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG8obig2MjA3KSx0KTtjb25zdCBpPW4oNjIwNykscz1uKDg0MDgpO3tjb25zdCBlPW4oNTcxNikuUjsoMCxpLnJlZ2lzdGVyQmFja2VuZCkoXCJ3ZWJnbFwiLGUsLTEwKX17Y29uc3QgZT1uKDI4MTgpLmM4OygwLGkucmVnaXN0ZXJCYWNrZW5kKShcImNwdVwiLGUsMTApLCgwLGkucmVnaXN0ZXJCYWNrZW5kKShcIndhc21cIixlLDEwKSwoMCxpLnJlZ2lzdGVyQmFja2VuZCkoXCJ4bm5wYWNrXCIsZSw5KSwoMCxpLnJlZ2lzdGVyQmFja2VuZCkoXCJ3ZWJublwiLGUsOSl9aS5lbnYudmVyc2lvbnMud2ViPXMudmVyc2lvbn0sNDkxMDooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5PXZvaWQgMDtjbGFzcyBue2NvbnN0cnVjdG9yKGUpe09iamVjdC5hc3NpZ24odGhpcyxlKX1nZXQgY2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5fY2FjaGVLZXl8fCh0aGlzLl9jYWNoZUtleT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5zb3J0KCkubWFwKChlPT5gJHt0aGlzW2VdfWApKS5qb2luKFwiO1wiKSksdGhpcy5fY2FjaGVLZXl9fXQuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5PWU9Pm5ldyBuKGUpfSw2ODc0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkF0dHJpYnV0ZT12b2lkIDA7Y29uc3Qgcj1uKDUxMjcpLG89bigyNDQ2KSxpPW4oOTI0MCkscz1uKDcyNzMpO3ZhciBhPXIub25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicztjbGFzcyB1e2NvbnN0cnVjdG9yKGUpe2lmKHRoaXMuX2F0dHJpYnV0ZXM9bmV3IE1hcCxudWxsIT1lKXtmb3IoY29uc3QgdCBvZiBlKXQgaW5zdGFuY2VvZiBvLm9ubnguQXR0cmlidXRlUHJvdG8/dGhpcy5fYXR0cmlidXRlcy5zZXQodC5uYW1lLFt1LmdldFZhbHVlKHQpLHUuZ2V0VHlwZSh0KV0pOnQgaW5zdGFuY2VvZiBhLkF0dHJpYnV0ZSYmdGhpcy5fYXR0cmlidXRlcy5zZXQodC5uYW1lKCksW3UuZ2V0VmFsdWUodCksdS5nZXRUeXBlKHQpXSk7aWYodGhpcy5fYXR0cmlidXRlcy5zaXplPGUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZWQgYXR0cmlidXRlIG5hbWVzXCIpfX1zZXQoZSx0LG4pe3RoaXMuX2F0dHJpYnV0ZXMuc2V0KGUsW24sdF0pfWRlbGV0ZShlKXt0aGlzLl9hdHRyaWJ1dGVzLmRlbGV0ZShlKX1nZXRGbG9hdChlLHQpe3JldHVybiB0aGlzLmdldChlLFwiZmxvYXRcIix0KX1nZXRJbnQoZSx0KXtyZXR1cm4gdGhpcy5nZXQoZSxcImludFwiLHQpfWdldFN0cmluZyhlLHQpe3JldHVybiB0aGlzLmdldChlLFwic3RyaW5nXCIsdCl9Z2V0VGVuc29yKGUsdCl7cmV0dXJuIHRoaXMuZ2V0KGUsXCJ0ZW5zb3JcIix0KX1nZXRGbG9hdHMoZSx0KXtyZXR1cm4gdGhpcy5nZXQoZSxcImZsb2F0c1wiLHQpfWdldEludHMoZSx0KXtyZXR1cm4gdGhpcy5nZXQoZSxcImludHNcIix0KX1nZXRTdHJpbmdzKGUsdCl7cmV0dXJuIHRoaXMuZ2V0KGUsXCJzdHJpbmdzXCIsdCl9Z2V0VGVuc29ycyhlLHQpe3JldHVybiB0aGlzLmdldChlLFwidGVuc29yc1wiLHQpfWdldChlLHQsbil7Y29uc3Qgcj10aGlzLl9hdHRyaWJ1dGVzLmdldChlKTtpZih2b2lkIDA9PT1yKXtpZih2b2lkIDAhPT1uKXJldHVybiBuO3Rocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgYXR0cmlidXRlIG5vdCBmb3VuZDogJHtlfWApfWlmKHJbMV0hPT10KXRocm93IG5ldyBFcnJvcihgdHlwZSBtaXNtYXRjaDogZXhwZWN0ZWQgJHt0fSBidXQgZ290ICR7clsxXX1gKTtyZXR1cm4gclswXX1zdGF0aWMgZ2V0VHlwZShlKXtjb25zdCB0PWUgaW5zdGFuY2VvZiBvLm9ubnguQXR0cmlidXRlUHJvdG8/ZS50eXBlOmUudHlwZSgpO3N3aXRjaCh0KXtjYXNlIG8ub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUOnJldHVyblwiZmxvYXRcIjtjYXNlIG8ub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVDpyZXR1cm5cImludFwiO2Nhc2Ugby5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOnJldHVyblwic3RyaW5nXCI7Y2FzZSBvLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1I6cmV0dXJuXCJ0ZW5zb3JcIjtjYXNlIG8ub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkZMT0FUUzpyZXR1cm5cImZsb2F0c1wiO2Nhc2Ugby5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UUzpyZXR1cm5cImludHNcIjtjYXNlIG8ub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1M6cmV0dXJuXCJzdHJpbmdzXCI7Y2FzZSBvLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1JTOnJldHVyblwidGVuc29yc1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBhdHRyaWJ1dGUgdHlwZSBpcyBub3Qgc3VwcG9ydGVkIHlldDogJHtvLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0XX1gKX19c3RhdGljIGdldFZhbHVlKGUpe2NvbnN0IHQ9ZSBpbnN0YW5jZW9mIG8ub25ueC5BdHRyaWJ1dGVQcm90bz9lLnR5cGU6ZS50eXBlKCk7aWYodD09PW8ub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIfHx0PT09by5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEhTKXRocm93IG5ldyBFcnJvcihcImdyYXBoIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtjb25zdCBuPXRoaXMuZ2V0VmFsdWVOb0NoZWNrKGUpO2lmKHQ9PT1vLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlQmJnMuTG9uZ1V0aWwuaXNMb25nKG4pKXJldHVybiBzLkxvbmdVdGlsLmxvbmdUb051bWJlcihuKTtpZih0PT09by5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UUyl7Y29uc3QgZT1uLHQ9bmV3IEFycmF5KGUubGVuZ3RoKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyl7Y29uc3Qgcj1lW25dO3Rbbl09cy5Mb25nVXRpbC5sb25nVG9OdW1iZXIocil9cmV0dXJuIHR9aWYodD09PW8ub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUilyZXR1cm4gZSBpbnN0YW5jZW9mIG8ub25ueC5BdHRyaWJ1dGVQcm90bz9pLlRlbnNvci5mcm9tUHJvdG8obik6aS5UZW5zb3IuZnJvbU9ydFRlbnNvcihuKTtpZih0PT09by5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUyl7aWYoZSBpbnN0YW5jZW9mIG8ub25ueC5BdHRyaWJ1dGVQcm90bylyZXR1cm4gbi5tYXAoKGU9PmkuVGVuc29yLmZyb21Qcm90byhlKSkpO2lmKGUgaW5zdGFuY2VvZiBhLkF0dHJpYnV0ZSlyZXR1cm4gbi5tYXAoKGU9PmkuVGVuc29yLmZyb21PcnRUZW5zb3IoZSkpKX1pZih0PT09by5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HJiZlIGluc3RhbmNlb2Ygby5vbm54LkF0dHJpYnV0ZVByb3RvKXtjb25zdCBlPW47cmV0dXJuKDAscy5kZWNvZGVVdGY4U3RyaW5nKShlKX1yZXR1cm4gdD09PW8ub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklOR1MmJmUgaW5zdGFuY2VvZiBvLm9ubnguQXR0cmlidXRlUHJvdG8/bi5tYXAocy5kZWNvZGVVdGY4U3RyaW5nKTpufXN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2soZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBvLm9ubnguQXR0cmlidXRlUHJvdG8/dGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdChlKTp0aGlzLmdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQoZSl9c3RhdGljIGdldFZhbHVlTm9DaGVja0Zyb21Pbm54Rm9ybWF0KGUpe3N3aXRjaChlLnR5cGUpe2Nhc2Ugby5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6cmV0dXJuIGUuZjtjYXNlIG8ub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVDpyZXR1cm4gZS5pO2Nhc2Ugby5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HOnJldHVybiBlLnM7Y2FzZSBvLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1I6cmV0dXJuIGUudDtjYXNlIG8ub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIOnJldHVybiBlLmc7Y2FzZSBvLm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVFM6cmV0dXJuIGUuZmxvYXRzO2Nhc2Ugby5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UUzpyZXR1cm4gZS5pbnRzO2Nhc2Ugby5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpyZXR1cm4gZS5zdHJpbmdzO2Nhc2Ugby5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuVEVOU09SUzpyZXR1cm4gZS50ZW5zb3JzO2Nhc2Ugby5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuR1JBUEhTOnJldHVybiBlLmdyYXBocztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7by5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbZS50eXBlXX1gKX19c3RhdGljIGdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQoZSl7c3dpdGNoKGUudHlwZSgpKXtjYXNlIGEuQXR0cmlidXRlVHlwZS5GTE9BVDpyZXR1cm4gZS5mKCk7Y2FzZSBhLkF0dHJpYnV0ZVR5cGUuSU5UOnJldHVybiBlLmkoKTtjYXNlIGEuQXR0cmlidXRlVHlwZS5TVFJJTkc6cmV0dXJuIGUucygpO2Nhc2UgYS5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpyZXR1cm4gZS50KCk7Y2FzZSBhLkF0dHJpYnV0ZVR5cGUuR1JBUEg6cmV0dXJuIGUuZygpO2Nhc2UgYS5BdHRyaWJ1dGVUeXBlLkZMT0FUUzpyZXR1cm4gZS5mbG9hdHNBcnJheSgpO2Nhc2UgYS5BdHRyaWJ1dGVUeXBlLklOVFM6e2NvbnN0IHQ9W107Zm9yKGxldCBuPTA7bjxlLmludHNMZW5ndGgoKTtuKyspdC5wdXNoKGUuaW50cyhuKSk7cmV0dXJuIHR9Y2FzZSBhLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzp7Y29uc3QgdD1bXTtmb3IobGV0IG49MDtuPGUuc3RyaW5nc0xlbmd0aCgpO24rKyl0LnB1c2goZS5zdHJpbmdzKG4pKTtyZXR1cm4gdH1jYXNlIGEuQXR0cmlidXRlVHlwZS5URU5TT1JTOntjb25zdCB0PVtdO2ZvcihsZXQgbj0wO248ZS50ZW5zb3JzTGVuZ3RoKCk7bisrKXQucHVzaChlLnRlbnNvcnMobikpO3JldHVybiB0fWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZTogJHthLkF0dHJpYnV0ZVR5cGVbZS50eXBlKCldfWApfX19dC5BdHRyaWJ1dGU9dX0sMTk3NTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5yZXNvbHZlQmFja2VuZD10LmJhY2tlbmQ9dm9pZCAwO2NvbnN0IHI9big0NDE4KSxvPW5ldyBNYXA7YXN5bmMgZnVuY3Rpb24gaShlKXtjb25zdCBuPXQuYmFja2VuZDtpZih2b2lkIDAhPT1uW2VdJiZmdW5jdGlvbihlKXtjb25zdCB0PWU7cmV0dXJuXCJpbml0aWFsaXplXCJpbiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmluaXRpYWxpemUmJlwiY3JlYXRlU2Vzc2lvbkhhbmRsZXJcImluIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuY3JlYXRlU2Vzc2lvbkhhbmRsZXImJlwiZGlzcG9zZVwiaW4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5kaXNwb3NlfShuW2VdKSl7Y29uc3QgdD1uW2VdO2xldCByPXQuaW5pdGlhbGl6ZSgpO2lmKFwib2JqZWN0XCI9PXR5cGVvZiByJiZcInRoZW5cImluIHImJihyPWF3YWl0IHIpLHIpcmV0dXJuIG8uc2V0KGUsdCksdH19dC5iYWNrZW5kPXt3ZWJnbDpuZXcgci5XZWJHTEJhY2tlbmR9LHQucmVzb2x2ZUJhY2tlbmQ9YXN5bmMgZnVuY3Rpb24gZSh0KXtpZighdClyZXR1cm4gZShbXCJ3ZWJnbFwiXSk7e2NvbnN0IGU9XCJzdHJpbmdcIj09dHlwZW9mIHQ/W3RdOnQ7Zm9yKGNvbnN0IHQgb2YgZSl7Y29uc3QgZT1vLmdldCh0KTtpZihlKXJldHVybiBlO2NvbnN0IG49YXdhaXQgaSh0KTtpZihuKXJldHVybiBufX10aHJvdyBuZXcgRXJyb3IoXCJubyBhdmFpbGFibGUgYmFja2VuZCB0byB1c2VcIil9fSw0NDE4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LldlYkdMQmFja2VuZD12b2lkIDA7Y29uc3Qgcj1uKDYyMDcpLG89bigxMzE1KSxpPW4oMjE3MSkscz1uKDMzODkpO3QuV2ViR0xCYWNrZW5kPWNsYXNze2dldCBjb250ZXh0SWQoKXtyZXR1cm4gci5lbnYud2ViZ2wuY29udGV4dElkfXNldCBjb250ZXh0SWQoZSl7ci5lbnYud2ViZ2wuY29udGV4dElkPWV9Z2V0IG1hdG11bE1heEJhdGNoU2l6ZSgpe3JldHVybiByLmVudi53ZWJnbC5tYXRtdWxNYXhCYXRjaFNpemV9c2V0IG1hdG11bE1heEJhdGNoU2l6ZShlKXtyLmVudi53ZWJnbC5tYXRtdWxNYXhCYXRjaFNpemU9ZX1nZXQgdGV4dHVyZUNhY2hlTW9kZSgpe3JldHVybiByLmVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlfXNldCB0ZXh0dXJlQ2FjaGVNb2RlKGUpe3IuZW52LndlYmdsLnRleHR1cmVDYWNoZU1vZGU9ZX1nZXQgcGFjaygpe3JldHVybiByLmVudi53ZWJnbC5wYWNrfXNldCBwYWNrKGUpe3IuZW52LndlYmdsLnBhY2s9ZX1nZXQgYXN5bmMoKXtyZXR1cm4gci5lbnYud2ViZ2wuYXN5bmN9c2V0IGFzeW5jKGUpe3IuZW52LndlYmdsLmFzeW5jPWV9aW5pdGlhbGl6ZSgpe3RyeXtyZXR1cm4gdGhpcy5nbENvbnRleHQ9KDAscy5jcmVhdGVXZWJHTENvbnRleHQpKHRoaXMuY29udGV4dElkKSxcIm51bWJlclwiIT10eXBlb2YgdGhpcy5tYXRtdWxNYXhCYXRjaFNpemUmJih0aGlzLm1hdG11bE1heEJhdGNoU2l6ZT0xNiksXCJzdHJpbmdcIiE9dHlwZW9mIHRoaXMudGV4dHVyZUNhY2hlTW9kZSYmKHRoaXMudGV4dHVyZUNhY2hlTW9kZT1cImZ1bGxcIiksXCJib29sZWFuXCIhPXR5cGVvZiB0aGlzLnBhY2smJih0aGlzLnBhY2s9ITEpLFwiYm9vbGVhblwiIT10eXBlb2YgdGhpcy5hc3luYyYmKHRoaXMuYXN5bmM9ITEpLG8uTG9nZ2VyLnNldFdpdGhFbnYoci5lbnYpLG8uTG9nZ2VyLnZlcmJvc2UoXCJXZWJHTEJhY2tlbmRcIixgQ3JlYXRlZCBXZWJHTENvbnRleHQ6ICR7dHlwZW9mIHRoaXMuZ2xDb250ZXh0fSB3aXRoIG1hdG11bE1heEJhdGNoU2l6ZTogJHt0aGlzLm1hdG11bE1heEJhdGNoU2l6ZX07IHRleHR1cmVDYWNoZU1vZGU6ICR7dGhpcy50ZXh0dXJlQ2FjaGVNb2RlfTsgcGFjazogJHt0aGlzLnBhY2t9OyBhc3luYzogJHt0aGlzLmFzeW5jfS5gKSwhMH1jYXRjaChlKXtyZXR1cm4gby5Mb2dnZXIud2FybmluZyhcIldlYkdMQmFja2VuZFwiLGBVbmFibGUgdG8gaW5pdGlhbGl6ZSBXZWJHTEJhY2tlbmQuICR7ZX1gKSwhMX19Y3JlYXRlU2Vzc2lvbkhhbmRsZXIoZSl7cmV0dXJuIG5ldyBpLldlYkdMU2Vzc2lvbkhhbmRsZXIodGhpcyxlKX1kaXNwb3NlKCl7dGhpcy5nbENvbnRleHQuZGlzcG9zZSgpfX19LDY4NTk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQ29vcmRzR2xzbExpYj12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpLG89bigxOTk3KSxpPW4oNjc1Nykscz1uKDc2MTgpLGE9big0MzIpO2NsYXNzIHUgZXh0ZW5kcyBvLkdsc2xMaWJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5vZmZzZXRUb0Nvb3JkcygpKSx0aGlzLmNvb3Jkc1RvT2Zmc2V0KCkpLHRoaXMudG9WZWMoKSksdGhpcy52YWx1ZUZyb20oKSksdGhpcy5nZXRDb21tb25VdGlsRnVuY3MoKSksdGhpcy5nZXRJbnB1dHNTYW1wbGluZ1NuaXBwZXRzKCkpLHRoaXMuZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KCkpfWdldEN1c3RvbVR5cGVzKCl7cmV0dXJue319b2Zmc2V0VG9Db29yZHMoKXtyZXR1cm57b2Zmc2V0VG9Db29yZHM6bmV3IG8uR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICB2ZWMyIG9mZnNldFRvQ29vcmRzKGludCBvZmZzZXQsIGludCB3aWR0aCwgaW50IGhlaWdodCkge1xcbiAgICAgICAgaW50IHQgPSBvZmZzZXQgLyB3aWR0aDtcXG4gICAgICAgIGludCBzID0gb2Zmc2V0IC0gdCp3aWR0aDtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gKHZlYzIocyx0KSArIHZlYzIoMC41LDAuNSkpIC8gdmVjMih3aWR0aCwgaGVpZ2h0KTtcXG4gICAgICAgIHJldHVybiBjb29yZHM7XFxuICAgICAgfVxcbiAgICAgIFwiKX19Y29vcmRzVG9PZmZzZXQoKXtyZXR1cm57Y29vcmRzVG9PZmZzZXQ6bmV3IG8uR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICBpbnQgY29vcmRzVG9PZmZzZXQodmVjMiBjb29yZHMsIGludCB3aWR0aCwgaW50IGhlaWdodCkge1xcbiAgICAgICAgZmxvYXQgcyA9IGNvb3Jkcy5zICogZmxvYXQod2lkdGgpO1xcbiAgICAgICAgZmxvYXQgdCA9IGNvb3Jkcy50ICogZmxvYXQoaGVpZ2h0KTtcXG4gICAgICAgIGludCBvZmZzZXQgPSBpbnQodCkgKiB3aWR0aCArIGludChzKTtcXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XFxuICAgICAgfVxcbiAgICAgIFwiKX19Z2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KCl7Y29uc3QgZT10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtyZXR1cm4gZS5pc1BhY2tlZD90aGlzLmdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChlKTp0aGlzLmdldFVucGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KGUpfWdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChlKXtjb25zdCB0PWUudW5wYWNrZWRTaGFwZSxuPVtlLndpZHRoLGUuaGVpZ2h0XSxyPXt9LHM9XCJnZXRPdXRwdXRDb29yZHNcIjtzd2l0Y2godC5sZW5ndGgpe2Nhc2UgMDpyW3NdPXRoaXMuZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk7YnJlYWs7Y2FzZSAxOnJbc109dGhpcy5nZXRPdXRwdXRQYWNrZWQxRENvb3Jkcyh0LG4pO2JyZWFrO2Nhc2UgMjpyW3NdPXRoaXMuZ2V0T3V0cHV0UGFja2VkMkRDb29yZHModCxuKTticmVhaztjYXNlIDM6cltzXT10aGlzLmdldE91dHB1dFBhY2tlZDNEQ29vcmRzKHQsbik7YnJlYWs7ZGVmYXVsdDpyW3NdPXRoaXMuZ2V0T3V0cHV0UGFja2VkTkRDb29yZHModCxuKX1jb25zdCBhPWBcXG4gICAgICB2b2lkIHNldE91dHB1dCh2ZWM0IHZhbCkge1xcbiAgICAgICAgJHsoMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikub3V0cHV0fSA9IHZhbDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIHIuZmxvYXRUZXh0dXJlU2V0UkdCQT1uZXcgby5HbHNsTGliUm91dGluZShhKSxyfWdldFVucGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KGUpe2NvbnN0IHQ9ZS51bnBhY2tlZFNoYXBlLG49W2Uud2lkdGgsZS5oZWlnaHRdLHI9e30scz1cImdldE91dHB1dENvb3Jkc1wiO3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJbc109dGhpcy5nZXRPdXRwdXRTY2FsYXJDb29yZHMoKTticmVhaztjYXNlIDE6cltzXT10aGlzLmdldE91dHB1dFVucGFja2VkMURDb29yZHModCxuKTticmVhaztjYXNlIDI6cltzXT10aGlzLmdldE91dHB1dFVucGFja2VkMkRDb29yZHModCxuKTticmVhaztjYXNlIDM6cltzXT10aGlzLmdldE91dHB1dFVucGFja2VkM0RDb29yZHModCxuKTticmVhaztjYXNlIDQ6cltzXT10aGlzLmdldE91dHB1dFVucGFja2VkNERDb29yZHModCxuKTticmVhaztjYXNlIDU6cltzXT10aGlzLmdldE91dHB1dFVucGFja2VkNURDb29yZHModCxuKTticmVhaztjYXNlIDY6cltzXT10aGlzLmdldE91dHB1dFVucGFja2VkNkRDb29yZHModCxuKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3V0cHV0IGRpbWVuc2lvbmFsaXR5OiAke3QubGVuZ3RofWApfWNvbnN0IGE9YFxcbiAgICAgICAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgdmFsKSB7XFxuICAgICAgICAgICR7KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLm91dHB1dH0gPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XFxuICAgICAgICB9XFxuICAgIGA7cmV0dXJuIHIuZmxvYXRUZXh0dXJlU2V0Uj1uZXcgby5HbHNsTGliUm91dGluZShhKSxyfWdldE91dHB1dFNjYWxhckNvb3Jkcygpe3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gMDtcXG4gICAgICB9XFxuICAgIFwiKX1nZXRPdXRwdXRQYWNrZWQxRENvb3JkcyhlLHQpe2NvbnN0IG49dDtsZXQgcj1cIlwiO3JldHVybiAxPT09blswXT8ocj1gXFxuICAgICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDIgKiBpbnQoVGV4Q29vcmRzLnkgKiAke25bMV19LjApO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgLG5ldyBvLkdsc2xMaWJSb3V0aW5lKHIpKToxPT09blsxXT8ocj1gXFxuICAgICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIDIgKiBpbnQoVGV4Q29vcmRzLnggKiAke25bMF19LjApO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgLG5ldyBvLkdsc2xMaWJSb3V0aW5lKHIpKToocj1gXFxuICAgICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke25bMF19LCAke25bMV19KSk7XFxuICAgICAgICAgIHJldHVybiAyICogKHJlc1RleFJDLnkgKiAke25bMF19ICsgcmVzVGV4UkMueCk7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgby5HbHNsTGliUm91dGluZShyKSl9Z2V0T3V0cHV0UGFja2VkMkRDb29yZHMoZSx0KXtsZXQgbj1cIlwiO2lmKHIuQXJyYXlVdGlsLmFycmF5c0VxdWFsKGUsdCkpcmV0dXJuIG49YFxcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICByZXR1cm4gMiAqIGl2ZWMyKFRleENvb3Jkcy54eSAqIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xcbiAgICAgICAgfVxcbiAgICAgIGAsbmV3IG8uR2xzbExpYlJvdXRpbmUobik7Y29uc3QgaT10LHM9TWF0aC5jZWlsKGVbMV0vMik7cmV0dXJuIG49YFxcbiAgICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7aVswXX0sICR7aVsxXX0pKTtcXG5cXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7aVswXX0gKyByZXNUZXhSQy54O1xcblxcbiAgICAgICAgICAvLyByZXZlcnNlIHIgYW5kIGMgb3JkZXIgZm9yIHBhY2tlZCB0ZXh0dXJlXFxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHtzfSkgKiAyO1xcbiAgICAgICAgICBpbnQgYyA9IDIgKiAoaW5kZXggLyAke3N9KTtcXG5cXG4gICAgICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICAgICAgfVxcbiAgICAgIGAsbmV3IG8uR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0UGFja2VkM0RDb29yZHMoZSx0KXtjb25zdCBuPVt0WzBdLHRbMV1dLHI9TWF0aC5jZWlsKGVbMl0vMiksaT1yKk1hdGguY2VpbChlWzFdLzIpLHM9YFxcbiAgICAgICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7blswXX0sICR7blsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7blswXX0gKyByZXNUZXhSQy54O1xcblxcbiAgICAgICAgICBpbnQgYiA9IGluZGV4IC8gJHtpfTtcXG4gICAgICAgICAgaW5kZXggLT0gYiAqICR7aX07XFxuXFxuICAgICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcXG4gICAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke3J9KSAqIDI7XFxuICAgICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7cn0pO1xcblxcbiAgICAgICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUocyl9Z2V0T3V0cHV0UGFja2VkTkRDb29yZHMoZSx0KXtjb25zdCBuPVt0WzBdLHRbMV1dLHI9TWF0aC5jZWlsKGVbZS5sZW5ndGgtMV0vMiksaT1yKk1hdGguY2VpbChlW2UubGVuZ3RoLTJdLzIpO2xldCBzPWksYT1cIlwiLHU9XCJiLCByLCBjXCI7Zm9yKGxldCB0PTI7dDxlLmxlbmd0aC0xO3QrKylzKj1lW2UubGVuZ3RoLXQtMV0sYT1gXFxuICAgICAgaW50IGIke3R9ID0gaW5kZXggLyAke3N9O1xcbiAgICAgIGluZGV4IC09IGIke3R9ICogJHtzfTtcXG4gICAgYCthLHU9YGIke3R9LCBgK3U7Y29uc3QgbD1gXFxuICAgICAgaXZlYyR7ZS5sZW5ndGh9IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7blswXX0sICR7blsxXX0pKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke25bMF19ICsgcmVzVGV4UkMueDtcXG5cXG4gICAgICAgICR7YX1cXG5cXG4gICAgICAgIGludCBiID0gaW5kZXggLyAke2l9O1xcbiAgICAgICAgaW5kZXggLT0gYiAqICR7aX07XFxuXFxuICAgICAgICAvLyByZXZlcnNlIHIgYW5kIGMgb3JkZXIgZm9yIHBhY2tlZCB0ZXh0dXJlXFxuICAgICAgICBpbnQgciA9IGltb2QoaW5kZXgsICR7cn0pICogMjtcXG4gICAgICAgIGludCBjID0gMiAqIChpbmRleCAvICR7cn0pO1xcblxcbiAgICAgICAgcmV0dXJuIGl2ZWMke2UubGVuZ3RofSgke3V9KTtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGwpfWdldE91dHB1dFVucGFja2VkMURDb29yZHMoZSx0KXtjb25zdCBuPWBcXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xcbiAgICAgICAgICByZXR1cm4gcmVzVGV4UkMueSAqICR7dFswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkMkRDb29yZHMoZSx0KXtjb25zdCBuPWBcXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RbMF19LCAke3RbMV19KSk7XFxuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAgaW50IHIgPSBpbmRleCAvICR7ZVsxXX07XFxuICAgICAgICAgIGludCBjID0gaW5kZXggLSByICogJHtlWzFdfTtcXG4gICAgICAgICAgcmV0dXJuIGl2ZWMyKHIsIGMpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pfWdldE91dHB1dFVucGFja2VkM0RDb29yZHMoZSx0KXtsZXQgbj1cIlwiO2NvbnN0IHI9ZS5sZW5ndGg7bGV0IGk9bnVsbDtyPDImJihpPVtdKSxpPW5ldyBBcnJheShyLTEpLGlbci0yXT1lW3ItMV07Zm9yKGxldCB0PXItMzt0Pj0wOy0tdClpW3RdPWlbdCsxXSplW3QrMV07Y29uc3Qgcz1bXCJyXCIsXCJjXCIsXCJkXCJdLGE9aS5tYXAoKChlLHQpPT5gaW50ICR7c1t0XX0gPSBpbmRleCAvICR7ZX07ICR7dD09PWkubGVuZ3RoLTE/YGludCAke3NbdCsxXX0gPSBpbmRleCAtICR7c1t0XX0gKiAke2V9YDpgaW5kZXggLT0gJHtzW3RdfSAqICR7ZX1gfTtgKSkuam9pbihcIlwiKTtyZXR1cm4gbj1gXFxuICAgICAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0WzBdfSArIHJlc1RleFJDLng7XFxuICAgICAgICAgICR7YX1cXG4gICAgICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICAgICAgfVxcbiAgICAgIGAsbmV3IG8uR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyhlLHQpe2xldCBuPVwiXCI7Y29uc3Qgcj1lLmxlbmd0aDtsZXQgaT1udWxsO3I8MiYmKGk9W10pLGk9bmV3IEFycmF5KHItMSksaVtyLTJdPWVbci0xXTtmb3IobGV0IHQ9ci0zO3Q+PTA7LS10KWlbdF09aVt0KzFdKmVbdCsxXTtjb25zdCBzPVtcInJcIixcImNcIixcImRcIixcImQyXCJdLGE9aS5tYXAoKChlLHQpPT5gaW50ICR7c1t0XX0gPSBpbmRleCAvICR7ZX07ICR7dD09PWkubGVuZ3RoLTE/YGludCAke3NbdCsxXX0gPSBpbmRleCAtICR7c1t0XX0gKiAke2V9YDpgaW5kZXggLT0gJHtzW3RdfSAqICR7ZX1gfTtgKSkuam9pbihcIlwiKTtyZXR1cm4gbj1gXFxuICAgICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dFswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICAke2F9XFxuICAgICAgICAgIHJldHVybiBpdmVjNChyLCBjLCBkLCBkMik7XFxuICAgICAgICB9XFxuICAgICAgYCxuZXcgby5HbHNsTGliUm91dGluZShuKX1nZXRPdXRwdXRVbnBhY2tlZDVEQ29vcmRzKGUsdCl7bGV0IG49XCJcIjtjb25zdCByPWUubGVuZ3RoO2xldCBpPW51bGw7cjwyJiYoaT1bXSksaT1uZXcgQXJyYXkoci0xKSxpW3ItMl09ZVtyLTFdO2ZvcihsZXQgdD1yLTM7dD49MDstLXQpaVt0XT1pW3QrMV0qZVt0KzFdO2NvbnN0IHM9W1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCJdLGE9aS5tYXAoKChlLHQpPT5gaW50ICR7c1t0XX0gPSBpbmRleCAvICR7ZX07ICR7dD09PWkubGVuZ3RoLTE/YGludCAke3NbdCsxXX0gPSBpbmRleCAtICR7c1t0XX0gKiAke2V9YDpgaW5kZXggLT0gJHtzW3RdfSAqICR7ZX1gfTtgKSkuam9pbihcIlwiKTtyZXR1cm4gbj1gXFxuICAgICAgaXZlYzUgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dFswXX0sICR7dFsxXX0pKTtcXG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dFswXX0gKyByZXNUZXhSQy54O1xcbiAgICAgICAgICAke2F9XFxuICAgICAgICAgIHJldHVybiBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xcbiAgICAgICAgfVxcbiAgICAgIGAsbmV3IG8uR2xzbExpYlJvdXRpbmUobil9Z2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhlLHQpe2xldCBuPVwiXCI7Y29uc3Qgcj1lLmxlbmd0aDtsZXQgaT1udWxsO3I8MiYmKGk9W10pLGk9bmV3IEFycmF5KHItMSksaVtyLTJdPWVbci0xXTtmb3IobGV0IHQ9ci0zO3Q+PTA7LS10KWlbdF09aVt0KzFdKmVbdCsxXTtjb25zdCBzPVtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiLFwiZDRcIl0sYT1pLm1hcCgoKGUsdCk9PmBpbnQgJHtzW3RdfSA9IGluZGV4IC8gJHtlfTsgJHt0PT09aS5sZW5ndGgtMT9gaW50ICR7c1t0KzFdfSA9IGluZGV4IC0gJHtzW3RdfSAqICR7ZX1gOmBpbmRleCAtPSAke3NbdF19ICogJHtlfWB9O2ApKS5qb2luKFwiXCIpO3JldHVybiBuPWBcXG4gICAgIGl2ZWM2IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0WzBdfSwgJHt0WzFdfSkpO1xcbiAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RbMF19ICsgcmVzVGV4UkMueDtcXG4gICAgICAgICAke2F9XFxuICAgICAgICAgcmV0dXJuIGl2ZWM2KHIsIGMsIGQsIGQyLCBkMywgZDQpO1xcbiAgICAgICB9XFxuICAgICBgLG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4pfWdldENvbW1vblV0aWxGdW5jcygpe2NvbnN0IGU9e307bGV0IHQ9XCJ1dkZyb21GbGF0XCI7ZVt0XT1uZXcgby5HbHNsTGliUm91dGluZShcIlxcbiAgICB2ZWMyIHV2RnJvbUZsYXQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgaW5kZXgpIHtcXG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC8gdGV4TnVtUjtcXG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC0gdGV4QyAqIHRleE51bVI7XFxuICAgICAgLy8gVE9ETzogc3dhcCB0ZXhSLCB0ZXhDIG9yZGVyIGluIGZvbGxvd2luZyBmdW5jdGlvbiBzbyByb3cgaXMgY29ycmVzcG9uZGluZyB0byB1IGFuZCBjb2x1bW4gaXMgY29ycmVzcG9uZGluZyB0b1xcbiAgICAgIC8vICAgICAgIHYuXFxuICAgICAgcmV0dXJuICh2ZWMyKHRleFIsIHRleEMpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtUiwgdGV4TnVtQyk7XFxuICAgIH1cXG4gICAgXCIpLHQ9XCJwYWNrZWRVVmZyb20xRFwiLGVbdF09bmV3IG8uR2xzbExpYlJvdXRpbmUoXCJcXG4gICAgICB2ZWMyIHBhY2tlZFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICAgICAgICBpbnQgdGV4ZWxJbmRleCA9IGluZGV4IC8gMjtcXG4gICAgICAgIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XFxuICAgICAgICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbiAgICAgIH1cXG4gICAgICBcIiksdD1cInBhY2tlZFVWZnJvbTJEXCIsZVt0XT1uZXcgby5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tMkQoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICBpbnQgdGV4ZWxJbmRleCA9IChyb3cgLyAyKSAqIHRleGVsc0luTG9naWNhbFJvdyArIChjb2wgLyAyKTtcXG4gICAgICAgIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XFxuICAgICAgICBpbnQgdGV4QyA9IHRleGVsSW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbiAgICAgIH1cXG4gICAgICBcIiksdD1cInBhY2tlZFVWZnJvbTNEXCIsZVt0XT1uZXcgby5HbHNsTGliUm91dGluZShcIlxcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLFxcbiAgICAgICAgICBpbnQgdGV4ZWxzSW5CYXRjaCwgaW50IHRleGVsc0luTG9naWNhbFJvdywgaW50IGIsXFxuICAgICAgICAgIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIGludCBpbmRleCA9IGIgKiB0ZXhlbHNJbkJhdGNoICsgKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgICAgICAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICAgICAgICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG4gICAgICB9XFxuICAgICAgXCIpLHQ9XCJzYW1wbGVUZXh0dXJlXCI7Y29uc3Qgbj0oMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7cmV0dXJuIGVbdF09bmV3IG8uR2xzbExpYlJvdXRpbmUoYFxcbiAgICAgICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcXG4gICAgICAgICAgICByZXR1cm4gJHtuLnRleHR1cmUyRH0odGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xcbiAgICAgICAgfWApLGV9Z2V0SW5wdXRzU2FtcGxpbmdTbmlwcGV0cygpe2NvbnN0IGU9e30sdD10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKG4scik9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW3JdLGk9KDAsYS5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUpKG4pO28uaXNQYWNrZWQ/ZVtpXT10aGlzLmdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoaSxuLG8pOmVbaV09dGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoaSxuLG8pO2NvbnN0IHM9KDAsYS5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWVBdE91dENvb3Jkcykobik7by51bnBhY2tlZFNoYXBlLmxlbmd0aDw9dC51bnBhY2tlZFNoYXBlLmxlbmd0aCYmKG8uaXNQYWNrZWQ/ZVtzXT10aGlzLmdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhzLG8sdCxuKTplW3NdPXRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMocyxvLHQsbikpfSkpLGV9Z2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzKGUsdCxuLGkpe2NvbnN0IHM9dC51bnBhY2tlZFNoYXBlLHU9bi51bnBhY2tlZFNoYXBlLGw9aSxjPSgwLGEuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKShsKSxwPXMubGVuZ3RoLGQ9dS5sZW5ndGgsZj1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyhzLHUpLGg9KDAsYS5nZXRDb29yZHNEYXRhVHlwZSkoZCksZz1kLXA7bGV0IGI7Y29uc3QgbT0oMCxhLmdldEdsQ2hhbm5lbHMpKCk7Yj0wPT09cD9cIlwiOmQ8MiYmZi5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOmYubWFwKChlPT5gY29vcmRzLiR7bVtlK2ddfSA9IDA7YCkpLmpvaW4oXCJcXG5cIik7bGV0IHk9XCJcIjt5PWQ8MiYmcD4wP1wiY29vcmRzXCI6cy5tYXAoKChlLHQpPT5gY29vcmRzLiR7bVt0K2ddfWApKS5qb2luKFwiLCBcIik7bGV0IF89XCJyZXR1cm4gb3V0cHV0VmFsdWU7XCI7Y29uc3Qgdj0xPT09ci5TaGFwZVV0aWwuc2l6ZShzKSxUPTE9PT1yLlNoYXBlVXRpbC5zaXplKHUpO2lmKDEhPT1wfHx2fHxUKXtpZih2JiYhVClfPTE9PT1kP1wiXFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLngsIDAuLCAwLik7XFxuICAgICAgICBcIjpcIlxcbiAgICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTtcXG4gICAgICAgIFwiO2Vsc2UgaWYoZi5sZW5ndGgpe2NvbnN0IGU9cC0yLHQ9cC0xO2YuaW5kZXhPZihlKT4tMSYmZi5pbmRleE9mKHQpPi0xP189XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTtcIjpmLmluZGV4T2YoZSk+LTE/Xz1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnksIG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnkpO1wiOmYuaW5kZXhPZih0KT4tMSYmKF89XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUuenopO1wiKX19ZWxzZSBfPVwiXFxuICAgICAgICByZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eSwgb3V0cHV0VmFsdWUueHkpO1xcbiAgICAgIFwiO2NvbnN0IHg9YFxcbiAgICAgIHZlYzQgJHtlfSgpIHtcXG4gICAgICAgICR7aH0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcXG4gICAgICAgIGludCBsYXN0RGltID0gY29vcmRzLiR7bVtkLTFdfTtcXG4gICAgICAgIGNvb3Jkcy4ke21bZC0xXX0gPSBjb29yZHMuJHttW2QtMl19O1xcbiAgICAgICAgY29vcmRzLiR7bVtkLTJdfSA9IGxhc3REaW07XFxuICAgICAgXFxuICAgICAgICAke2J9XFxuICAgICAgICB2ZWM0IG91dHB1dFZhbHVlID0gJHtjfSgke3l9KTtcXG4gICAgICAgICR7X31cXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKHgsW1wiY29vcmRpbmF0ZXMuZ2V0T3V0cHV0Q29vcmRzXCJdKX1nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhlLHQsbixpKXtjb25zdCBzPVtuLndpZHRoLG4uaGVpZ2h0XSx1PVt0LndpZHRoLHQuaGVpZ2h0XSxsPXQudW5wYWNrZWRTaGFwZS5sZW5ndGgsYz1uLnVucGFja2VkU2hhcGUubGVuZ3RoLHA9dC51bnBhY2tlZFNoYXBlLGQ9bi51bnBhY2tlZFNoYXBlLGY9KDAsYS5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUpKGkpO2lmKGw9PT1jJiZyLkFycmF5VXRpbC5hcnJheXNFcXVhbCh1LHMpKXtjb25zdCB0PWBcXG4gICAgICAgICAgZmxvYXQgJHtlfSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke2l9LCBUZXhDb29yZHMpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZSh0LFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWNvbnN0IGg9KDAsYS5nZXRDb29yZHNEYXRhVHlwZSkoYyksZz1yLkJyb2FkY2FzdFV0aWwuZ2V0QnJvYWRjYXN0RGltcyhwLGQpLGI9Yy1sO2xldCBtO2NvbnN0IHk9KDAsYS5nZXRHbENoYW5uZWxzKSgpO209MD09PWw/XCJcIjpjPDImJmcubGVuZ3RoPj0xP1wiY29vcmRzID0gMDtcIjpnLm1hcCgoZT0+YGNvb3Jkcy4ke3lbZStiXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpO2xldCBfPVwiXCI7Xz1jPDImJmw+MD9cImNvb3Jkc1wiOnQudW5wYWNrZWRTaGFwZS5tYXAoKChlLHQpPT5gY29vcmRzLiR7eVt0K2JdfWApKS5qb2luKFwiLCBcIik7Y29uc3Qgdj1gXFxuICAgICAgICBmbG9hdCAke2V9KCkge1xcbiAgICAgICAgICAke2h9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICAke219XFxuICAgICAgICAgIHJldHVybiAke2Z9KCR7X30pO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKHYsW1wiY29vcmRpbmF0ZXMuZ2V0T3V0cHV0Q29vcmRzXCJdKX1nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGUsdCxuKXtzd2l0Y2gobi51bnBhY2tlZFNoYXBlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJTY2FsYXIoZSx0KTtjYXNlIDE6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjFEKGUsdCxuKTtjYXNlIDI6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjJEKGUsdCxuKTtjYXNlIDM6cmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjNEKGUsdCxuKTtkZWZhdWx0OnJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJORChlLHQsbil9fWdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChlLHQsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGU7c3dpdGNoKHIubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyU2NhbGFyKGUsdCxuKTtjYXNlIDE6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyMUQoZSx0LG4pO2Nhc2UgMjpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIyRChlLHQsbik7Y2FzZSAzOnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjNEKGUsdCxuKTtjYXNlIDQ6cmV0dXJuIHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyNEQoZSx0LG4pO2Nhc2UgNTpyZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI1RChlLHQsbik7Y2FzZSA2OnJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlcjZEKGUsdCxuKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGltZW5zaW9uICR7ci5sZW5ndGh9LURgKX19Z2V0UGFja2VkU2FtcGxlclNjYWxhcihlLHQpe2NvbnN0IG49YFxcbiAgICAgICAgICB2ZWM0ICR7ZX0oKSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLnRleHR1cmUyRH0oJHt0fSwgaGFsZkNSKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobil9Z2V0UGFja2VkU2FtcGxlcjFEKGUsdCxuKXtjb25zdCByPVtuLndpZHRoLG4uaGVpZ2h0XSxzPVtyWzFdLHJbMF1dLGE9KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLHU9YHZlYzQgJHtlfShpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gcGFja2VkVVZmcm9tMUQoXFxuICAgICAgJHtzWzBdfSwgJHtzWzFdfSwgaW5kZXgpO1xcbiAgICAgIHJldHVybiAke2EudGV4dHVyZTJEfSgke3R9LCB1dik7XFxuICAgIH1gO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZSh1LFtcImNvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTFEXCJdKX1nZXRQYWNrZWRTYW1wbGVyMkQoZSx0LG4pe2NvbnN0IHM9bi51bnBhY2tlZFNoYXBlLGE9W24ud2lkdGgsbi5oZWlnaHRdLHU9KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLGw9YVswXSxjPWFbMV07aWYobnVsbCE9YSYmci5BcnJheVV0aWwuYXJyYXlzRXF1YWwocyxhKSl7Y29uc3Qgbj1gdmVjNCAke2V9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMigke2N9LjAsICR7bH0uMCk7XFxuICAgICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHt0fSwgdXYpO1xcbiAgICAgIH1gO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuKX1jb25zdCBwPWEsZD1NYXRoLmNlaWwoc1sxXS8yKSxmPWB2ZWM0ICR7ZX0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRCgke3BbMV19LCAke3BbMF19LCAke2R9LCByb3csIGNvbCk7XFxuICAgICAgcmV0dXJuICR7dS50ZXh0dXJlMkR9KCR7dH0sIHV2KTtcXG4gICAgfWA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGYsW1wiY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMkRcIl0pfWdldFBhY2tlZFNhbXBsZXIzRChlLHQsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUscz1bbi53aWR0aCxuLmhlaWdodF0sdT1bc1swXSxzWzFdXSxsPSgwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtpZigxPT09clswXSl7Y29uc3QgaT1yLnNsaWNlKDEpLHM9WzEsMl0sdT0oMCxhLnNxdWVlemVJbnB1dFNoYXBlKShyLGkpLGw9W1wiYlwiLFwicm93XCIsXCJjb2xcIl0sYz1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTtjLnVucGFja2VkU2hhcGU9dTtjb25zdCBwPXRoaXMuZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dChlLHQsYyksZD1gJHtwLnJvdXRpbmVCb2R5fVxcbiAgICAgIHZlYzQgJHtlfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgcmV0dXJuICR7ZX0oJHsoMCxhLmdldFNxdWVlemVkUGFyYW1zKShsLHMpfSk7XFxuICAgICAgfSBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShkLHAuZGVwZW5kZW5jaWVzKX1jb25zdCBjPXVbMF0scD11WzFdLGQ9TWF0aC5jZWlsKHJbMl0vMiksZj1gdmVjNCAke2V9KGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxcbiAgICAgICAgJHtwfSwgJHtjfSwgJHtkKk1hdGguY2VpbChyWzFdLzIpfSwgJHtkfSwgYiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiAke2wudGV4dHVyZTJEfSgke3R9LCB1dik7fWA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGYsW1wiY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tM0RcIl0pfWdldFBhY2tlZFNhbXBsZXJORChlLHQsbil7Y29uc3Qgcj1uLnVucGFja2VkU2hhcGUscz1yLmxlbmd0aCxhPVtuLndpZHRoLG4uaGVpZ2h0XSx1PSgwLGkuZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKSxsPVthWzBdLGFbMV1dLGM9bFsxXSxwPWxbMF0sZD1NYXRoLmNlaWwocltzLTFdLzIpO2xldCBmPWQqTWF0aC5jZWlsKHJbcy0yXS8yKSxoPVwiaW50IGIsIGludCByb3csIGludCBjb2xcIixnPWBiICogJHtmfSArIChyb3cgLyAyKSAqICR7ZH0gKyAoY29sIC8gMilgO2ZvcihsZXQgZT0yO2U8cy0xO2UrKyloPWBpbnQgYiR7ZX0sIGAraCxmKj1yW3MtZS0xXSxnPWBiJHtlfSAqICR7Zn0gKyBgK2c7Y29uc3QgYj1gdmVjNCAke2V9KCR7aH0pIHtcXG4gICAgICBpbnQgaW5kZXggPSAke2d9O1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyAke3B9O1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogJHtwfTtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMigke3B9LCAke2N9KTtcXG4gICAgICByZXR1cm4gJHt1LnRleHR1cmUyRH0oJHt0fSwgdXYpO1xcbiAgICB9YDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoYil9Z2V0VW5wYWNrZWRTYW1wbGVyU2NhbGFyKGUsdCxuKXtjb25zdFtyLGldPVtuLndpZHRoLG4uaGVpZ2h0XTtpZigxPT09ciYmMT09PWkpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke2V9KCkge1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIGhhbGZDUik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3Qgcz1gXFxuICAgICAgICBmbG9hdCAke2V9KCkge1xcbiAgICAgICAgICBpbnQgb2Zmc2V0XyR7dH0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7cn0sICR7aX0pO1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3J9LCAke2l9LCBvZmZzZXRfJHt0fSk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShzLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0XCJdKX1nZXRVbnBhY2tlZFNhbXBsZXIxRChlLHQsbil7Y29uc3Qgcj1uLndpZHRoLGk9bi5oZWlnaHQ7aWYoMT09PWkmJjE9PT1yKXtjb25zdCBuPWBcXG4gICAgICAgIGZsb2F0ICR7ZX0oaW50IGluZGV4KSB7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIGhhbGZDUik7XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCJdKX1pZigxPT09aSl7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IGluZGV4KSB7XFxuICAgICAgICAgICAgdmVjMiB1diA9IHZlYzIoKGZsb2F0KGluZGV4KSArIDAuNSkgLyAke3J9LjAsIDAuNSk7XFxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShuLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWlmKDE9PT1yKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgaW5kZXgpIHtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gJHtpfS4wKTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3Qgcz1gXFxuICAgICAgICBmbG9hdCAke2V9KGludCBpbmRleCkge1xcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3J9LCAke2l9LCBpbmRleCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShzLFtcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIixcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIl0pfWdldFVucGFja2VkU2FtcGxlcjJEKGUsdCxuKXtjb25zdCBpPW4udW5wYWNrZWRTaGFwZSx1PVtuLmhlaWdodCxuLndpZHRoXTtpZihudWxsIT11JiZyLkFycmF5VXRpbC5hcnJheXNFcXVhbChpLHUpKXtjb25zdCBuPWBcXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHJvdywgY29sKSArIGhhbGZDUikgLyB2ZWMyKCR7dVsxXX0uMCwgJHt1WzBdfS4wKTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3R7bmV3U2hhcGU6bCxrZXB0RGltczpjfT0oMCxzLnNxdWVlemVTaGFwZSkoaSkscD1sO2lmKHAubGVuZ3RoPGkubGVuZ3RoKXtjb25zdCByPSgwLGEuc3F1ZWV6ZUlucHV0U2hhcGUpKGkscCkscz1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTtzLnVucGFja2VkU2hhcGU9cjtjb25zdCB1PVtcImNvbFwiLFwicm93XCJdLGw9YFxcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGUsdCxzKS5yb3V0aW5lQm9keX1cXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7ZX0oJHsoMCxhLmdldFNxdWVlemVkUGFyYW1zKSh1LGMpfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGwsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Y29uc3QgZD11WzFdLGY9dVswXTtpZigxPT09Zil7Y29uc3Qgbj1gXFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIGludCBvZmZzZXRfJHt0fSA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtkfSwgJHtmfSk7XFxuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7dH0pLCB2ZWMzKCR7aVsxXX0sIDEsIDEpKTtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyAke2R9LjApO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobixbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9aWYoMT09PWQpe2NvbnN0IG49YFxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7dH0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7ZH0sICR7Zn0pO1xcbiAgICAgICAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIG9mZnNldF8ke3R9KSwgdmVjMygke2lbMV19LCAxLCAxKSk7XFxuICAgICAgICAgICAgdmVjMiB1diA9IHZlYzIoKGluZGV4ICsgMC41KSAvICR7Zn0uMCwgMC41KTtcXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke3R9LCB1dik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKG4sW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWNvbnN0IGg9YFxcbiAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICAgIGludCBpbmRleCA9IGNvbCAqICR7aVsxXX0gKyByb3c7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7ZH0sICR7Zn0sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGgsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjNEKGUsdCxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxpPXJbMV0qclsyXSx1PXJbMl0se25ld1NoYXBlOmwsa2VwdERpbXM6Y309KDAscy5zcXVlZXplU2hhcGUpKHIpLHA9bDtpZihwLmxlbmd0aDxyLmxlbmd0aCl7Y29uc3QgaT0oMCxhLnNxdWVlemVJbnB1dFNoYXBlKShyLHApLHM9W1wiYmF0Y2hcIixcImNvbFwiLFwicm93XCJdLHU9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuKSk7dS51bnBhY2tlZFNoYXBlPWk7Y29uc3QgbD10aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChlLHQsdSksZD1jLnJldmVyc2UoKSxmPWBcXG4gICAgICAgICAgJHtsLnJvdXRpbmVCb2R5fVxcbiAgICAgICAgICBmbG9hdCAke2V9KGludCBiYXRjaCwgaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgICAgIHJldHVybiAke2V9KCR7KDAsYS5nZXRTcXVlZXplZFBhcmFtcykocyxkKX0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShmLGwuZGVwZW5kZW5jaWVzKX1jb25zdCBkPWBcXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgZGVwdGgsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgICAgICAgaW50IGluZGV4ID0gZGVwdGggKiAke2l9ICsgY29sICogJHt1fSArIHJvdztcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke24ud2lkdGh9LCAke24uaGVpZ2h0fSwgaW5kZXgpO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGQsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjREKGUsdCxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxpPXJbM10scz1yWzJdKmksYT1gXFxuICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3JbMV0qc30gKyBjb2wgKiAke3N9ICtcXG4gICAgICAgICAgICAgIGRlcHRoMiAqICR7aX0gKyBkZXB0aDtcXG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHtuLndpZHRofSwgJHtuLmhlaWdodH0sIGluZGV4KTtcXG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHt0fSwgdXYpO1xcbiAgICAgICAgfVxcbiAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiLFwiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiXSl9Z2V0VW5wYWNrZWRTYW1wbGVyNUQoZSx0LG4pe2NvbnN0IHI9bi51bnBhY2tlZFNoYXBlLGk9cls0XSx1PXJbM10qaSxsPXJbMl0qdSxjPXJbMV0qbCx7bmV3U2hhcGU6cCxrZXB0RGltczpkfT0oMCxzLnNxdWVlemVTaGFwZSkocik7aWYocC5sZW5ndGg8ci5sZW5ndGgpe2NvbnN0IGk9KDAsYS5zcXVlZXplSW5wdXRTaGFwZSkocixwKSxzPVtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIl0sdT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTt1LnVucGFja2VkU2hhcGU9aTtjb25zdCBsPWBcXG4gICAgICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChlLHQsdSkucm91dGluZUJvZHl9XFxuICAgICAgICAgIGZsb2F0ICR7ZX0oaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgICAgICAgcmV0dXJuICR7ZX0oJHsoMCxhLmdldFNxdWVlemVkUGFyYW1zKShzLGQpfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGA7cmV0dXJuIG5ldyBvLkdsc2xMaWJSb3V0aW5lKGwsW1wiY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZVwiLFwiY29vcmRpbmF0ZXMudXZGcm9tRmxhdFwiXSl9Y29uc3QgZj1gXFxuICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke2N9ICsgY29sICogJHtsfSArIGRlcHRoICogJHt1fSArXFxuICAgICAgICAgIGRlcHRoMyAqICR7aX0gKyBkZXB0aDI7XFxuICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7bi53aWR0aH0sICR7bi5oZWlnaHR9LCBpbmRleCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBgO3JldHVybiBuZXcgby5HbHNsTGliUm91dGluZShmLFtcImNvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmVcIixcImNvb3JkaW5hdGVzLnV2RnJvbUZsYXRcIl0pfWdldFVucGFja2VkU2FtcGxlcjZEKGUsdCxuKXtjb25zdCByPW4udW5wYWNrZWRTaGFwZSxpPXJbNV0sdT1yWzRdKmksbD1yWzNdKnUsYz1yWzJdKmwscD1yWzFdKmMse25ld1NoYXBlOmQsa2VwdERpbXM6Zn09KDAscy5zcXVlZXplU2hhcGUpKHIpO2lmKGQubGVuZ3RoPHIubGVuZ3RoKXtjb25zdCBpPSgwLGEuc3F1ZWV6ZUlucHV0U2hhcGUpKHIsZCkscz1bXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIixcImRlcHRoMlwiLFwiZGVwdGgzXCIsXCJkZXB0aDRcIl0sdT1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKTt1LnVucGFja2VkU2hhcGU9aTtjb25zdCBsPWBcXG4gICAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGUsdCx1KS5yb3V0aW5lQm9keX1cXG4gICAgICAgICAgICBmbG9hdCAke2V9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgICAgICAgIHJldHVybiAke2V9KCR7KDAsYS5nZXRTcXVlZXplZFBhcmFtcykocyxmKX0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUobCxbXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCJdKX1jb25zdCBoPWBcXG4gICAgICAgICAgZmxvYXQgJHtlfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgICAgIGludCBpbmRleCA9IHJvdyAqICR7cH0gKyBjb2wgKiAke2N9ICsgZGVwdGggKiAke2x9ICtcXG4gICAgICAgICAgICBkZXB0aDIgKiAke3V9ICsgZGVwdGgzICogJHtpfSArIGRlcHRoNDtcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke24ud2lkdGh9LCAke24uaGVpZ2h0fSwgaW5kZXgpO1xcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7dH0sIHV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm4gbmV3IG8uR2xzbExpYlJvdXRpbmUoaCxbXCJjb29yZGluYXRlcy51dkZyb21GbGF0XCIsXCJjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlXCIsXCJjb29yZGluYXRlcy5jb29yZHNUb09mZnNldFwiXSl9dG9WZWMoKXtjb25zdCBlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LHQ9ZS5zaGFwZS5sZW5ndGgsbj1lLnN0cmlkZXMscj1lLndpZHRoLGk9ZS5oZWlnaHQscz1bXTtmb3IobGV0IGU9MDtlPHQtMTsrK2Upcy5wdXNoKGBcXG4gICAgICAgIGNbJHtlfV0gPSBvZmZzZXQgLyAke25bZV19O2ApLHMucHVzaChgXFxuICAgICAgICBvZmZzZXQgLT0gY1ske2V9XSAqICR7bltlXX07YCk7cy5wdXNoKGBcXG4gICAgICAgIGNbJHt0LTF9XSA9IG9mZnNldDtgKTtjb25zdCBhPWBcXG4gICAgICB2b2lkIHRvVmVjKHZlYzIgdGV4Q29vcmRzLCBvdXQgaW50IGNbJHt0fV0pIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldCh0ZXhDb29yZHMsICR7cn0sICR7aX0pO1xcbiAgICAgICAgJHtzLmpvaW4oXCJcIil9XFxuICAgICAgfVxcbiAgICAgIHZvaWQgdG9WZWMoaW50IG9mZnNldCwgb3V0IGludCBjWyR7dH1dKSB7XFxuICAgICAgICAke3Muam9pbihcIlwiKX1cXG4gICAgICB9XFxuICAgIGA7cmV0dXJue3RvVmVjOm5ldyBvLkdsc2xMaWJSb3V0aW5lKGEsW1wiY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXRcIl0pfX12YWx1ZUZyb20oKXtjb25zdCBlPXt9O3JldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKCgodCxuKT0+e2NvbnN0IHI9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0saT0oci51bnBhY2tlZFNoYXBlLmxlbmd0aD4wP3IudW5wYWNrZWRTaGFwZTpyLnNoYXBlKS5sZW5ndGg7bGV0IHM9YF8ke3R9YDtlW3NdPW5ldyBvLkdsc2xMaWJSb3V0aW5lKHRoaXMuZ2V0VmFsdWVGcm9tU2luZ2xlKHQsaSxyLndpZHRoLHIuaGVpZ2h0LCExKSxbYHNoYXBlVXRpbHMuaW5kaWNlc1RvT2Zmc2V0JHtzfWAsXCJjb29yZGluYXRlcy5vZmZzZXRUb0Nvb3Jkc1wiLFwiZnJhZ2NvbG9yLmdldENvbG9yQXNGbG9hdFwiXSkscys9XCJfVFwiLGVbc109bmV3IG8uR2xzbExpYlJvdXRpbmUodGhpcy5nZXRWYWx1ZUZyb21TaW5nbGUodCxpLHIud2lkdGgsci5oZWlnaHQsITApLFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke3N9YCxcImNvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzXCIsXCJmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0XCJdKX0pKSxlfWdldFZhbHVlRnJvbVNpbmdsZShlLHQsbixyLG8pe2xldCBzPWBfJHtlfWA7cmV0dXJuIG8mJihzKz1cIl9UXCIpLGBcXG4gICAgICAgIGZsb2F0ICR7c30oaW50IG1bJHt0fV0pIHtcXG4gICAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldCR7c30obSk7XFxuICAgICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke259LCAke3J9KTtcXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHsoMCxpLmdldEdsc2wpKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfSgke2V9LCBjb29yZHMpKTtcXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgYH1nZXRQYWNrZWRWYWx1ZUZyb20oZSx0LG4scixvKXtsZXQgcz1gXyR7ZX1fUGFja2A7cmV0dXJuIG8mJihzKz1cIl9UXCIpLGBcXG4gICAgICAgIHZlYzQgJHtzfShpbnQgbVske3R9XSkge1xcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0XyR7ZX0obSk7XFxuICAgICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke259LCAke3J9KTtcXG4gICAgICAgICAgcmV0dXJuICR7KDAsaS5nZXRHbHNsKSh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pLnRleHR1cmUyRH0oJHtlfSwgY29vcmRzKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGB9fXQuQ29vcmRzR2xzbExpYj11fSwxOTk3OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIG47T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Ub3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXM9dC5HbHNsTGliUm91dGluZU5vZGU9dC5HbHNsTGliUm91dGluZT10Lkdsc2xMaWI9dC5HbHNsQ29udGV4dD10LkZ1bmN0aW9uVHlwZT12b2lkIDAsKG49dC5GdW5jdGlvblR5cGV8fCh0LkZ1bmN0aW9uVHlwZT17fSkpW24uVmFsdWVCYXNlZD0wXT1cIlZhbHVlQmFzZWRcIixuW24uUG9zaXRpb25hbD0xXT1cIlBvc2l0aW9uYWxcIix0Lkdsc2xDb250ZXh0PWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLHIpe3RoaXMuZ2xDb250ZXh0PWUsdGhpcy5wcm9ncmFtSW5mbz10LHRoaXMuaW5wdXRUZXh0dXJlTGF5b3V0cz1uLHRoaXMub3V0cHV0VGV4dHVyZUxheW91dD1yfX0sdC5HbHNsTGliPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuY29udGV4dD1lfX0sdC5HbHNsTGliUm91dGluZT1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMucm91dGluZUJvZHk9ZSx0aGlzLmRlcGVuZGVuY2llcz10fX0sdC5HbHNsTGliUm91dGluZU5vZGU9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMubmFtZT1lLHRoaXMuZGVwZW5kZW5jaWVzPW58fFtdLHQmJih0aGlzLnJvdXRpbmVCb2R5PXQpfWFkZERlcGVuZGVuY3koZSl7ZSYmdGhpcy5kZXBlbmRlbmNpZXMucHVzaChlKX19LHQuVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzPWNsYXNze3N0YXRpYyByZXR1cm5PcmRlcmVkTm9kZXMoZSl7aWYoIWV8fDA9PT1lLmxlbmd0aClyZXR1cm5bXTtpZigxPT09ZS5sZW5ndGgpcmV0dXJuIGU7Y29uc3QgdD1uZXcgU2V0LG49bmV3IFNldCxyPW5ldyBBcnJheTtyZXR1cm4gdGhpcy5jcmVhdGVPcmRlcmVkTm9kZXMoZSx0LG4scikscn1zdGF0aWMgY3JlYXRlT3JkZXJlZE5vZGVzKGUsdCxuLHIpe2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7KytvKXRoaXMuZGZzVHJhdmVyc2UoZVtvXSx0LG4scil9c3RhdGljIGRmc1RyYXZlcnNlKGUsdCxuLHIpe2lmKCFlfHxuLmhhcyhlLm5hbWUpKXJldHVybjtpZih0LmhhcyhlLm5hbWUpKXRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGRldGVjdGVkLiBDYW4ndCB0b3BvbG9naWNhbGx5IHNvcnQgcm91dGluZXMgbmVlZGVkIGZvciBzaGFkZXIuXCIpO3QuYWRkKGUubmFtZSk7Y29uc3Qgbz1lLmRlcGVuZGVuY2llcztpZihvJiZvLmxlbmd0aD4wKWZvcihsZXQgZT0wO2U8by5sZW5ndGg7KytlKXRoaXMuZGZzVHJhdmVyc2Uob1tlXSx0LG4scik7ci5wdXNoKGUpLG4uYWRkKGUubmFtZSksdC5kZWxldGUoZS5uYW1lKX19fSwxMzcxOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkVuY29kaW5nR2xzbExpYj12b2lkIDA7Y29uc3Qgcj1uKDE5OTcpO2NsYXNzIG8gZXh0ZW5kcyByLkdsc2xMaWJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9Z2V0RnVuY3Rpb25zKCl7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLmVuY29kZUZsb2F0MzIoKSksdGhpcy5kZWNvZGVGbG9hdDMyKCkpfWdldEN1c3RvbVR5cGVzKCl7cmV0dXJue319ZW5jb2RlRmxvYXQzMigpe3JldHVybntlbmNvZGU6bmV3IHIuR2xzbExpYlJvdXRpbmUoXCJoaWdocCB2ZWM0IGVuY29kZShoaWdocCBmbG9hdCBmKSB7XFxuICAgICAgICByZXR1cm4gdmVjNChmLCAwLjAsIDAuMCwgMC4wKTtcXG4gICAgICB9XFxuICAgICAgICBcIil9fWRlY29kZUZsb2F0MzIoKXtyZXR1cm57ZGVjb2RlOm5ldyByLkdsc2xMaWJSb3V0aW5lKFwiaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgICAgcmV0dXJuIHJnYmEucjtcXG4gICAgICB9XFxuICAgICAgICBcIil9fWVuY29kZVVpbnQ4KCl7Y29uc3QgZT1vLmlzTGl0dGxlRW5kaWFuKCk/XCJyZ2JhLnJnYmE9cmdiYS5hYmdyO1wiOlwiXCI7cmV0dXJue2VuY29kZTpuZXcgci5HbHNsTGliUm91dGluZShgXFxuICAgICAgaGlnaHAgdmVjNCBlbmNvZGUoaGlnaHAgZmxvYXQgZikge1xcbiAgICAgICAgaGlnaHAgZmxvYXQgRiA9IGFicyhmKTtcXG4gICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSBzdGVwKDAuMCwtZik7XFxuICAgICAgICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikpO1xcbiAgICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSAoZXhwMigtIEV4cG9uZW50KSAqIEYpO1xcbiAgICAgICAgRXhwb25lbnQgPSBmbG9vcihsb2cyKEYpICsgMTI3LjApICsgZmxvb3IobG9nMihNYW50aXNzYSkpO1xcbiAgICAgICAgaGlnaHAgdmVjNCByZ2JhO1xcbiAgICAgICAgcmdiYVswXSA9IDEyOC4wICogU2lnbiAgKyBmbG9vcihFeHBvbmVudCpleHAyKC0xLjApKTtcXG4gICAgICAgIHJnYmFbMV0gPSAxMjguMCAqIG1vZChFeHBvbmVudCwyLjApICsgbW9kKGZsb29yKE1hbnRpc3NhKjEyOC4wKSwxMjguMCk7XFxuICAgICAgICByZ2JhWzJdID0gZmxvb3IobW9kKGZsb29yKE1hbnRpc3NhKmV4cDIoMjMuMCAtOC4wKSksZXhwMig4LjApKSk7XFxuICAgICAgICByZ2JhWzNdID0gZmxvb3IoZXhwMigyMy4wKSptb2QoTWFudGlzc2EsZXhwMigtMTUuMCkpKTtcXG4gICAgICAgICR7ZX1cXG4gICAgICAgIHJnYmEgPSByZ2JhIC8gMjU1LjA7IC8vIHZhbHVlcyBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQgdG8gWzAsMV1cXG4gICAgICAgIHJldHVybiByZ2JhO1xcbiAgICB9XFxuICAgICAgICBgKX19ZGVjb2RlVWludDgoKXtjb25zdCBlPW8uaXNMaXR0bGVFbmRpYW4oKT9cInJnYmEucmdiYT1yZ2JhLmFiZ3I7XCI6XCJcIjtyZXR1cm57ZGVjb2RlOm5ldyByLkdsc2xMaWJSb3V0aW5lKGBcXG4gICAgICAgIGhpZ2hwIGZsb2F0IGRlY29kZShoaWdocCB2ZWM0IHJnYmEpIHtcXG4gICAgICAgICAgcmdiYSA9IHJnYmEgKiAyNTUuMDsgLy8gdmFsdWVzIG5lZWQgdG8gYmUgZGUtbm9ybWFsaXplZCBmcm9tIFswLDFdIHRvIFswLDI1NV1cXG4gICAgICAgICAgJHtlfVxcbiAgICAgICAgICBoaWdocCBmbG9hdCBTaWduID0gMS4wIC0gc3RlcCgxMjguMCxyZ2JhWzBdKSoyLjA7XFxuICAgICAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gMi4wICogbW9kKHJnYmFbMF0sMTI4LjApICsgc3RlcCgxMjguMCxyZ2JhWzFdKSAtIDEyNy4wO1xcbiAgICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IG1vZChyZ2JhWzFdLDEyOC4wKSo2NTUzNi4wICsgcmdiYVsyXSoyNTYuMCArcmdiYVszXSArIGZsb2F0KDB4ODAwMDAwKTtcXG4gICAgICAgICAgaGlnaHAgZmxvYXQgUmVzdWx0ID0gIFNpZ24gKiBleHAyKEV4cG9uZW50KSAqIChNYW50aXNzYSAqIGV4cDIoLTIzLjAgKSk7XFxuICAgICAgICAgIHJldHVybiBSZXN1bHQ7XFxuICAgICAgfVxcbiAgICAgICAgYCl9fXN0YXRpYyBpc0xpdHRsZUVuZGlhbigpe2NvbnN0IGU9bmV3IEFycmF5QnVmZmVyKDQpLHQ9bmV3IFVpbnQzMkFycmF5KGUpLG49bmV3IFVpbnQ4QXJyYXkoZSk7aWYodFswXT0zNzM1OTI4NTU5LDIzOT09PW5bMF0pcmV0dXJuITA7aWYoMjIyPT09blswXSlyZXR1cm4hMTt0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuZGlhbm5lc3NcIil9fXQuRW5jb2RpbmdHbHNsTGliPW99LDI2OTE6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRnJhZ0NvbG9yR2xzbExpYj12b2lkIDA7Y29uc3Qgcj1uKDE5OTcpLG89big2NzU3KTtjbGFzcyBpIGV4dGVuZHMgci5HbHNsTGlie2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpfWdldEZ1bmN0aW9ucygpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdGhpcy5zZXRGcmFnQ29sb3IoKSksdGhpcy5nZXRDb2xvckFzRmxvYXQoKSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1zZXRGcmFnQ29sb3IoKXtjb25zdCBlPSgwLG8uZ2V0R2xzbCkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtyZXR1cm57c2V0RnJhZ0NvbG9yOm5ldyByLkdsc2xMaWJSb3V0aW5lKGBcXG4gICAgICAgIHZvaWQgc2V0RnJhZ0NvbG9yKGZsb2F0IHZhbHVlKSB7XFxuICAgICAgICAgICAgJHtlLm91dHB1dH0gPSBlbmNvZGUodmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgYCxbXCJlbmNvZGluZy5lbmNvZGVcIl0pfX1nZXRDb2xvckFzRmxvYXQoKXtyZXR1cm57Z2V0Q29sb3JBc0Zsb2F0Om5ldyByLkdsc2xMaWJSb3V0aW5lKFwiXFxuICAgICAgICBmbG9hdCBnZXRDb2xvckFzRmxvYXQodmVjNCBjb2xvcikge1xcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGUoY29sb3IpO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCIsW1wiZW5jb2RpbmcuZGVjb2RlXCJdKX19fXQuRnJhZ0NvbG9yR2xzbExpYj1pfSwzODc4OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5yZXBsYWNlSW5saW5lcz12b2lkIDA7Y29uc3Qgbj0vQGlubGluZVtcXHNcXG5cXHJdKyhcXHcrKVtcXHNcXG5cXHJdKyhbMC05YS16QS1aX10rKVxccypcXCgoW14pXSopXFwpXFxzKnsoKFtefV18W1xcblxccl0pKil9L2dtO3QucmVwbGFjZUlubGluZXM9ZnVuY3Rpb24oZSl7Y29uc3QgdD17fTtsZXQgcjtmb3IoO251bGwhPT0ocj1uLmV4ZWMoZSkpOyl7Y29uc3QgZT1yWzNdLnNwbGl0KFwiLFwiKS5tYXAoKGU9Pntjb25zdCB0PWUudHJpbSgpLnNwbGl0KFwiIFwiKTtyZXR1cm4gdCYmMj09PXQubGVuZ3RoP3t0eXBlOnRbMF0sbmFtZTp0WzFdfTpudWxsfSkpLmZpbHRlcigoZT0+bnVsbCE9PWUpKTt0W3JbMl1dPXtwYXJhbXM6ZSxib2R5OnJbNF19fWZvcihjb25zdCBuIGluIHQpe2NvbnN0IG89XCIoXFxcXHcrKT9cXFxccysoW18wLTlhLXpBLVpdKylcXFxccys9XFxcXHMrX19GVU5DX19cXFxcKCguKilcXFxcKVxcXFxzKjtcIi5yZXBsYWNlKFwiX19GVU5DX19cIixuKSxpPW5ldyBSZWdFeHAobyxcImdtXCIpO2Zvcig7bnVsbCE9PShyPWkuZXhlYyhlKSk7KXtjb25zdCBvPXJbMV0saT1yWzJdLHM9clszXS5zcGxpdChcIixcIiksYT1vP2Ake299ICR7aX07YDpcIlwiO2xldCB1PXRbbl0uYm9keSxsPVwiXCI7dFtuXS5wYXJhbXMuZm9yRWFjaCgoKGUsdCk9PntlJiYobCs9YCR7ZS50eXBlfSAke2UubmFtZX0gPSAke3NbdF19O1xcbmApfSkpLHU9YCR7bH1cXG4gJHt1fWAsdT11LnJlcGxhY2UoXCJyZXR1cm5cIixgJHtpfSA9IGApO2NvbnN0IGM9YFxcbiAgICAgICR7YX1cXG4gICAgICB7XFxuICAgICAgICAke3V9XFxuICAgICAgfVxcbiAgICAgIGA7ZT1lLnJlcGxhY2UoclswXSxjKX19cmV0dXJuIGUucmVwbGFjZShuLFwiXCIpfX0sODg5NzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HbHNsUHJlcHJvY2Vzc29yPXZvaWQgMDtjb25zdCByPW4oMTk5Nyksbz1uKDM4NzgpLGk9bigxMjQ4KSxzPW4oNjc1Nyk7dC5HbHNsUHJlcHJvY2Vzc29yPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLG8pe3RoaXMubGlicz17fSx0aGlzLmdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoPXt9LHRoaXMuY29udGV4dD1uZXcgci5HbHNsQ29udGV4dChlLHQsbixvKSxPYmplY3Qua2V5cyhpLmdsc2xSZWdpc3RyeSkuZm9yRWFjaCgoZT0+e2NvbnN0IHQ9bmV3IGkuZ2xzbFJlZ2lzdHJ5W2VdKHRoaXMuY29udGV4dCk7dGhpcy5saWJzW2VdPXR9KSk7Y29uc3Qgcz10aGlzLmdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoO2Zvcihjb25zdCBlIGluIHRoaXMubGlicyl7Y29uc3QgdD10aGlzLmxpYnNbZV0uZ2V0RnVuY3Rpb25zKCk7Zm9yKGNvbnN0IG4gaW4gdCl7Y29uc3Qgbz1lK1wiLlwiK247bGV0IGk7c1tvXT8oaT1zW29dLGkucm91dGluZUJvZHk9dFtuXS5yb3V0aW5lQm9keSk6KGk9bmV3IHIuR2xzbExpYlJvdXRpbmVOb2RlKG8sdFtuXS5yb3V0aW5lQm9keSksc1tvXT1pKTtjb25zdCBhPXRbbl0uZGVwZW5kZW5jaWVzO2lmKGEpZm9yKGxldCBlPTA7ZTxhLmxlbmd0aDsrK2UpaWYoc1thW2VdXSlpLmFkZERlcGVuZGVuY3koc1thW2VdXSk7ZWxzZXtjb25zdCB0PW5ldyByLkdsc2xMaWJSb3V0aW5lTm9kZShhW2VdKTtzW2FbZV1dPXQsaS5hZGREZXBlbmRlbmN5KHQpfX19fXByZXByb2Nlc3MoKXtjb25zdCBlPXRoaXMuY29udGV4dC5wcm9ncmFtSW5mbztsZXQgdD1lLnNoYWRlclNvdXJjZTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmhhc01haW58fCh0PWAke3R9XFxuICAgICAgJHsoMCxzLmdldERlZmF1bHRGcmFnU2hhZGVyTWFpbikodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uLHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aCl9YCksdD0oMCxvLnJlcGxhY2VJbmxpbmVzKSh0KSxgJHsoMCxzLmdldEZyYWdTaGFkZXJQcmVhbWJsZSkodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKX1cXG4gICAgJHt0aGlzLmdldFVuaWZvcm1zKGUuaW5wdXROYW1lcyxlLnZhcmlhYmxlcyl9XFxuICAgICR7dGhpcy5nZXRJbXBvcnRzKHQpfVxcbiAgICAke3R9YH1nZXRJbXBvcnRzKGUpe2NvbnN0IHQ9dGhpcy5zZWxlY3RHbHNsTGliUm91dGluZXNUb0JlSW5jbHVkZWQoZSk7aWYoMD09PXQubGVuZ3RoKXJldHVyblwiXCI7bGV0IG49XCJcIjtmb3IobGV0IGU9MDtlPHQubGVuZ3RoOysrZSl7aWYoIXRbZV0ucm91dGluZUJvZHkpdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGJvZHkgZm9yIHRoZSBHbHNsIExpYnJhcnkgcm91dGluZTogJHt0W2VdLm5hbWV9YCk7bis9dFtlXS5yb3V0aW5lQm9keStcIlxcblwifXJldHVybiBufXNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZChlKXtjb25zdCB0PVtdO3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoKS5mb3JFYWNoKChuPT57Y29uc3Qgcj1uLnNwbGl0KFwiLlwiKVsxXTstMSE9PWUuaW5kZXhPZihyKSYmdC5wdXNoKHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGhbbl0pfSkpLHIuVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzLnJldHVybk9yZGVyZWROb2Rlcyh0KX1nZXRVbmlmb3JtcyhlLHQpe2NvbnN0IG49W107aWYoZSlmb3IoY29uc3QgdCBvZiBlKW4ucHVzaChgdW5pZm9ybSBzYW1wbGVyMkQgJHt0fTtgKTtpZih0KWZvcihjb25zdCBlIG9mIHQpbi5wdXNoKGB1bmlmb3JtICR7ZS50eXBlfSAke2UubmFtZX0ke2UuYXJyYXlMZW5ndGg/YFske2UuYXJyYXlMZW5ndGh9XWA6XCJcIn07YCk7cmV0dXJuIG4uam9pbihcIlxcblwiKX19fSwxMjQ4OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lmdsc2xSZWdpc3RyeT12b2lkIDA7Y29uc3Qgcj1uKDY4NTkpLG89bigxMzcxKSxpPW4oMjY5MSkscz1uKDkxODMpLGE9big5MzE0KTt0Lmdsc2xSZWdpc3RyeT17ZW5jb2Rpbmc6by5FbmNvZGluZ0dsc2xMaWIsZnJhZ2NvbG9yOmkuRnJhZ0NvbG9yR2xzbExpYix2ZWM6YS5WZWNHbHNsTGliLHNoYXBlVXRpbHM6cy5TaGFwZVV0aWxzR2xzbExpYixjb29yZGluYXRlczpyLkNvb3Jkc0dsc2xMaWJ9fSw5MTgzOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlNoYXBlVXRpbHNHbHNsTGliPXZvaWQgMDtjb25zdCByPW4oMTk5Nyk7Y2xhc3MgbyBleHRlbmRzIHIuR2xzbExpYntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMuYmNhc3RJbmRleCgpKSx0aGlzLmJjYXN0TWF0bXVsSW5kZXgoKSksdGhpcy5vZmZzZXRUb0luZGljZXMoKSksdGhpcy5pbmRpY2VzVG9PZmZzZXQoKSksdGhpcy5pbmNyZW1lbnRJbmRpY2VzKCkpfWdldEN1c3RvbVR5cGVzKCl7cmV0dXJue319YmNhc3RJbmRleCgpe2NvbnN0IGU9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLHQ9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKChuLG8pPT57Y29uc3QgaT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tvXS51bnBhY2tlZFNoYXBlO2lmKGkubGVuZ3RoPD1lKXtjb25zdCBvPWkubGVuZ3RoLHM9ZS1vLGE9YGJjYXN0SW5kaWNlc18ke259YDtsZXQgdT1cIlwiO2ZvcihsZXQgZT0wO2U8bzsrK2UpdSs9YFxcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2V9XSA9IGludCggbW9kKGZsb2F0KGJjYXN0ZWRJbmRpY2VzWyR7cytlfV0pLCAke2lbZV19LjApICk7XFxuICAgICAgICAgIGA7Y29uc3QgbD1gXFxuICAgICAgICB2b2lkICR7YX0gKGludCBiY2FzdGVkSW5kaWNlc1ske2V9XSwgb3V0IGludCByZWFsSW5kaWNlc1ske299XSkge1xcbiAgICAgICAgICAke3V9XFxuICAgICAgICB9XFxuICAgICAgICBgO3RbYV09bmV3IHIuR2xzbExpYlJvdXRpbmUobCl9fSkpLHR9YmNhc3RNYXRtdWxJbmRleCgpe2NvbnN0IGU9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoLHQ9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKChuLG8pPT57Y29uc3QgaT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tvXS5zaGFwZTtpZighKGkubGVuZ3RoPDJ8fGkubGVuZ3RoPmUpKXtjb25zdCBvPWkubGVuZ3RoLHM9ZS1vLGE9YGJjYXN0TWF0bXVsSW5kaWNlc18ke259YDtsZXQgdT1cIlwiO2ZvcihsZXQgZT0wO2U8by0yOysrZSl1Kz1gXFxuICAgICAgICAgIHJlYWxJbmRpY2VzWyR7ZX1dID0gaW50KCBtb2QoZmxvYXQoYmNhc3RlZEluZGljZXNbJHtzK2V9XSksICR7aVtlXX0uMCkgKTtcXG4gICAgICAgICAgYDtjb25zdCBsPWBcXG4gICAgICAgIHZvaWQgJHthfShpbnQgYmNhc3RlZEluZGljZXNbJHtlfV0sIG91dCBpbnQgcmVhbEluZGljZXNbJHtvfV0pIHtcXG4gICAgICAgICAgJHt1fVxcbiAgICAgICAgICByZWFsSW5kaWNlc1ske28tMX1dID0gYmNhc3RlZEluZGljZXNbJHtlLTF9XTtcXG4gICAgICAgICAgcmVhbEluZGljZXNbJHtvLTJ9XSA9IGJjYXN0ZWRJbmRpY2VzWyR7ZS0yfV07XFxuICAgICAgICB9XFxuICAgICAgICBgO3RbYV09bmV3IHIuR2xzbExpYlJvdXRpbmUobCl9fSkpLHR9aW5kaWNlc1RvT2Zmc2V0KCl7Y29uc3QgZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKHQsbik9Pntjb25zdCBpPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnNoYXBlLHM9dGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbbl0uc3RyaWRlcyxhPWkubGVuZ3RoO2xldCB1PWBpbmRpY2VzVG9PZmZzZXRfJHt0fWA7ZVt1XT1uZXcgci5HbHNsTGliUm91dGluZShvLmluZGV4VG9PZmZzZXRTaW5nbGUodSxhLHMpKSx1PWBpbmRpY2VzVG9PZmZzZXRfJHt0fV9UYCxlW3VdPW5ldyByLkdsc2xMaWJSb3V0aW5lKG8uaW5kZXhUb09mZnNldFNpbmdsZSh1LGEscy5zbGljZSgpLnJldmVyc2UoKSkpfSkpLGV9c3RhdGljIGluZGV4VG9PZmZzZXRTaW5nbGUoZSx0LG4pe2xldCByPVwiXCI7Zm9yKGxldCBlPXQtMTtlPj0wOy0tZSlyKz1gXFxuICAgICAgICBvZmZzZXQgKz0gaW5kaWNlc1ske2V9XSAqICR7bltlXX07XFxuICAgICAgICBgO3JldHVybmBcXG4gICAgICBpbnQgJHtlfShpbnQgaW5kaWNlc1ske3R9XSkge1xcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XFxuICAgICAgICAke3J9XFxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xcbiAgICAgIH1cXG4gICAgICBgfW9mZnNldFRvSW5kaWNlcygpe2NvbnN0IGU9e307cmV0dXJuIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKCh0LG4pPT57Y29uc3QgaT10aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tuXS5zaGFwZSxzPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnN0cmlkZXMsYT1pLmxlbmd0aDtsZXQgdT1gb2Zmc2V0VG9JbmRpY2VzXyR7dH1gO2VbdV09bmV3IHIuR2xzbExpYlJvdXRpbmUoby5vZmZzZXRUb0luZGljZXNTaW5nbGUodSxhLHMpKSx1PWBvZmZzZXRUb0luZGljZXNfJHt0fV9UYCxlW3VdPW5ldyByLkdsc2xMaWJSb3V0aW5lKG8ub2Zmc2V0VG9JbmRpY2VzU2luZ2xlKHUsYSxzLnNsaWNlKCkucmV2ZXJzZSgpKSl9KSksZX1zdGF0aWMgb2Zmc2V0VG9JbmRpY2VzU2luZ2xlKGUsdCxuKXtjb25zdCByPVtdO2ZvcihsZXQgZT0wO2U8dC0xOysrZSlyLnB1c2goYFxcbiAgICAgIGluZGljZXNbJHtlfV0gPSBvZmZzZXQgLyAke25bZV19O2ApLHIucHVzaChgXFxuICAgICAgICBvZmZzZXQgLT0gaW5kaWNlc1ske2V9XSAqICR7bltlXX07YCk7cmV0dXJuIHIucHVzaChgXFxuICAgICAgaW5kaWNlc1ske3QtMX1dID0gb2Zmc2V0O2ApLGBcXG4gICAgICB2b2lkICR7ZX0oaW50IG9mZnNldCwgb3V0IGludCBpbmRpY2VzWyR7dH1dKSB7XFxuICAgICAgICAke3Iuam9pbihcIlwiKX1cXG4gICAgICB9XFxuICAgICAgYH1pbmNyZW1lbnRJbmRpY2VzKCl7Y29uc3QgZT17fTtyZXR1cm4gdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgoKHQsbik9Pntjb25zdCBvPXRoaXMuY29udGV4dC5pbnB1dFRleHR1cmVMYXlvdXRzW25dLnNoYXBlLGk9by5sZW5ndGgscz1gaW5jcmVtZW50SW5kaWNlc18ke3R9YDtsZXQgYT1cIlwiO2ZvcihsZXQgZT0wO2U8aTsrK2UpYSs9YFxcbiAgICAgICAgc2hhcGVbJHtlfV0gPSAke29bZV19O2A7Y29uc3QgdT1gXFxuICAgICAgICB2b2lkICR7c30oaW50IGF4aXMsIG91dCBpbnQgaW5kaWNlc1ske2l9XSkge1xcbiAgICAgICAgICBpbnQgc2hhcGVbJHtpfV07XFxuICAgICAgICAgICR7YX07XFxuICAgICAgICAgIGZvcihpbnQgaSA9ICR7aX0gLTEgOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgICAgIGlmKGkgPiBheGlzKSBjb250aW51ZTtcXG4gICAgICAgICAgICBpbmRpY2VzW2ldICs9IDE7XFxuICAgICAgICAgICAgaWYoaW5kaWNlc1tpXSA8IHNoYXBlW2ldKSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW5kaWNlc1tpXSA9IDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGA7ZVtzXT1uZXcgci5HbHNsTGliUm91dGluZSh1KX0pKSxlfX10LlNoYXBlVXRpbHNHbHNsTGliPW99LDY3NTc6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldERlZmF1bHRGcmFnU2hhZGVyTWFpbj10LmdldEZyYWdTaGFkZXJQcmVhbWJsZT10LmdldFZlcnRleFNoYWRlclNvdXJjZT10LmdldEdsc2w9dm9pZCAwO2NvbnN0IG49e3ZlcnNpb246XCJcIixhdHRyaWJ1dGU6XCJhdHRyaWJ1dGVcIix2YXJ5aW5nVmVydGV4OlwidmFyeWluZ1wiLHZhcnlpbmdGcmFnOlwidmFyeWluZ1wiLHRleHR1cmUyRDpcInRleHR1cmUyRFwiLG91dHB1dDpcImdsX0ZyYWdDb2xvclwiLG91dHB1dERlY2xhcmF0aW9uOlwiXCJ9LHI9e3ZlcnNpb246XCIjdmVyc2lvbiAzMDAgZXNcIixhdHRyaWJ1dGU6XCJpblwiLHZhcnlpbmdWZXJ0ZXg6XCJvdXRcIix2YXJ5aW5nRnJhZzpcImluXCIsdGV4dHVyZTJEOlwidGV4dHVyZVwiLG91dHB1dDpcIm91dHB1dENvbG9yXCIsb3V0cHV0RGVjbGFyYXRpb246XCJvdXQgdmVjNCBvdXRwdXRDb2xvcjtcIn07ZnVuY3Rpb24gbyhlKXtyZXR1cm4gMT09PWU/bjpyfXQuZ2V0R2xzbD1vLHQuZ2V0VmVydGV4U2hhZGVyU291cmNlPWZ1bmN0aW9uKGUpe2NvbnN0IHQ9byhlKTtyZXR1cm5gJHt0LnZlcnNpb259XFxuICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICAgICR7dC5hdHRyaWJ1dGV9IHZlYzMgcG9zaXRpb247XFxuICAgICAgJHt0LmF0dHJpYnV0ZX0gdmVjMiB0ZXh0dXJlQ29vcmQ7XFxuXFxuICAgICAgJHt0LnZhcnlpbmdWZXJ0ZXh9IHZlYzIgVGV4Q29vcmRzO1xcblxcbiAgICAgIHZvaWQgbWFpbigpXFxuICAgICAge1xcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XFxuICAgICAgICAgIFRleENvb3JkcyA9IHRleHR1cmVDb29yZDtcXG4gICAgICB9YH0sdC5nZXRGcmFnU2hhZGVyUHJlYW1ibGU9ZnVuY3Rpb24oZSl7Y29uc3QgdD1vKGUpO3JldHVybmAke3QudmVyc2lvbn1cXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbiAgICBwcmVjaXNpb24gaGlnaHAgaW50O1xcbiAgICBwcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xcbiAgICAke3QudmFyeWluZ0ZyYWd9IHZlYzIgVGV4Q29vcmRzO1xcbiAgICAke3Qub3V0cHV0RGVjbGFyYXRpb259XFxuICAgIGNvbnN0IHZlYzIgaGFsZkNSID0gdmVjMigwLjUsIDAuNSk7XFxuXFxuICAgIC8vIEN1c3RvbSB2ZWN0b3IgdHlwZXMgdG8gaGFuZGxlIGhpZ2hlciBkaW1lbmFsaXRpZXMuXFxuICAgIHN0cnVjdCBpdmVjNVxcbiAgICB7XFxuICAgICAgaW50IHg7XFxuICAgICAgaW50IHk7XFxuICAgICAgaW50IHo7XFxuICAgICAgaW50IHc7XFxuICAgICAgaW50IHU7XFxuICAgIH07XFxuXFxuICAgIHN0cnVjdCBpdmVjNlxcbiAgICB7XFxuICAgICAgaW50IHg7XFxuICAgICAgaW50IHk7XFxuICAgICAgaW50IHo7XFxuICAgICAgaW50IHc7XFxuICAgICAgaW50IHU7XFxuICAgICAgaW50IHY7XFxuICAgIH07XFxuXFxuICAgIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xcbiAgICAgIHJldHVybiB4IC0geSAqICh4IC8geSk7XFxuICAgIH1cXG5cXG4gICAgYH0sdC5nZXREZWZhdWx0RnJhZ1NoYWRlck1haW49ZnVuY3Rpb24oZSx0KXtyZXR1cm5gXFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGludCBpbmRpY2VzWyR7dH1dO1xcbiAgICB0b1ZlYyhUZXhDb29yZHMsIGluZGljZXMpO1xcbiAgICB2ZWM0IHJlc3VsdCA9IHZlYzQocHJvY2VzcyhpbmRpY2VzKSk7XFxuICAgICR7byhlKS5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgfVxcbiAgYH19LDkzMTQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVmVjR2xzbExpYj12b2lkIDA7Y29uc3Qgcj1uKDE5OTcpO2NsYXNzIG8gZXh0ZW5kcyByLkdsc2xMaWJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSl9Z2V0Q3VzdG9tVHlwZXMoKXtyZXR1cm57fX1nZXRGdW5jdGlvbnMoKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0aGlzLmJpbmFyeVZlY0Z1bmN0aW9ucygpKSx0aGlzLmNvcHlWZWMoKSksdGhpcy5zZXRWZWNJdGVtKCkpLHRoaXMuZ2V0VmVjSXRlbSgpKX1iaW5hcnlWZWNGdW5jdGlvbnMoKXtjb25zdCBlPXRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aCx0PXthZGQ6XCIrPVwiLHN1YjpcIi09XCIsbXVsOlwiKj1cIixkaXY6XCIvPVwifSxuPXt9O2Zvcihjb25zdCBvIGluIHQpe2NvbnN0IGk9YCR7b31WZWNgO2xldCBzPVwiXCI7Zm9yKGxldCBuPTA7bjxlOysrbilzKz1gXFxuICAgICAgICAgIGRlc3RbJHtufV0gJHt0W29dfSBzcmNbJHtufV07XFxuICAgICAgICAgIGA7Y29uc3QgYT1gXFxuICAgICAgICB2b2lkICR7aX0oaW50IHNyY1ske2V9XSwgb3V0IGludCBkZXN0WyR7ZX1dKSB7XFxuICAgICAgICAgICR7c31cXG4gICAgICAgIH1cXG4gICAgICAgIGA7bltpXT1uZXcgci5HbHNsTGliUm91dGluZShhKX1yZXR1cm4gbn1jb3B5VmVjKCl7Y29uc3QgZT10aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7bGV0IHQ9XCJcIjtmb3IobGV0IG49MDtuPGU7KytuKXQrPWBcXG4gICAgICAgIGRlc3RbJHtufV0gPSBzcmNbJHtufV07XFxuICAgICAgICBgO2NvbnN0IG49YFxcbiAgICAgIHZvaWQgY29weVZlYyhpbnQgc3JjWyR7ZX1dLCBvdXQgaW50IGRlc3RbJHtlfV0pIHtcXG4gICAgICAgICR7dH1cXG4gICAgICB9XFxuICAgICAgYDtyZXR1cm57Y29weVZlYzpuZXcgci5HbHNsTGliUm91dGluZShuKX19c2V0VmVjSXRlbSgpe2NvbnN0IGU9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoO2xldCB0PWBcXG4gICAgICAgIGlmKGluZGV4IDwgMClcXG4gICAgICAgICAgICBpbmRleCA9JHtlfSArIGluZGV4O1xcbiAgICAgICAgaWYgKGluZGV4ID09IDApXFxuICAgICAgICAgICAgbVswXSA9IHZhbHVlO1xcbiAgICAgICAgYDtmb3IobGV0IG49MTtuPGUtMTsrK24pdCs9YFxcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtufSlcXG4gICAgICAgICAgICBtWyR7bn1dID0gdmFsdWU7XFxuICAgICAgICAgICAgYDt0Kz1gXFxuICAgICAgICBlbHNlXFxuICAgICAgICAgICAgbVske2UtMX1dID0gdmFsdWU7XFxuICAgICAgICBgO2NvbnN0IG49YFxcbiAgICAgIHZvaWQgc2V0VmVjSXRlbShvdXQgaW50IG1bJHtlfV0sIGludCBpbmRleCwgaW50IHZhbHVlKSB7XFxuICAgICAgICAke3R9XFxuICAgICAgfVxcbiAgICAgICAgYDtyZXR1cm57c2V0VmVjSXRlbTpuZXcgci5HbHNsTGliUm91dGluZShuKX19Z2V0VmVjSXRlbSgpe2NvbnN0IGU9dGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoO2xldCB0PWBcXG4gICAgICAgIGlmKGluZGV4IDwgMClcXG4gICAgICAgICAgICBpbmRleCA9ICR7ZX0gKyBpbmRleDtcXG4gICAgICAgIGlmIChpbmRleCA9PSAwKVxcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xcbiAgICAgIGA7Zm9yKGxldCBuPTE7bjxlLTE7KytuKXQrPWBcXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09ICR7bn0pXFxuICAgICAgICAgICAgcmV0dXJuIG1bJHtufV07XFxuICAgICAgYDt0Kz1gXFxuICAgICAgICBlbHNlXFxuICAgICAgICAgICAgcmV0dXJuIG1bJHtlLTF9XTtcXG4gICAgICAgIGA7Y29uc3Qgbj1gXFxuICAgICAgaW50IGdldFZlY0l0ZW0oaW50IG1bJHtlfV0sIGludCBpbmRleCkge1xcbiAgICAgICAgJHt0fVxcbiAgICAgIH1cXG4gICAgYDtyZXR1cm57Z2V0VmVjSXRlbTpuZXcgci5HbHNsTGliUm91dGluZShuKX19fXQuVmVjR2xzbExpYj1vfSw3ODYwOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LldlYkdMSW5mZXJlbmNlSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDEzMTUpLG89big5MjQwKSxpPW4oNzI3Mykscz1uKDkpLGE9big3Mzc5KSx1PW4oMjQ4OCksbD1uKDU0MCksYz1uKDMzMTQpLHA9big1NjM5KTt0LldlYkdMSW5mZXJlbmNlSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnNlc3Npb249ZSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfWNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChlLHQpe3JldHVybigwLGMuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksZSx0KX1leGVjdXRlUHJvZ3JhbShlLHQpe2lmKHQubGVuZ3RoPGUuaW5wdXROYW1lcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCBzaXplIG11c3RuJ3QgYmUgbGVzcyB0aGFuICR7ZS5pbnB1dE5hbWVzLmxlbmd0aH0uYCk7aWYoZS5pbnB1dE5hbWVzLmxlbmd0aCE9PWUuaW5wdXRUeXBlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgbmFtZXMgc2l6ZSBkb2VzIG5vdCBtYXRjaCBpbnB1dCB0eXBlc1wiKTtjb25zdCBuPVtdO2ZvcihsZXQgcj0wO3I8ZS5pbnB1dE5hbWVzLmxlbmd0aDsrK3IpbltyXT10aGlzLmdldE9yQ3JlYXRlVGV4dHVyZURhdGEodFtyXSxlLmlucHV0VHlwZXNbcl0pO2NvbnN0IHI9KChlLHQpPT57Y29uc3Qgbj10Lm1hcCgoZT0+YCR7ZS51bnBhY2tlZFNoYXBlLmpvaW4oXCIsXCIpfTske2Uud2lkdGh9eCR7ZS5oZWlnaHR9YCkpLmpvaW4oXCJfXCIpO2xldCByPWUubmFtZTtyZXR1cm4gZS5jYWNoZUhpbnQmJihyKz1cIltcIitlLmNhY2hlSGludCtcIl1cIikscis9XCI6XCIrbixyfSkoZSxuKTtsZXQgbz10aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3Qocik7Y29uc3QgaT1vP28ucHJvZ3JhbUluZm86XCJmdW5jdGlvblwiPT10eXBlb2YgZS5nZXQ/ZS5nZXQoKTplLHM9KDAsYy5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksaS5vdXRwdXQuZGltcyxpLm91dHB1dC50ZXh0dXJlVHlwZSksYT10aGlzLmNyZWF0ZVRleHR1cmVEYXRhKHMsaS5vdXRwdXQudHlwZSk7cmV0dXJuIG98fChvPXRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5idWlsZChpLG4sYSksdGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KHIsbykpLHRoaXMucnVuUHJvZ3JhbShvLG4sYSksYX1ydW4oZSx0KXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbShlLHQpLnRlbnNvcn1ydW5Qcm9ncmFtKGUsdCxuKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbilpZighIXRbbl0uaXNQYWNrZWQhPShlLnByb2dyYW1JbmZvLmlucHV0VHlwZXNbbl09PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKGBpbnB1dFske259XSBwcm9wZXJ0eSBwYWNrZWQgaW5jb25zaXN0ZW50YCk7aWYoISFuLmlzUGFja2VkIT0oZS5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGU9PT1wLlRleHR1cmVUeXBlLnBhY2tlZCkpdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnRcIik7dGhpcy5zZXNzaW9uLnByb2dyYW1NYW5hZ2VyLnJ1bihlLHQsbil9Z2V0T3JDcmVhdGVUZXh0dXJlRGF0YShlLHQpe2xldCBuPXRoaXMuZ2V0VGV4dHVyZURhdGEoZS5kYXRhSWQsdD09PXAuVGV4dHVyZVR5cGUucGFja2VkKTtpZighbiYmKG49dGhpcy5nZXRUZXh0dXJlRGF0YShlLmRhdGFJZCx0IT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpLG4pKXJldHVybiB0PT09cC5UZXh0dXJlVHlwZS5wYWNrZWQ/dGhpcy5wYWNrKG4pOnRoaXMudW5wYWNrKG4pO2lmKCFuKXtjb25zdCByPSgwLGMuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkodGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LGUuZGltcyx0KTtpZih0PT09cC5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKXtjb25zdCBuPTEscj00LG89ZS5kaW1zO2lmKDQ9PT1vLmxlbmd0aCl7Y29uc3QgaT1bb1swXSxNYXRoLmNlaWwob1sxXSpvWzJdKm9bM10vcildLHM9KDAsYy5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksaSx0KTtsZXQgYT1lLm51bWJlckRhdGE7aWYob1sxXSpvWzJdKm9bM10lciE9MCl7Y29uc3QgdD1vWzBdLGk9b1sxXSpvWzJdKm9bM10scz1NYXRoLmNlaWwoaSpuL3IpKnI7YT1uZXcgRmxvYXQzMkFycmF5KHQqcyk7Zm9yKGxldCByPTA7cjx0Oysrcil7Y29uc3QgdD1yKmksbz1yKnMrciVuKmk7YS5zZXQoZS5udW1iZXJEYXRhLnN1YmFycmF5KHQsdCtpKSxvKX19cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEocyxlLnR5cGUsYSxlLDEpfX1pZih0PT09cC5UZXh0dXJlVHlwZS5wYWNrZWQpe2NvbnN0IHQ9KDAsYy5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKSh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksZS5kaW1zLDEsW10se3JldmVyc2VXSDohMH0pLHI9dGhpcy5jcmVhdGVUZXh0dXJlRGF0YSh0LGUudHlwZSxlLm51bWJlckRhdGEsZSwxKTtuPXRoaXMucGFjayhyKX1lbHNlIG49dGhpcy5jcmVhdGVUZXh0dXJlRGF0YShyLGUudHlwZSxlLm51bWJlckRhdGEsZSwxKX1yZXR1cm4gbn1jcmVhdGVUZXh0dXJlRGF0YUZyb21MYXlvdXRCaW5kVGVuc29yKGUsdCxuLHIpe3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKGUsdCxuLHIsMSl9Y3JlYXRlVGV4dHVyZURhdGEoZSx0LG4sbyxpKXtyLkxvZ2dlci52ZXJib3NlKFwiSW5mZXJlbmNlSGFuZGxlclwiLGBDcmVhdGluZyBUZXh0dXJlRGF0YTogbGF5b3V0Olske0pTT04uc3RyaW5naWZ5KGUpfV1gKTtjb25zdCBzPXRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5jcmVhdGVUZXh0dXJlRnJvbUxheW91dCh0LGUsbixpKTtyZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGUsdCxzLG8pfXJlc2hhcGVVbnBhY2tlZChlLHQpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGUscC5UZXh0dXJlVHlwZS51bnBhY2tlZCkscj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09dC5sZW5ndGg/dDpbMV0sc3RyaWRlczppLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0KSx1bnBhY2tlZFNoYXBlOnR9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocixlLnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9cmVzaGFwZVBhY2tlZChlLHQpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGUscC5UZXh0dXJlVHlwZS5wYWNrZWQpO2lmKCgwLGEuaXNSZXNoYXBlQ2hlYXApKGUuZGltcyx0KSl7Y29uc3Qgcj17Y2hhbm5lbHM6bi5jaGFubmVscyxoZWlnaHQ6bi5oZWlnaHQsd2lkdGg6bi53aWR0aCxzaGFwZTowIT09dC5sZW5ndGg/dDpbMV0sc3RyaWRlczppLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0KSx1bnBhY2tlZFNoYXBlOnQsaXNQYWNrZWQ6ITB9O3JldHVybiB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUocixlLnR5cGUsbi50ZXh0dXJlKS50ZW5zb3J9Y29uc3Qgcj0oMCxhLnByb2Nlc3NEaW1zM0QpKGUuZGltcyksbz0oMCxhLnByb2Nlc3NEaW1zM0QpKHQpLHM9dGhpcy5yZXNoYXBlUGFja2VkKGUsciksdT10aGlzLnJ1bigoMCxhLmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyKSh0aGlzLHMsbyksW3NdKTtyZXR1cm4gdGhpcy5yZXNoYXBlUGFja2VkKHUsdCl9Y2FzdChlLHQpe2NvbnN0IG49dGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGUscC5UZXh0dXJlVHlwZS51bnBhY2tlZCk7cmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShuLHQsbi50ZXh0dXJlKS50ZW5zb3J9Y3JlYXRlVGV4dHVyZURhdGFGcm9tVGV4dHVyZShlLHQsbixyLGkpe2NvbnN0IHM9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHt0ZW5zb3I6cnx8bmV3IG8uVGVuc29yKGUudW5wYWNrZWRTaGFwZSx0LChlPT50aGlzLnJlYWRUZXh0dXJlKHMpKSwoYXN5bmMgZT0+dGhpcy5yZWFkVGV4dHVyZUFzeW5jKHMpKSx2b2lkIDAsaSksdGV4dHVyZTpufSk7cmV0dXJuIHRoaXMuc2V0VGV4dHVyZURhdGEocy50ZW5zb3IuZGF0YUlkLHMsZS5pc1BhY2tlZCksc31nZXRUZXh0dXJlRGF0YShlLHQ9ITEpe3JldHVybiB0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcihlKT90aGlzLnNlc3Npb24uZ2V0VGV4dHVyZURhdGEoZSx0KTp0P3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQoZSk6dGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KGUpfXNldFRleHR1cmVEYXRhKGUsdCxuPSExKXt0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcihlKT90aGlzLnNlc3Npb24uc2V0VGV4dHVyZURhdGEoZSx0LG4pOihuP3RoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZTp0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSkuc2V0KGUsdCl9aXNUZXh0dXJlTGF5b3V0Q2FjaGVkKGUsdD0hMSl7cmV0dXJuISF0aGlzLmdldFRleHR1cmVEYXRhKGUuZGF0YUlkLHQpfWRpc3Bvc2UoKXt0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKChlPT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUoZSkpKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKChlPT50aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUoZSkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlYWRUZXh0dXJlKGUpe3JldHVybiBlLmlzUGFja2VkP3RoaXMucmVhZFRleHR1cmUodGhpcy51bnBhY2soZSkpOnRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD90aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUoZSxlLnRlbnNvci50eXBlLGUuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsZSkpfWFzeW5jIHJlYWRUZXh0dXJlQXN5bmMoZSl7cmV0dXJuIGUuaXNQYWNrZWQ/dGhpcy5yZWFkVGV4dHVyZUFzeW5jKHRoaXMudW5wYWNrKGUpKTp0aGlzLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ/dGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlQXN5bmMoZSxlLnRlbnNvci50eXBlLGUuY2hhbm5lbHMpOnRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCgoMCx1LmVuY29kZUFzVWludDgpKHRoaXMsZSkpfXBhY2soZSl7cmV0dXJuIHRoaXMuZXhlY3V0ZVByb2dyYW0oKDAscy5jcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIpKHRoaXMsZS50ZW5zb3IpLFtlLnRlbnNvcl0pfXVucGFjayhlKXtyZXR1cm4gdGhpcy5leGVjdXRlUHJvZ3JhbSgoMCxsLmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKSh0aGlzLGUudGVuc29yKSxbZS50ZW5zb3JdKX19fSw0MTEwOmZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9bik7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LG4pO28mJiEoXCJnZXRcImluIG8/IXQuX19lc01vZHVsZTpvLndyaXRhYmxlfHxvLmNvbmZpZ3VyYWJsZSl8fChvPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W25dfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsbyl9OmZ1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pLGVbcl09dFtuXX0pLG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pfTpmdW5jdGlvbihlLHQpe2UuZGVmYXVsdD10fSksaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciBuIGluIGUpXCJkZWZhdWx0XCIhPT1uJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxuKSYmcih0LGUsbik7cmV0dXJuIG8odCxlKSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LldFQkdMX09QX1JFU09MVkVfUlVMRVM9dm9pZCAwO2NvbnN0IHM9big4ODE3KSxhPWkobig1MTk0KSksdT1uKDQ3NTIpLGw9big2NjY4KSxjPW4oOTc1NCkscD1uKDUwNDIpLGQ9big2NzQyKSxmPW4oNDEyNSksaD1uKDYxNDkpLGc9big1Mzc4KSxiPW4oNjk4MSksbT1uKDc0MTMpLHk9big3MDA2KSxfPW4oODI3Niksdj1uKDU1NjUpLFQ9bigyODM0KSx4PW4oMTAxMCksdz1uKDgxMjYpLE89bigyODAxKSxTPW4oNTY1KSxBPW4oMjQ0NCksUD1uKDgxNSksST1uKDU2NCksRT1uKDU0MTYpLEQ9bigxMjQwKSwkPW4oNTk0NCksaz1uKDU3MDcpLEY9aShuKDkwODcpKSxOPW4oNzg2MiksTD1uKDM5ODApO3QuV0VCR0xfT1BfUkVTT0xWRV9SVUxFUz1bW1wiQWJzXCIsXCJcIixcIjYrXCIsRi5hYnNdLFtcIkFjb3NcIixcIlwiLFwiNytcIixGLmFjb3NdLFtcIkFkZFwiLFwiXCIsXCI3K1wiLGEuYWRkXSxbXCJBbmRcIixcIlwiLFwiNytcIixhLmFuZF0sW1wiQXNpblwiLFwiXCIsXCI3K1wiLEYuYXNpbl0sW1wiQXRhblwiLFwiXCIsXCI3K1wiLEYuYXRhbl0sW1wiQXZlcmFnZVBvb2xcIixcIlwiLFwiNytcIixULmF2ZXJhZ2VQb29sLFQucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdLFtcIkJhdGNoTm9ybWFsaXphdGlvblwiLFwiXCIsXCI3K1wiLHMuYmF0Y2hOb3JtYWxpemF0aW9uLHMucGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzXSxbXCJDYXN0XCIsXCJcIixcIjYrXCIsdS5jYXN0LHUucGFyc2VDYXN0QXR0cmlidXRlc10sW1wiQ2VpbFwiLFwiXCIsXCI2K1wiLEYuY2VpbF0sW1wiQ2xpcFwiLFwiXCIsXCI2LTEwXCIsRi5jbGlwLEYucGFyc2VDbGlwQXR0cmlidXRlc10sW1wiQ2xpcFwiLFwiXCIsXCIxMStcIixGLmNsaXBWMTFdLFtcIkNvbmNhdFwiLFwiXCIsXCI0K1wiLGwuY29uY2F0LGwucGFyc2VDb25jYXRBdHRyaWJ1dGVzXSxbXCJDb252XCIsXCJcIixcIjErXCIsYy5jb252LGMucGFyc2VDb252QXR0cmlidXRlc10sW1wiQ29udlRyYW5zcG9zZVwiLFwiXCIsXCIxK1wiLHAuY29udlRyYW5zcG9zZSxwLnBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXNdLFtcIkNvc1wiLFwiXCIsXCI3K1wiLEYuY29zXSxbXCJEaXZcIixcIlwiLFwiNytcIixhLmRpdl0sW1wiRHJvcG91dFwiLFwiXCIsXCI3K1wiLEYuaWRlbnRpdHldLFtcIkRlcHRoVG9TcGFjZVwiLFwiXCIsXCIxK1wiLGQuZGVwdGhUb1NwYWNlLGQucGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzXSxbXCJFcXVhbFwiLFwiXCIsXCI3K1wiLGEuZXF1YWxdLFtcIkVsdVwiLFwiXCIsXCI2K1wiLEYuZWx1LEYucGFyc2VFbHVBdHRyaWJ1dGVzXSxbXCJFeHBcIixcIlwiLFwiNitcIixGLmV4cF0sW1wiRmxhdHRlblwiLFwiXCIsXCIxK1wiLGYuZmxhdHRlbixmLnBhcnNlRmxhdHRlbkF0dHJpYnV0ZXNdLFtcIkZsb29yXCIsXCJcIixcIjYrXCIsRi5mbG9vcl0sW1wiRnVzZWRDb252XCIsXCJjb20ubWljcm9zb2Z0XCIsXCIxK1wiLGMuY29udixjLnBhcnNlQ29udkF0dHJpYnV0ZXNdLFtcIkdhdGhlclwiLFwiXCIsXCIxK1wiLGguZ2F0aGVyLGgucGFyc2VHYXRoZXJBdHRyaWJ1dGVzXSxbXCJHZW1tXCIsXCJcIixcIjctMTBcIixnLmdlbW0sZy5wYXJzZUdlbW1BdHRyaWJ1dGVzVjddLFtcIkdlbW1cIixcIlwiLFwiMTErXCIsZy5nZW1tLGcucGFyc2VHZW1tQXR0cmlidXRlc1YxMV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixcIlwiLFwiMStcIixULmdsb2JhbEF2ZXJhZ2VQb29sLFQucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdLFtcIkdsb2JhbE1heFBvb2xcIixcIlwiLFwiMStcIixULmdsb2JhbE1heFBvb2xdLFtcIkdyZWF0ZXJcIixcIlwiLFwiNytcIixhLmdyZWF0ZXJdLFtcIklkZW50aXR5XCIsXCJcIixcIjErXCIsRi5pZGVudGl0eV0sW1wiSW1hZ2VTY2FsZXJcIixcIlwiLFwiMStcIixiLmltYWdlU2NhbGVyLGIucGFyc2VJbWFnZVNjYWxlckF0dHJpYnV0ZXNdLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFwiXCIsXCI2K1wiLG0uaW5zdGFuY2VOb3JtYWxpemF0aW9uLG0ucGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzXSxbXCJMZWFreVJlbHVcIixcIlwiLFwiNitcIixGLmxlYWt5UmVsdSxGLnBhcnNlTGVha3lSZWx1QXR0cmlidXRlc10sW1wiTGVzc1wiLFwiXCIsXCI3K1wiLGEubGVzc10sW1wiTFJOXCIsXCJcIixcIjErXCIseS5scm4seS5wYXJzZUxybkF0dHJpYnV0ZXNdLFtcIkxvZ1wiLFwiXCIsXCI2K1wiLEYubG9nXSxbXCJNYXRNdWxcIixcIlwiLFwiMStcIixfLm1hdE11bCxfLnBhcnNlTWF0TXVsQXR0cmlidXRlc10sW1wiTWF4UG9vbFwiLFwiXCIsXCIxK1wiLFQubWF4UG9vbCxULnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdLFtcIk11bFwiLFwiXCIsXCI3K1wiLGEubXVsXSxbXCJOZWdcIixcIlwiLFwiNitcIixGLm5lZ10sW1wiTm90XCIsXCJcIixcIjErXCIsRi5ub3RdLFtcIk9yXCIsXCJcIixcIjcrXCIsYS5vcl0sW1wiUGFkXCIsXCJcIixcIjItMTBcIix2LnBhZFYyLHYucGFyc2VQYWRBdHRyaWJ1dGVzVjJdLFtcIlBhZFwiLFwiXCIsXCIxMStcIix2LnBhZFYxMSx2LnBhcnNlUGFkQXR0cmlidXRlc1YxMV0sW1wiUG93XCIsXCJcIixcIjcrXCIsYS5wb3ddLFtcIlBSZWx1XCIsXCJcIixcIjcrXCIsYS5wUmVsdV0sW1wiUmVkdWNlTG9nU3VtXCIsXCJcIixcIjErXCIseC5yZWR1Y2VMb2dTdW0seC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlZHVjZU1heFwiLFwiXCIsXCIxK1wiLHgucmVkdWNlTWF4LHgucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNZWFuXCIsXCJcIixcIjErXCIseC5yZWR1Y2VNZWFuLHgucGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxbXCJSZWR1Y2VNaW5cIixcIlwiLFwiMStcIix4LnJlZHVjZU1pbix4LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlUHJvZFwiLFwiXCIsXCIxK1wiLHgucmVkdWNlUHJvZCx4LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtXCIsXCJcIixcIjEtMTJcIix4LnJlZHVjZVN1bSx4LnBhcnNlUmVkdWNlQXR0cmlidXRlc10sW1wiUmVkdWNlU3VtU3F1YXJlXCIsXCJcIixcIjErXCIseC5yZWR1Y2VMb2dTdW1TcXVhcmUseC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFtcIlJlbHVcIixcIlwiLFwiNitcIixGLnJlbHVdLFtcIlJlc2hhcGVcIixcIlwiLFwiNStcIix3LnJlc2hhcGVdLFtcIlJlc2l6ZVwiLFwiXCIsXCIxMFwiLE8ucmVzaXplLE8ucGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwXSxbXCJSZXNpemVcIixcIlwiLFwiMTErXCIsTy5yZXNpemUsTy5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTFdLFtcIlNoYXBlXCIsXCJcIixcIjErXCIsUy5zaGFwZV0sW1wiU2lnbW9pZFwiLFwiXCIsXCI2K1wiLEYuc2lnbW9pZF0sW1wiU2luXCIsXCJcIixcIjcrXCIsRi5zaW5dLFtcIlNsaWNlXCIsXCJcIixcIjEwK1wiLEEuc2xpY2VWMTBdLFtcIlNsaWNlXCIsXCJcIixcIjEtOVwiLEEuc2xpY2UsQS5wYXJzZVNsaWNlQXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxLTEyXCIsUC5zb2Z0bWF4LFAucGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sW1wiU29mdG1heFwiLFwiXCIsXCIxMytcIixQLnNvZnRtYXhWMTMsUC5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzXSxbXCJTcGxpdFwiLFwiXCIsXCIyLTEyXCIsSS5zcGxpdCxJLnBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxbXCJTcXJ0XCIsXCJcIixcIjYrXCIsRi5zcXJ0XSxbXCJTcXVlZXplXCIsXCJcIixcIjEtMTJcIixFLnNxdWVlemUsRS5wYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxbXCJTcXVlZXplXCIsXCJcIixcIjEzK1wiLEUuc3F1ZWV6ZVYxM10sW1wiU3ViXCIsXCJcIixcIjcrXCIsYS5zdWJdLFtcIlN1bVwiLFwiXCIsXCI2K1wiLEQuc3VtXSxbXCJUYW5cIixcIlwiLFwiNytcIixGLnRhbl0sW1wiVGFuaFwiLFwiXCIsXCI2K1wiLEYudGFuaF0sW1wiVGlsZVwiLFwiXCIsXCI2K1wiLCQudGlsZV0sW1wiVHJhbnNwb3NlXCIsXCJcIixcIjErXCIsay50cmFuc3Bvc2Usay5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXNdLFtcIlVwc2FtcGxlXCIsXCJcIixcIjctOFwiLEwudXBzYW1wbGUsTC5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxbXCJVcHNhbXBsZVwiLFwiXCIsXCI5XCIsTC51cHNhbXBsZSxMLnBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjldLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxLTEyXCIsTi51bnNxdWVlemUsTi5wYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXNdLFtcIlVuc3F1ZWV6ZVwiLFwiXCIsXCIxMytcIixOLnVuc3F1ZWV6ZVYxM10sW1wiWG9yXCIsXCJcIixcIjcrXCIsYS54b3JdXX0sODgxNzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9dC5iYXRjaE5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNjc1NyksaT1uKDU2MzkpLHM9e25hbWU6XCJCYXRjaE5vcm1hbGl6YXRpb25cIixpbnB1dE5hbWVzOltcIkFcIixcIlNjYWxlXCIsXCJCXCIsXCJNZWFuXCIsXCJWYXJpYW5jZVwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkLGkuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTt0LmJhdGNoTm9ybWFsaXphdGlvbj0oZSx0LG4pPT4odSh0KSxbZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PmEoZSx0LG4pfSksdCldKSx0LnBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJlcHNpbG9uXCIsMWUtNSksbj1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJtb21lbnR1bVwiLC45KSxvPWUuYXR0cmlidXRlcy5nZXRJbnQoXCJzcGF0aWFsXCIsMSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtlcHNpbG9uOnQsbW9tZW50dW06bixzcGF0aWFsOm99KX07Y29uc3QgYT0oZSx0LG4pPT57Y29uc3Qgcj0oMCxvLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxhPXRbMF0uZGltcy5sZW5ndGgsW3UsbF09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQodFsxXS5kaW1zLGkuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGM9YFxcbiAgZmxvYXQgcHJvY2VzcyhpbnRbJHthfV0gaW5kaWNlcykge1xcbiAgICB2ZWMyIHBvc2l0aW9uID0gb2Zmc2V0VG9Db29yZHMoaW5kaWNlc1sxXSwgJHt1fSwgJHtsfSk7XFxuICAgIGZsb2F0IHNjYWxlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ci50ZXh0dXJlMkR9KFNjYWxlLCBwb3NpdGlvbikpO1xcbiAgICBmbG9hdCBtZWFuID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ci50ZXh0dXJlMkR9KE1lYW4sIHBvc2l0aW9uKSk7XFxuICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ci50ZXh0dXJlMkR9KFZhcmlhbmNlLCBwb3NpdGlvbikpO1xcbiAgICBmbG9hdCBiID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ci50ZXh0dXJlMkR9KEIsIHBvc2l0aW9uKSk7XFxuXFxuICAgIHJldHVybiBzY2FsZSAqICggKF9BKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZmxvYXQoJHtuLmVwc2lsb259KSkgKSArIGI7XFxuICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtvdXRwdXQ6e2RpbXM6dFswXS5kaW1zLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpjfSl9LHU9ZT0+e2lmKCFlfHw1IT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzLlwiKTtjb25zdCB0PWVbMF0sbj1lWzFdLHI9ZVsyXSxvPWVbM10saT1lWzRdO2lmKHQuZGltcy5sZW5ndGg8M3x8MSE9PW4uZGltcy5sZW5ndGh8fDEhPT1yLmRpbXMubGVuZ3RofHwxIT09by5kaW1zLmxlbmd0aHx8MSE9PWkuZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYobi5kaW1zWzBdIT09dC5kaW1zWzFdfHxyLmRpbXNbMF0hPT10LmRpbXNbMV18fG8uZGltc1swXSE9PXQuZGltc1sxXXx8aS5kaW1zWzBdIT09dC5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwiZmxvYXQzMlwiIT09dC50eXBlJiZcImZsb2F0NjRcIiE9PXQudHlwZXx8XCJmbG9hdDMyXCIhPT1uLnR5cGUmJlwiZmxvYXQ2NFwiIT09bi50eXBlfHxcImZsb2F0MzJcIiE9PXIudHlwZSYmXCJmbG9hdDY0XCIhPT1yLnR5cGV8fFwiZmxvYXQzMlwiIT09by50eXBlJiZcImZsb2F0NjRcIiE9PW8udHlwZXx8XCJmbG9hdDMyXCIhPT1pLnR5cGUmJlwiZmxvYXQ2NFwiIT09aS50eXBlKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIHR5cGVzLlwiKX19LDUxOTQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQueG9yPXQuc3ViPXQucFJlbHU9dC5wb3c9dC5vcj10Lm11bD10Lmxlc3M9dC5ncmVhdGVyPXQuZXF1YWw9dC5kaXY9dC5hbmQ9dC5hZGQ9dC5nbHNsUFJlbHU9dC5nbHNsUG93PXQuZ2xzbFhvcj10Lmdsc2xPcj10Lmdsc2xBbmQ9dC5nbHNsTGVzcz10Lmdsc2xHcmVhdGVyPXQuZ2xzbEVxdWFsPXQuZ2xzbFN1Yj10Lmdsc2xNdWw9dC5nbHNsRGl2PXQuZ2xzbEFkZD12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpLG89bigxOTk3KSxpPW4oNjc1Nykscz1uKDU2MzkpO2Z1bmN0aW9uIGEoKXtjb25zdCBlPVwiYWRkX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSArIGI7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdjEgKyB2MjtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gdSgpe2NvbnN0IGU9XCJkaXZfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhIC8gYjtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIHJldHVybiB2MSAvIHYyO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBsKCl7Y29uc3QgZT1cIm11bF9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGEgKiBiO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHYxICogdjI7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGMoKXtjb25zdCBlPVwic3ViX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gYSAtIGI7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdjEgLSB2MjtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gcCgpe2NvbnN0IGU9XCJlcXVhbF9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KGEgPT0gYik7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdmVjNChlcXVhbCh2MSwgdjIpKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gZCgpe2NvbnN0IGU9XCJncmVhdGVyX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoYSA+IGIpO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuIHZlYzQoIHYxLnIgPiB2Mi5yICxcXG4gICAgICB2MS5nID4gdjIuZyxcXG4gICAgICB2MS5iID4gdjIuYixcXG4gICAgICB2MS5hID4gdjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBmKCl7Y29uc3QgZT1cImxlc3NfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBmbG9hdChhIDwgYik7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdmVjNCggdjEuciA8IHYyLnIgLFxcbiAgICAgICAgICAgICAgICB2MS5nIDwgdjIuZyxcXG4gICAgICAgICAgICAgICAgdjEuYiA8IHYyLmIsXFxuICAgICAgICAgICAgICAgIHYxLmEgPCB2Mi5hICk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOm8uRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIGgoKXtjb25zdCBlPVwiYW5kX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgJiYgYm9vbChiKSApO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XFxuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xcbiAgICByZXR1cm4gdmVjNCggYjEuciAmJiBiMi5yICxcXG4gICAgICAgICAgICAgICAgYjEuZyAmJiBiMi5nLFxcbiAgICAgICAgICAgICAgICBiMS5iICYmIGIyLmIsXFxuICAgICAgICAgICAgICAgIGIxLmEgJiYgYjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBnKCl7Y29uc3QgZT1cIm9yX1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX0oZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgICByZXR1cm4gZmxvYXQoIGJvb2woYSkgfHwgYm9vbChiKSApO1xcbiAgfVxcbiAgdmVjNCAke2V9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgYnZlYzQgYjEgPSBidmVjNCh2MSk7XFxuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xcbiAgICByZXR1cm4gdmVjNCggYjEuciB8fCBiMi5yICxcXG4gICAgICAgICAgICAgICAgYjEuZyB8fCBiMi5nLFxcbiAgICAgICAgICAgICAgICBiMS5iIHx8IGIyLmIsXFxuICAgICAgICAgICAgICAgIGIxLmEgfHwgYjIuYSApO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBiKCl7Y29uc3QgZT1cInhvcl9cIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9KGZsb2F0IGEsIGZsb2F0IGIpIHtcXG4gICAgcmV0dXJuIGZsb2F0KCBib29sKGEpIF5eIGJvb2woYikgKTtcXG4gIH1cXG4gIHZlYzQgJHtlfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XFxuICAgIGJ2ZWM0IGIxID0gYnZlYzQodjEpO1xcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcXG4gICAgcmV0dXJuIHZlYzQoIGIxLnIgXl4gYjIuciAsXFxuICAgICAgICAgICAgICAgIGIxLmcgXl4gYjIuZyxcXG4gICAgICAgICAgICAgICAgYjEuYiBeXiBiMi5iLFxcbiAgICAgICAgICAgICAgICBiMS5hIF5eIGIyLmEgKTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gbSgpe3JldHVybiBmdW5jdGlvbihlKXtjb25zdCB0PWAke2V9X2A7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHt0fShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiAke2V9KGEsIGIpO1xcbiAgfVxcbiAgdmVjNCAke3R9KHZlYzQgdjEsIHZlYzQgdjIpIHtcXG4gICAgcmV0dXJuICR7ZX0odjEsIHYyKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6by5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19KFwicG93XCIpfWZ1bmN0aW9uIHkoKXtjb25zdCBlPVwicHJlbHVfXCI7cmV0dXJue2JvZHk6YFxcbiAgZmxvYXQgJHtlfShmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgIHJldHVybiBhIDwgMC4wID8gYSAqIGI6IGE7XFxuICB9XFxuICB2ZWM0ICR7ZX0odmVjNCB2MSwgdmVjNCB2Mikge1xcbiAgICByZXR1cm4gdmVjNChcXG4gICAgICB2MS5yIDwgMC4wID8gdjEuciAqIHYyLnI6IHYxLnIsXFxuICAgICAgdjEuZyA8IDAuMCA/IHYxLmcgKiB2Mi5nOiB2MS5nLFxcbiAgICAgIHYxLmIgPCAwLjAgPyB2MS5iICogdjIuYjogdjEuYixcXG4gICAgICB2MS5hIDwgMC4wID8gdjEuYSAqIHYyLmE6IHYxLmFcXG4gICAgICApO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTpvLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX10Lmdsc2xBZGQ9YSx0Lmdsc2xEaXY9dSx0Lmdsc2xNdWw9bCx0Lmdsc2xTdWI9Yyx0Lmdsc2xFcXVhbD1wLHQuZ2xzbEdyZWF0ZXI9ZCx0Lmdsc2xMZXNzPWYsdC5nbHNsQW5kPWgsdC5nbHNsT3I9Zyx0Lmdsc2xYb3I9Yix0Lmdsc2xQb3c9bSx0Lmdsc2xQUmVsdT15O2NvbnN0IF89KGUsdCxuLHI9dFswXS50eXBlLG8pPT57Y29uc3QgaT1lLnNlc3Npb24ucGFjaz9zLlRleHR1cmVUeXBlLnBhY2tlZDpzLlRleHR1cmVUeXBlLnVucGFja2VkO3JldHVybntuYW1lOm4ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbaSxpXSxjYWNoZUhpbnQ6byxnZXQ6KCk9PnYoZSx0LG4scil9fSx2PShlLHQsbixvPXRbMF0udHlwZSk9Pntjb25zdCBhPWUuc2Vzc2lvbi5wYWNrP3MuVGV4dHVyZVR5cGUucGFja2VkOnMuVGV4dHVyZVR5cGUudW5wYWNrZWQsdT0hci5TaGFwZVV0aWwuYXJlRXF1YWwodFswXS5kaW1zLHRbMV0uZGltcyk7bGV0IGw9dFswXS5kaW1zO2NvbnN0IGM9ZS5zZXNzaW9uLnBhY2s7aWYodSl7Y29uc3Qgcz1yLkJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKHRbMF0uZGltcyx0WzFdLmRpbXMsITEpO2lmKCFzKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2w9cztjb25zdCB1PWwubGVuZ3RoLHA9MCE9PXRbMF0uZGltcy5sZW5ndGg/dFswXS5kaW1zLmxlbmd0aDoxLGQ9MCE9PXRbMV0uZGltcy5sZW5ndGg/dFsxXS5kaW1zLmxlbmd0aDoxLGY9MCE9PXRbMF0uZGltcy5sZW5ndGg/XCJiY2FzdEluZGljZXNfQShpbmRpY2VzLCBhaW5kaWNlcyk7XCI6XCJhaW5kaWNlc1swXSA9IDA7XCIsaD0wIT09dFsxXS5kaW1zLmxlbmd0aD9cImJjYXN0SW5kaWNlc19CKGluZGljZXMsIGJpbmRpY2VzKTtcIjpcImJpbmRpY2VzWzBdID0gMDtcIixnPSgwLGkuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGI9Yz9gXFxuICAgICAgJHtuLmJvZHl9XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCBhID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gJHtuLm5hbWV9KGEsIGIpO1xcbiAgICAgICAgJHtnLm91dHB1dH0gPSByZXN1bHQ7XFxuICAgICAgfWA6YFxcbiAgICAgICR7bi5ib2R5fVxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHt1fV0pIHtcXG4gICAgICAgIGludCBhaW5kaWNlc1ske3B9XTtcXG4gICAgICAgIGludCBiaW5kaWNlc1ske2R9XTtcXG4gICAgICAgICR7Zn1cXG4gICAgICAgICR7aH1cXG4gICAgICAgIHJldHVybiAke24ubmFtZX0oX0EoYWluZGljZXMpLCBfQihiaW5kaWNlcykpO1xcbiAgICAgIH1gO3JldHVybntuYW1lOm4ubmFtZSxpbnB1dE5hbWVzOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczpbYSxhXSxvdXRwdXQ6e2RpbXM6bCx0eXBlOm8sdGV4dHVyZVR5cGU6YX0sc2hhZGVyU291cmNlOmIsaGFzTWFpbjpjfX1jb25zdCBwPSgwLGkuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLGQ9YFxcbiAgICAke24uYm9keX1cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIHZlYzQgdjEgPSAke3AudGV4dHVyZTJEfShBLCBUZXhDb29yZHMpO1xcbiAgICAgIHZlYzQgdjIgPSAke3AudGV4dHVyZTJEfShCLCBUZXhDb29yZHMpO1xcbiAgICAgIHZlYzQgcmVzdWx0ID0gJHtuLm5hbWV9KHYxLCB2Mik7XFxuICAgICAgJHtwLm91dHB1dH0gPSByZXN1bHQ7XFxuICAgIH1cXG4gICAgYDtyZXR1cm57bmFtZTpuLm5hbWUsaW5wdXROYW1lczpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6W2EsYV0sb3V0cHV0OntkaW1zOnRbMF0uZGltcyx0eXBlOm8sdGV4dHVyZVR5cGU6YX0sc2hhZGVyU291cmNlOmQsaGFzTWFpbjohMH19O3QuYWRkPShlLHQpPT5bZS5ydW4oXyhlLHQsYSgpKSx0KV0sdC5hbmQ9KGUsdCk9PltlLnJ1bihfKGUsdCxoKCksXCJib29sXCIpLHQpXSx0LmRpdj0oZSx0KT0+W2UucnVuKF8oZSx0LHUoKSksdCldLHQuZXF1YWw9KGUsdCk9PltlLnJ1bihfKGUsdCxwKCksXCJib29sXCIpLHQpXSx0LmdyZWF0ZXI9KGUsdCk9PltlLnJ1bihfKGUsdCxkKCksXCJib29sXCIpLHQpXSx0Lmxlc3M9KGUsdCk9PltlLnJ1bihfKGUsdCxmKCksXCJib29sXCIpLHQpXSx0Lm11bD0oZSx0KT0+W2UucnVuKF8oZSx0LGwoKSksdCldLHQub3I9KGUsdCk9PltlLnJ1bihfKGUsdCxnKCksXCJib29sXCIpLHQpXSx0LnBvdz0oZSx0KT0+W2UucnVuKF8oZSx0LG0oKSksdCldLHQucFJlbHU9KGUsdCk9PltlLnJ1bihfKGUsdCx5KCkpLHQpXSx0LnN1Yj0oZSx0KT0+W2UucnVuKF8oZSx0LGMoKSksdCldLHQueG9yPShlLHQpPT5bZS5ydW4oXyhlLHQsYigpLFwiYm9vbFwiKSx0KV19LDQ3NTI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VDYXN0QXR0cmlidXRlcz10LmNhc3Q9dm9pZCAwO2NvbnN0IHI9big3MjczKTt0LmNhc3Q9KGUsdCxuKT0+KG8odCksW2UuY2FzdCh0WzBdLG4pXSksdC5wYXJzZUNhc3RBdHRyaWJ1dGVzPWU9PnIuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGUuYXR0cmlidXRlcy5nZXRJbnQoXCJ0b1wiKSk7Y29uc3Qgbz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDYXN0IHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDQ1OTU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSksaT1uKDQzMikscz1uKDU2MTQpO3QuY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm9Mb2FkZXI9KGUsdCxuKT0+e2NvbnN0IHU9KGw9dC5sZW5ndGgsYz1uLmNhY2hlS2V5LHtuYW1lOlwiQ29uY2F0IChwYWNrZWQpXCIsaW5wdXROYW1lczpBcnJheS5mcm9tKHtsZW5ndGg6bH0sKChlLHQpPT5gWCR7dH1gKSksaW5wdXRUeXBlczpBcnJheShsKS5maWxsKG8uVGV4dHVyZVR5cGUucGFja2VkKSxjYWNoZUhpbnQ6Y30pO3ZhciBsLGM7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKGUsdCxuLHUpPT57Y29uc3QgbD1uWzBdLmRpbXMuc2xpY2UoKTtpZih1Pj1sLmxlbmd0aHx8dTwtMSpsLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgZGltZW5zaW9uYWxpdHlcIik7dTwwJiYodT1sLmxlbmd0aCt1KTtjb25zdCBjPWwuc2xpY2UoMCk7Zm9yKGxldCBlPTE7ZTxuLmxlbmd0aDtlKyspe2NvbnN0IHQ9bltlXS5kaW1zLnNsaWNlKCk7Zm9yKGxldCBlPTA7ZTxsLmxlbmd0aDtlKyspaWYoZT09PXUpY1t1XSs9dFtlXTtlbHNlIGlmKGxbZV0hPT10W2VdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfWNvbnN0IHA9Yy5sZW5ndGgsZD0oMCxzLmdldENoYW5uZWxzKShcImNvb3Jkc1wiLHApLGY9KDAsaS5nZXRDb29yZHNEYXRhVHlwZSkocCksaD0oMCxzLnVucGFja0Zyb21DaGFubmVsKSgpLGc9bi5tYXAoKGU9PmUuZGltcykpLGI9KDAsaS5nZXRHbENoYW5uZWxzKShwKSxtPW5ldyBBcnJheShnLmxlbmd0aC0xKTttWzBdPWdbMF1bdV07Zm9yKGxldCBlPTE7ZTxtLmxlbmd0aDtlKyspbVtlXT1tW2UtMV0rZ1tlXVt1XTtjb25zdCB5PWJbdV0sXz1iLnNsaWNlKC0yKSx2PWIuam9pbigpO2xldCBUPWBpZiAoJHt5fSA8ICR7bVswXX0pIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgIGdldFgwKCR7dn0pLCB2ZWMyKCR7Xy5qb2luKCl9KSk7XFxuICAgICAgICB9YDtmb3IobGV0IGU9MTtlPG0ubGVuZ3RoO2UrKyl7Y29uc3QgdD1tW2UtMV07VCs9YFxcbiAgICAgICAgICAgIGlmICgke3l9IDwgJHttW2VdfSAgJiYgJHt5fSA+PSAke21bZS0xXX0pIHtcXG4gICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICBnZXRYJHtlfSgke2EoYix5LHQpfSksXFxuICAgICAgICAgICAgICAgIHZlYzIoJHthKF8seSx0KX0pKTtcXG4gICAgICAgICAgICB9YH1jb25zdCB4PW0ubGVuZ3RoLHc9bVttLmxlbmd0aC0xXTtUKz1gXFxuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXFxuICAgICAgICAgICAgICBnZXRYJHt4fSgke2EoYix5LHcpfSksXFxuICAgICAgICAgICAgICB2ZWMyKCR7YShfLHksdyl9KSk7YDtjb25zdCBPPSgwLHIuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFM9YFxcbiAgICAgICAgICAke2h9XFxuICAgICAgICAgIGZsb2F0IGdldFZhbHVlKCR7Yi5tYXAoKGU9PlwiaW50IFwiK2UpKX0pIHtcXG4gICAgICAgICAgICAke1R9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICAgICR7Zn0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgICAgaW50IGxhc3REaW0gPSBjb29yZHMuJHtiW3AtMV19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0xXX0gPSBjb29yZHMuJHtiW3AtMl19O1xcbiAgICAgICAgICAgIGNvb3Jkcy4ke2JbcC0yXX0gPSBsYXN0RGltO1xcblxcbiAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2R9KSwgMC4sIDAuLCAwLik7XFxuXFxuICAgICAgICAgICAgJHtkW3AtMV19ID0gJHtkW3AtMV19ICsgMTtcXG4gICAgICAgICAgICBpZiAoJHtkW3AtMV19IDwgJHtjW3AtMV19KSB7XFxuICAgICAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKCR7ZH0pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAke2RbcC0yXX0gPSAke2RbcC0yXX0gKyAxO1xcbiAgICAgICAgICAgIGlmICgke2RbcC0yXX0gPCAke2NbcC0yXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoJHtkfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICR7ZFtwLTFdfSA9ICR7ZFtwLTFdfSAtIDE7XFxuICAgICAgICAgICAgaWYgKCR7ZFtwLTJdfSA8ICR7Y1twLTJdfSAmJlxcbiAgICAgICAgICAgICAgICAke2RbcC0xXX0gPCAke2NbcC0xXX0pIHtcXG4gICAgICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoJHtkfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICR7Ty5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpjLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6UyxoYXNNYWluOiEwfSl9KShlLHUsdCxuLmF4aXMpfSl9O2NvbnN0IGE9KGUsdCxuKT0+e2NvbnN0IHI9ZS5pbmRleE9mKHQpO3JldHVybiBlLm1hcCgoKGUsdCk9PnQ9PT1yP2Ake2V9IC0gJHtufWA6ZSkpLmpvaW4oKX19LDY2Njg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VDb25jYXRBdHRyaWJ1dGVzPXQuY29uY2F0PXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDU2MzkpLGk9big0NTk1KTt0LmNvbmNhdD0oZSx0LG4pPT4ocCh0KSxlLnNlc3Npb24ucGFjayYmdFswXS5kaW1zLmxlbmd0aD4xP1tlLnJ1bigoMCxpLmNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyKShlLHQsbiksdCldOltlLnJ1bihzKGUsdCxuKSx0KV0pO2NvbnN0IHM9KGUsdCxuKT0+e2NvbnN0IHI9KGk9dC5sZW5ndGgscz1uLmNhY2hlS2V5LHtuYW1lOlwiQ29uY2F0XCIsaW5wdXROYW1lczpBcnJheS5mcm9tKHtsZW5ndGg6aX0sKChlLHQpPT5gWCR7dH1gKSksaW5wdXRUeXBlczpBcnJheShpKS5maWxsKG8uVGV4dHVyZVR5cGUudW5wYWNrZWQpLGNhY2hlSGludDpzfSk7dmFyIGkscztyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PigoZSx0LG4scik9Pntjb25zdCBpPW5bMF0uZGltcy5zbGljZSgpO2lmKHI+PWkubGVuZ3RofHxyPC0xKmkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc24ndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eVwiKTtyPDAmJihyPWkubGVuZ3RoK3IpO2NvbnN0IHM9aS5zbGljZSgwKTtmb3IobGV0IGU9MTtlPG4ubGVuZ3RoO2UrKyl7Y29uc3QgdD1uW2VdLmRpbXMuc2xpY2UoKTtmb3IobGV0IGU9MDtlPGkubGVuZ3RoO2UrKylpZihlPT09cilzW3JdKz10W2VdO2Vsc2UgaWYoaVtlXSE9PXRbZV0pdGhyb3cgbmV3IEVycm9yKFwibm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2hcIil9Y29uc3QgcD1zLmxlbmd0aCxkPW5ldyBBcnJheShuLmxlbmd0aCk7bGV0IGY9MDtmb3IobGV0IGU9MDtlPGQubGVuZ3RoOysrZSlmKz1uW2VdLmRpbXNbcl0sZFtlXT1mO2xldCBoPVwiXCI7aD1uLmxlbmd0aDw1P2EoZCk6dShkKTtjb25zdCBnPWBcXG4gICAgICAgICR7bChuLmxlbmd0aCxwKX1cXG4gICAgICAgICR7YyhkKX1cXG4gICAgICAgICR7aH1cXG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtwfV0pIHtcXG4gICAgICAgICAgaW50IHRleHR1cmVJbmRleCA9IGdldFRleHR1cmVXaGVyZURhdGFSZXNpZGVzIChpbmRpY2VzWyR7cn1dKTtcXG5cXG4gICAgICAgICAgaWYodGV4dHVyZUluZGV4ICE9IDApIHtcXG4gICAgICAgICAgICBpbmRpY2VzWyR7cn1dID0gaW5kaWNlc1ske3J9XSAtIGludChnZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXgodGV4dHVyZUluZGV4LWludCgxKSkpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmUodGV4dHVyZUluZGV4LCBpbmRpY2VzKTtcXG4gICAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpzLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpnfSl9KSgwLHIsdCxuLmF4aXMpfSl9LGE9ZT0+e2NvbnN0IHQ9ZS5tYXAoKChlLHQpPT5gaWYoaW5kZXg8JHtlfSkge3JldHVybiAke3R9O31cXG5gKSk7cmV0dXJuYGludCBnZXRUZXh0dXJlV2hlcmVEYXRhUmVzaWRlcyhpbnQgaW5kZXgpIHtcXG4gICAgICAke3Quam9pbihcIlwiKX1cXG4gICAgfWB9LHU9ZT0+YShlKSxsPShlLHQpPT57Y29uc3Qgbj1bYGZsb2F0IGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZShpbnQgdGV4dHVyZUluZGV4LCBpbnQgaW5kaWNlc1ske3R9XSkge2BdO2ZvcihsZXQgdD0wO3Q8ZTsrK3QpMD09PXQ/bi5wdXNoKGBcXHRpZiAodGV4dHVyZUluZGV4ID09ICR7dH0pIHsgcmV0dXJuIF9YJHt0fShpbmRpY2VzKTsgfWApOnQ9PT1lLTE/bi5wdXNoKGBcXHRlbHNlIHsgcmV0dXJuIF9YJHt0fShpbmRpY2VzKTsgfWApOm4ucHVzaChgXFx0ZWxzZSBpZiAodGV4dHVyZUluZGV4ID09ICR7dH0pIHsgcmV0dXJuIF9YJHt0fShpbmRpY2VzKTsgfWApO3JldHVybiBuLnB1c2goXCJcXHR9XCIpLG4uam9pbihcIlxcblwiKX0sYz1lPT57Y29uc3QgdD1bXCJpbnQgZ2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4KGludCBpbmRleCkge1wiXTtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbikwPT09bj90LnB1c2goYFxcdGlmIChpbmRleCA9PSAke259KSB7IHJldHVybiAke2Vbbl19OyB9YCk6bj09PWUubGVuZ3RoLTE/dC5wdXNoKGBcXHRlbHNlIHsgcmV0dXJuICR7ZVtuXX07IH1gKTp0LnB1c2goYFxcdGVsc2UgaWYgKGluZGV4ID09ICR7bn0pIHsgcmV0dXJuICR7ZVtuXX07IH1gKTtyZXR1cm4gdC5wdXNoKFwiXFx0fVwiKSx0LmpvaW4oXCJcXG5cIil9O3QucGFyc2VDb25jYXRBdHRyaWJ1dGVzPWU9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczplLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiKX0pO2NvbnN0IHA9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2NvbnN0IHQ9ZVswXS50eXBlLG49ZVswXS5kaW1zLmxlbmd0aDtpZihcInN0cmluZ1wiPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO2Zvcihjb25zdCByIG9mIGUpe2lmKHIudHlwZSE9PXQpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYoci5kaW1zLmxlbmd0aCE9PW4pdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKX19fSw3ODI1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlcj12b2lkIDA7Y29uc3Qgcj1uKDEzMTUpLG89big2NzU3KSxpPW4oNTYzOSkscz1uKDk3NTQpLGE9bigyMTUwKTt0LmNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlcj0oZSx0LG4pPT57Y29uc3QgdT0obD10Lmxlbmd0aD4yLGM9bi5jYWNoZUtleSx7bmFtZTpcIkdyb3VwZWRDb252XCIsaW5wdXROYW1lczpsP1tcIlhcIixcIldcIixcIkJpYXNcIl06W1wiWFwiLFwiV1wiXSxpbnB1dFR5cGVzOmw/W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXTpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6Y30pO3ZhciBsLGM7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKGUsdCxuLHUpPT57Y29uc3QgbD10Lmxlbmd0aD4yP1widmFsdWUgKz0gZ2V0QmlhcyhvdXRwdXRfY2hhbm5lbCk7XCI6XCJcIixjPXRbMF0uZGltcy5zbGljZSgpLHA9dFsxXS5kaW1zLnNsaWNlKCksZD1wWzBdL3UuZ3JvdXA7ci5Mb2dnZXIudmVyYm9zZShcIkdyb3VwZWRDb252XCIsYGF1dHBQYWQ6JHt1LmF1dG9QYWR9LCBkaWxhdGlvbnM6JHt1LmRpbGF0aW9uc30sIGdyb3VwOiR7dS5ncm91cH0sIGtlcm5lbFNoYXBlOiR7dS5rZXJuZWxTaGFwZX0sIHBhZHM6JHt1LnBhZHN9LCBzdHJpZGVzOiR7dS5zdHJpZGVzfWApO2NvbnN0IGY9KDAscy5jYWxjdWxhdGVPdXRwdXRTaGFwZSkoYyxwLHUuZGlsYXRpb25zLHUucGFkcyx1LnN0cmlkZXMpLGg9KDAsby5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikse2FjdGl2YXRpb25GdW5jdGlvbjpnLGFwcGx5QWN0aXZhdGlvbjpifT0oMCxhLmdldEFjdGl2YXRpb25TbmlwcGV0KSh1KSxtPWBcXG4gIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke3Uuc3RyaWRlc1swXX0sICR7dS5zdHJpZGVzWzFdfSk7XFxuICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHt1LnBhZHNbMF19LCAke3UucGFkc1sxXX0pO1xcbiAgJHtnfVxcbiAgdm9pZCBtYWluKCkge1xcbiAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgIGludCBvdXRwdXRfY2hhbm5lbCA9IGNvb3Jkcy55O1xcbiAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMuencgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgaW50IGdyb3VwX2lkID0gb3V0cHV0X2NoYW5uZWwgLyAke2R9O1xcblxcbiAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcXG4gICAgZm9yIChpbnQgd0luQ2hhbm5lbCA9IDA7IHdJbkNoYW5uZWwgPCAke3BbMV19OyB3SW5DaGFubmVsKyspIHtcXG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHtwWzFdfSArIHdJbkNoYW5uZWw7XFxuICAgICAgZm9yIChpbnQgd0hlaWdodCA9IDA7IHdIZWlnaHQgPCAke3BbMl19OyB3SGVpZ2h0KyspIHtcXG4gICAgICAgIGludCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogJHt1LmRpbGF0aW9uc1swXX07XFxuXFxuICAgICAgICBpZiAoeEhlaWdodCA8IDAgfHwgeEhlaWdodCA+PSAke2NbMl19KSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yIChpbnQgd1dpZHRoID0gMDsgd1dpZHRoIDwgJHtwWzNdfTsgd1dpZHRoKyspIHtcXG4gICAgICAgICAgaW50IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogJHt1LmRpbGF0aW9uc1sxXX07XFxuICAgICAgICAgIGlmICh4V2lkdGggPCAwIHx8IHhXaWR0aCA+PSAke2NbM119KSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIGlucHV0X2NoYW5uZWwsIHhXaWR0aCwgeEhlaWdodCk7XFxuICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKG91dHB1dF9jaGFubmVsLCB3SW5DaGFubmVsLCB3V2lkdGgsIHdIZWlnaHQpO1xcbiAgICAgICAgICB2YWx1ZSArPSB4VmFsKndWYWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7bH1cXG4gICAgJHtifVxcbiAgICAke2gub3V0cHV0fSA9IHZlYzQodmFsdWUsIC4wLCAuMCwgLjApO1xcbiAgfVxcbmA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmYsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOm0saGFzTWFpbjohMH0pfSkoZSx0LHUsbil9KX19LDc3MDg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY29udjJEUGFja2VkPXQuY29udjJEUGFja2VkUG9pbnR3aXNlPXZvaWQgMDtjb25zdCByPW4oOTc1NCksbz1uKDU5NTApLGk9big1NjMyKTt0LmNvbnYyRFBhY2tlZFBvaW50d2lzZT0oZSx0LG4pPT57Y29uc3Qgbz10WzBdLmRpbXMscz10WzFdLmRpbXMsYT0oMCxyLmNhbGN1bGF0ZU91dHB1dFNoYXBlKShvLHMsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyksdT1lLnJlc2hhcGVQYWNrZWQodFswXSxbb1sxXSxvWzJdKm9bM11dKSxsPWUucmVzaGFwZVBhY2tlZCh0WzFdLFtzWzBdLHNbMV1dKSxjPXQubGVuZ3RoPjI/W2wsdSx0WzJdXTpbbCx1XSxwPWUucnVuKCgwLGkuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIpKGUsYyxuKSxjKTtyZXR1cm4gZS5yZXNoYXBlUGFja2VkKHAsYSl9LHQuY29udjJEUGFja2VkPShlLHQsbik9Pntjb25zdCBzPXRbMF0uZGltcyxhPXRbMV0uZGltcyx1PSgwLHIuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKHMsYSxuLmRpbGF0aW9ucyxuLnBhZHMsbi5zdHJpZGVzKSxsPWUucnVuKCgwLG8uY3JlYXRlUGFja2VkSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIpKGUsdFswXSx0WzFdLHUsbiksW3RbMF1dKSxjPWUucmVzaGFwZVBhY2tlZCh0WzFdLFthWzBdLGFbMV0qYVsyXSphWzNdXSkscD0zPT09dC5sZW5ndGg/W2MsbCx0WzJdXTpbYyxsXSxkPWUucnVuKCgwLGkuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIpKGUscCxuKSxwKTtyZXR1cm4gZS5yZXNoYXBlUGFja2VkKGQsdSl9fSw1MDQyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM9dC5jb252VHJhbnNwb3NlPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDY3NTcpLGk9big1NjM5KSxzPW4oMjE1MCksYT0oZSx0LG4scixvLGkpPT4oZS0xKSp0K24rKHItMSkqbysxLWksdT0oZSx0LG4scixvKT0+e2NvbnN0IGk9TWF0aC5mbG9vcihlLzIpO1wiU0FNRV9VUFBFUlwiPT09dD8obltyXT1pLG5bb109ZS1pKTpcIlNBTUVfTE9XRVJcIj09PXQmJihuW3JdPWUtaSxuW29dPWkpfTt0LmNvbnZUcmFuc3Bvc2U9KGUsdCxuKT0+KGQodCxuKSxsKGUsdCxuKSk7Y29uc3QgbD0oZSx0LG4pPT57Y29uc3Qgcj1wKG4sdCk7cmV0dXJuW2MoZSx0LHIpXX0sYz0oZSx0LG4pPT5lLnJ1bigoKGUsdCxuKT0+e2NvbnN0IHI9KGE9dC5sZW5ndGg+Mix1PW4uY2FjaGVLZXkse25hbWU6XCJDb252VHJhbnNwb3NlXCIsaW5wdXROYW1lczphP1tcIlhcIixcIldcIixcIkJcIl06W1wiWFwiLFwiV1wiXSxpbnB1dFR5cGVzOmE/W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXTpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciBhLHU7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT4oKGUsdCxuLHIpPT57Y29uc3QgYT10Lmxlbmd0aD4yP1wiZ2V0QihvdXRwdXRfY2hhbm5lbClcIjpcIjAuMFwiLHU9dFswXS5kaW1zLGw9dFsxXS5kaW1zLGM9bFsxXSxwPWxbMF0vci5ncm91cCxkPVt0WzBdLmRpbXNbMF0sdFsxXS5kaW1zWzFdKnIuZ3JvdXAsLi4uci5vdXRwdXRTaGFwZV0sZj0oMCxvLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSx7YWN0aXZhdGlvbkZ1bmN0aW9uOmgsYXBwbHlBY3RpdmF0aW9uOmd9PSgwLHMuZ2V0QWN0aXZhdGlvblNuaXBwZXQpKHIpLGI9YFxcbiAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKCR7ci5zdHJpZGVzWzBdfSwgJHtyLnN0cmlkZXNbMV19KTtcXG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3IucGFkc1swXX0sICR7ci5wYWRzWzFdfSk7XFxuICAke2h9XFxuICB2b2lkIG1haW4oKSB7XFxuICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XFxuXFxuICAgIGl2ZWMyIGxvYyA9IGNvb3Jkcy56dyArIHBhZHM7XFxuXFxuICAgIGludCBncm91cF9pZCA9IG91dHB1dF9jaGFubmVsIC8gJHtjfTtcXG4gICAgaW50IHdPdXRDaGFubmVsID0gb3V0cHV0X2NoYW5uZWwgLSBncm91cF9pZCAqICR7Y307XFxuXFxuICAgIGZsb2F0IHZhbHVlID0gJHthfTtcXG4gICAgZm9yIChpbnQgaW5DaGFubmVsT2Zmc2V0ID0gMDsgaW5DaGFubmVsT2Zmc2V0IDwgJHtwfTsgaW5DaGFubmVsT2Zmc2V0KyspIHtcXG4gICAgICBpbnQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogJHtwfSArIGluQ2hhbm5lbE9mZnNldDtcXG4gICAgICBmb3IgKGludCB3V09mZiA9IDA7IHdXT2ZmIDwgJHtsWzJdfTsgd1dPZmYrKykge1xcbiAgICAgICAgZm9yIChpbnQgd0hPZmYgPSAwOyB3SE9mZiA8ICR7bFszXX07IHdIT2ZmKyspIHtcXG4gICAgICAgICAgaXZlYzIgd09mZiA9IGl2ZWMyKHdXT2ZmICogJHtyLmRpbGF0aW9uc1swXX0sIHdIT2ZmICogJHtyLmRpbGF0aW9uc1sxXX0pO1xcbiAgICAgICAgICBpdmVjMiB3TG9jID0gbG9jIC0gd09mZjtcXG4gICAgICAgICAgaXZlYzIgd0xvY0luID0gd0xvYyAvIHN0cmlkZXM7XFxuICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICB3TG9jSW4gKiBzdHJpZGVzID09IHdMb2MgJiZcXG4gICAgICAgICAgICB3TG9jSW4ueCA+PSAwICYmIHdMb2NJbi54IDwgJHt1WzJdfSAmJlxcbiAgICAgICAgICAgIHdMb2NJbi55ID49IDAgJiYgd0xvY0luLnkgPCAke3VbM119XFxuICAgICAgICAgICkge1xcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB3TG9jSW4ueSwgd0xvY0luLngpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKGlucHV0X2NoYW5uZWwsIHdPdXRDaGFubmVsLCB3SE9mZiwgd1dPZmYpO1xcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgICR7Z31cXG4gICAgJHtmLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcXG4gIH1cXG5gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpkLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpiLGhhc01haW46ITB9KX0pKGUsdCxyLG4pfSl9KShlLHQsbiksdCkscD0oZSx0KT0+e2NvbnN0IG49ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKDA9PT1lLmtlcm5lbFNoYXBlLmxlbmd0aClmb3IobGV0IGU9MjtlPHRbMV0uZGltcy5sZW5ndGg7KytlKW4ucHVzaCh0WzFdLmRpbXNbZV0pO2NvbnN0IHI9ZS5wYWRzLnNsaWNlKCksbz1lLm91dHB1dFNoYXBlLnNsaWNlKCk7KChlLHQsbixyLG8saSxzLGwpPT57Y29uc3QgYz1lLmxlbmd0aC0yLHA9MD09PWwubGVuZ3RoO2ZvcihsZXQgZD0wO2Q8YzsrK2Qpe2NvbnN0IGY9cD9lW2QrMl0qaVtkXTpsW2RdLGg9YShlW2QrMl0saVtkXSxvW2RdLHRbZF0sbltkXSxmKTt1KGgscixvLGQsZCtjKSxwJiZsLnB1c2goaVtkXSooZVtkKzJdLTEpK3NbZF0rKHRbZF0tMSkqbltkXSsxLW9bZF0tb1tkK2NdKX19KSh0WzBdLmRpbXMsbixlLmRpbGF0aW9ucyxlLmF1dG9QYWQscixlLnN0cmlkZXMsZS5vdXRwdXRQYWRkaW5nLG8pO2NvbnN0IGk9T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihpLHtrZXJuZWxTaGFwZTpuLHBhZHM6cixvdXRwdXRTaGFwZTpvLGNhY2hlS2V5OmUuY2FjaGVLZXl9KSxpfTt0LnBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLG49KDAscy5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKHQpLG89dC5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLGk9dC5nZXRJbnRzKFwiZGlsYXRpb25zXCIsWzEsMV0pLGE9dC5nZXRJbnQoXCJncm91cFwiLDEpLHU9dC5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIsW10pLGw9dC5nZXRJbnRzKFwib3V0cHV0X3BhZGRpbmdcIixbMCwwXSksYz10LmdldEludHMoXCJvdXRwdXRfc2hhcGVcIixbXSkscD10LmdldEludHMoXCJwYWRzXCIsWzAsMCwwLDBdKSxkPXQuZ2V0SW50cyhcInN0cmlkZXNcIixbMSwxXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKE9iamVjdC5hc3NpZ24oe2F1dG9QYWQ6byxkaWxhdGlvbnM6aSxncm91cDphLGtlcm5lbFNoYXBlOnUsb3V0cHV0UGFkZGluZzpsLG91dHB1dFNoYXBlOmMscGFkczpwLHN0cmlkZXM6ZH0sbikpfTtjb25zdCBkPShlLHQpPT57aWYoIWV8fDIhPT1lLmxlbmd0aCYmMyE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZig0IT09ZVswXS5kaW1zLmxlbmd0aHx8NCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYoZVswXS5kaW1zWzFdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7Y29uc3Qgbj1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZigzPT09ZS5sZW5ndGgmJigxIT09ZVsyXS5kaW1zLmxlbmd0aHx8ZVsyXS5kaW1zWzBdIT09bikpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2NvbnN0IHI9ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7cn1EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3J9RGApO2lmKHQucGFkcy5sZW5ndGghPT0yKnIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAkezIqcn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PXIpdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtyfURgKTtpZigwIT09dC5rZXJuZWxTaGFwZS5sZW5ndGgmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKDAhPT10Lm91dHB1dFNoYXBlLmxlbmd0aCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIik7aWYoXCJmbG9hdDMyXCIhPT1lWzBdLnR5cGV8fFwiZmxvYXQzMlwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkNvbnZUcmFuc3Bvc2UgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpO2lmKDM9PT1lLmxlbmd0aCYmXCJmbG9hdDMyXCIhPT1lWzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sOTc1NDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUNvbnZBdHRyaWJ1dGVzPXQuY29udj10LmNhbGN1bGF0ZU91dHB1dFNoYXBlPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDcyNzMpLGk9big3ODI1KSxzPW4oNzcwOCksYT1uKDMyODEpLHU9bigyMTUwKSxsPW4oMTYyNSksYz1uKDgyNzYpO3QuY2FsY3VsYXRlT3V0cHV0U2hhcGU9KGUsdCxuLHIsbyk9Pntjb25zdCBpPWVbMF0scz1lLnNsaWNlKDIpLGE9cy5sZW5ndGgsdT10WzBdLGw9dC5zbGljZSgyKS5tYXAoKChlLHQpPT5lKyhlLTEpKihuW3RdLTEpKSksYz1zLm1hcCgoKGUsdCk9PmUrclt0XStyW3QrYV0pKSxwPWMubWFwKCgoZSx0KT0+TWF0aC5mbG9vcigoZS1sW3RdK29bdF0pL29bdF0pKSk7cmV0dXJuW2ksdV0uY29uY2F0KC4uLnApfSx0LmNvbnY9KGUsdCxuKT0+KGcodCxuKSxwKGUsdCxuKSk7Y29uc3QgcD0oZSx0LG4pPT57Y29uc3Qgcj1oKG4sdCksbz1lLnNlc3Npb24ucGFjayxhPTE9PT1yLmtlcm5lbFNoYXBlWzBdJiYxPT09ci5rZXJuZWxTaGFwZVsxXTtyZXR1cm4gci5ncm91cD4xP1tlLnJ1bigoMCxpLmNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlcikoZSx0LHIpLHQpXTphJiZvP1tkKGUsdCxyKV06byYmND09PXRbMF0uZGltcy5sZW5ndGgmJjE9PT10WzBdLmRpbXNbMF0mJiFhP1soMCxzLmNvbnYyRFBhY2tlZCkoZSx0LHIpXTpbZihlLHQscildfSxkPShlLG4scik9Pntjb25zdCBvPW5bMF0uZGltcyxpPW5bMV0uZGltcyxzPSgwLHQuY2FsY3VsYXRlT3V0cHV0U2hhcGUpKG8saSxyLmRpbGF0aW9ucyxyLnBhZHMsci5zdHJpZGVzKSxhPWUucmVzaGFwZVVucGFja2VkKG5bMF0sW29bMV0sb1syXSpvWzNdXSksdT1lLnJlc2hhcGVVbnBhY2tlZChuWzFdLFtpWzBdLGlbMV1dKSxsPW4ubGVuZ3RoPjI/W3UsYSxuWzJdXTpbdSxhXSxwPWUucnVuKCgwLGMuY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIpKGwsciksbCk7cmV0dXJuIGUucmVzaGFwZVVucGFja2VkKHAscyl9LGY9KGUsbixyKT0+e2NvbnN0IG89blswXS5kaW1zLGk9blsxXS5kaW1zLHM9KDAsdC5jYWxjdWxhdGVPdXRwdXRTaGFwZSkobyxpLHIuZGlsYXRpb25zLHIucGFkcyxyLnN0cmlkZXMpLHU9ZS5ydW4oKDAsbC5jcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcikoZSxuWzBdLG5bMV0scyxyKSxbblswXV0pLGM9Mz09PW4ubGVuZ3RoP1t1LG5bMV0sblsyXV06W3UsblsxXV07cmV0dXJuIGUucnVuKCgwLGEuY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvTG9hZGVyKShlLG4scyxyKSxjKX0saD0oZSx0KT0+e2NvbnN0IG49ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKDA9PT1lLmtlcm5lbFNoYXBlLmxlbmd0aClmb3IobGV0IGU9MjtlPHRbMV0uZGltcy5sZW5ndGg7KytlKW4ucHVzaCh0WzFdLmRpbXNbZV0pO2NvbnN0IHI9ZS5wYWRzLnNsaWNlKCk7by5Qb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHRbMF0uZGltcyxlLnN0cmlkZXMsZS5kaWxhdGlvbnMsbixyLGUuYXV0b1BhZCk7Y29uc3QgaT1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKGkse2tlcm5lbFNoYXBlOm4scGFkczpyLGNhY2hlS2V5OmUuY2FjaGVLZXl9KSxpfTt0LnBhcnNlQ29udkF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLG49KDAsdS5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpKHQpLG89dC5nZXRTdHJpbmcoXCJhdXRvX3BhZFwiLFwiTk9UU0VUXCIpLGk9dC5nZXRJbnRzKFwiZGlsYXRpb25zXCIsWzEsMV0pLHM9dC5nZXRJbnQoXCJncm91cFwiLDEpLGE9dC5nZXRJbnRzKFwia2VybmVsX3NoYXBlXCIsW10pLGw9dC5nZXRJbnRzKFwicGFkc1wiLFswLDAsMCwwXSksYz10LmdldEludHMoXCJzdHJpZGVzXCIsWzEsMV0pO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KShPYmplY3QuYXNzaWduKHthdXRvUGFkOm8sZGlsYXRpb25zOmksZ3JvdXA6cyxrZXJuZWxTaGFwZTphLHBhZHM6bCxzdHJpZGVzOmN9LG4pKX07Y29uc3QgZz0oZSx0KT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgmJjMhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoNCE9PWVbMF0uZGltcy5sZW5ndGh8fDQhPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252XCIpO2lmKGVbMF0uZGltc1sxXSE9PWVbMV0uZGltc1sxXSp0Lmdyb3VwKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7aWYoMz09PWUubGVuZ3RoJiYoMSE9PWVbMl0uZGltcy5sZW5ndGh8fGVbMV0uZGltc1swXSE9PWVbMl0uZGltc1swXSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2NvbnN0IG49ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PW4pdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7bn1EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PW4pdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke259RGApO2lmKHQucGFkcy5sZW5ndGghPT0yKm4pdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAkezIqbn1EYCk7aWYoMCE9PXQua2VybmVsU2hhcGUubGVuZ3RoJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZXx8XCJmbG9hdDMyXCIhPT1lWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQ29udiBpbnB1dChYLFcpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3JcIik7aWYoMz09PWUubGVuZ3RoJiZcImZsb2F0MzJcIiE9PWVbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDb252IGlucHV0KGJpYXMpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3JcIil9fSw2NzQyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlRGVwdGhUb1NwYWNlQXR0cmlidXRlcz10LmRlcHRoVG9TcGFjZT12b2lkIDA7Y29uc3Qgcj1uKDU3MDcpO3QuZGVwdGhUb1NwYWNlPShlLHQsbik9PntvKHQpO2NvbnN0IGk9bi5ibG9ja3NpemUscz1pKmksYT1cIkRDUlwiPT09bi5tb2RlP1swLDMsNCwxLDUsMl06WzAsMSw0LDIsNSwzXSx1PVwiRENSXCI9PT1uLm1vZGU/W3RbMF0uZGltc1swXSxpLGksdFswXS5kaW1zWzFdL3MsdFswXS5kaW1zWzJdLHRbMF0uZGltc1szXV06W3RbMF0uZGltc1swXSx0WzBdLmRpbXNbMV0vcyxpLGksdFswXS5kaW1zWzJdLHRbMF0uZGltc1szXV0sbD1lLnJlc2hhcGVVbnBhY2tlZCh0WzBdLHUpLGM9e3Blcm06YSxjYWNoZUtleTpgJHthfWB9LFtwXT0oMCxyLnRyYW5zcG9zZSkoZSxbbF0sYyksZD1bdFswXS5kaW1zWzBdLHRbMF0uZGltc1sxXS9zLHRbMF0uZGltc1syXSppLHRbMF0uZGltc1szXSppXTtyZXR1cm5bZS5yZXNoYXBlVW5wYWNrZWQocCxkKV19LHQucGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcy5nZXRJbnQoXCJibG9ja3NpemVcIik7aWYodDwxKXRocm93IG5ldyBFcnJvcihgYmxvY2tzaXplIG11c3QgYmUgPj0gMSwgYnV0IGdvdCA6ICR7dH0gZm9yIERlcHRoVG9TcGFjZWApO2NvbnN0IG49ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcIkRDUlwiKTtpZihcIkRDUlwiIT09biYmXCJDUkRcIiE9PW4pdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHtufSBmb3IgRGVwdGhUb1NwYWNlYCk7cmV0dXJue21vZGU6bixibG9ja3NpemU6dH19O2NvbnN0IG89ZT0+e2lmKDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYERlcHRoVG9TcGFjZSBleHBlY3QgMSBpbnB1dHMsIGJ1dCBnb3QgJHtlLmxlbmd0aH1gKTtpZihcInN0cmluZ1wiPT09ZVswXS50eXBlfHw0IT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVwdGhUb1NwYWNlIGlucHV0IHNob3VsZCBiZSBhIDQtRCBudW1lcmljIHRlbnNvclwiKX19LDMyODE6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNzI3Myksbz1uKDY3NTcpLGk9big1NjM5KSxzPW4oMjE1MCksYT1uKDE2MjUpO3QuY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvTG9hZGVyPShlLHQsbix1KT0+e2NvbnN0IGw9KChlLHQpPT4oe25hbWU6XCJDb252RG90UHJvZHVjdFwiLGlucHV0TmFtZXM6ZT9bXCJJbTJDb2xcIixcIktcIixcIkJcIl06W1wiSW0yQ29sXCIsXCJLXCJdLGlucHV0VHlwZXM6ZT9baS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24saS5UZXh0dXJlVHlwZS51bnBhY2tlZF06W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uXSxjYWNoZUtleTp0LmFjdGl2YXRpb25DYWNoZUtleX0pKSh0Lmxlbmd0aD4yLHUpO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2dldDooKT0+KChlLHQsbix1LGwpPT57Y29uc3QgYz1uWzBdLmRpbXMscD1uWzFdLmRpbXMsZD1bcFswXSxNYXRoLmNlaWwoY1sxXSpwWzJdKnBbM10vNCldLGY9KDAsYS5jYWxjdWxhdGVJbTJDb2xEaW1zKShjLHAsdSksW2gsZ109ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZCxpLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pLGI9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZiksW20seV09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoZixpLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pLF89dS5sZW5ndGgsdj1uLmxlbmd0aDwzP1wiMC4wXCI6XCJfQihiKVwiLFQ9TWF0aC5jZWlsKGNbMV0qcFsyXSpwWzNdLzQpLHthY3RpdmF0aW9uRnVuY3Rpb246eCxhcHBseUFjdGl2YXRpb246d309KDAscy5nZXRBY3RpdmF0aW9uU25pcHBldCkobCksTz0oMCxvLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxTPWBcXG4ke3h9XFxuZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske199XSkge1xcbiAgaW50IGJbMV07XFxuICBiWzBdID0gaW5kaWNlc1sxXTtcXG4gIGludCBpbTJjb2xbNF07XFxuICBpbTJjb2xbMF0gPSBpbmRpY2VzWzBdO1xcbiAgaW0yY29sWzFdID0gaW5kaWNlc1syXTtcXG4gIGltMmNvbFsyXSA9IGluZGljZXNbM107XFxuICBpbnQgaW0yY29sT2Zmc2V0ID0gaW0yY29sWzBdICogJHtiWzBdfSArIGltMmNvbFsxXSAqICR7YlsxXX0gKyBpbTJjb2xbMl0gKiAke2JbMl19O1xcbiAgaW50IGtlcm5lbE9mZnNldCA9IGluZGljZXNbMV0gKiAke2RbMV19O1xcbiAgZmxvYXQgdmFsdWUgPSAke3Z9O1xcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAke1R9OyArK2kpIHtcXG4gICAgdmVjMiBpbTJjb2xDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhpbTJjb2xPZmZzZXQsICR7bX0sICR7eX0pO1xcbiAgICB2ZWMyIGtlcm5lbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGtlcm5lbE9mZnNldCwgJHtofSwgJHtnfSk7XFxuICAgIHZhbHVlICs9IGRvdCgke08udGV4dHVyZTJEfShJbTJDb2wsIGltMmNvbENvb3JkcyksICR7Ty50ZXh0dXJlMkR9KEssIGtlcm5lbENvb3JkcykpO1xcbiAgICArK2ltMmNvbE9mZnNldDtcXG4gICAgKytrZXJuZWxPZmZzZXQ7XFxuICB9XFxuICAke3d9XFxuICByZXR1cm4gdmFsdWU7XFxufWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOnUsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOlN9KX0pKGUsbCx0LG4sdSl9KX19LDQxMjU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VGbGF0dGVuQXR0cmlidXRlcz10LmZsYXR0ZW49dm9pZCAwO2NvbnN0IHI9big3MjczKTt0LmZsYXR0ZW49KGUsdCxuKT0+e28odCxuKTtjb25zdCBpPXIuU2hhcGVVdGlsLmZsYXR0ZW5TaGFwZSh0WzBdLmRpbXMsbik7cmV0dXJuW2UucmVzaGFwZVVucGFja2VkKHRbMF0saSldfSx0LnBhcnNlRmxhdHRlbkF0dHJpYnV0ZXM9ZT0+ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwxKTtjb25zdCBvPShlLHQpPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0dGVuIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2NvbnN0IG49ZVswXS5kaW1zLmxlbmd0aDtpZigwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJzY2FsYXIgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO2lmKHQ8LW58fHQ+bil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF4aXNcIik7aWYoXCJzdHJpbmdcIj09PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQuXCIpfX0sMjE1MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXM9dC5nZXRBY3RpdmF0aW9uU25pcHBldD12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpLG89big5MDg3KTt0LmdldEFjdGl2YXRpb25TbmlwcGV0PWZ1bmN0aW9uKGUpe2xldCB0O3N3aXRjaChlLmFjdGl2YXRpb24pe2Nhc2VcIlJlbHVcIjp0PSgwLG8uZ2xzbFJlbHUpKCk7YnJlYWs7Y2FzZVwiU2lnbW9pZFwiOnQ9KDAsby5nbHNsU2lnbW9pZCkoKTticmVhaztjYXNlXCJDbGlwXCI6dD0oMCxvLmdsc2xDbGlwKShlLmNsaXBNaW4sZS5jbGlwTWF4KTticmVhaztkZWZhdWx0OnJldHVybnthY3RpdmF0aW9uRnVuY3Rpb246XCJcIixhcHBseUFjdGl2YXRpb246XCJcIn19Y29uc3Qgbj10Lm5hbWU7cmV0dXJue2FjdGl2YXRpb25GdW5jdGlvbjp0LmJvZHksYXBwbHlBY3RpdmF0aW9uOmB2YWx1ZSA9ICR7bn1fKHZhbHVlKTtgfX0sdC5wYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5nZXRTdHJpbmcoXCJhY3RpdmF0aW9uXCIsXCJcIik7aWYoXCJDbGlwXCI9PT10KXtjb25zdFtuLG9dPWUuZ2V0RmxvYXRzKFwiYWN0aXZhdGlvbl9wYXJhbXNcIixbci5NSU5fQ0xJUCxyLk1BWF9DTElQXSk7cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4Om8sY2xpcE1pbjpuLGFjdGl2YXRpb25DYWNoZUtleTpgJHt0fToke259LCR7b31gfX1yZXR1cm57YWN0aXZhdGlvbjp0LGFjdGl2YXRpb25DYWNoZUtleTp0fX19LDYxNDk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VHYXRoZXJBdHRyaWJ1dGVzPXQuZ2F0aGVyPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDYxNDUpLGk9big3MjczKSxzPW4oNTYzOSk7dC5nYXRoZXI9KGUsdCxuKT0+KGwodCxuLmF4aXMpLFtlLnJ1bih1KGUsdCxuKSx0KV0pLHQucGFyc2VHYXRoZXJBdHRyaWJ1dGVzPWU9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczplLmF0dHJpYnV0ZXMuZ2V0SW50KFwiYXhpc1wiLDApfSk7Y29uc3QgYT17bmFtZTpcIkdhdGhlclwiLGlucHV0TmFtZXM6W1wiQVwiLFwiQlwiXSxpbnB1dFR5cGVzOltzLlRleHR1cmVUeXBlLnVucGFja2VkLHMuVGV4dHVyZVR5cGUudW5wYWNrZWRdfSx1PShlLHQsbik9Pntjb25zdCByPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXl9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PigoZSx0LG4scik9Pntjb25zdCBvPW5bMF0uZGltcy5zbGljZSgpLGE9blsxXS5kaW1zLnNsaWNlKCksdT1uZXcgQXJyYXkoby5sZW5ndGgrYS5sZW5ndGgtMSk7cj1pLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKHIsby5sZW5ndGgpO2NvbnN0IGw9W107Zm9yKGxldCBlPTA7ZTx1Lmxlbmd0aDtlKyspZTxyPyh1W2VdPW9bZV0sbC5wdXNoKGBpbnB1dElkeFske2V9XSA9IG91dHB1dElkeFske2V9XTtgKSk6ZTxyK2EubGVuZ3RoPyh1W2VdPWFbZS1yXSxsLnB1c2goYGluZGV4RGF0YUlkeFske2Utcn1dID0gb3V0cHV0SWR4WyR7ZX1dO2ApKToodVtlXT1vW2UtYS5sZW5ndGgrMV0sbC5wdXNoKGBpbnB1dElkeFske2UtYS5sZW5ndGgrMX1dID0gb3V0cHV0SWR4WyR7ZX1dO2ApKTtjb25zdCBjPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHt1Lmxlbmd0aHx8MX1dKSB7XFxuICAgICAgICBpbnQgaW5wdXRJZHhbJHtvLmxlbmd0aH1dO1xcbiAgICAgICAgaW50IGluZGV4RGF0YUlkeFske2EubGVuZ3RofHwxfV07XFxuICAgICAgICBpbmRleERhdGFJZHhbMF0gPSAwO1xcbiAgICAgICAgJHtsLmpvaW4oXCJcXG4gICAgICAgIFwiKX1cXG4gICAgICAgIGludCBpZHggPSBpbnQoX0IoaW5kZXhEYXRhSWR4KSk7XFxuICAgICAgICBpbnB1dElkeFske3J9XSA9IGlkeCA8IDAgPyBpZHggKyAke29bcl19IDogaWR4O1xcbiAgICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOm5bMF0udHlwZSx0ZXh0dXJlVHlwZTpzLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6Y30pfSkoMCxyLHQsbi5heGlzKX0pfSxsPShlLHQpPT57aWYoIWV8fDIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2NvbnN0IG49ZVswXS5kaW1zLmxlbmd0aDtpZihuPDEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYodDwtbnx8dD5uLTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGlzLlwiKTtpZigtMT09PW8uTlVNQkVSX1RZUEVTLmluZGV4T2YoZVswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09ZVsxXS50eXBlJiZcImludDE2XCIhPT1lWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IHR5cGUuXCIpfX0sNTM3ODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUdlbW1BdHRyaWJ1dGVzVjExPXQucGFyc2VHZW1tQXR0cmlidXRlc1Y3PXQuZ2VtbT12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNTYzOSk7dC5nZW1tPShlLHQsbik9PihsKHQsbiksW2UucnVuKGEodCxuKSx0KV0pO2NvbnN0IHM9KGUsdCk9Pntjb25zdCBuPTAhPT1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwidHJhbnNBXCIsMCksbz0wIT09ZS5hdHRyaWJ1dGVzLmdldEludChcInRyYW5zQlwiLDApLGk9ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwxKSxzPWUuYXR0cmlidXRlcy5nZXRGbG9hdChcImJldGFcIiwxKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3RyYW5zQTpuLHRyYW5zQjpvLGFscGhhOmksYmV0YTpzLGlzT3B0aW9uYWxDOnR9KX07dC5wYXJzZUdlbW1BdHRyaWJ1dGVzVjc9ZT0+cyhlLCExKSx0LnBhcnNlR2VtbUF0dHJpYnV0ZXNWMTE9ZT0+cyhlLCEwKTtjb25zdCBhPShlLHQpPT57Y29uc3Qgbj17bmFtZTpcIkdlbW1cIixpbnB1dE5hbWVzOjM9PT1lLmxlbmd0aD9bXCJBXCIsXCJCXCIsXCJDXCJdOltcIkFcIixcIkJcIl0saW5wdXRUeXBlczozPT09ZS5sZW5ndGg/W2kuVGV4dHVyZVR5cGUudW5wYWNrZWQsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXTpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZCxpLlRleHR1cmVUeXBlLnVucGFja2VkXSxrZXk6dC5jYWNoZUtleX07cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7Z2V0OigpPT51KG4sZSx0KX0pfSx1PShlLHQsbik9Pntjb25zdCByPXRbMF0uZGltcy5zbGljZSgpLHM9dFsxXS5kaW1zLnNsaWNlKCksW2EsdV09by5HZW1tVXRpbC5nZXRTaGFwZU9mR2VtbVJlc3VsdChyLG4udHJhbnNBLHMsbi50cmFuc0IsMz09PXQubGVuZ3RoP3RbMl0uZGltczp2b2lkIDApLGw9W2EsdV07aWYoIWwpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IGM9cltyLmxlbmd0aC0xXSxwPVwiXCI7bi50cmFuc0EmJihjPXJbMF0pLG4udHJhbnNBJiZuLnRyYW5zQj9wPVwidmFsdWUgKz0gX0FfVChhKSAqIF9CX1QoYik7XCI6bi50cmFuc0EmJiFuLnRyYW5zQj9wPVwidmFsdWUgKz0gX0FfVChhKSAqIF9CKGIpO1wiOiFuLnRyYW5zQSYmbi50cmFuc0I/cD1cInZhbHVlICs9IF9BKGEpICogX0JfVChiKTtcIjpuLnRyYW5zQXx8bi50cmFuc0J8fChwPVwidmFsdWUgKz0gX0EoYSkgKiBfQihiKTtcIik7Y29uc3QgZD1sLmxlbmd0aCxmPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7ZH1dKSB7XFxuICAgICAgICAgIGludCBhWyR7ZH1dO1xcbiAgICAgICAgICBpbnQgYlske2R9XTtcXG4gICAgICAgICAgJHszPT09dC5sZW5ndGg/YGludCBjWyR7dFsyXS5kaW1zLmxlbmd0aH1dO2A6XCJcIn1cXG5cXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCBhKTtcXG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCBiKTtcXG4gICAgICAgICAgJHszPT09dC5sZW5ndGg/XCJiY2FzdEluZGljZXNfQyhpbmRpY2VzLCBjKTtcIjpcIlwifVxcblxcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9IDAuMDtcXG4gICAgICAgICAgZm9yIChpbnQgaz0wOyBrPCR7Y307ICsraykge1xcbiAgICAgICAgICAgICAgYVske2QtMX1dID0gaztcXG4gICAgICAgICAgICAgIGJbJHtkLTJ9XSA9IGs7XFxuICAgICAgICAgICAgICAke3B9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIGFscGhhO1xcbiAgICAgICAgICAkezM9PT10Lmxlbmd0aD9cInZhbHVlICs9IGJldGEgKiBfQyhjKTtcIjpcIlwifVxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmwsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sdmFyaWFibGVzOlt7bmFtZTpcImFscGhhXCIsdHlwZTpcImZsb2F0XCIsZGF0YTpuLmFscGhhfSx7bmFtZTpcImJldGFcIix0eXBlOlwiZmxvYXRcIixkYXRhOm4uYmV0YX1dLHNoYWRlclNvdXJjZTpmfSl9LGw9KGUsdCk9PntpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBtaXNzaW5nXCIpO2lmKHQuaXNPcHRpb25hbEMmJihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgc2hhcGUuXCIpO2lmKCF0LmlzT3B0aW9uYWxDJiYzIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiR2VtbSByZXF1aXJlcyAzIGlucHV0c1wiKTtpZigzPT09ZS5sZW5ndGgmJjEhPT1lWzJdLmRpbXMubGVuZ3RoJiYyIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlIG9mIENcIik7aWYoXCJmbG9hdDMyXCIhPT1lWzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVswXS50eXBlfHxcImZsb2F0MzJcIiE9PWVbMV0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzFdLnR5cGV8fDM9PT1lLmxlbmd0aCYmXCJmbG9hdDMyXCIhPT1lWzJdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVsyXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoZVswXS50eXBlIT09ZVsxXS50eXBlfHwzPT09ZS5sZW5ndGgmJmVbMF0udHlwZSE9PWVbMl0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX19LDU5NTA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlUGFja2VkSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSksaT1uKDU2MTQpO3QuY3JlYXRlUGFja2VkSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXI9KGUsdCxuLHMsYSk9Pntjb25zdCB1PShsPWEuY2FjaGVLZXkse25hbWU6XCJJbTJDb2wgKHBhY2tlZClcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS5wYWNrZWRdLGNhY2hlSGludDpsfSk7dmFyIGw7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Z2V0OigpPT4oKGUsdCxuLHMsYSx1KT0+e2NvbnN0IGw9bi5kaW1zLGM9cy5kaW1zLHA9YS5sZW5ndGgsZD1bY1sxXSpjWzJdKmNbM10sYVsyXSphWzNdXSxmPWNbMl0qY1szXSxoPSgwLGkudW5wYWNrRnJvbUNoYW5uZWwpKCksZz0oMCxyLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtsZXQgYj1cIlwiO2ZvcihsZXQgZT0wO2U8PTE7ZSsrKWZvcihsZXQgdD0wO3Q8PTE7dCsrKWIrPWBcXG4gICAgICAgICAgICBibG9ja0luZGV4ID0gcmMueCArICR7dH07XFxuICAgICAgICAgICAgcG9zID0gcmMueSArICR7ZX07XFxuXFxuICAgICAgICAgICAgaWYoYmxvY2tJbmRleCA8ICR7ZFsxXX0gJiYgcG9zIDwgJHtkWzBdfSkge1xcbiAgICAgICAgICAgICAgb2Zmc2V0WSA9IGludChibG9ja0luZGV4IC8gKCR7YVtwLTFdfSkpICogJHt1LnN0cmlkZXNbMF19IC1cXG4gICAgICAgICAgICAgICAgJHt1LnBhZHNbMF19O1xcbiAgICAgICAgICAgICAgZDAgPSBvZmZzZXRZICsgJHt1LmRpbGF0aW9uc1swXX0gKiAoaW1vZChwb3MsICR7Zn0pIC8gJHtjWzJdfSk7XFxuXFxuICAgICAgICAgICAgICBpZihkMCA8ICR7bFsyXX0gJiYgZDAgPj0gMCkge1xcbiAgICAgICAgICAgICAgICBvZmZzZXRYID0gaW1vZChibG9ja0luZGV4LCAke2FbcC0xXX0pICogJHt1LnN0cmlkZXNbMV19IC1cXG4gICAgICAgICAgICAgICAgICAke3UucGFkc1sxXX07XFxuICAgICAgICAgICAgICAgIGQxID0gb2Zmc2V0WCArICR7dS5kaWxhdGlvbnNbMV19ICogaW1vZChpbW9kKHBvcywgJHtmfSksICR7Y1syXX0pO1xcblxcbiAgICAgICAgICAgICAgICBpZihkMSA8ICR7bFszXX0gJiYgZDEgPj0gMCkge1xcblxcbiAgICAgICAgICAgICAgICAgIGNoID0gaW50KGZsb2F0KHBvcykvICR7Zn0uKTtcXG4gICAgICAgICAgICAgICAgICAgIGlubmVyRGltcyA9IHZlYzIoZDAsIGQxKTtcXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFskezIqZSt0fV0gPSBnZXRDaGFubmVsKFxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRBKDAsIGNoLCBpbnQoaW5uZXJEaW1zLngpLFxcbiAgICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYDtjb25zdCBtPWBcXG4gICAgICAke2h9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XFxuICAgICAgICAgIGludCBibG9ja0luZGV4LCBwb3MsIG9mZnNldFksIGQwLCBvZmZzZXRYLCBkMSwgY2g7XFxuICAgICAgICAgIHZlYzIgaW5uZXJEaW1zO1xcbiAgICAgICAgICAke2J9XFxuICAgICAgICAgICR7Zy5vdXRwdXR9ID0gcmVzdWx0O1xcbiAgICAgIH1cXG4gICAgICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpkLHR5cGU6bi50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxzaGFkZXJTb3VyY2U6bSxoYXNNYWluOiEwfSl9KShlLHUsdCxuLHMsYSl9KX19LDE2MjU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY2FsY3VsYXRlSW0yQ29sRGltcz10LmNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNTYzOSk7dC5jcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcj0oZSxuLG8saSxzKT0+e2NvbnN0IGE9KHU9cy5jYWNoZUtleSx7bmFtZTpcIkltMkNvbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltyLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6dX0pO3ZhciB1O3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2dldDooKT0+KChlLG4sbyxpLHMsYSk9Pntjb25zdCB1PW8uZGltcyxsPWkuZGltcyxjPXMubGVuZ3RoLHA9KDAsdC5jYWxjdWxhdGVJbTJDb2xEaW1zKSh1LGwscyw0KSxkPWBcXG4gICAgICAgIGNvbnN0IGludCBYQyA9ICR7dVsxXX07XFxuICAgICAgICBjb25zdCBpbnQgWEggPSAke3VbMl19O1xcbiAgICAgICAgY29uc3QgaW50IFhXID0gJHt1WzNdfTtcXG4gICAgICAgIGNvbnN0IGludCBLSCA9ICR7YS5rZXJuZWxTaGFwZVswXX07XFxuICAgICAgICBjb25zdCBpbnQgS1cgPSAke2Eua2VybmVsU2hhcGVbMV19O1xcbiAgICAgICAgY29uc3QgaW50IGRpbGF0aW9uSCA9ICR7YS5kaWxhdGlvbnNbMF19O1xcbiAgICAgICAgY29uc3QgaW50IGRpbGF0aW9uVyA9ICR7YS5kaWxhdGlvbnNbMV19O1xcbiAgICAgICAgY29uc3QgaW50IHN0cmlkZUggPSAke2Euc3RyaWRlc1swXX07XFxuICAgICAgICBjb25zdCBpbnQgc3RyaWRlVyA9ICR7YS5zdHJpZGVzWzFdfTtcXG4gICAgICAgIGNvbnN0IGludCBwYWRIID0gJHthLnBhZHNbMF19O1xcbiAgICAgICAgY29uc3QgaW50IHBhZFcgPSAke2EucGFkc1sxXX07XFxuICAgICAgICBjb25zdCBpbnQgS0hLVyA9IEtIKktXO1xcbiAgICAgICAgY29uc3QgaW50IFhDS0hLVyA9IFhDICogS0hLVztcXG4gICAgICAgIGNvbnN0IGludCBvdXRwdXRDaGFubmVscyA9IDQ7XFxuICAgICAgICB2ZWM0IHByb2Nlc3MoaW50IGluZGljZXNbJHtjfV0pIHtcXG4gICAgICAgICAgaW50IGIgID0gaW5kaWNlc1swXTsgLy8gYmF0Y2ggc2l6ZVxcbiAgICAgICAgICBpbnQgb2ggPSBpbmRpY2VzWzFdICogc3RyaWRlSCAtIHBhZEg7IC8vb3V0cHV0IGhlaWdodFxcbiAgICAgICAgICBpbnQgb3cgPSBpbmRpY2VzWzJdICogc3RyaWRlVyAtIHBhZFc7IC8vb3V0cHV0IHdpZHRoXFxuICAgICAgICAgIGludCBwID0gaW5kaWNlc1szXSAqIG91dHB1dENoYW5uZWxzOyAvL3BhdGNoXFxuICAgICAgICAgIHZlYzQgdmFsdWUgPSB2ZWM0KDAuMCk7XFxuICAgICAgICAgIGZvcihpbnQgaT0wOyBpIDwgb3V0cHV0Q2hhbm5lbHM7ICsraSkge1xcbiAgICAgICAgICAgIGlmKHAgPCBYQ0tIS1cpIHtcXG4gICAgICAgICAgICAgIGludCBwYXRjaEMgPSBwIC8gS0hLVztcXG4gICAgICAgICAgICAgIGludCBwYXRjaEggPSAocCAtIHBhdGNoQypLSEtXKSAvIEtXO1xcbiAgICAgICAgICAgICAgaW50IHBhdGNoVyA9IChwIC0gcGF0Y2hDKktIS1cpIC0gcGF0Y2hIICogS1c7XFxuICAgICAgICAgICAgICBpbnQgeGgyID0gb2ggKyBwYXRjaEggKiBkaWxhdGlvbkg7XFxuICAgICAgICAgICAgICBpbnQgeHcyID0gb3cgKyBwYXRjaFcgKiBkaWxhdGlvblc7XFxuICAgICAgICAgICAgICBpbnQgeFske3UubGVuZ3RofV07XFxuICAgICAgICAgICAgICB4WzBdID0gYjtcXG4gICAgICAgICAgICAgIHhbMV0gPSBwYXRjaEM7XFxuICAgICAgICAgICAgICB4WzJdID0geGgyO1xcbiAgICAgICAgICAgICAgeFszXSA9IHh3MjtcXG4gICAgICAgICAgICAgIGlmKHhoMiA+PSAwICYmXFxuICAgICAgICAgICAgICAgICAgeGgyIDwgWEggJiZcXG4gICAgICAgICAgICAgICAgICB4dzIgPj0gMCAmJlxcbiAgICAgICAgICAgICAgICAgIHh3MiA8IFhXKSB7XFxuICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gX1goeCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICsrcDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpwLHR5cGU6by50eXBlLHRleHR1cmVUeXBlOnIuVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbn0sc2hhZGVyU291cmNlOmR9KX0pKDAsYSxuLG8saSxzKX0pfSx0LmNhbGN1bGF0ZUltMkNvbERpbXM9KGUsdCxuLHI9NCk9PltuWzBdLG5bMl0sblszXSxNYXRoLmNlaWwoZVsxXSp0WzJdKnRbM10vcildfSw2OTgxOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzPXQuaW1hZ2VTY2FsZXI9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNTYzOSk7dC5pbWFnZVNjYWxlcj0oZSx0LG4pPT4odSh0KSxbZS5ydW4ocyhlLHQsbiksdCldKSx0LnBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzPWU9Pntjb25zdCB0PWUuYXR0cmlidXRlcy5nZXRGbG9hdChcInNjYWxlXCIpLG49ZS5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcImJpYXNcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzY2FsZTp0LGJpYXM6bn0pfTtjb25zdCBpPXtuYW1lOlwiSW1hZ2VTY2FsZXJcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbby5UZXh0dXJlVHlwZS51bnBhY2tlZF19LHM9KGUsdCxuKT0+e2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGkpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleX0pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+KChlLHQsbixyKT0+e2NvbnN0IGk9blswXS5kaW1zLnNsaWNlKCkscz1pLmxlbmd0aCx1PWBcXG4gICAgICAke2Eoci5iaWFzLmxlbmd0aCl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3N9XSkge1xcbiAgICAgICAgcmV0dXJuIF9YKGluZGljZXMpICogc2NhbGUgKyBnZXRCaWFzKGJpYXMsIGluZGljZXNbMV0pO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczppLHR5cGU6blswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHZhcmlhYmxlczpbe25hbWU6XCJiaWFzXCIsdHlwZTpcImZsb2F0XCIsYXJyYXlMZW5ndGg6ci5iaWFzLmxlbmd0aCxkYXRhOnIuYmlhc30se25hbWU6XCJzY2FsZVwiLHR5cGU6XCJmbG9hdFwiLGRhdGE6ci5zY2FsZX1dLHNoYWRlclNvdXJjZTp1fSl9KSgwLHIsdCxuKX0pfSxhPWU9Pntjb25zdCB0PVtgZmxvYXQgZ2V0QmlhcyhmbG9hdCBiaWFzWyR7ZX1dLCBpbnQgY2hhbm5lbCkge2BdO2ZvcihsZXQgbj0wO248ZTsrK24pMD09PW4/dC5wdXNoKGBcXHRpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk6bj09PWUtMT90LnB1c2goYFxcdGVsc2UgeyByZXR1cm4gYmlhc1ske259XTsgfWApOnQucHVzaChgXFx0ZWxzZSBpZiAoY2hhbm5lbCA9PSAke259KSB7IHJldHVybiBiaWFzWyR7bn1dOyB9YCk7cmV0dXJuIHQucHVzaChcIlxcdH1cIiksdC5qb2luKFwiXFxuXCIpfSx1PWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkltYWdlU2NhbGVyIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKDQhPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sNzQxMzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZUluc3RhbmNlTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM9dC5pbnN0YW5jZU5vcm1hbGl6YXRpb249dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSk7dC5pbnN0YW5jZU5vcm1hbGl6YXRpb249KGUsdCxuKT0+e2wodCk7Y29uc3Qgcj1lLnJ1bihzKHRbMF0pLHQpO3JldHVybltlLnJ1bih1KGUsdFswXSxuLHIuZGltcyksW3RbMF0scix0WzFdLHRbMl1dKV19LHQucGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzPWU9PmUuYXR0cmlidXRlcy5nZXRGbG9hdChcImVwc2lsb25cIiwxZS01KTtjb25zdCBpPXtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uX01lYW5BbmRWYXJpYW5jZVwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXX0scz1lPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30saSkse2dldDooKT0+KChlLHQpPT57Y29uc3Qgbj10LmRpbXMuc2xpY2UoKSxyPW5bMV0saT1uWzJdKm5bM10scz1bblswXSxyXSxhPWBcXG4gICAgICB2ZWM0IHByb2Nlc3MoaW50WzJdIGluZGljZXMpIHtcXG4gICAgICAgIHZlYzQgdiA9IHZlYzQoMC4wKTtcXG4gICAgICAgIGludCBhWzRdO1xcbiAgICAgICAgYVswXSA9IGluZGljZXNbMF07XFxuICAgICAgICBhWzFdID0gaW5kaWNlc1sxXTtcXG4gICAgICAgIGZsb2F0IHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0geDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgbWVhbiA9IHRlbXAgLyBmbG9hdCgke2l9KTtcXG4gICAgICAgIHRlbXAgPSAwLjA7XFxuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7blsyXX07IGEyKyspIHtcXG4gICAgICAgICAgYVsyXSA9IGEyO1xcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7blszXX07IGEzKyspIHtcXG4gICAgICAgICAgICBhWzNdID0gYTM7XFxuICAgICAgICAgICAgZmxvYXQgeCA9IF9YKGEpO1xcbiAgICAgICAgICAgIHRlbXAgKz0gKHggLSBtZWFuKSAqICh4IC0gbWVhbik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHYuciA9IG1lYW47XFxuICAgICAgICB2LmcgPSB0ZW1wIC8gZmxvYXQoJHtpfSk7XFxuXFxuICAgICAgICByZXR1cm4gdjtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtvdXRwdXQ6e2RpbXM6cyx0eXBlOnQudHlwZSx0ZXh0dXJlVHlwZTpvLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LHNoYWRlclNvdXJjZTphfSl9KShpLGUpfSksYT17bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbl9Db21wdXRlT3V0cHV0XCIsaW5wdXROYW1lczpbXCJYXCIsXCJNZWFuQW5kVmFyaWFuY2VcIixcIlNjYWxlXCIsXCJCXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLG8uVGV4dHVyZVR5cGUudW5wYWNrZWQsby5UZXh0dXJlVHlwZS51bnBhY2tlZF19LHU9KGUsdCxuLGkpPT57Y29uc3Qgcz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpgJHtufWB9KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtnZXQ6KCk9PigoZSx0LG4saSxzKT0+e2NvbnN0IGE9KDAsci5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksW3UsbF09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQocyxvLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pLFtjLHBdPVt1LzQsbF0sZD1gXFxuICAgICAgdmVjNCBnZXRfTWVhbkFuZFZhcmlhbmNlKGludFsyXSBtdikge1xcbiAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7Y30sICR7cH0pO1xcbiAgICAgICAgcmV0dXJuICR7YS50ZXh0dXJlMkR9KE1lYW5BbmRWYXJpYW5jZSwgY29vcmRzKTtcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbNF0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IG12WzJdO1xcbiAgICAgICAgbXZbMF0gPSBpbmRpY2VzWzBdO1xcbiAgICAgICAgbXZbMV0gPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgdmVjNCBtZWFuX2FuZF92YXJpYW5jZSA9IGdldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xcbiAgICAgICAgZmxvYXQgbWVhbiA9IG1lYW5fYW5kX3ZhcmlhbmNlLnI7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IG1lYW5fYW5kX3ZhcmlhbmNlLmc7XFxuXFxuICAgICAgICBpbnQgc2JbMV07XFxuICAgICAgICBzYlswXSA9IGluZGljZXNbMV07XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IF9TY2FsZShzYik7XFxuICAgICAgICBmbG9hdCBiID0gX0Ioc2IpO1xcblxcbiAgICAgICAgcmV0dXJuIHNjYWxlICogKF9YKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZXBzaWxvbikgKyBiO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse291dHB1dDp7ZGltczpuLmRpbXMsdHlwZTpuLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sdmFyaWFibGVzOlt7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZmxvYXRcIixkYXRhOml9XSxzaGFkZXJTb3VyY2U6ZH0pfSkoZSxzLHQsbixpKX0pfSxsPWU9PntpZighZXx8MyE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkluc3RhbmNlTm9ybWFsaXphdGlvbiByZXF1aXJlcyAzIGlucHV0cy5cIik7Y29uc3QgdD1lWzBdLG49ZVsxXSxyPWVbMl07aWYodC5kaW1zLmxlbmd0aDwzfHwxIT09bi5kaW1zLmxlbmd0aHx8MSE9PXIuZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZS5cIik7aWYobi5kaW1zWzBdIT09dC5kaW1zWzFdfHxyLmRpbXNbMF0hPT10LmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBtaXNtYXRjaGVkLlwiKTtpZihcImZsb2F0MzJcIiE9PXQudHlwZSYmXCJmbG9hdDY0XCIhPT10LnR5cGV8fFwiZmxvYXQzMlwiIT09bi50eXBlJiZcImZsb2F0NjRcIiE9PW4udHlwZXx8XCJmbG9hdDMyXCIhPT1yLnR5cGUmJlwiZmxvYXQ2NFwiIT09ci50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoNCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS5cIil9fSw3MDA2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZUxyblByb2dyYW1JbmZvTG9hZGVyPXQucGFyc2VMcm5BdHRyaWJ1dGVzPXQubHJuPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDU2MzkpO3QubHJuPShlLHQsbik9PihhKHQpLFtlLnJ1bihzKHQsbiksdCldKSx0LnBhcnNlTHJuQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJhbHBoYVwiLDFlLTQpLG49ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYmV0YVwiLC43NSksbz1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJiaWFzXCIsMSksaT1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwic2l6ZVwiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2FscGhhOnQsYmV0YTpuLGJpYXM6byxzaXplOml9KX07Y29uc3QgaT17bmFtZTpcIkxSTlwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXX07ZnVuY3Rpb24gcyhlLHQpe3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30saSkse2NhY2hlSGludDp0LmNhY2hlS2V5LGdldDooKT0+ZnVuY3Rpb24oZSx0KXtjb25zdCBuPWVbMF0uZGltc1sxXSxyPWVbMF0uZGltcy5sZW5ndGgscz0tTWF0aC5mbG9vcigodC5zaXplLTEpLzIpLGE9TWF0aC5jZWlsKCh0LnNpemUtMSkvMiksdT1gZmxvYXQoJHt0LmFscGhhfSkgLyBmbG9hdCgke3Quc2l6ZX0pYCxsPWBcXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3J9XSkge1xcbiAgICAgICAgaW50IGMgPSBpbmRpY2VzWzFdO1xcbiAgICAgICAgZmxvYXQgeCA9IF9YKGluZGljZXMpO1xcbiAgICAgICAgZmxvYXQgc3F1YXJlX3N1bSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAke3N9OyBpIDw9ICR7YX07IGkrKykge1xcbiAgICAgICAgICBpbnQgaWR4ID0gYyArIGk7XFxuICAgICAgICAgIGlmIChjID49IDAgJiYgYyA8ICR7bn0pIHtcXG4gICAgICAgICAgICBpbmRpY2VzWzFdID0gaWR4O1xcbiAgICAgICAgICAgIGZsb2F0IGogPSBfWChpbmRpY2VzKTtcXG4gICAgICAgICAgICBzcXVhcmVfc3VtICs9IGogKiBqO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4geCAvIHBvdyhmbG9hdCgke3QuYmlhc30pICsgJHt1fSAqIHNxdWFyZV9zdW0sIGZsb2F0KCR7dC5iZXRhfSkpO1xcbiAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGkpLHtjYWNoZUhpbnQ6dC5jYWNoZUtleSxvdXRwdXQ6e2RpbXM6ZVswXS5kaW1zLHR5cGU6ZVswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpsfSl9KGUsdCl9KX10LmNyZWF0ZUxyblByb2dyYW1JbmZvTG9hZGVyPXM7Y29uc3QgYT1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJMUk4gcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoNCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgb25seSBzdXBwb3J0IExSTiBmb3IgaW5wdXQgd2l0aCBcIk5DSFdcIiBmb3JtYXQnKTtpZihcImZsb2F0MzJcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdHlwZVwiKX19LDU2MzI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big3MjczKSxvPW4oNjc1NyksaT1uKDU2MzkpLHM9big0MzIpLGE9bigyMTUwKSx1PW4oODI3Nik7dC5jcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcj0oZSx0LG4pPT57Y29uc3QgbD0oYz10Lmxlbmd0aD4yLHA9bi5hY3RpdmF0aW9uQ2FjaGVLZXkse25hbWU6XCJNYXRNdWwgKHBhY2tlZClcIixpbnB1dE5hbWVzOmM/W1wiQVwiLFwiQlwiLFwiQmlhc1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6Yz9baS5UZXh0dXJlVHlwZS5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWQsaS5UZXh0dXJlVHlwZS5wYWNrZWRdOltpLlRleHR1cmVUeXBlLnBhY2tlZCxpLlRleHR1cmVUeXBlLnBhY2tlZF0sY2FjaGVIaW50OnB9KTt2YXIgYyxwO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse2dldDooKT0+KChlLHQsbixsKT0+e2NvbnN0IGM9bi5sZW5ndGg+MixwPWM/XCJ2YWx1ZSArPSBnZXRCaWFzRm9yTWF0bXVsKCk7XCI6XCJcIixkPW5bMF0uZGltcyxmPW5bMV0uZGltcyxoPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoZCxmLCEwKSxnPSFyLlNoYXBlVXRpbC5hcmVFcXVhbChuWzBdLmRpbXMsblsxXS5kaW1zKTtpZighaCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2NvbnN0IGI9ZFtkLmxlbmd0aC0xXSxtPU1hdGguY2VpbChiLzIpLHk9ZC5sZW5ndGgsXz1mLmxlbmd0aCx2PSgwLG8uZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLFQ9KDAscy5nZXRDb29yZHNEYXRhVHlwZSkoaC5sZW5ndGgpLHg9aC5sZW5ndGgsdz0oMCxzLmdldEdsQ2hhbm5lbHMpKCkse2FjdGl2YXRpb25GdW5jdGlvbjpPLGFwcGx5QWN0aXZhdGlvbjpTfT0oMCxhLmdldEFjdGl2YXRpb25TbmlwcGV0KShsKSxBPWM/YCR7KDAsdS5nZXRCaWFzRm9yTWF0bXVsKShULHcsblsyXS5kaW1zLGgsITApfWA6XCJcIixQPWc/YCR7ZnVuY3Rpb24oZSx0LG4sbyl7bGV0IGk9W10scz1bXTtjb25zdCBhPW5bMF0uZGltcyx1PW5bMV0uZGltcyxsPWEubGVuZ3RoLGM9dS5sZW5ndGgscD1vLmxlbmd0aCxkPXAtbCxmPXAtYztpPWEubWFwKCgoZSxuKT0+YGNvb3Jkcy4ke3RbbitkXX1gKSksaVtsLTFdPVwiaSoyXCIsaS5qb2luKFwiLCBcIikscz11Lm1hcCgoKGUsbik9PmBjb29yZHMuJHt0W24rZl19YCkpLHNbYy0yXT1cImkqMlwiLHMuam9pbihcIiwgXCIpO2NvbnN0IGg9ci5Ccm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoYSxvKSxnPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKHUsbyksYj1oLm1hcCgoZT0+YGNvb3Jkcy4ke3RbZStkXX0gPSAwO2ApKS5qb2luKFwiXFxuXCIpLG09Zy5tYXAoKGU9PmBjb29yZHMuJHt0W2UrZl19ID0gMDtgKSkuam9pbihcIlxcblwiKSx5PWBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke3RbcC0xXX07XFxuICBjb29yZHMuJHt0W3AtMV19ID0gY29vcmRzLiR7dFtwLTJdfTtcXG4gIGNvb3Jkcy4ke3RbcC0yXX0gPSBsYXN0RGltO2A7cmV0dXJuYFxcbnZlYzQgZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGludCBpKSB7XFxuICAke2V9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHt5fVxcbiAgJHtifVxcbiAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldEEoJHtpfSk7XFxuICByZXR1cm4gb3V0cHV0VmFsdWU7XFxufVxcblxcbnZlYzQgZ2V0QkF0T3V0Q29vcmRzTWF0bXVsKGludCBpKSB7XFxuICAke2V9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHt5fVxcbiAgJHttfVxcbiAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldEIoJHtzfSk7XFxuICByZXR1cm4gb3V0cHV0VmFsdWU7XFxufWB9KFQsdyxuLGgpfWA6XCJcIixJPWc/XCJnZXRBQXRPdXRDb29yZHNNYXRtdWwoaSlcIjpgZ2V0QSgke2Z1bmN0aW9uKGUsdCl7bGV0IG49XCJcIjtmb3IobGV0IHI9MDtyPHQtMjtyKyspbis9YHJjLiR7ZVtyXX0sIGA7cmV0dXJuIG4rPWByYy4ke2VbdC0yXX0sIGkqMmAsbn0odyx5KX0pYCxFPWc/XCJnZXRCQXRPdXRDb29yZHNNYXRtdWwoaSlcIjpgZ2V0Qigke2Z1bmN0aW9uKGUsdCl7bGV0IG49XCJcIjtmb3IobGV0IHI9MDtyPHQtMjtyKyspbis9YHJjLiR7ZVtyXX0sIGA7cmV0dXJuIG4rPWBpKjIsIHJjLiR7ZVt0LTFdfWAsbn0odyxfKX0pYCxEPWBcXG4gICAgICAgICAgICAke1B9XFxuICAgICAgICAgICAgJHtBfVxcbiAgICAgICAgICAgICR7T31cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAke2c/XCJcIjpgJHtUfSByYyA9XFxuICAgICAgICAgIGdldE91dHB1dENvb3JkcygpOyBpbnQgbGFzdERpbSA9IHJjLiR7d1t4LTFdfTsgcmMuJHt3W3gtMV19ID1cXG4gICAgICAgICAgcmMuJHt3W3gtMl19OyByYy4ke3dbeC0yXX0gPSBsYXN0RGltO1xcbiAgICAgIGB9XFxuXFxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwKTtcXG4gICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHttfTsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHZlYzQgYSA9ICR7SX07XFxuICAgICAgICAgICAgICAgIHZlYzQgYiA9ICR7RX07XFxuXFxuICAgICAgICAgICAgICAgIHZhbHVlICs9IChhLnJyYmIgKiBiLnJncmcpO1xcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAoYS5nZ2FhICogYi5iYWJhKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICR7cH1cXG4gICAgICAgICAgICAgICR7U31cXG4gICAgICAgICAgICAgICR7di5vdXRwdXR9ID0gdmFsdWU7XFxuICAgICAgICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOmgsdHlwZTpuWzBdLnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTpELGhhc01haW46ITB9KX0pKGUsbCx0LG4pfSl9fSw4Mjc2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldEJpYXNGb3JNYXRtdWw9dC5jcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcj10LnBhcnNlTWF0TXVsQXR0cmlidXRlcz10Lm1hdE11bD12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpLG89big1NjM5KSxpPW4oNDMyKSxzPW4oMjE1MCksYT1uKDU2MzIpO3QubWF0TXVsPShlLHQsbik9PihjKHQpLGUuc2Vzc2lvbi5wYWNrP1tlLnJ1bigoMCxhLmNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKShlLHQsbiksdCldOltlLnJ1bihsKHQsbiksdCldKSx0LnBhcnNlTWF0TXVsQXR0cmlidXRlcz1lPT4oMCxzLnBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykoZS5hdHRyaWJ1dGVzKTtjb25zdCB1PShlLHQpPT4oe25hbWU6XCJNYXRNdWxcIixpbnB1dE5hbWVzOmU/W1wiQVwiLFwiQlwiLFwiQmlhc1wiXTpbXCJBXCIsXCJCXCJdLGlucHV0VHlwZXM6ZT9bby5UZXh0dXJlVHlwZS51bnBhY2tlZCxvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdOltvLlRleHR1cmVUeXBlLnVucGFja2VkLG8uVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDp0fSk7ZnVuY3Rpb24gbChlLHQpe2NvbnN0IG49dShlLmxlbmd0aD4yLHQuYWN0aXZhdGlvbkNhY2hlS2V5KTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmZ1bmN0aW9uKGUsdCxuKXtjb25zdCBhPXRbMF0uZGltcyx1PXRbMV0uZGltcyxsPXIuQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoYSx1LCEwKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2NvbnN0IGM9KDAsaS5nZXRDb29yZHNEYXRhVHlwZSkobC5sZW5ndGgpLGQ9KDAsaS5nZXRHbENoYW5uZWxzKSgpLHthY3RpdmF0aW9uRnVuY3Rpb246ZixhcHBseUFjdGl2YXRpb246aH09KDAscy5nZXRBY3RpdmF0aW9uU25pcHBldCkobiksZz10Lmxlbmd0aD4yLGI9Zz9cInZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTtcIjpcIlwiLG09Zz9gJHtwKGMsZCx0WzJdLmRpbXMsbCwhMSl9YDpcIlwiLHk9bC5sZW5ndGgsXz1hLmxlbmd0aCx2PXUubGVuZ3RoLFQ9YFxcbiAgICAke2Z9XFxuICAgICR7bX1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3l9XSkge1xcbiAgICAgICAgaW50IGFbJHtffV07XFxuICAgICAgICBpbnQgYlske3Z9XTtcXG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19BKGluZGljZXMsIGEpO1xcbiAgICAgICAgYmNhc3RNYXRtdWxJbmRpY2VzX0IoaW5kaWNlcywgYik7XFxuXFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGZvciAoaW50IGs9MDsgazwke2FbYS5sZW5ndGgtMV19OyArK2spIHtcXG4gICAgICAgICAgICBhWyR7Xy0xfV0gPSBrO1xcbiAgICAgICAgICAgIGJbJHt2LTJ9XSA9IGs7XFxuICAgICAgICAgICAgdmFsdWUgKz0gX0EoYSkgKiBfQihiKTtcXG4gICAgICAgIH1cXG4gICAgICAgICR7Yn1cXG4gICAgICAgICR7aH1cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxlKSx7b3V0cHV0OntkaW1zOmwsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOlR9KX0obixlLHQpfSl9dC5jcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcj1sO2NvbnN0IGM9ZT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZXx8XCJmbG9hdDMyXCIhPT1lWzFdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcImlucHV0cyBzaG91bGQgYmUgZmxvYXQgdHlwZVwiKTtpZihlWzBdLnR5cGUhPT1lWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRzIHR5cGVzIHNob3VsZCBtYXRjaFwiKX07ZnVuY3Rpb24gcChlLHQsbixvLGkpe2xldCBzPVwiXCI7Y29uc3QgYT1uLmxlbmd0aCx1PW8ubGVuZ3RoLGw9dS1hO3M9dTwyJiZhPjA/XCJjb29yZHNcIjpuLm1hcCgoKGUsbik9PmBjb29yZHMuJHt0W24rbF19YCkpLmpvaW4oXCIsIFwiKTtjb25zdCBjPXIuQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKG4sbykubWFwKChlPT5gY29vcmRzLiR7dFtlK2xdfSA9IDA7YCkpLmpvaW4oXCJcXG5cIik7bGV0IHA9XCJ2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS55eSlcIjtyZXR1cm4gMT09PXIuU2hhcGVVdGlsLnNpemUobikmJihwPVwidmVjNChvdXRwdXRWYWx1ZS54KVwiKSxpP2BcXG52ZWM0IGdldEJpYXNGb3JNYXRtdWwoKSB7XFxuICAke2V9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgJHtjfVxcbiAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldEJpYXMoJHtzfSk7XFxuICByZXR1cm4gJHtwfTtcXG59YDpgXFxuZmxvYXQgZ2V0Qmlhc0Zvck1hdG11bCgpIHtcXG4gICR7ZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAke2N9XFxuICByZXR1cm4gZ2V0Qmlhcyhjb29yZHMueCk7XFxufWB9dC5nZXRCaWFzRm9yTWF0bXVsPXB9LDk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlUGFja1Byb2dyYW1JbmZvTG9hZGVyPXZvaWQgMDtjb25zdCByPW4oNjc1Nyksbz1uKDU2MzkpLGk9big0MzIpLHM9big1NjE0KSxhPXtuYW1lOlwicGFja1wiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWRdfTt0LmNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlcj0oZSx0KT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtnZXQ6KCk9PigoZSx0KT0+e2NvbnN0IG49KDAsci5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksdT10LmRpbXMsbD11Lmxlbmd0aCxjPXQuZGltcy5sZW5ndGgscD0oMCxpLmdldENvb3Jkc0RhdGFUeXBlKShjKSxkPSgwLHMuZ2V0Q2hhbm5lbHMpKFwicmNcIixjKSxmPShoPWMsZz1kLGI9dVt1Lmxlbmd0aC0yXSxtPXVbdS5sZW5ndGgtMV0sMD09PWh8fDE9PT1oP1wiXCI6YFxcbiAgICBpbnQgciA9ICR7Z1toLTJdfTtcXG4gICAgaW50IGMgPSAke2dbaC0xXX07XFxuICAgIGludCBycDEgPSAke2dbaC0yXX0gKyAxO1xcbiAgICBpbnQgY3AxID0gJHtnW2gtMV19ICsgMTtcXG4gICAgYm9vbCByRWRnZSA9IHJwMSA+PSAke219O1xcbiAgICBib29sIGNFZGdlID0gY3AxID49ICR7Yn07XFxuICAgIGApO3ZhciBoLGcsYixtO2xldCB5O3k9MD09PWw/WzEsMV06MT09PWw/W3VbMF0sMV06W3VbYy0xXSx1W2MtMl1dO2NvbnN0IF89ZnVuY3Rpb24oZSx0LG4pe2lmKDA9PT1lKXJldHVyblwiZmFsc2VcIjtpZigxPT09ZSlyZXR1cm5gcmMgPiAke3RbMF19YDtsZXQgcj1cIlwiO2ZvcihsZXQgbz1lLTI7bzxlO28rKylyKz1gJHtuW29dfSA+PSAke3Rbby1lKzJdfWAsbzxlLTEmJihyKz1cInx8XCIpO3JldHVybiByfShjLHksZCksdj1mdW5jdGlvbihlLHQpe2NvbnN0IG49ZS5sZW5ndGg7aWYoMD09PW4pcmV0dXJuXCJnZXRBKCksIDAsIDAsIDBcIjtpZigxPT09bilyZXR1cm5gZ2V0QShyYyksXFxuICAgICAgICAgICAgcmMgKyAxID49ICR7ZVswXX0gPyAwLiA6IGdldEEocmMgKyAxKSxcXG4gICAgICAgICAgICAwLCAwYDtsZXQgcj1cIlwiO2lmKG4+Milmb3IobGV0IGU9MDtlPG4tMjsrK2Upcis9YCR7dFtlXX0sYDtyZXR1cm5gZ2V0QSgke3J9ciwgYyksXFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKCR7cn1ycDEsIGMpLFxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QSgke3J9ciwgY3AxKSxcXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHtyfXJwMSwgY3AxKWB9KHUsZCksVD1gXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICR7cH0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgaWYoJHtffSkge1xcbiAgICAgICAgICAgICR7bi5vdXRwdXR9ID0gdmVjNCgwKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAke2Z9XFxuXFxuICAgICAgICAgICAgJHtuLm91dHB1dH0gPSB2ZWM0KCR7dn0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtoYXNNYWluOiEwLG91dHB1dDp7ZGltczp0LmRpbXMsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTpUfSl9KShlLHQpfSl9LDU2MTQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQudW5wYWNrRnJvbUNoYW5uZWw9dC5nZXRDaGFubmVscz10LmdldFZlY0NoYW5uZWxzPXZvaWQgMDtjb25zdCByPW4oNDMyKTtmdW5jdGlvbiBvKGUsdCl7cmV0dXJuKDAsci5nZXRHbENoYW5uZWxzKSh0KS5tYXAoKHQ9PmAke2V9LiR7dH1gKSl9dC5nZXRWZWNDaGFubmVscz1vLHQuZ2V0Q2hhbm5lbHM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMT09PXQ/W2VdOm8oZSx0KX0sdC51bnBhY2tGcm9tQ2hhbm5lbD1mdW5jdGlvbigpe3JldHVyblwiXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XFxuICAgICAgaW50IG1vZENvb3JkID0gaW1vZChkaW0sIDIpO1xcbiAgICAgIHJldHVybiBtb2RDb29yZCA9PSAwID8gZnJhZy5yIDogZnJhZy5nO1xcbiAgICB9XFxuXFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCB2ZWMyIGlubmVyRGltcykge1xcbiAgICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XFxuICAgICAgcmV0dXJuIG1vZENvb3JkLnggPT0gMC4gP1xcbiAgICAgICAgKG1vZENvb3JkLnkgPT0gMC4gPyBmcmFnLnIgOiBmcmFnLmcpIDpcXG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcXG4gICAgfVxcbiAgXCJ9fSw1NTY1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlUGFkQXR0cmlidXRlc1YxMT10LnBhZFYxMT10LnBhcnNlUGFkQXR0cmlidXRlc1YyPXQucGFkVjI9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNzI3MyksaT1uKDY3NTcpLHM9big1NjM5KSxhPXtuYW1lOlwiUGFkXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W3MuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTt0LnBhZFYyPShlLHQsbik9PihjKHQpLFtlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+bChlLHRbMF0sbil9KSx0KV0pLHQucGFyc2VQYWRBdHRyaWJ1dGVzVjI9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm1vZGVcIixcImNvbnN0YW50XCIpLG49ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwidmFsdWVcIiwwKSxvPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwicGFkc1wiKTtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21vZGU6dCx2YWx1ZTpuLHBhZHM6b30pfSx0LnBhZFYxMT0oZSxuLHIpPT57cChuKTtjb25zdCBvPXUoZSxuLHIpO3JldHVybigwLHQucGFkVjIpKGUsW25bMF1dLG8pfSx0LnBhcnNlUGFkQXR0cmlidXRlc1YxMT1lPT5lLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwiY29uc3RhbnRcIik7Y29uc3QgdT0oZSx0LG4pPT57aWYoIWUuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbMV0uZGF0YUlkKXx8dC5sZW5ndGg+PTMmJiFlLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzJdLmRhdGFJZCkpdGhyb3cgbmV3IEVycm9yKFwiZHluYW1pYyBwYWQgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7Y29uc3Qgbz1BcnJheS5mcm9tKHRbMV0uaW50ZWdlckRhdGEpLGk9dC5sZW5ndGg+PTM/dFsyXS5mbG9hdERhdGFbMF06MDtyZXR1cm4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe21vZGU6bixwYWRzOm8sdmFsdWU6aX0pfSxsPShlLHQsbik9Pntjb25zdCByPW8uU2hhcGVVdGlsLnBhZFNoYXBlKHQuZGltcy5zbGljZSgpLG4ucGFkcyksaT1yLmxlbmd0aCxhPWBcXG4gICAgICAke2QoZSx0LG4pfVxcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7aX1dIGluZGljZXMpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhZEEoaW5kaWNlcyk7XFxuICAgICAgfWA7cmV0dXJue25hbWU6XCJQYWRcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbcy5UZXh0dXJlVHlwZS51bnBhY2tlZF0sb3V0cHV0OntkaW1zOnIsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6cy5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmF9fSxjPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBhZCByZXF1aXJlcyAxIGlucHV0XCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxwPWU9PntpZighZXx8MiE9PWUubGVuZ3RoJiYzIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGFkIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoXCJpbnQzMlwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoZS5sZW5ndGg+PTMmJlwic3RyaW5nXCI9PT1lWzJdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sZD0oZSx0LG4pPT57Y29uc3Qgcj0oMCxpLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbYSx1XT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LmRpbXMscy5UZXh0dXJlVHlwZS51bnBhY2tlZCksbD1vLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0LmRpbXMpO3N3aXRjaChuLm1vZGUpe2Nhc2VcImNvbnN0YW50XCI6cmV0dXJuIGYocix0LmRpbXMsbCxhLHUsbi5wYWRzLG4udmFsdWUpO2Nhc2VcInJlZmxlY3RcIjpyZXR1cm4gaChyLHQuZGltcyxsLGEsdSxuLnBhZHMpO2Nhc2VcImVkZ2VcIjpyZXR1cm4gZyhyLHQuZGltcyxsLGEsdSxuLnBhZHMpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0sZj0oZSx0LG4scixvLGkscyk9Pntjb25zdCBhPXQubGVuZ3RoO2xldCB1PVwiXCI7Zm9yKGxldCBlPWEtMTtlPj0wOy0tZSl1Kz1gXFxuICAgICAgICBrID0gbVske2V9XSAtICR7aVtlXX07XFxuICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XFxuICAgICAgICBpZiAoayA+PSAke3RbZV19KSByZXR1cm4gY29uc3RhbnQ7XFxuICAgICAgICBvZmZzZXQgKz0gayAqICR7bltlXX07XFxuICAgICAgICBgO3JldHVybmBcXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7YX1dKSB7XFxuICAgICAgICBjb25zdCBmbG9hdCBjb25zdGFudCA9IGZsb2F0KCR7c30pO1xcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XFxuICAgICAgICBpbnQgayA9IDA7XFxuICAgICAgICAke3V9XFxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHtyfSwgJHtvfSk7XFxuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2UudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgICAgYH0saD0oZSx0LG4scixvLGkpPT57Y29uc3Qgcz10Lmxlbmd0aDtsZXQgYT1cIlwiO2ZvcihsZXQgZT1zLTE7ZT49MDstLWUpYSs9YFxcbiAgICAgICAgayA9IG1bJHtlfV0gLSAke2lbZV19O1xcbiAgICAgICAgaWYgKGsgPCAwKSB7IGsgPSAtazsgfVxcbiAgICAgICAge1xcbiAgICAgICAgICBjb25zdCBpbnQgXzJuXzEgPSAkezIqKHRbZV0tMSl9O1xcbiAgICAgICAgICBrID0gaW50KCBtb2QoIGZsb2F0KGspLCBmbG9hdChfMm5fMSkgKSApIDtcXG4gICAgICAgICAgaWYoayA+PSAke3RbZV19KSB7IGsgPSBfMm5fMSAtIGs7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW2VdfTtcXG4gICAgICAgIGA7cmV0dXJuYFxcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHtzfV0pIHtcXG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xcbiAgICAgICAgaW50IGsgPSAwO1xcbiAgICAgICAgJHthfVxcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7cn0sICR7b30pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtlLnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGB9LGc9KGUsdCxuLHIsbyxpKT0+e2NvbnN0IHM9dC5sZW5ndGg7bGV0IGE9XCJcIjtmb3IobGV0IGU9cy0xO2U+PTA7LS1lKWErPWBcXG4gICAgICAgIGsgPSBtWyR7ZX1dIC0gJHtpW2VdfTtcXG4gICAgICAgIGlmIChrIDwgMCkgIGsgPSAwO1xcbiAgICAgICAgaWYgKGsgPj0gJHt0W2VdfSkgayA9ICR7dFtlXS0xfTtcXG4gICAgICAgIG9mZnNldCArPSBrICogJHtuW2VdfTtcXG4gICAgICBgO3JldHVybmBcXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7c31dKSB7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcXG4gICAgICAgIGludCBrID0gMDtcXG4gICAgICAgICR7YX1cXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3J9LCAke299KTtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7ZS50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBgfX0sMjgzNDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nbG9iYWxNYXhQb29sPXQucGFyc2VNYXhQb29sQXR0cmlidXRlcz10Lm1heFBvb2w9dC5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcz10Lmdsb2JhbEF2ZXJhZ2VQb29sPXQucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9dC5hdmVyYWdlUG9vbD12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNTYzOSk7dC5hdmVyYWdlUG9vbD0oZSx0LG4pPT57cCh0KTtjb25zdCByPXtuYW1lOlwiQXZlcmFnZVBvb2xcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF0sY2FjaGVIaW50Om4uY2FjaGVLZXl9O3JldHVybltlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse2dldDooKT0+cyh0LHIsITEsbil9KSx0KV19LHQucGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcImF1dG9fcGFkXCIsXCJOT1RTRVRcIiksbj1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwiY2VpbF9tb2RlXCIsMCksbz0wIT09ZS5hdHRyaWJ1dGVzLmdldEludChcImNvdW50X2luY2x1ZGVfcGFkXCIsMCksaT1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiKSxzPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwic3RyaWRlc1wiLFtdKSxhPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwicGFkc1wiLFtdKTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXV0b1BhZDp0LGNlaWxNb2RlOm4sY291bnRJbmNsdWRlUGFkOm8sa2VybmVsU2hhcGU6aSxzdHJpZGVzOnMscGFkczphfSl9O2NvbnN0IHM9KGUsdCxuLHIpPT57Y29uc3RbcyxhXT11KGUscixuKSxsPW8uU2hhcGVVdGlsLnNpemUocy5rZXJuZWxTaGFwZSk7bGV0IGM9XCJcIjtzLmNvdW50SW5jbHVkZVBhZD9jKz1gdmFsdWUgLz0gZmxvYXQoJHtsfSk7YDpjKz1gdmFsdWUgLz0gZmxvYXQoJHtsfSAtIHBhZCk7YDtjb25zdCBwPWBcXG4gICAgICAgICR7ZChlWzBdLmRpbXMscyxcInZhbHVlICs9IF9YKHgpO1wiLGMsXCIwLjBcIil9XFxuICAgICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6YSx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6cH0pfTt0Lmdsb2JhbEF2ZXJhZ2VQb29sPShlLHQsbik9PntwKHQpO2NvbnN0IHI9e25hbWU6XCJHbG9iYWxBdmVyYWdlUG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXSxjYWNoZUhpbnQ6YCR7bi5jb3VudEluY2x1ZGVQYWR9YH07cmV0dXJuW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxyKSx7Z2V0OigpPT5zKHQsciwhMCxuKX0pLHQpXX0sdC5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcz1lPT57Y29uc3QgdD0wIT09ZS5hdHRyaWJ1dGVzLmdldEludChcImNvdW50X2luY2x1ZGVfcGFkXCIsMCk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6dCxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W119KX0sdC5tYXhQb29sPShlLHQsbik9PntwKHQpO2NvbnN0IHI9e25hbWU6XCJNYXhQb29sXCIsaW5wdXROYW1lczpbXCJYXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRdLGNhY2hlSGludDpuLmNhY2hlS2V5fTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIpLHtnZXQ6KCk9PmEodCxyLCExLG4pfSksdCldfSx0LnBhcnNlTWF4UG9vbEF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcImF1dG9fcGFkXCIsXCJOT1RTRVRcIiksbj1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwiY2VpbF9tb2RlXCIsMCksbz1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImtlcm5lbF9zaGFwZVwiKSxpPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwic3RyaWRlc1wiLFtdKSxzPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwicGFkc1wiLFtdKSxhPWUuYXR0cmlidXRlcy5nZXRJbnQoXCJzdG9yYWdlX29yZGVyXCIsMCksdT1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImRpbGF0aW9uc1wiLFtdKTtpZigwIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZigwIT09bil0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHthdXRvUGFkOnQsY2VpbE1vZGU6bixjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6byxzdHJpZGVzOmkscGFkczpzLHN0b3JhZ2VPcmRlcjphLGRpbGF0aW9uczp1fSl9O2NvbnN0IGE9KGUsdCxuLHIpPT57Y29uc3RbbyxzXT11KGUscixuKSxhPWBcXG4gICAgICAke2QoZVswXS5kaW1zLG8sXCJcXG4gICAgICB2YWx1ZSA9IG1heChfWCh4KSwgdmFsdWUpO1xcbiAgICBcIixcIlwiLFwiLTFlNVwiKX1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLHtvdXRwdXQ6e2RpbXM6cyx0eXBlOmVbMF0udHlwZSx0ZXh0dXJlVHlwZTppLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6YX0pfSx1PShlLHQsbik9Pntjb25zdCByPWVbMF0uZGltcy5zbGljZSgpLGk9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSxzPXQua2VybmVsU2hhcGUuc2xpY2UoKSxhPXQuc3RyaWRlcy5zbGljZSgpLHU9aT90LmRpbGF0aW9ucy5zbGljZSgpOltdLGw9dC5wYWRzLnNsaWNlKCk7by5Qb29sQ29udlV0aWwuYWRqdXN0UG9vbEF0dHJpYnV0ZXMobixyLHMsYSx1LGwpO2NvbnN0IGM9by5Qb29sQ29udlV0aWwuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShuLHIsYSx1LHMsbCx0LmF1dG9QYWQpLHA9T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gaT9PYmplY3QuYXNzaWduKHAse2tlcm5lbFNoYXBlOnMsc3RyaWRlczphLHBhZHM6bCxkaWxhdGlvbnM6dSxjYWNoZUtleTp0LmNhY2hlS2V5fSk6T2JqZWN0LmFzc2lnbihwLHtrZXJuZWxTaGFwZTpzLHN0cmlkZXM6YSxwYWRzOmwsY2FjaGVLZXk6dC5jYWNoZUtleX0pLFtwLGNdfSxsPXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXSxjYWNoZUtleTpcIlwifSxjPXtuYW1lOlwiR2xvYmFsTWF4UG9vbFwiLGlucHV0TmFtZXM6W1wiWFwiXSxpbnB1dFR5cGVzOltpLlRleHR1cmVUeXBlLnVucGFja2VkXX07dC5nbG9iYWxNYXhQb29sPShlLHQpPT4ocCh0KSxbZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtnZXQ6KCk9PmEodCxjLCEwLGwpfSksdCldKTtjb25zdCBwPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSxkPShlLHQsbixyLGkpPT57Y29uc3Qgcz1lLmxlbmd0aDtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7Y29uc3Qgbz10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTFdLGE9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMV0sdT10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTFdLGw9dC5wYWRzW3QucGFkcy5sZW5ndGgtMV0sYz1lW3MtMV07bGV0IHA9XCJcIixkPVwiXCIsZj1cIlwiO2lmKHA9dStsIT09MD9gXFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtvfTsgaSsrKSB7XFxuICAgICAgICAgICAgeFske3N9IC0gMV0gPSBpbmRpY2VzWyR7c30gLSAxXSAqICR7YX0gLSAke3V9ICsgaTtcXG4gICAgICAgICAgICBpZiAoeFske3N9IC0gMV0gPCAwIHx8IHhbJHtzfSAtIDFdID49ICR7Y30pIHtcXG4gICAgICAgICAgICAgIHBhZCsrO1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICR7bn1cXG4gICAgICAgICAgfWA6YFxcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7b307IGkrKykge1xcbiAgICAgICAgICAgIHhbJHtzfSAtIDFdID0gaW5kaWNlc1ske3N9IC0gMV0gKiAke2F9IC0gJHt1fSArIGk7XFxuICAgICAgICAgICAgJHtufVxcbiAgICAgICAgICB9YCwyPT09dC5rZXJuZWxTaGFwZS5sZW5ndGgpe2NvbnN0IG49dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0yXSxyPXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTJdLGk9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0yXSxhPXQucGFkc1t0LnBhZHMubGVuZ3RoLTJdLHU9ZVtzLTJdO2Q9aSthIT09MD9gXFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke259OyBqKyspIHtcXG4gICAgICAgICAgICAgIHhbJHtzfSAtIDJdID0gaW5kaWNlc1ske3N9IC0gMl0gKiAke3J9IC0gJHtpfSArIGo7XFxuICAgICAgICAgICAgICBpZiAoeFske3N9IC0gMl0gPCAwIHx8IHhbJHtzfSAtIDJdID49ICR7dX0pIHtcXG4gICAgICAgICAgICAgICAgcGFkKz0gJHtvfTtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgIGA6YFxcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgJHtufTsgaisrKSB7XFxuICAgICAgICAgICAgICB4WyR7c30gLSAyXSA9IGluZGljZXNbJHtzfSAtIDJdICogJHtyfSAtICR7aX0gKyBqO1xcbiAgICAgICAgICAgIGAsZj1cIlxcbiAgICAgICAgICB9XFxuICAgICAgICBcIn1yZXR1cm5gXFxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7c31dKSB7XFxuICAgICAgICAgIGludCB4WyR7c31dO1xcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xcblxcbiAgICAgICAgICBmbG9hdCB2YWx1ZSA9ICR7aX07XFxuICAgICAgICAgIGludCBwYWQgPSAwO1xcbiAgICAgICAgICAke2R9XFxuICAgICAgICAgICR7cH1cXG4gICAgICAgICAgJHtmfVxcbiAgICAgICAgICAke3J9XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBgfXtjb25zdCBhPW8uU2hhcGVVdGlsLnNpemUodC5rZXJuZWxTaGFwZSksdT1vLlNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyh0Lmtlcm5lbFNoYXBlKSxsPXUubGVuZ3RoLGM9dC5wYWRzLmxlbmd0aCxwPWgobCksZD1mKGUsXCJpbnB1dERpbXNcIiksZz1mKHQucGFkcyxcInBhZHNcIiksYj1mKHUsXCJrZXJuZWxTdHJpZGVzXCIpLG09Zih0LnN0cmlkZXMsXCJzdHJpZGVzXCIpO2xldCB5PVwiXCI7cmV0dXJuIHk9dC5wYWRzLnJlZHVjZSgoKGUsdCk9PmUrdCkpP2BcXG4gICAgICAgICAgICBpZiAoeFtqXSA+PSBpbnB1dERpbXNbal0gfHwgeFtqXSA8IDApIHtcXG4gICAgICAgICAgICAgIHBhZCsrO1xcbiAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmICghaXNQYWQpIHtcXG4gICAgICAgICAgICAke259XFxuICAgICAgICAgIH1gOmBcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAke259XFxuICAgICAgICBgLGBcXG4gICAgICAgICR7cH1cXG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtzfV0pIHtcXG4gICAgICAgICAgaW50IHhbJHtzfV07XFxuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgeCk7XFxuICAgICAgICAgIGludCBvZmZzZXRbJHtsfV07XFxuICAgICAgICAgIGludCBwYWRzWyR7Y31dO1xcbiAgICAgICAgICBpbnQgaW5wdXREaW1zWyR7c31dO1xcbiAgICAgICAgICBpbnQga2VybmVsU3RyaWRlc1ske2x9XTtcXG4gICAgICAgICAgaW50IHN0cmlkZXNbJHtsfV07XFxuICAgICAgICAgICR7Z31cXG4gICAgICAgICAgJHtkfVxcbiAgICAgICAgICAke219XFxuICAgICAgICAgICR7Yn1cXG5cXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke2l9O1xcbiAgICAgICAgICBpbnQgcGFkID0gMDtcXG4gICAgICAgICAgYm9vbCBpc1BhZCA9IGZhbHNlO1xcbiAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7YX07IGkrKykge1xcbiAgICAgICAgICAgIG9mZnNldFRvSW5kaWNlcyhpLCBrZXJuZWxTdHJpZGVzLCBvZmZzZXQpO1xcbiAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9ICR7c30gLSAke2x9OyBqIDwgJHtzfTsgaisrKSB7XFxuICAgICAgICAgICAgICB4W2pdID0gaW5kaWNlc1tqXSAqIHN0cmlkZXNbaiAtICR7c30gKyAke2x9XVxcbiAgICAgICAgICAgICAgICArIG9mZnNldFtqIC0gJHtzfSArICR7bH1dIC0gcGFkc1tqIC0gMl07XFxuICAgICAgICAgICAgICAke3l9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgJHtyfVxcblxcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgYH19LGY9KGUsdCk9PntsZXQgbj1cIlwiO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKW4rPWBcXG4gICAgICAke3R9WyR7cn1dID0gJHtlW3JdfTtcXG4gICAgYDtyZXR1cm4gbn0saD1lPT5gXFxuICB2b2lkIG9mZnNldFRvSW5kaWNlcyhpbnQgb2Zmc2V0LCBpbnRbJHtlfV0gc3RyaWRlcywgb3V0IGludFske2V9XSBpbmRpY2VzKSB7XFxuICAgIGlmICgke2V9ID09IDApIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2V9IC0gMTsgKytpKSB7XFxuICAgICAgaW5kaWNlc1tpXSA9IG9mZnNldCAvIHN0cmlkZXNbaV07XFxuICAgICAgb2Zmc2V0IC09IGluZGljZXNbaV0gKiBzdHJpZGVzW2ldO1xcbiAgICB9XFxuICAgIGluZGljZXNbJHtlfSAtIDFdID0gb2Zmc2V0O1xcbiAgfWB9LDEwMTA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucmVkdWNlTG9nU3VtU3F1YXJlPXQucmVkdWNlTG9nU3VtPXQucmVkdWNlUHJvZD10LnJlZHVjZU1pbj10LnJlZHVjZU1heD10LnJlZHVjZU1lYW49dC5yZWR1Y2VTdW09dC5wYXJzZVJlZHVjZUF0dHJpYnV0ZXM9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNjE0NSksaT1uKDcyNzMpLHM9big1NjM5KSxhPShlLHQsbixyLG8pPT57bCh0KTtjb25zdCBpPXtuYW1lOnIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W3MuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGkpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PnUoZSx0LG4scixvLGkpfSksdCldfTt0LnBhcnNlUmVkdWNlQXR0cmlidXRlcz1lPT57Y29uc3QgdD1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIixbXSksbj0xPT09ZS5hdHRyaWJ1dGVzLmdldEludChcImtlZXBkaW1zXCIsMSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtheGVzOnQsa2VlcERpbXM6bn0pfTtjb25zdCB1PShlLHQsbixyLG8sYSk9Pntjb25zdCB1PVtdLGw9dFswXS5kaW1zLmxlbmd0aHx8MSxjPVtdLHA9aS5TaGFwZVV0aWwubm9ybWFsaXplQXhlcyhuLmF4ZXMsdFswXS5kaW1zLmxlbmd0aCksZD1vKHQscCk7bGV0IGY9ZFsxXTtmb3IobGV0IGU9MDtlPHRbMF0uZGltcy5sZW5ndGg7ZSsrKXAuaW5kZXhPZihlKT49MHx8MD09PXAubGVuZ3RoPyhuLmtlZXBEaW1zJiZ1LnB1c2goMSksZj1gXFxuICAgICAgICAgIGZvcihpbnQgaiR7ZX0gPSAwOyBqJHtlfSA8ICR7dFswXS5kaW1zW2VdfTsgaiR7ZX0rKykge1xcbiAgICAgICAgICAgIGlucHV0SWR4WyR7ZX1dID0gaiR7ZX07XFxuICAgICAgICAgICAgJHtmfVxcbiAgICAgICAgICB9YCk6KGMucHVzaChgaW5wdXRJZHhbJHtlfV0gPSBvdXRwdXRJZHhbJHt1Lmxlbmd0aH1dO2ApLHUucHVzaCh0WzBdLmRpbXNbZV0pKTtjb25zdCBoPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHt1Lmxlbmd0aHx8MX1dKSB7XFxuICAgICAgICBmbG9hdCB2YWx1ZTsgICAgICAgICAgICAgICAgIC8vIGZpbmFsIHJlc3VsdFxcbiAgICAgICAgaW50IGlucHV0SWR4WyR7bH1dOyAgICAgIC8vIGFkZHJlc3NpbmcgaW5wdXQgZGF0YVxcbiAgICAgICAgJHtjLmpvaW4oXCJcXG5cIil9XFxuICAgICAgICAke2RbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxcbiAgICAgICAgJHtmfVxcbiAgICAgICAgJHtkWzJdfSAgICAgICAvLyBmaW5hbCBjb21wdXRhdGlvbiBmb3IgcmVkdWNlIG1lYW5cXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9YDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGEpLHtvdXRwdXQ6e2RpbXM6dSx0eXBlOnRbMF0udHlwZSx0ZXh0dXJlVHlwZTpzLlRleHR1cmVUeXBlLnVucGFja2VkfSxzaGFkZXJTb3VyY2U6aH0pfSxsPWU9PntpZighZXx8MSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIGlucHV0LlwiKTtpZigtMT09PW8uTlVNQkVSX1RZUEVTLmluZGV4T2YoZVswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfTt0LnJlZHVjZVN1bT0oZSx0LG4pPT5hKGUsdCxuLFwiUmVkdWNlU3VtXCIsKCgpPT5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixcIlwiXSkpLHQucmVkdWNlTWVhbj0oZSx0LG4pPT5hKGUsdCxuLFwiUmVkdWNlTWVhblwiLCgoZSx0KT0+e2xldCBuPTE7Zm9yKGxldCByPTA7cjxlWzBdLmRpbXMubGVuZ3RoO3IrKykodC5pbmRleE9mKHIpPj0wfHwwPT09dC5sZW5ndGgpJiYobio9ZVswXS5kaW1zW3JdKTtyZXR1cm5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixgdmFsdWUgLz0gJHtufS47YF19KSksdC5yZWR1Y2VNYXg9KGUsdCxuKT0+YShlLHQsbixcIlJlZHVjZU1heFwiLCgoZSx0KT0+e2NvbnN0IG49W107Zm9yKGxldCByPTA7cjxlWzBdLmRpbXMubGVuZ3RoO3IrKykodC5pbmRleE9mKHIpPj0wfHwwPT09dC5sZW5ndGgpJiZuLnB1c2goYGlucHV0SWR4WyR7cn1dID0gMDtgKTtyZXR1cm5bYCR7bi5qb2luKFwiXFxuXCIpfVxcbnZhbHVlID0gX0EoaW5wdXRJZHgpO2AsXCJ2YWx1ZSA9IG1heCh2YWx1ZSwgX0EoaW5wdXRJZHgpKTtcIixcIlwiXX0pKSx0LnJlZHVjZU1pbj0oZSx0LG4pPT5hKGUsdCxuLFwiUmVkdWNlTWluXCIsKChlLHQpPT57Y29uc3Qgbj1bXTtmb3IobGV0IHI9MDtyPGVbMF0uZGltcy5sZW5ndGg7cisrKSh0LmluZGV4T2Yocik+PTB8fDA9PT10Lmxlbmd0aCkmJm4ucHVzaChgaW5wdXRJZHhbJHtyfV0gPSAwO2ApO3JldHVybltgJHtuLmpvaW4oXCJcXG5cIil9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCxcInZhbHVlID0gbWluKHZhbHVlLCBfQShpbnB1dElkeCkpO1wiLFwiXCJdfSkpLHQucmVkdWNlUHJvZD0oZSx0LG4pPT5hKGUsdCxuLFwiUmVkdWNlUHJvZFwiLCgoKT0+W1widmFsdWUgPSAxLjA7XCIsXCJ2YWx1ZSAqPSBfQShpbnB1dElkeCk7XCIsXCJcIl0pKSx0LnJlZHVjZUxvZ1N1bT0oZSx0LG4pPT5hKGUsdCxuLFwiUmVkdWNlTG9nU3VtXCIsKCgpPT5bXCJ2YWx1ZSA9IDAuMDtcIixcInZhbHVlICs9IF9BKGlucHV0SWR4KTtcIixcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pKSx0LnJlZHVjZUxvZ1N1bVNxdWFyZT0oZSx0LG4pPT5hKGUsdCxuLFwiUmVkdWNlTG9nU3VtU3F1YXJlXCIsKCgpPT5bXCJmbG9hdCB0OyB2YWx1ZSA9IDAuMDtcIixcInQgPSBfQShpbnB1dElkeCk7IHZhbHVlICs9IHQgKiB0O1wiLFwiXCJdKSl9LDczNzk6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuaXNSZXNoYXBlQ2hlYXA9dC5wcm9jZXNzRGltczNEPXQuY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm9Mb2FkZXI9dm9pZCAwO2NvbnN0IHI9big3MjczKSxvPW4oNjc1NyksaT1uKDU2MzkpLHM9big1NjE0KTt0LmNyZWF0ZVBhY2tlZFJlc2hhcGUzRFByb2dyYW1JbmZvTG9hZGVyPShlLHQsbik9Pntjb25zdCBhPShlPT4oe25hbWU6XCJSZXNoYXBlIChwYWNrZWQpXCIsaW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS5wYWNrZWRdLGlucHV0TmFtZXM6W1wiQVwiXSxjYWNoZUhpbnQ6YCR7ZX1gfSkpKG4pO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2dldDooKT0+KChlLHQsbixhKT0+e2NvbnN0IHU9dC5kaW1zLGw9YTtsZXQgYz1cIlwiO2ZvcihsZXQgZT0wO2U8NDtlKyspe2xldCB0PVwiXCI7c3dpdGNoKGUpe2Nhc2UgMDp0PVwib3V0cHV0Q29vcmRzID0gcmM7XCI7YnJlYWs7Y2FzZSAxOnQ9XCJvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnopO1wiO2JyZWFrO2Nhc2UgMjp0PVwib3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSwgcmMueisxKTtcIjticmVhaztjYXNlIDM6dD1cIm91dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueisxKTtcIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcn1jKz1gXFxuICAgICAgICAke3R9XFxuICAgICAgICAke2U+MD9cImlmKG91dHB1dENvb3Jkcy55IDwgcm93cyAmJiBvdXRwdXRDb29yZHMueiA8IGNvbHMpe1wiOlwiXCJ9XFxuICAgICAgICAgIGludCBmbGF0dGVuZWRJbmRleCA9IGdldEZsYXR0ZW5lZEluZGV4KG91dHB1dENvb3Jkcyk7XFxuXFxuICAgICAgICAgIGl2ZWMzIGlucHV0UkMgPSBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhmbGF0dGVuZWRJbmRleCk7XFxuICAgICAgICAgIHZlYzIgaW5uZXJEaW1zID0gdmVjMihmbG9hdChpbnB1dFJDLnkpLGZsb2F0KGlucHV0UkMueikpO1xcblxcbiAgICAgICAgICByZXN1bHRbJHtlfV0gPSBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlubmVyRGltcyk7XFxuXFxuICAgICAgICAke2U+MD9cIn1cIjpcIlwifVxcbiAgICAgIGB9Y29uc3QgcD0oMCxvLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxkPWBcXG4gICAgICAke2Z1bmN0aW9uKGUpe2NvbnN0IHQ9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZSksbj1bXCJiXCIsXCJyXCIsXCJjXCJdLG89XCJpbmRleFwiLGk9dC5tYXAoKChlLHIpPT5gaW50ICR7bltyXX0gPSAke299IC8gJHtlfTsgJHtyPT09dC5sZW5ndGgtMT9gaW50ICR7bltyKzFdfSA9ICR7b30gLSAke25bcl19ICogJHtlfWA6YGluZGV4IC09ICR7bltyXX0gKiAke2V9YH07YCkpLmpvaW4oXCJcIik7cmV0dXJuYFxcbiAgICBpdmVjMyBpbnB1dENvb3Jkc0Zyb21SZXNoYXBlZE91dENvb3JkcyhpbnQgaW5kZXgpIHtcXG4gICAgICAke2l9XFxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xcbiAgICB9XFxuICBgfSh1KX1cXG4gICAgICAke2Z1bmN0aW9uKGUpe2NvbnN0IHQ9ci5TaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZSk7cmV0dXJuYFxcbiAgaW50IGdldEZsYXR0ZW5lZEluZGV4KGl2ZWMzIGNvb3Jkcykge1xcbiAgICAvLyByZXZlcnNlIHksIHogb3JkZXJcXG4gICAgcmV0dXJuIGNvb3Jkcy54ICogJHt0WzBdfSArIGNvb3Jkcy56ICogJHt0WzFdfSArIGNvb3Jkcy55O1xcbiAgfVxcbmB9KGwpfVxcbiAgICAgICR7KDAscy51bnBhY2tGcm9tQ2hhbm5lbCkoKX1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XFxuXFxuICAgICAgICBpdmVjMyBvdXRwdXRDb29yZHM7XFxuICAgICAgICBpbnQgcm93cyA9ICR7bFsyXX07XFxuICAgICAgICBpbnQgY29scyA9ICR7bFsxXX07XFxuXFxuICAgICAgICAke2N9XFxuICAgICAgICAke3Aub3V0cHV0fSA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmwsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS5wYWNrZWR9LHNoYWRlclNvdXJjZTpkLGhhc01haW46ITB9KX0pKGUsdCxhLG4pfSl9LHQucHJvY2Vzc0RpbXMzRD1mdW5jdGlvbihlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuWzEsMSwxXTtsZXQgdD0xO2ZvcihsZXQgbj0wO248ZS5sZW5ndGgtMjsrK24pdCo9ZVtuXTtyZXR1cm5bdCxlLmxlbmd0aD4xP2VbZS5sZW5ndGgtMl06MSxlW2UubGVuZ3RoLTFdXX0sdC5pc1Jlc2hhcGVDaGVhcD1mdW5jdGlvbihlLHQpe2xldCBuPSExO3JldHVybiBuPTA9PT1lLmxlbmd0aHx8MD09PXQubGVuZ3RofHwoZS5sZW5ndGg8Mnx8dC5sZW5ndGg8Mj9lW2UubGVuZ3RoLTFdPT09dFt0Lmxlbmd0aC0xXTplW2UubGVuZ3RoLTFdPT09dFt0Lmxlbmd0aC0xXSYmZVtlLmxlbmd0aC0yXT09PXRbdC5sZW5ndGgtMl0pLG59fSw4MTI2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnJlc2hhcGU9dm9pZCAwO2NvbnN0IHI9big3MjczKTt0LnJlc2hhcGU9KGUsdCk9Pntjb25zdCBuPXIuU2hhcGVVdGlsLmNhbGN1bGF0ZVJlc2hhcGVkRGltcyh0WzBdLmRpbXMsdFsxXS5pbnRlZ2VyRGF0YSk7cmV0dXJuIGUuc2Vzc2lvbi5wYWNrP1tlLnJlc2hhcGVQYWNrZWQodFswXSxuKV06W2UucmVzaGFwZVVucGFja2VkKHRbMF0sbildfX0sMjgwMTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE9dC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTA9dC5yZXNpemU9dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSksaT1uKDQzMikscz1uKDU2MTQpLGE9bigzOTgwKSx1PXtuYW1lOlwiUmVzaXplXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W28uVGV4dHVyZVR5cGUucGFja2VkXX07dC5yZXNpemU9KGUsdCxuKT0+KCgwLGEudmFsaWRhdGVJbnB1dHMpKHQsbiksW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5sKGUsdCxuKX0pLHQpXSksdC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTA9ZT0+KDAsYS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykoZSwxMCksdC5wYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE9ZT0+KDAsYS5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcykoZSwxMSk7Y29uc3QgbD0oZSx0LG4pPT57Y29uc3QgYT0oMCxyLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbbCxwXT1jKHQsbik7aWYobC5ldmVyeSgoZT0+MT09PWUpKSYmXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIiE9PW4uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOnAsdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS5wYWNrZWR9LGhhc01haW46ITAsc2hhZGVyU291cmNlOmB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IHYgPSAke2EudGV4dHVyZTJEfShYLCBUZXhDb29yZHMpO1xcbiAgICAgICAgICAgICAgICAgICAgJHthLm91dHB1dH0gPSB2O1xcbiAgICAgICAgICAgICAgICB9YH0pO2NvbnN0IGQ9cC5sZW5ndGg7aWYoZDwyKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgYmUgYXQgbGVhc3QgMiwgYnV0IGdvdCAke2R9YCk7Y29uc3QgZj1wW2QtMl0saD1wW2QtMV0sZz10WzBdLmRpbXM7aWYoZCE9PWcubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgbWF0Y2ggaW5wdXQgJHtnLmxlbmd0aH0sIGJ1dCBnb3QgJHtkfWApO2NvbnN0IGI9Z1tkLTJdLG09Z1tkLTFdLHk9bFtkLTJdLF89bFtkLTFdO2xldCB2PVwiXCI7aWYoXCJsaW5lYXJcIiE9PW4ubW9kZSl0aHJvdyBuZXcgRXJyb3IoYHJlc2l6ZSAocGFja2VkKSBkb2VzIG5vdCBzdXBwb3J0IG1vZGU6ICcke24ubW9kZX0nYCk7c3dpdGNoKG4uY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUpe2Nhc2VcImFzeW1tZXRyaWNcIjp2PVwiXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpIC8gc2NhbGVXSFdIO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIjticmVhaztjYXNlXCJoYWxmX3BpeGVsXCI6dj1cIlxcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh2ZWM0KGNvb3JkcykgKyAwLjUpIC8gc2NhbGVXSFdIIC0gMC41O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIjticmVhaztjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjp2PWBcXG4gICAgICAgICAgICAgICAgICAgIHZlYzQgZ2V0U291cmNlRnJhY0luZGV4KGl2ZWM0IGNvb3Jkcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgZmNvb3JkcyA9IHZlYzQoY29vcmRzKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtofS4wID4gMS4wID8gKGZjb29yZHMueCArIDAuNSkgLyBzY2FsZVdIV0gueCAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtmfS4wID4gMS4wID8gKGZjb29yZHMueSArIDAuNSkgLyBzY2FsZVdIV0gueSAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtofS4wID4gMS4wID8gKGZjb29yZHMueiArIDAuNSkgLyBzY2FsZVdIV0gueiAtIDAuNSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtmfS4wID4gMS4wID8gKGZjb29yZHMudyArIDAuNSkgLyBzY2FsZVdIV0gudyAtIDAuNSA6IDAuMFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYDticmVhaztjYXNlXCJhbGlnbl9jb3JuZXJzXCI6dj1gXFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHJlc2l6ZWQgPSB2ZWM0KCR7aH0uMCAtIDEuMCwgJHtmfS4wIC0gMS4wLCAke2h9LjAgLSAxLjAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7Zn0uMCAtIDEuMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBvcmlnaW5hbCA9IHZlYzQoJHttfS4wIC0gMS4wLCAke2J9LjAgLSAxLjAsICR7bX0uMCAtIDEuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtifS4wIC0gMS4wKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IG5ld19zY2FsZSA9IG9yaWdpbmFsIC8gcmVzaXplZDtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBgO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHtuLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfSdgKX1jb25zdCBUPSgwLGkuZ2V0Q29vcmRzRGF0YVR5cGUpKGQpLHg9YFxcbiAgICAgICAgICAgIGNvbnN0IHZlYzIgaW5wdXRXSCA9IHZlYzIoJHtifS4wLCAke219LjApO1xcbiAgICAgICAgICAgIGNvbnN0IHZlYzQgc2NhbGVXSFdIID0gdmVjNChmbG9hdCgke3l9KSwgZmxvYXQoJHtffSksIGZsb2F0KCR7eX0pLCBmbG9hdCgke199KSk7XFxuICAgICAgICAgICAgJHsoMCxzLnVucGFja0Zyb21DaGFubmVsKSgpfVxcbiAgICAgICAgICAgICR7dn1cXG4gICAgICAgICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IHgxMCwgaW50IHIsIGludCBjLCBpbnQgZCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKHgxMCwgciwgYywgZCksIHZlYzIoYywgZCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgICAgICAgICR7VH0gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgICAgICAgICAgaW50IGJhdGNoID0gcmNbMF07XFxuICAgICAgICAgICAgICAgIGludCBkZXB0aCA9IHJjWzFdO1xcblxcbiAgICAgICAgICAgICAgICAvLyByZXRyaWV2ZSB0aGUgNCBjb29yZGluYXRlcyB0aGF0IGlzIHVzZWQgaW4gdGhlIDQgcGFja2VkIG91dHB1dCB2YWx1ZXMuXFxuICAgICAgICAgICAgICAgIGl2ZWM0IGNvb3JkcyA9IGl2ZWM0KHJjLnd6LCByYy53ICsgMSwgcmMueiArIDEpO1xcblxcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNvdXJjZSBpbmRleCBpbiBmcmFjdGlvblxcbiAgICAgICAgICAgICAgICB2ZWM0IHNvdXJjZUZyYWMgPSBnZXRTb3VyY2VGcmFjSW5kZXgoY29vcmRzKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmQgb2YgdGhlIDQgdmFsdWVzIHRoYXQgd2lsbCBiZSBwYWNrZWQgaW50byBvbmUgdGV4ZWwuXFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgwMCA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnh5LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnh5KSkpO1xcbiAgICAgICAgICAgICAgICBpdmVjNCB4MDEgPSBpdmVjNChtYXgoc291cmNlRnJhYy54dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54dykpKTtcXG4gICAgICAgICAgICAgICAgaXZlYzQgeDEwID0gaXZlYzQobWF4KHNvdXJjZUZyYWMuenksIHZlYzIoMC4wKSksIG1pbihpbnB1dFdIIC0gMS4wLCBjZWlsKHNvdXJjZUZyYWMuenkpKSk7XFxuICAgICAgICAgICAgICAgIGl2ZWM0IHgxMSA9IGl2ZWM0KG1heChzb3VyY2VGcmFjLnp3LCB2ZWMyKDAuMCkpLCBtaW4oaW5wdXRXSCAtIDEuMCwgY2VpbChzb3VyY2VGcmFjLnp3KSkpO1xcblxcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRSb3cgPSByYy53IDwgJHtmLTF9O1xcbiAgICAgICAgICAgICAgICBib29sIGhhc05leHRDb2wgPSByYy56IDwgJHtoLTF9O1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IHRvcExlZnQgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgICAgZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAwLngsIHgwMC55KSxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLnkpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMS54LCB4MTEueSkgOiAwLjApO1xcblxcbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1yaWdodCBjb3JuZXIgaW50byBvbmUgdmVjNCBzdHJ1Y3R1cmVcXG4gICAgICAgICAgICAgICAgdmVjNCB0b3BSaWdodCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLncpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS54LCB4MDEudykgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLngsIHgxMC53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS53KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLWxlZnQgY29ybmVyIGludG8gb25lIHZlYzQgc3RydWN0dXJlXFxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tTGVmdCA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLnkpLFxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMS56LCB4MDEueSkgOiAwLjAsXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC55KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS55KSA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxcbiAgICAgICAgICAgICAgICB2ZWM0IGJvdHRvbVJpZ2h0ID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC56LCB4MDAudyksXFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS53KSA6IDAuMCxcXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTAueiwgeDEwLncpIDogMC4wLFxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueiwgeDExLncpIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnBvbGF0aW9uIGZyYWN0aW9uIG9uIHUgYW5kIHYgZGlyZWN0aW9uXFxuICAgICAgICAgICAgICAgIHZlYzQgZnJhYyA9IHZlYzQoc291cmNlRnJhYykgLSBmbG9vcihzb3VyY2VGcmFjKTtcXG4gICAgICAgICAgICAgICAgdmVjNCBjbGFtcEZyYWMgPSBjbGFtcChmcmFjLCB2ZWM0KDAuMCksIHZlYzQoMS4wKSk7XFxuXFxuICAgICAgICAgICAgICAgIHZlYzQgdG9wID0gbWl4KHRvcExlZnQsIHRvcFJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XFxuICAgICAgICAgICAgICAgIHZlYzQgbmV3VmFsdWUgPSBtaXgodG9wLCBib3R0b20sIGNsYW1wRnJhYy54eHp6KTtcXG5cXG4gICAgICAgICAgICAgICAgJHthLm91dHB1dH0gPSB2ZWM0KG5ld1ZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse291dHB1dDp7ZGltczpwLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUucGFja2VkfSxoYXNNYWluOiEwLHNoYWRlclNvdXJjZTp4fSl9LGM9KGUsdCk9Pntjb25zdCBuPWVbMF0uZGltcztsZXQgcixvPXQuc2NhbGVzO2lmKDA9PT1vLmxlbmd0aCl7Y29uc3QgaT1lW3Quc2NhbGVzSW5wdXRJZHhdO2lmKGkmJjAhPT1pLnNpemUpe2lmKGVbdC5zaXplc0lucHV0SWR4XSl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBzY2FsZXMgb3Igc2l6ZXMgbXVzdCBiZSBwcm92aWRlZCBhcyBpbnB1dC5cIik7bz1wKGksdC5tb2RlLHQuaXNSZXNpemUpfWVsc2V7Y29uc3QgaT1lW3Quc2l6ZXNJbnB1dElkeF07aWYoIWl8fDA9PT1pLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIHNjYWxlcyBvciBzaXplcyBNVVNUIGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtyPUFycmF5LmZyb20oaS5pbnRlZ2VyRGF0YSksbz1kKHIsbix0Lm1vZGUsdC5pc1Jlc2l6ZSl9fWVsc2UgaWYoZVt0LnNpemVzSW5wdXRJZHhdKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LlwiKTtjb25zdCBpPXJ8fG4ubWFwKCgoZSx0KT0+TWF0aC5mbG9vcihlKm9bdF0pKSk7cmV0dXJuW28saV19LHA9KGUsdCxuKT0+e2NvbnN0IHI9QXJyYXkuZnJvbShlLmZsb2F0RGF0YSk7cmV0dXJuKDAsYS5zY2FsZXNWYWxpZGF0aW9uKShyLHQsbikscn0sZD0oZSx0LG4scik9Pntjb25zdCBvPXQubGVuZ3RoLGk9bmV3IEFycmF5KG8pO2ZvcihsZXQgbj0wLHI9bztuPHI7bisrKWlmKDA9PT10W25dKXtpZigwIT09ZVtuXSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkaW0gaXMgemVybyBidXQgcmVxdWlyZWQgb3V0cHV0IGRpbSBpcyBub24temVyby5cIik7aVtuXT0xfWVsc2UgaVtuXT1lW25dL3Rbbl07cmV0dXJuKDAsYS5zY2FsZXNWYWxpZGF0aW9uKShpLG4sciksaX19LDU2NTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zaGFwZT12b2lkIDA7Y29uc3Qgcj1uKDkyNDApO3Quc2hhcGU9KGUsdCk9PihvKHQpLFtuZXcgci5UZW5zb3IoW3RbMF0uZGltcy5sZW5ndGhdLFwiaW50MzJcIix2b2lkIDAsdm9pZCAwLG5ldyBJbnQzMkFycmF5KHRbMF0uZGltcykpXSk7Y29uc3Qgbz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSByZXF1aXJlcyAxIGlucHV0LlwiKX19LDI0NDQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuc2xpY2VWMTA9dC5wYXJzZVNsaWNlQXR0cmlidXRlcz10LnNsaWNlPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDYxNDUpLGk9big3MjczKSxzPW4oNTYzOSksYT17bmFtZTpcIlNsaWNlXCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W3MuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTt0LnNsaWNlPShlLHQsbik9PihsKHQpLFtlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+dShlLHRbMF0sbil9KSx0KV0pLHQucGFyc2VTbGljZUF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldEludHMoXCJzdGFydHNcIiksbj1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImVuZHNcIiksbz1lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIixbXSk7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtzdGFydHM6dCxlbmRzOm4sYXhlczpvfSl9O2NvbnN0IHU9KGUsdCxuKT0+e2NvbnN0IHI9MD09PW4uYXhlcy5sZW5ndGg/dC5kaW1zLnNsaWNlKDApLm1hcCgoKGUsdCk9PnQpKTpuLmF4ZXMsbz1pLlNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKHIsdC5kaW1zLmxlbmd0aCksdT1uLnN0YXJ0cy5tYXAoKChlLG4pPT5lPnQuZGltc1tvW25dXS0xP3QuZGltc1tvW25dXTppLlNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGUsdC5kaW1zW29bbl1dKSkpLGw9bi5lbmRzLm1hcCgoKGUsbik9PmU+dC5kaW1zW29bbl1dLTE/dC5kaW1zW29bbl1dOmkuU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoZSx0LmRpbXNbb1tuXV0pKSksYz10LmRpbXMuc2xpY2UoKSxwPVtdO2ZvcihsZXQgZT0wO2U8by5sZW5ndGg7ZSsrKWNbb1tlXV09bFtlXS11W2VdLHVbZV0+MCYmcC5wdXNoKGBvdXRwdXRJZHhbJHtvW2VdfV0gKz0gJHt1W2VdfTtgKTtjb25zdCBkPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtjLmxlbmd0aH1dKSB7XFxuICAgICAgICAke3Auam9pbihcIlxcbiAgICAgIFwiKX1cXG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYSkse291dHB1dDp7ZGltczpjLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOnMuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpkfSl9LGw9ZT0+e2lmKCFlfHwxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiU2xpY2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoLTE9PT1vLk5VTUJFUl9UWVBFUy5pbmRleE9mKGVbMF0udHlwZSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX07dC5zbGljZVYxMD0oZSx0KT0+e3AodCk7Y29uc3Qgbj1jKGUsdCk7cmV0dXJuW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT51KGUsdFswXSxuKX0pLFt0WzBdXSldfTtjb25zdCBjPShlLHQpPT57aWYoIWUuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbMV0uZGF0YUlkKXx8IWUuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRbMl0uZGF0YUlkKXx8dC5sZW5ndGg+PTQmJiFlLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzNdLmRhdGFJZCl8fHQubGVuZ3RoPj01JiYhZS5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIodFs0XS5kYXRhSWQpKXRocm93IG5ldyBFcnJvcihcImR5bmFtaWMgc2xpY2UgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWRcIik7aWYodC5sZW5ndGg+PTUmJnRbNF0uaW50ZWdlckRhdGEuc29tZSgoZT0+MSE9PWUpKSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm9uLTEgc3RlcHMgaXMgbm90IHN1cHBvcnRlZCBmb3IgU2xpY2VcIik7Y29uc3Qgbj1BcnJheS5mcm9tKHRbMV0uaW50ZWdlckRhdGEpLHI9QXJyYXkuZnJvbSh0WzJdLmludGVnZXJEYXRhKSxvPXQubGVuZ3RoPj00P0FycmF5LmZyb20odFszXS5pbnRlZ2VyRGF0YSk6W107cmV0dXJue3N0YXJ0czpuLGVuZHM6cixheGVzOm8sY2FjaGVLZXk6YCR7b307JHtufTske3J9YH19LHA9ZT0+e2lmKCFlfHxlLmxlbmd0aDwzfHxlLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihcImludDMyXCIhPT1lWzFdLnR5cGV8fDEhPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7aWYoXCJpbnQzMlwiIT09ZVsyXS50eXBlfHwxIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKGUubGVuZ3RoPj00JiYoXCJpbnQzMlwiIT09ZVszXS50eXBlfHwxIT09ZVszXS5kaW1zLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKTtpZihlLmxlbmd0aD49NSYmKFwiaW50MzJcIiE9PWVbNF0udHlwZXx8MSE9PWVbNF0uZGltcy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw4MTU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuc29mdG1heFYxMz10LnBhcnNlU29mdG1heEF0dHJpYnV0ZXNWMTM9dC5wYXJzZVNvZnRtYXhBdHRyaWJ1dGVzPXQuc29mdG1heD12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNjc1Nykscz1uKDU2MzkpLGE9big1NzA3KSx1PXtuYW1lOlwiU29mdG1heENvbXB1dGVNYXhcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbcy5UZXh0dXJlVHlwZS51bnBhY2tlZF19LGw9e25hbWU6XCJTb2Z0bWF4Q29tcHV0ZVNjYWxlXCIsaW5wdXROYW1lczpbXCJBXCIsXCJNYXhcIl0saW5wdXRUeXBlczpbcy5UZXh0dXJlVHlwZS51bnBhY2tlZCxzLlRleHR1cmVUeXBlLnVucGFja2VkXX0sYz17bmFtZTpcIlNvZnRNYXhcIixpbnB1dE5hbWVzOltcIkFcIixcIk1heFwiLFwiTm9ybVwiXSxpbnB1dFR5cGVzOltzLlRleHR1cmVUeXBlLnVucGFja2VkLHMuVGV4dHVyZVR5cGUudW5wYWNrZWQscy5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3Quc29mdG1heD0oZSx0LG4pPT57Zyh0KTtjb25zdCByPXRbMF0uZGltcy5zbGljZSgpLGk9by5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsci5sZW5ndGgpLHM9by5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHIsaSksYT1vLlNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihyLGkpO3JldHVybiBwKGUsdCxuLHMsYSl9LHQucGFyc2VTb2Z0bWF4QXR0cmlidXRlcz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwxKX0pLHQucGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxMz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2F4aXM6ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwtMSl9KSx0LnNvZnRtYXhWMTM9KGUsdCxuKT0+e2codCk7Y29uc3QgaT10WzBdLmRpbXMuc2xpY2UoKSxzPW8uU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMobi5heGlzLGkubGVuZ3RoKSx1PWkubGVuZ3RoLGw9cyE9PXUtMSxjPVtdO2xldCBkLGY9W10saD1bXTtsJiYoZj1BcnJheS5mcm9tKHtsZW5ndGg6dX0pLm1hcCgoKGUsdCk9PnQpKSxmW3NdPXUtMSxmW3UtMV09cyxmLm1hcCgoZT0+Yy5wdXNoKGlbZV0pKSksZD0oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe3Blcm06Zn0pLGg9KDAsYS50cmFuc3Bvc2UpKGUsdCxkKSk7Y29uc3QgYj1sP28uU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbihjLHUtMSk6by5TaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGksdS0xKSxtPWw/by5TaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oYyx1LTEpOm8uU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGksdS0xKSx5PXAoZSxsP2g6dCxuLGIsbSk7cmV0dXJuIGw/KDAsYS50cmFuc3Bvc2UpKGUseSxkKTp5fTtjb25zdCBwPShlLHQsbixyLG8pPT57Y29uc3QgaT1kKGUsdFswXSxyLG8sW3JdKSxzPWUucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7Y2FjaGVIaW50Om4uY2FjaGVLZXksZ2V0OigpPT5pfSksdCksYT1mKGUsdFswXSxyLG8saS5vdXRwdXQuZGltcyxbcl0pLHA9ZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGwpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9PmF9KSxbdFswXSxzXSksZz1oKGUsdFswXSxyLG8saS5vdXRwdXQuZGltcyxhLm91dHB1dC5kaW1zKTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGMpLHtjYWNoZUhpbnQ6bi5jYWNoZUtleSxnZXQ6KCk9Pmd9KSxbdFswXSxzLHBdKV19LGQ9KGUsdCxuLHIsbyk9Pntjb25zdFthLGxdPWUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHQuZGltcyxzLlRleHR1cmVUeXBlLnVucGFja2VkKSxjPW8ubGVuZ3RoO2lmKG48MXx8cjwxKXRocm93IG5ldyBFcnJvcihcIkxvZ2ljYWwgcm93IGNvdW50IE4gYW5kIGZlYXR1cmUgY291bnQgRCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpO2lmKDEhPT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSAxXCIpO2lmKG9bMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50XCIpO2NvbnN0IHA9KDAsaS5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbiksZD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtjfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHthfSxcXG4gICAgICAgICR7bH0gKSkpO1xcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBmbG9hdCBjdXJyZW50ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7cC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXFxuICAgICAgICAgICAgJHthfSwgJHtsfSkpKTtcXG4gICAgICAgICAgaWYoY3VycmVudCA+IG1heClcXG4gICAgICAgICAgbWF4ID0gY3VycmVudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBtYXg7XFxuICAgICAgfWA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx1KSx7b3V0cHV0OntkaW1zOm8sdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6cy5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmR9KX0sZj0oZSx0LG4scixvLGEpPT57Y29uc3RbdSxjXT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0LmRpbXMscy5UZXh0dXJlVHlwZS51bnBhY2tlZCkscD1hLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMVwiKTtpZihhWzBdIT09bil0aHJvdyBuZXcgRXJyb3IoXCJTaGFwZSBvZiB0aGUgb3V0cHV0IHNob3VsZCBiZSBlcXVhbCB0byBsb2dpY2FsIHJvdyBjb3VudFwiKTtpZigxIT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uYWxpdHkgb2YgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIHNob3VsZCBiZSAxXCIpO2lmKG9bMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgZD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtwfV0gaW5kaWNlcykge1xcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke3J9O1xcblxcbiAgICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSAwLjA7XFxuICAgICAgICBmbG9hdCBtYXggPSBfTWF4KGluZGljZXMpO1xcbiAgICAgICAgZm9yKGludCBpPTA7IGk8JHtyfTsgKytpKVxcbiAgICAgICAge1xcbiAgICAgICAgICBub3JtX2ZhY3RvciArPSBleHAoZ2V0Q29sb3JBc0Zsb2F0KCR7KDAsaS5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxcbiAgICAgICAgICAgICR7dX0sICR7Y30pKSkgLSBtYXgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG5vcm1fZmFjdG9yO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbCkse291dHB1dDp7ZGltczphLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOnMuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpkfSl9LGg9KGUsdCxuLHIsbyxpKT0+e2NvbnN0W2EsdV09ZS5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQodC5kaW1zLHMuVGV4dHVyZVR5cGUudW5wYWNrZWQpLGw9dC5kaW1zLmxlbmd0aDtpZihuPDF8fHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKTtpZigxIT09by5sZW5ndGh8fDEhPT1pLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDFcIik7aWYob1swXSE9PW58fGlbMF0hPT1uKXRocm93IG5ldyBFcnJvcihcIlNoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnRcIik7Y29uc3QgcD1gXFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtsfV0gaW5kaWNlcykge1xcblxcbiAgICAgIC8vIGdldCBvZmZzZXQgb2YgY3VycmVudCBsb2dpY2FsIHRlbnNvciBpbmRleCBmcm9tIHRoZSAyLUQgdGV4dHVyZSBjb29yZGluYXRlcyAoVGV4Q29vcmRzKVxcbiAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7YX0sICR7dX0pO1xcblxcbiAgICAgIC8vZGV0ZXJtaW5lIHRoZSBsb2dpY2FsIHJvdyBmb3IgdGhpcyBpbmRleFxcbiAgICAgIGludCBsb2dpY2FsX3Jvd19pbmRleFsxXTtcXG4gICAgICBsb2dpY2FsX3Jvd19pbmRleFswXSA9IG9mZnNldCAvICR7cn07XFxuXFxuICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSBfTm9ybShsb2dpY2FsX3Jvd19pbmRleCk7XFxuXFxuICAgICAgLy8gYXZvaWQgcG9zc2libGUgZGl2aXNpb24gYnkgMFxcbiAgICAgIC8vIGlmIG5vcm1fZmFjb3IgaXMgMCwgYWxsIGVsZW1lbnRzIGFyZSB6ZXJvXFxuICAgICAgLy8gaWYgc28sIHJldHVybiAwXFxuICAgICAgaWYobm9ybV9mYWN0b3IgPT0gMC4wKVxcbiAgICAgICAgcmV0dXJuIDAuMDtcXG5cXG4gICAgICByZXR1cm4gZXhwKF9BKGluZGljZXMpIC0gX01heChsb2dpY2FsX3Jvd19pbmRleCkpIC8gbm9ybV9mYWN0b3I7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sYykse291dHB1dDp7ZGltczp0LmRpbXMsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6cy5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnB9KX0sZz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGVcIil9fSw1NjQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VTcGxpdEF0dHJpYnV0ZXM9dC5zcGxpdD12b2lkIDA7Y29uc3Qgcj1uKDQ5MTApLG89big3MjczKSxpPW4oNTYzOSkscz17bmFtZTpcIlNwbGl0XCIsaW5wdXROYW1lczpbXCJBXCJdLGlucHV0VHlwZXM6W2kuVGV4dHVyZVR5cGUudW5wYWNrZWRdfTt0LnNwbGl0PShlLHQsbik9PntsKHQpO2NvbnN0IHI9by5TaGFwZVV0aWwubm9ybWFsaXplQXhpcyhuLmF4aXMsdFswXS5kaW1zLmxlbmd0aCksaT1hKGUsdCxyLG4pLGM9W107Zm9yKGxldCBvPTA7bzxpOysrbyljLnB1c2goZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX07JHtvfWAsZ2V0OigpPT51KGUsdFswXSxuLHIsbyl9KSx0KSk7cmV0dXJuIGN9LHQucGFyc2VTcGxpdEF0dHJpYnV0ZXM9ZT0+e2NvbnN0IHQ9ZS5hdHRyaWJ1dGVzLmdldEludChcImF4aXNcIiwwKSxuPWUuYXR0cmlidXRlcy5nZXRJbnRzKFwic3BsaXRcIixbXSksbz1lLm91dHB1dHMubGVuZ3RoO3JldHVybigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YXhpczp0LHNwbGl0Om4sbnVtT3V0cHV0czpvfSl9O2NvbnN0IGE9KGUsdCxuLHIpPT57Y29uc3RbLGldPW8uU3BsaXRVdGlsLnNwbGl0U2hhcGUodFswXS5kaW1zLG4sci5zcGxpdCxyLm51bU91dHB1dHMpO3JldHVybiBpLmxlbmd0aH0sdT0oZSx0LG4scixhKT0+e2NvbnN0W3UsbF09by5TcGxpdFV0aWwuc3BsaXRTaGFwZSh0LmRpbXMscixuLnNwbGl0LG4ubnVtT3V0cHV0cyksYz1sW2FdLHA9dVthXSxkPWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cC5sZW5ndGh9XSkge1xcbiAgICAgICAgaW5kaWNlc1ske3J9XSArPSAke2N9O1xcbiAgICAgICAgcmV0dXJuIF9BKGluZGljZXMpO1xcbiAgICAgIH1cXG4gICAgYDtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHMpLHtjYWNoZUhpbnQ6YCR7bi5jYWNoZUtleX06JHthfWAsb3V0cHV0OntkaW1zOnAsdHlwZTp0LnR5cGUsdGV4dHVyZVR5cGU6aS5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOmR9KX0sbD1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcGxpdCByZXF1aXJlcyBvbmUgaW5wdXQuXCIpO2lmKFwiaW50OFwiIT09ZVswXS50eXBlJiZcInVpbnQ4XCIhPT1lWzBdLnR5cGUmJlwiaW50MTZcIiE9PWVbMF0udHlwZSYmXCJ1aW50MTZcIiE9PWVbMF0udHlwZSYmXCJpbnQzMlwiIT09ZVswXS50eXBlJiZcInVpbnQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0MzJcIiE9PWVbMF0udHlwZSYmXCJmbG9hdDY0XCIhPT1lWzBdLnR5cGUmJlwiYm9vbFwiIT09ZVswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9fSw1NDE2OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnBhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXM9dC5zcXVlZXplVjEzPXQuc3F1ZWV6ZT12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpO3Quc3F1ZWV6ZT0oZSx0LG4pPT57byh0KTtjb25zdCBpPXIuU2hhcGVVdGlsLnNxdWVlemVTaGFwZSh0WzBdLmRpbXMsbik7cmV0dXJuW2UucmVzaGFwZVVucGFja2VkKHRbMF0saSldfSx0LnNxdWVlemVWMTM9KGUsbik9PihpKG4pLCgwLHQuc3F1ZWV6ZSkoZSxbblswXV0sQXJyYXkuZnJvbShuWzFdLmludGVnZXJEYXRhKSkpLHQucGFyc2VTcXVlZXplQXR0cmlidXRlcz1lPT5lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIik7Y29uc3Qgbz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTcXVlZXplIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwic3RyaW5nXCI9PT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSxpPWU9PntpZighZXx8MiE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlNxdWVlemUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKFwiaW50MzJcIiE9PWVbMV0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfX0sMTI0MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5zdW09dm9pZCAwO2NvbnN0IHI9big2NzU3KSxvPW4oNTYzOSk7dC5zdW09KGUsdCk9PntzKHQpO2NvbnN0IG49e25hbWU6XCJTdW1cIixpbnB1dE5hbWVzOnQubWFwKCgoZSx0KT0+YFgke3R9YCkpLGlucHV0VHlwZXM6bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG8uVGV4dHVyZVR5cGUudW5wYWNrZWQpfTtyZXR1cm5bZS5ydW4oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtnZXQ6KCk9PmkoZSx0LG4pfSksdCldfTtjb25zdCBpPShlLHQsbik9Pntjb25zdCBpPSgwLHIuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHM9dFswXS5kaW1zLnNsaWNlKCksYT10Lm1hcCgoKGUsdCk9PmAke2kudGV4dHVyZTJEfShYJHt0fSxUZXhDb29yZHMpYCkpLmpvaW4oXCIgKyBcIiksdT1gXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke2F9O1xcbiAgICAgICAgJHtpLm91dHB1dH0gPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBgO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse291dHB1dDp7ZGltczpzLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LGhhc01haW46ITAsc2hhZGVyU291cmNlOnV9KX0scz1lPT57aWYoIWV8fDA9PT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTdW0gcmVxdWlyZXMgaW5wdXRzLlwiKTtjb25zdCB0PWVbMF0uZGltcy5sZW5ndGg7Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDtuKyspe2lmKHQhPT1lW25dLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIklucHV0IHNoYXBlcyBhcmUgbWlzbWF0Y2hlZC5cIik7Zm9yKGxldCByPTA7cjx0O3IrKylpZihlWzBdLmRpbXNbcl0hPT1lW25dLmRpbXNbcl0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgc2hhcGVzIGFyZSBub3QgbWF0Y2hlZC5cIil9aWYoXCJmbG9hdDMyXCIhPT1lWzBdLnR5cGUmJlwiZmxvYXQ2NFwiIT09ZVswXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIik7Zm9yKGxldCB0PTE7dDxlLmxlbmd0aDt0KyspaWYoZVswXS50eXBlIT09ZVt0XS50eXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBub3QgbWF0Y2hlZC5cIil9fSw1OTQ0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnRpbGU9dm9pZCAwO2NvbnN0IHI9big2MTQ1KSxvPW4oNTYzOSk7dC50aWxlPShlLHQpPT57cyh0KTtjb25zdCBuPXtuYW1lOlwiVGlsZVwiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXX07cmV0dXJuW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7Z2V0OigpPT5pKGUsdCxuKX0pLHQpXX07Y29uc3QgaT0oZSx0LG4pPT57Y29uc3Qgcj10WzBdLmRpbXMuc2xpY2UoKSxpPW5ldyBBcnJheShyLmxlbmd0aCkscz1bXTtmb3IobGV0IGU9MDtlPHIubGVuZ3RoO2UrKylpW2VdPXJbZV0qdFsxXS5udW1iZXJEYXRhW2VdLHMucHVzaChgaW5wdXRJZHhbJHtlfV0gPSBpbnQobW9kKGZsb2F0KG91dHB1dElkeFske2V9XSksICR7cltlXX0uKSk7YCk7Y29uc3QgYT1pLmxlbmd0aCx1PWBcXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHthfV0pIHtcXG4gICAgICAgIGludCBpbnB1dElkeFske2F9XTtcXG4gICAgICAgICR7cy5qb2luKFwiXFxuXCIpfVxcbiAgICAgICAgcmV0dXJuIF9BKGlucHV0SWR4KTtcXG4gICAgICB9XFxuICAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3V0cHV0OntkaW1zOmksdHlwZTp0WzBdLnR5cGUsdGV4dHVyZVR5cGU6by5UZXh0dXJlVHlwZS51bnBhY2tlZH0sc2hhZGVyU291cmNlOnV9KX0scz1lPT57aWYoIWV8fDIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXQuXCIpO2lmKDEhPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRoZSBzZWNvbmQgaW5wdXQgc2hhcGUgbXVzdCAxIGRpbWVuc2lvbi5cIik7aWYoZVsxXS5kaW1zWzBdIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlLlwiKTtpZigtMT09PXIuTlVNQkVSX1RZUEVTLmluZGV4T2YoZVswXS50eXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpO2lmKFwiaW50MzJcIiE9PWVbMV0udHlwZSYmXCJpbnQxNlwiIT09ZVsxXS50eXBlKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVwZWF0IHR5cGUuXCIpfX0sNTcwNzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM9dC50cmFuc3Bvc2U9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNzI3MyksaT1uKDU2MzkpLHM9e25hbWU6XCJUcmFuc3Bvc2VcIixpbnB1dE5hbWVzOltcIkFcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3QudHJhbnNwb3NlPShlLHQsbik9PihwKHQpLFtlLnJ1bihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2NhY2hlSGludDpuLmNhY2hlS2V5LGdldDooKT0+YShlLHRbMF0sbi5wZXJtKX0pLHQpXSksdC5wYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXM9ZT0+KDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtwZXJtOmUuYXR0cmlidXRlcy5nZXRJbnRzKFwicGVybVwiLFtdKX0pO2NvbnN0IGE9KGUsdCxuKT0+e2NvbnN0IHI9dC5kaW1zO249dShyLG4pO2NvbnN0IG89bChyLG4pLGE9ci5sZW5ndGgscD1gXFxuICAgICAgJHtjKFwicGVybVwiLG4sYSl9XFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2F9XSkge1xcbiAgICAgICAgaW50IGFbJHthfV07XFxuICAgICAgICBwZXJtKGEsIGluZGljZXMpO1xcbiAgICAgICAgcmV0dXJuIF9BKGEpO1xcbiAgICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse291dHB1dDp7ZGltczpvLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpwfSl9LHU9KGUsdCk9Pih0JiZ0Lmxlbmd0aCE9PWUubGVuZ3RoJiYodD1bLi4uZS5rZXlzKCldLnJldmVyc2UoKSksdCksbD0oZSx0KT0+KHQ9dShlLHQpLG8uU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybShlLHQpKSxjPShlLHQsbik9Pntjb25zdCByPVtdO3IucHVzaChgdm9pZCAke2V9KG91dCBpbnQgYVske259XSwgaW50IHNyY1ske259XSkge2ApO2ZvcihsZXQgZT0wO2U8bjsrK2Upci5wdXNoKGBcXHRhWyR7dFtlXX1dPXNyY1ske2V9XTtgKTtyZXR1cm4gci5wdXNoKFwiXFx0fVwiKSxyLmpvaW4oXCJcXG5cIil9LHA9ZT0+e2lmKCFlfHwxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKFwiZmxvYXQzMlwiIT09ZVswXS50eXBlJiZcImZsb2F0NjRcIiE9PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgYmUgZmxvYXQgdGVuc29yXCIpfX0sMjQ4ODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5lbmNvZGVBc1VpbnQ4PXZvaWQgMDtjb25zdCByPW4oNjc1Nyksbz1uKDU2MzkpO3QuZW5jb2RlQXNVaW50OD0oZSx0KT0+e2NvbnN0IG49dC5zaGFwZSxpPSgwLHIuZ2V0R2xzbCkoZS5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pLHM9YFxcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NQVggPSAxLjcwMTQxMTg0ZTM4O1xcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gICAgYm9vbCBpc05hTihmbG9hdCB2YWwpIHtcXG4gICAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgdmVjNCBlbmNvZGVBc1VpbnQ4KGhpZ2hwIGZsb2F0IHYpIHtcXG4gICAgICBpZiAoaXNOYU4odikpIHtcXG4gICAgICAgIHJldHVybiB2ZWM0KDI1NSwgMjU1LCAyNTUsIDI1NSk7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICAgIGlmKGF2IDwgRkxPQVRfTUlOKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XFxuICAgICAgICByZXR1cm4gdmVjNCgwLjAsIDAuMCwgMTI4LjAsIDEyNy4wKSAvIDI1NS4wO1xcbiAgICAgIH0gZWxzZSBpZih2IDwgLUZMT0FUX01BWCkge1xcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgICAgfVxcblxcbiAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xcblxcbiAgICAgIGNbMl0gPSBmbG9vcigxMjguMCAqIG0pO1xcbiAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICAgIGNbMV0gPSBmbG9vcigzMjc2OC4wICogbSk7XFxuICAgICAgbSAtPSBjWzFdIC8gMzI3NjguMDtcXG4gICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgICAgaGlnaHAgZmxvYXQgZWJpYXMgPSBlICsgMTI3LjA7XFxuICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcXG4gICAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICAgIGNbMl0gKz0gZmxvb3IoZWJpYXMpICogMTI4LjA7XFxuXFxuICAgICAgY1szXSArPSAxMjguMCAqIHN0ZXAoMC4wLCAtdik7XFxuXFxuICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZmxvYXQgdmFsdWUgPSAke2kudGV4dHVyZTJEfShYLFRleENvb3JkcykucjtcXG4gICAgICAke2kub3V0cHV0fSA9IGVuY29kZUFzVWludDgodmFsdWUpO1xcbiAgICB9YCxhPXtuYW1lOlwiVWludDhFbmNvZGVcIixpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnVucGFja2VkXSxpbnB1dE5hbWVzOltcIlhcIl0sb3V0cHV0OntkaW1zOm4sdHlwZTp0LnRlbnNvci50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUuZG93bmxvYWRVaW50OEFzRmxvYXR9LHNoYWRlclNvdXJjZTpzLGhhc01haW46ITB9O3JldHVybiBlLmV4ZWN1dGVQcm9ncmFtKGEsW3QudGVuc29yXSl9fSw5MDg3OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnRhbmg9dC50YW49dC5zcXJ0PXQuc2luPXQuc2lnbW9pZD10LnJlbHU9dC5ub3Q9dC5uZWc9dC5sb2c9dC5wYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXM9dC5sZWFreVJlbHU9dC5pZGVudGl0eT10LmZsb29yPXQuZXhwPXQucGFyc2VFbHVBdHRyaWJ1dGVzPXQuZWx1PXQuY29zPXQuY2VpbD10LmNsaXBWMTE9dC5wYXJzZUNsaXBBdHRyaWJ1dGVzPXQuY2xpcD10LmF0YW49dC5hc2luPXQuYWNvcz10LmFicz10Lmdsc2xUYW5oPXQuZ2xzbFRhbj10Lmdsc2xTcXJ0PXQuZ2xzbFNpZ21vaWQ9dC5nbHNsUmVsdT10Lmdsc2xTaW49dC5nbHNsTm90PXQuZ2xzbE5lZz10Lmdsc2xMb2c9dC5nbHNsTGVha3lSZWx1PXQuZ2xzbElkZW50aXR5PXQuZ2xzbENsaXA9dC5nbHNsRmxvb3I9dC5nbHNsRXhwPXQuZ2xzbEVsdT10Lmdsc2xDb3M9dC5nbHNsQ2VpbD10Lmdsc2xBdGFuPXQuZ2xzbEFzaW49dC5nbHNsQWNvcz10Lmdsc2xBYnM9dm9pZCAwO2NvbnN0IHI9big0OTEwKSxvPW4oNzI3MyksaT1uKDE5OTcpLHM9big2NzU3KSxhPW4oNTYzOSk7ZnVuY3Rpb24gdSgpe3JldHVybiBFKFwiYWJzXCIpfWZ1bmN0aW9uIGwoKXtyZXR1cm4gRShcImFjb3NcIil9ZnVuY3Rpb24gYygpe3JldHVybiBFKFwiYXNpblwiKX1mdW5jdGlvbiBwKCl7cmV0dXJuIEUoXCJhdGFuXCIpfWZ1bmN0aW9uIGQoKXtyZXR1cm4gRShcImNlaWxcIil9ZnVuY3Rpb24gZigpe3JldHVybiBFKFwiY29zXCIpfWZ1bmN0aW9uIGgoZSl7Y29uc3QgdD1cImVsdVwiO3JldHVybntib2R5OmBcXG4gIGNvbnN0IGZsb2F0IGFscGhhID0gZmxvYXQoJHtlfSk7XFxuXFxuICBmbG9hdCAke3R9XyhmbG9hdCBhKSB7XFxuICAgIHJldHVybiBhID49IDAuMCA/IGE6IChleHAoYSkgLSAxLjApICogYWxwaGE7XFxuICB9XFxuICB2ZWM0ICR7dH1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gdmVjNCgke3R9Xyh2LngpLCAke3R9Xyh2LnkpLCAke3R9Xyh2LnopLCAke3R9Xyh2LncpKTtcXG4gIH1cXG4gIGAsbmFtZTp0LHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gZygpe3JldHVybiBFKFwiZXhwXCIpfWZ1bmN0aW9uIGIoKXtyZXR1cm4gRShcImZsb29yXCIpfWZ1bmN0aW9uIG0oZSx0KXtjb25zdCBuPVwiY2xpcFwiO3JldHVybntib2R5OmBcXG4gIGNvbnN0IGZsb2F0IG1pbiA9IGZsb2F0KCR7ZX0pO1xcbiAgY29uc3QgZmxvYXQgbWF4ID0gZmxvYXQoJHt0fSk7XFxuXFxuICBmbG9hdCAke259XyhmbG9hdCBhKSB7XFxuICAgIHJldHVybiBjbGFtcChhLCBtaW4sIG1heCk7XFxuICB9XFxuICB2ZWM0ICR7bn1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gY2xhbXAodiwgbWluLCBtYXgpO1xcbiAgfVxcbiAgYCxuYW1lOm4sdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiB5KCl7Y29uc3QgZT1cImluZGVudGl0eVwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGE7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gdjtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19ZnVuY3Rpb24gXyhlKXtjb25zdCB0PVwibGVha3lSZWx1XCI7cmV0dXJue2JvZHk6YFxcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke2V9KTtcXG5cXG4gIGZsb2F0ICR7dH1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYWxwaGEgOiBhO1xcbiAgfVxcbiAgdmVjNCAke3R9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIHZlYzQoJHt0fV8odi54KSwgJHt0fV8odi55KSwgJHt0fV8odi56KSwgJHt0fV8odi53KSk7XFxuICB9XFxuICBgLG5hbWU6dCx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHYoKXtyZXR1cm4gRShcImxvZ1wiKX1mdW5jdGlvbiBUKCl7Y29uc3QgZT1cIm5lZ1wiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIC1hO1xcbiAgfVxcbiAgdmVjNCAke2V9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIC12O1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiB4KCl7Y29uc3QgZT1cIm5vdFwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIGZsb2F0KCAhIGJvb2woYSkgKTtcXG4gIH1cXG4gIGJvb2wgJHtlfV8oYm9vbCBhKSB7XFxuICAgIHJldHVybiAhYTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiB2ZWM0KCFib29sKHYueCksICFib29sKHYueSksICFib29sKHYueiksICFib29sKHYudykpO1xcbiAgfVxcbiAgYnZlYzQgJHtlfV8oYnZlYzQgdikge1xcbiAgICByZXR1cm4gYnZlYzQoIXYueCwgIXYueSwgIXYueiwgIXYudyk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIHcoKXtyZXR1cm4gRShcInNpblwiKX1mdW5jdGlvbiBPKCl7Y29uc3QgZT1cInJlbHVcIjtyZXR1cm57Ym9keTpgXFxuICBmbG9hdCAke2V9XyhmbG9hdCBhKSB7XFxuICAgIHJldHVybiBtYXgoIGEsIDAuMCApO1xcbiAgfVxcbiAgdmVjNCAke2V9Xyh2ZWM0IHYpIHtcXG4gICAgcmV0dXJuIG1heCggdiwgMC4wICk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIFMoKXtjb25zdCBlPVwic2lnbW9pZFwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuIDEuMCAvICgxLjAgKyBleHAoLWEpKTtcXG4gIH1cXG4gIHZlYzQgJHtlfV8odmVjNCB2KSB7XFxuICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC12KSk7XFxuICB9XFxuICBgLG5hbWU6ZSx0eXBlOmkuRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9fWZ1bmN0aW9uIEEoKXtyZXR1cm4gRShcInNxcnRcIil9ZnVuY3Rpb24gUCgpe3JldHVybiBFKFwidGFuXCIpfWZ1bmN0aW9uIEkoKXtjb25zdCBlPVwidGFuaFwiO3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgYSA9IGNsYW1wKGEsIC0xMC4sIDEwLik7XFxuICAgIGEgPSBleHAoMi4qYSk7XFxuICAgIHJldHVybiAoYSAtIDEuKSAvIChhICsgMS4pO1xcbiAgfVxcbiAgdmVjNCAke2V9Xyh2ZWM0IHYpIHtcXG4gICAgdiA9IGNsYW1wKHYsIC0xMC4sIDEwLik7XFxuICAgIHYgPSBleHAoMi4qdik7XFxuICAgIHJldHVybiAodiAtIDEuKSAvICh2ICsgMS4pO1xcbiAgfVxcbiAgYCxuYW1lOmUsdHlwZTppLkZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfX1mdW5jdGlvbiBFKGUpe3JldHVybntib2R5OmBcXG4gIGZsb2F0ICR7ZX1fKGZsb2F0IGEpIHtcXG4gICAgcmV0dXJuICR7ZX0oYSk7XFxuICB9XFxuICB2ZWM0ICR7ZX1fKHZlYzQgdikge1xcbiAgICByZXR1cm4gJHtlfSh2KTtcXG4gIH1cXG4gIGAsbmFtZTplLHR5cGU6aS5GdW5jdGlvblR5cGUuVmFsdWVCYXNlZH19dC5nbHNsQWJzPXUsdC5nbHNsQWNvcz1sLHQuZ2xzbEFzaW49Yyx0Lmdsc2xBdGFuPXAsdC5nbHNsQ2VpbD1kLHQuZ2xzbENvcz1mLHQuZ2xzbEVsdT1oLHQuZ2xzbEV4cD1nLHQuZ2xzbEZsb29yPWIsdC5nbHNsQ2xpcD1tLHQuZ2xzbElkZW50aXR5PXksdC5nbHNsTGVha3lSZWx1PV8sdC5nbHNsTG9nPXYsdC5nbHNsTmVnPVQsdC5nbHNsTm90PXgsdC5nbHNsU2luPXcsdC5nbHNsUmVsdT1PLHQuZ2xzbFNpZ21vaWQ9Uyx0Lmdsc2xTcXJ0PUEsdC5nbHNsVGFuPVAsdC5nbHNsVGFuaD1JO2NvbnN0IEQ9KGUsdCxuLHIpPT57Y29uc3Qgbz1lLnNlc3Npb24ucGFjaz9hLlRleHR1cmVUeXBlLnBhY2tlZDphLlRleHR1cmVUeXBlLnVucGFja2VkLGk9e25hbWU6bi5uYW1lLGlucHV0VHlwZXM6W29dLGlucHV0TmFtZXM6W1wiQVwiXSxjYWNoZUhpbnQ6cn07cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxpKSx7Z2V0OigpPT4oKGUsdCxuLHIpPT57Y29uc3Qgbz1lLnNlc3Npb24ucGFjaz9hLlRleHR1cmVUeXBlLnBhY2tlZDphLlRleHR1cmVUeXBlLnVucGFja2VkLGk9KDAscy5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx0KSx7b3V0cHV0OntkaW1zOm4uZGltcyx0eXBlOm4udHlwZSx0ZXh0dXJlVHlwZTpvfSxzaGFkZXJTb3VyY2U6YFxcbiAgICAgJHtyLmJvZHl9XFxuICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgIHZlYzQgdiA9ICR7aS50ZXh0dXJlMkR9KEEsIFRleENvb3Jkcyk7XFxuICAgICAgIHYgPSAke3IubmFtZX1fKHYpO1xcbiAgICAgICAke2kub3V0cHV0fSA9IHY7XFxuICAgICB9XFxuICAgICBgLGhhc01haW46ITB9KX0pKGUsaSx0LG4pfSl9O3QuYWJzPShlLHQpPT5bZS5ydW4oRChlLHRbMF0sdSgpKSx0KV0sdC5hY29zPShlLHQpPT5bZS5ydW4oRChlLHRbMF0sbCgpKSx0KV0sdC5hc2luPShlLHQpPT5bZS5ydW4oRChlLHRbMF0sYygpKSx0KV0sdC5hdGFuPShlLHQpPT5bZS5ydW4oRChlLHRbMF0scCgpKSx0KV0sdC5jbGlwPShlLHQsbik9PltlLnJ1bihEKGUsdFswXSxtKG4ubWluLG4ubWF4KSxuLmNhY2hlS2V5KSx0KV0sdC5wYXJzZUNsaXBBdHRyaWJ1dGVzPWU9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7bWluOmUuYXR0cmlidXRlcy5nZXRGbG9hdChcIm1pblwiLG8uTUlOX0NMSVApLG1heDplLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJtYXhcIixvLk1BWF9DTElQKX0pLHQuY2xpcFYxMT0oZSxuKT0+e2NvbnN0IHI9JChlLG4pO3JldHVybigwLHQuY2xpcCkoZSxbblswXV0scil9O2NvbnN0ICQ9KGUsdCk9PntpZih0Lmxlbmd0aD49MyYmKCFlLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzFdLmRhdGFJZCl8fCFlLnNlc3Npb24uaXNJbml0aWFsaXplcih0WzJdLmRhdGFJZCkpKXRocm93IG5ldyBFcnJvcihcImR5bmFtaWMgY2xpcCBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZFwiKTtjb25zdCBuPXQubGVuZ3RoPj0zP3RbMV0ubnVtYmVyRGF0YVswXTpvLk1JTl9DTElQLGk9dC5sZW5ndGg+PTM/dFsyXS5udW1iZXJEYXRhWzBdOm8uTUFYX0NMSVA7cmV0dXJuKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHttaW46bixtYXg6aX0pfTt0LmNlaWw9KGUsdCk9PltlLnJ1bihEKGUsdFswXSxkKCkpLHQpXSx0LmNvcz0oZSx0KT0+W2UucnVuKEQoZSx0WzBdLGYoKSksdCldLHQuZWx1PShlLHQsbik9PltlLnJ1bihEKGUsdFswXSxoKG4uYWxwaGEpLG4uY2FjaGVLZXkpLHQpXSx0LnBhcnNlRWx1QXR0cmlidXRlcz1lPT4oMCxyLmNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSkoe2FscGhhOmUuYXR0cmlidXRlcy5nZXRGbG9hdChcImFscGhhXCIsMSl9KSx0LmV4cD0oZSx0KT0+W2UucnVuKEQoZSx0WzBdLGcoKSksdCldLHQuZmxvb3I9KGUsdCk9PltlLnJ1bihEKGUsdFswXSxiKCkpLHQpXSx0LmlkZW50aXR5PShlLHQpPT5bZS5ydW4oRChlLHRbMF0seSgpKSx0KV0sdC5sZWFreVJlbHU9KGUsdCxuKT0+W2UucnVuKEQoZSx0WzBdLF8obi5hbHBoYSksbi5jYWNoZUtleSksdCldLHQucGFyc2VMZWFreVJlbHVBdHRyaWJ1dGVzPWU9PigwLHIuY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KSh7YWxwaGE6ZS5hdHRyaWJ1dGVzLmdldEZsb2F0KFwiYWxwaGFcIiwuMDEpfSksdC5sb2c9KGUsdCk9PltlLnJ1bihEKGUsdFswXSx2KCkpLHQpXSx0Lm5lZz0oZSx0KT0+W2UucnVuKEQoZSx0WzBdLFQoKSksdCldLHQubm90PShlLHQpPT5bZS5ydW4oRChlLHRbMF0seCgpKSx0KV0sdC5yZWx1PShlLHQpPT5bZS5ydW4oRChlLHRbMF0sTygpKSx0KV0sdC5zaWdtb2lkPShlLHQpPT5bZS5ydW4oRChlLHRbMF0sUygpKSx0KV0sdC5zaW49KGUsdCk9PltlLnJ1bihEKGUsdFswXSx3KCkpLHQpXSx0LnNxcnQ9KGUsdCk9PltlLnJ1bihEKGUsdFswXSxBKCkpLHQpXSx0LnRhbj0oZSx0KT0+W2UucnVuKEQoZSx0WzBdLFAoKSksdCldLHQudGFuaD0oZSx0KT0+W2UucnVuKEQoZSx0WzBdLEkoKSksdCldfSw1NDA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXI9dC5jcmVhdGVVbnBhY2tQcm9ncmFtSW5mbz12b2lkIDA7Y29uc3Qgcj1uKDY3NTcpLG89big1NjM5KSxpPW4oNDMyKSxzPW4oNTYxNCksYT17bmFtZTpcInVucGFja1wiLGlucHV0TmFtZXM6W1wiQVwiXSxpbnB1dFR5cGVzOltvLlRleHR1cmVUeXBlLnBhY2tlZF19O3QuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm89KGUsdCk9Pntjb25zdCBuPXQuZGltcy5sZW5ndGgsdT0oMCxzLmdldENoYW5uZWxzKShcInJjXCIsbiksbD11LnNsaWNlKC0yKSxjPSgwLGkuZ2V0Q29vcmRzRGF0YVR5cGUpKG4pLHA9KDAscy51bnBhY2tGcm9tQ2hhbm5lbCkoKSxkPTA9PT10LmRpbXMubGVuZ3RoP1wiXCI6ZnVuY3Rpb24oZSx0KXtpZigxPT09ZSlyZXR1cm5cInJjXCI7bGV0IG49XCJcIjtmb3IobGV0IHI9MDtyPGU7cisrKW4rPXRbcl0scjxlLTEmJihuKz1cIixcIik7cmV0dXJuIG59KG4sdSksZj1uPD0xP1wicmNcIjpgdmVjMigke2wuam9pbihcIixcIil9KWAsaD1gXFxuICAgICR7cH1cXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgICR7Y30gcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG5cXG4gICAgICAgLy8gU2FtcGxlIHRoZSB0ZXh0dXJlIHdpdGggdGhlIGNvb3JkcyB0byBnZXQgdGhlIHJnYmEgY2hhbm5lbCB2YWx1ZS5cXG4gICAgICAgdmVjNCBwYWNrZWRJbnB1dCA9IGdldEEoJHtkfSk7XFxuXFxuICAgICAgICR7KDAsci5nZXRHbHNsKShlLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbikub3V0cHV0fSA9IHZlYzQoZ2V0Q2hhbm5lbChwYWNrZWRJbnB1dCwgJHtmfSksIDAsIDAsIDApO1xcbiAgICAgfVxcbiAgIGA7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7aGFzTWFpbjohMCxvdXRwdXQ6e2RpbXM6dC5kaW1zLHR5cGU6dC50eXBlLHRleHR1cmVUeXBlOm8uVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTpofSl9LHQuY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXI9KGUsbik9Pk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxhKSx7Z2V0OigpPT4oMCx0LmNyZWF0ZVVucGFja1Byb2dyYW1JbmZvKShlLG4pfSl9LDc4NjI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQucGFyc2VVbnNxdWVlemVBdHRyaWJ1dGVzPXQudW5zcXVlZXplVjEzPXQudW5zcXVlZXplPXZvaWQgMDtjb25zdCByPW4oNzI3Myk7dC51bnNxdWVlemU9KGUsdCxuKT0+e28odCk7Y29uc3QgaT1yLlNoYXBlVXRpbC51bnNxdWVlemVTaGFwZSh0WzBdLmRpbXMsbik7cmV0dXJuW2UucmVzaGFwZVVucGFja2VkKHRbMF0saSldfSx0LnVuc3F1ZWV6ZVYxMz0oZSxuKT0+KGkobiksKDAsdC51bnNxdWVlemUpKGUsW25bMF1dLEFycmF5LmZyb20oblsxXS5pbnRlZ2VyRGF0YSkpKSx0LnBhcnNlVW5zcXVlZXplQXR0cmlidXRlcz1lPT5lLmF0dHJpYnV0ZXMuZ2V0SW50cyhcImF4ZXNcIik7Y29uc3Qgbz1lPT57aWYoIWV8fDEhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJVbnNxdWVlemUgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoXCJzdHJpbmdcIj09PWVbMF0udHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy5cIil9LGk9ZT0+e2lmKCFlfHwyIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVW5zcXVlZXplIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihcImludDMyXCIhPT1lWzFdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX19LDM5ODA6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuc2NhbGVzVmFsaWRhdGlvbj10LnZhbGlkYXRlSW5wdXRzPXQucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXM9dC5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5PXQucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWNz10LnVwc2FtcGxlPXZvaWQgMDtjb25zdCByPW4oNDkxMCksbz1uKDY3NTcpLGk9big1NjM5KSxzPXtuYW1lOlwiVXBzYW1wbGVcIixpbnB1dE5hbWVzOltcIlhcIl0saW5wdXRUeXBlczpbaS5UZXh0dXJlVHlwZS51bnBhY2tlZF19O3QudXBzYW1wbGU9KGUsbixyKT0+KCgwLHQudmFsaWRhdGVJbnB1dHMpKG4sciksW2UucnVuKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7Y2FjaGVIaW50OnIuY2FjaGVLZXksZ2V0OigpPT5hKGUsbixyKX0pLG4pXSksdC5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3PWU9PigwLHQucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKGUsNyksdC5wYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5PWU9PigwLHQucGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMpKGUsOSksdC5wYXJzZVVwc2FtcGxlQXR0cmlidXRlcz0oZSxuKT0+e2NvbnN0IG89bj49MTAsaT1lLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKFwibW9kZVwiLFwibmVhcmVzdFwiKTtpZihcIm5lYXJlc3RcIiE9PWkmJlwibGluZWFyXCIhPT1pJiYobjwxMXx8XCJjdWJpY1wiIT09aSkpdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHtpfWApO2xldCBzPVtdO248OSYmKHM9ZS5hdHRyaWJ1dGVzLmdldEZsb2F0cyhcInNjYWxlc1wiKSwoMCx0LnNjYWxlc1ZhbGlkYXRpb24pKHMsaSxvKSk7Y29uc3QgYT1lLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJleHRyYXBvbGF0aW9uX3ZhbHVlXCIsMCksdT1uPjEwP2UuYXR0cmlidXRlcy5nZXRTdHJpbmcoXCJjb29yZGluYXRlX3RyYW5zZm9ybWF0aW9uX21vZGVcIixcImhhbGZfcGl4ZWxcIik6XCJhc3ltbWV0cmljXCI7aWYoLTE9PT1bXCJhc3ltbWV0cmljXCIsXCJweXRvcmNoX2hhbGZfcGl4ZWxcIixcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCIsXCJhbGlnbl9jb3JuZXJzXCIsXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixcImhhbGZfcGl4ZWxcIl0uaW5kZXhPZih1KSl0aHJvdyBuZXcgRXJyb3IoYGNvb3JkaW5hdGVfdHJhbnNmb3JtX21vZGUgJyR7dX0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBsPVwidGZfY3JvcF9hbmRfcmVzaXplXCI9PT11LGM9bCxwPVwibmVhcmVzdFwiPT09aSYmbj49MTE/ZS5hdHRyaWJ1dGVzLmdldFN0cmluZyhcIm5lYXJlc3RfbW9kZVwiLFwicm91bmRfcHJlZmVyX2Zsb29yXCIpOlwiXCI7aWYoLTE9PT1bXCJyb3VuZF9wcmVmZXJfZmxvb3JcIixcInJvdW5kX3ByZWZlcl9jZWlsXCIsXCJmbG9vclwiLFwiY2VpbFwiLFwiXCJdLmluZGV4T2YocCkpdGhyb3cgbmV3IEVycm9yKGBuZWFyZXN0X21vZGUgJyR7cH0nIGlzIG5vdCBzdXBwb3J0ZWRgKTtjb25zdCBkPWUuYXR0cmlidXRlcy5nZXRGbG9hdChcImN1YmljX2NvZWZmX2FcIiwtLjc1KSxmPTAhPT1lLmF0dHJpYnV0ZXMuZ2V0SW50KFwiZXhjbHVkZV9vdXRzaWRlXCIsMCk7aWYoZiYmXCJjdWJpY1wiIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJleGNsdWRlX291dHNpZGUgY2FuIGJlIHNldCB0byAxIG9ubHkgd2hlbiBtb2RlIGlzIENVQklDLlwiKTtjb25zdCBoPW48MTF8fFwibmVhcmVzdFwiPT09aSYmXCJhc3ltbWV0cmljXCI9PT11JiZcImZsb29yXCI9PT1wO2xldCBnPTAsYj0wLG09MDtyZXR1cm4gbj4xMD9lLmlucHV0cy5sZW5ndGg+Mj8oZz0xLGI9MixtPTMpOihiPTEsbT0yKTo5PT09biYmKGI9MSksKDAsci5jcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkpKHtvcHNldDpuLGlzUmVzaXplOm8sbW9kZTppLHNjYWxlczpzLGV4dHJhcG9sYXRpb25WYWx1ZTphLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOnUsdXNlRXh0cmFwb2xhdGlvbjpjLG5lZWRSb2lJbnB1dDpsLG5lYXJlc3RNb2RlOnAsY3ViaWNDb2VmZmljaWVudEE6ZCxleGNsdWRlT3V0c2lkZTpmLHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbjpoLHJvaUlucHV0SWR4Omcsc2NhbGVzSW5wdXRJZHg6YixzaXplc0lucHV0SWR4Om19KX07Y29uc3QgYT0oZSx0LG4pPT57Y29uc3Qgcj0oMCxvLmdldEdsc2wpKGUuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKSxbYSx1XT1lLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0WzBdLmRpbXMsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCksbD10WzBdLmRpbXMubWFwKCgoZSx0KT0+TWF0aC5mbG9vcihlKm4uc2NhbGVzW3RdKSkpLFtjLHBdPWUuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGwsaS5UZXh0dXJlVHlwZS51bnBhY2tlZCksZD1sLmxlbmd0aCxmPW5ldyBBcnJheShkKSxoPW5ldyBBcnJheShkKTtsZXQgZz1gXFxuICAgICAgaW50IG91dHB1dF9waXRjaGVzWyR7ZH1dO1xcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7ZH1dO1xcbiAgICAgIGA7Zm9yKGxldCBlPWQtMTtlPj0wO2UtLSlmW2VdPWU9PT1kLTE/MTpmW2UrMV0qbFtlKzFdLGhbZV09ZT09PWQtMT8xOmhbZSsxXSp0WzBdLmRpbXNbZSsxXSxnKz1gXFxuICAgICAgICBvdXRwdXRfcGl0Y2hlc1ske2V9XSA9ICR7ZltlXX07XFxuICAgICAgICBpbnB1dF9waXRjaGVzWyR7ZX1dID0gJHtoW2VdfTtcXG4gICAgICAgIGA7Y29uc3QgYj1gXFxuICAgICAgZmxvYXQgZ2V0SW5wdXRGbG9hdChpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMoaW5kZXgsICR7YX0sICR7dX0pO1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtyLnRleHR1cmUyRH0oWCwgY29vcmRzKSk7XFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgfVxcbiAgICAgIGAsbT1cIm5lYXJlc3RcIj09PW4ubW9kZT9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2R9XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtjfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBkLCBtO1xcbiAgICAgIGZvciAoaW50IGRpbSA9IDA7IGRpbSA8ICR7ZH07ICsrZGltKSB7XFxuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBkICogb3V0cHV0X3BpdGNoZXNbZGltXTtcXG4gICAgICAgIG91dHB1dF9pbmRleCA9IG07XFxuXFxuICAgICAgICBpZiAoc2NhbGVzW2RpbV0gIT0gMSAmJiBkID4gMCkge1xcbiAgICAgICAgICBpbnQgZDIgPSBkIC8gc2NhbGVzW2RpbV07XFxuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcXG4gICAgICAgICAgZCA9IGQyO1xcbiAgICAgICAgfVxcbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xcbiAgICB9YDo0PT09ZD9gXFxuICAgICR7Yn1cXG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1s0XSkge1xcbiAgICAgIGludCBpbnB1dF9pbmRleCA9IDA7XFxuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtjfSwgJHtwfSk7XFxuXFxuICAgICAgJHtnfVxcblxcbiAgICAgIGludCBtO1xcbiAgICAgIGludCBpbmRleF9vZl9kaW0wLCBpbmRleF9vZl9kaW0xLCBpbmRleF9vZl9kaW0yLCBpbmRleF9vZl9kaW0zO1xcbiAgICAgIGluZGV4X29mX2RpbTAgPSBvdXRwdXRfaW5kZXggLyBvdXRwdXRfcGl0Y2hlc1swXTtcXG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2RpbTEgPSBtIC8gb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgbSA9IG0gLSBpbmRleF9vZl9kaW0xICogb3V0cHV0X3BpdGNoZXNbMV07XFxuICAgICAgaW5kZXhfb2ZfZGltMiA9IG0gLyBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBtID0gbSAtIGluZGV4X29mX2RpbTIgKiBvdXRwdXRfcGl0Y2hlc1syXTtcXG4gICAgICBpbmRleF9vZl9kaW0zID0gbTtcXG5cXG4gICAgICBpbnQgaW5kZXhfb2ZfaW5wdXRfZGltMiwgaW5kZXhfb2ZfaW5wdXRfZGltMywgeF9vZmZzZXQsIHlfb2Zmc2V0O1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTIgPSBpbmRleF9vZl9kaW0yIC8gc2NhbGVzWzJdO1xcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMiAtIGluZGV4X29mX2lucHV0X2RpbTIgKiBzY2FsZXNbMl07XFxuICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMyA9IGluZGV4X29mX2RpbTMgLyBzY2FsZXNbM107XFxuICAgICAgeF9vZmZzZXQgPSBpbmRleF9vZl9kaW0zIC0gaW5kZXhfb2ZfaW5wdXRfZGltMyAqIHNjYWxlc1szXTtcXG5cXG4gICAgICBpbnB1dF9pbmRleCA9IGluZGV4X29mX2RpbTAgKiBpbnB1dF9waXRjaGVzWzBdICtcXG4gICAgICAgICAgICBpbmRleF9vZl9kaW0xICogaW5wdXRfcGl0Y2hlc1sxXSArXFxuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiAqIGlucHV0X3BpdGNoZXNbMl0gK1xcbiAgICAgICAgICAgIGluZGV4X29mX2lucHV0X2RpbTM7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0yID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTIgPT0gKCR7dFswXS5kaW1zWzJdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDJcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0yID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMl0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMyA9PSAoaW5wdXRfcGl0Y2hlc1syXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDNcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMiA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzJdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1szXSk7XFxuICAgIH1gOmBcXG4gICAgJHtifVxcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzJdKSB7XFxuICAgICAgaW50IGlucHV0X2luZGV4ID0gMDtcXG4gICAgICBpbnQgb3V0cHV0X2luZGV4ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke2N9LCAke3B9KTtcXG5cXG4gICAgICAke2d9XFxuXFxuICAgICAgaW50IG07XFxuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XFxuICAgICAgaW5kZXhfb2ZfZGltMCA9IG91dHB1dF9pbmRleCAvIG91dHB1dF9waXRjaGVzWzBdO1xcbiAgICAgIG0gPSBvdXRwdXRfaW5kZXggLSBpbmRleF9vZl9kaW0wICogb3V0cHV0X3BpdGNoZXNbMF07XFxuICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XFxuXFxuICAgICAgaW50IGluZGV4X29mX2lucHV0X2RpbTAsIGluZGV4X29mX2lucHV0X2RpbTEsIHhfb2Zmc2V0LCB5X29mZnNldDtcXG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcXG4gICAgICB5X29mZnNldCA9IGluZGV4X29mX2RpbTAgLSBpbmRleF9vZl9pbnB1dF9kaW0wICogc2NhbGVzWzBdO1xcbiAgICAgIGluZGV4X29mX2lucHV0X2RpbTEgPSBpbmRleF9vZl9kaW0xIC8gc2NhbGVzWzFdO1xcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XFxuXFxuICAgICAgaW5wdXRfaW5kZXggPSBpbmRleF9vZl9pbnB1dF9kaW0wICogaW5wdXRfcGl0Y2hlc1swXSArIGluZGV4X29mX2lucHV0X2RpbTE7XFxuXFxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XFxuICAgICAgZmxvYXQgeDEwLCB4MDEsIHgxMTtcXG5cXG4gICAgICBib29sIGVuZF9vZl9kaW0wID0gZmFsc2U7XFxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTAgPT0gKCR7dFswXS5kaW1zWzBdfSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDBcXG4gICAgICAgIHgwMSA9IHgwMDtcXG4gICAgICAgIGVuZF9vZl9kaW0wID0gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgeDAxID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIGlucHV0X3BpdGNoZXNbMF0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMSA9PSAoaW5wdXRfcGl0Y2hlc1swXSAtIDEpKSB7XFxuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDFcXG4gICAgICAgIHgxMCA9IHgwMDtcXG4gICAgICAgIHgxMSA9IHgwMTtcXG4gICAgICB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB4MTAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgMSk7XFxuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMCA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdICsgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xcbiAgICAgIHJldHVybiB5MCArIGZsb2F0KHhfb2Zmc2V0KSAqICh5MSAtIHkwKSAvIGZsb2F0KHNjYWxlc1sxXSk7XFxuICAgIH1gO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse291dHB1dDp7ZGltczpsLHR5cGU6dFswXS50eXBlLHRleHR1cmVUeXBlOmkuVGV4dHVyZVR5cGUudW5wYWNrZWR9LHNoYWRlclNvdXJjZTptLHZhcmlhYmxlczpbe25hbWU6XCJzY2FsZXNcIix0eXBlOlwiaW50XCIsYXJyYXlMZW5ndGg6bi5zY2FsZXMubGVuZ3RoLGRhdGE6bi5zY2FsZXMubWFwKChlPT5NYXRoLmNlaWwoZSkpKX1dfSl9O3QudmFsaWRhdGVJbnB1dHM9KGUsdCk9PntpZighZXx8dC5vcHNldDw5JiYxIT09ZS5sZW5ndGh8fHQub3BzZXQ+PTkmJnQub3BzZXQ8MTEmJjIhPT1lLmxlbmd0aHx8dC5vcHNldD49MTEmJmUubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dHMuXCIpO2lmKHQuc2NhbGVzLmxlbmd0aD4wJiZlWzBdLmRpbXMubGVuZ3RoIT09dC5zY2FsZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUuXCIpO2lmKFwic3RyaW5nXCI9PT1lWzBdLnR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuXCIpfSx0LnNjYWxlc1ZhbGlkYXRpb249KGUsdCxuKT0+e2lmKG4pe2Zvcihjb25zdCB0IG9mIGUpaWYodDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIDAuXCIpfWVsc2UgZm9yKGNvbnN0IHQgb2YgZSlpZih0PDEpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGUgdmFsdWUgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLlwiKTtpZighKFwibGluZWFyXCIhPT10JiZcImN1YmljXCIhPT10fHwyPT09ZS5sZW5ndGh8fDQ9PT1lLmxlbmd0aCYmMT09PWVbMF0mJjE9PT1lWzFdKSl0aHJvdyBuZXcgRXJyb3IoYCdMaW5lYXInIG1vZGUgYW5kICdDdWJpYycgbW9kZSBvbmx5IHN1cHBvcnQgMi1EIGlucHV0cyAoJ0JpbGluZWFyJywgJ0JpY3ViaWMnKSAgICAgICAgIG9yIDQtRCBpbnB1dHMgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvdXRlcm1vc3QgMiBzY2FsZSB2YWx1ZXMgYmVpbmcgMSAgICAgICAgIGluIHRoZSAke24/XCJSZXNpemVcIjpcIlVwc2FtcGxlXCJ9IG9wZWFydG9yLmApfX0sMjc1NzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Qcm9ncmFtTWFuYWdlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMDcpLG89bigxMzE1KSxpPW4oODg5Nykscz1uKDY3NTcpO3QuUHJvZ3JhbU1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMucHJvZmlsZXI9ZSx0aGlzLmdsQ29udGV4dD10LHRoaXMudGV4dHVyZUxheW91dFN0cmF0ZWd5PW4sdGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QoZSl7cmV0dXJuIHRoaXMucmVwby5nZXQoZSl9c2V0QXJ0aWZhY3QoZSx0KXt0aGlzLnJlcG8uc2V0KGUsdCl9cnVuKGUsdCxuKXt2YXIgcjt0aGlzLnByb2ZpbGVyLmV2ZW50KFwib3BcIixgUHJvZ3JhbU1hbmFnZXIucnVuICR7bnVsbCE9PShyPWUucHJvZ3JhbUluZm8ubmFtZSkmJnZvaWQgMCE9PXI/cjpcInVua25vd24ga2VybmVsXCJ9YCwoKCk9Pnt2YXIgcjtjb25zdCBpPXRoaXMuZ2xDb250ZXh0LmdsLHM9ZS5wcm9ncmFtO2kudXNlUHJvZ3JhbShzKTt0cnl7dGhpcy5iaW5kT3V0cHV0KG4pLHRoaXMuYXR0cmlidXRlc0JvdW5kfHx0aGlzLmJpbmRBdHRyaWJ1dGVzKGUuYXR0cmliTG9jYXRpb25zKSx0aGlzLmJpbmRVbmlmb3JtcyhlLnVuaWZvcm1Mb2NhdGlvbnMsbnVsbCE9PShyPWUucHJvZ3JhbUluZm8udmFyaWFibGVzKSYmdm9pZCAwIT09cj9yOltdLHQpfWNhdGNoKHQpe3Rocm93IG8uTG9nZ2VyLmVycm9yKFwiUHJvZ3JhbU1hbmFnZXJcIixlLnByb2dyYW1JbmZvLnNoYWRlclNvdXJjZSksdH10aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiR2xDb250ZXh0LmRyYXcoKVwiLCgoKT0+e3RoaXMuZ2xDb250ZXh0LmRyYXcoKX0pKX0pLHRoaXMuZ2xDb250ZXh0KX1kaXNwb3NlKCl7dGhpcy52ZXJ0ZXhTaGFkZXImJnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlciksdGhpcy5yZXBvLmZvckVhY2goKGU9PnRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0oZS5wcm9ncmFtKSkpfWJ1aWxkKGUsdCxuKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlByb2dyYW1NYW5hZ2VyLmJ1aWxkXCIsKCgpPT57Y29uc3Qgcj1uZXcgaS5HbHNsUHJlcHJvY2Vzc29yKHRoaXMuZ2xDb250ZXh0LGUsdCxuKSxvPXIucHJlcHJvY2VzcygpLHM9dGhpcy5jb21waWxlKG8pO3JldHVybntwcm9ncmFtSW5mbzplLHByb2dyYW06cyx1bmlmb3JtTG9jYXRpb25zOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhzLHIuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLHIuY29udGV4dC5wcm9ncmFtSW5mby52YXJpYWJsZXMpLGF0dHJpYkxvY2F0aW9uczp0aGlzLmdldEF0dHJpYkxvY2F0aW9ucyhzKX19KSl9Y29tcGlsZShlKXtpZighdGhpcy52ZXJ0ZXhTaGFkZXIpe28uTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixcIkNvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZVwiKTtjb25zdCBlPSgwLHMuZ2V0VmVydGV4U2hhZGVyU291cmNlKSh0aGlzLmdsQ29udGV4dC52ZXJzaW9uKTt0aGlzLnZlcnRleFNoYWRlcj10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKGUsdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUil9ci5lbnYuZGVidWcmJm8uTG9nZ2VyLnZlcmJvc2UoXCJQcm9yZ3JhbU1hbmFnZXJcIixgRnJhZ1NoYWRlcjpcXG4ke2V9XFxuYCk7Y29uc3QgdD10aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKGUsdGhpcy5nbENvbnRleHQuZ2wuRlJBR01FTlRfU0hBREVSKSxuPXRoaXMuZ2xDb250ZXh0LmNyZWF0ZVByb2dyYW0odGhpcy52ZXJ0ZXhTaGFkZXIsdCk7cmV0dXJuIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0KSxufWJpbmRPdXRwdXQoZSl7Y29uc3QgdD1lLndpZHRoLG49ZS5oZWlnaHQ7by5Mb2dnZXIudmVyYm9zZShcIlByb3JncmFtTWFuYWdlclwiLGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHt0fS8ke259LCBzaGFwZT0ke2Uuc2hhcGV9LCB0eXBlPSR7ZS50ZW5zb3IudHlwZX1gKSx0aGlzLmdsQ29udGV4dC5hdHRhY2hGcmFtZWJ1ZmZlcihlLnRleHR1cmUsdCxuKX1iaW5kQXR0cmlidXRlcyhlKXtjb25zdCB0PWUucG9zaXRpb24sbj1lLnRleHR1cmVDb29yZDt0aGlzLmdsQ29udGV4dC5zZXRWZXJ0ZXhBdHRyaWJ1dGVzKHQsbiksdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITB9YmluZFVuaWZvcm1zKGUsdCxuKXt2YXIgcjtjb25zdCBvPXRoaXMuZ2xDb250ZXh0LmdsO2xldCBpPTA7Zm9yKGNvbnN0e25hbWU6cyx0eXBlOmEsbG9jYXRpb246dSxhcnJheUxlbmd0aDpsfW9mIGUpe2NvbnN0IGU9bnVsbD09PShyPXQuZmluZCgoZT0+ZS5uYW1lPT09cykpKXx8dm9pZCAwPT09cj92b2lkIDA6ci5kYXRhO2lmKFwic2FtcGxlcjJEXCIhPT1hJiYhZSl0aHJvdyBuZXcgRXJyb3IoYHZhcmlhYmxlICcke3N9JyBkb2VzIG5vdCBoYXZlIGRhdGEgZGVmaW5lZCBpbiBwcm9ncmFtIGluZm9gKTtzd2l0Y2goYSl7Y2FzZVwic2FtcGxlcjJEXCI6dGhpcy5iaW5kVGV4dHVyZShuW2ldLHUsaSksaSsrO2JyZWFrO2Nhc2VcImZsb2F0XCI6bD9vLnVuaWZvcm0xZnYodSxlKTpvLnVuaWZvcm0xZih1LGUpO2JyZWFrO2Nhc2VcImludFwiOmw/by51bmlmb3JtMWl2KHUsZSk6by51bmlmb3JtMWkodSxlKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5pZm9ybSBub3QgaW1wbGVtZW50ZWQ6ICR7YX1gKX19fWJpbmRUZXh0dXJlKGUsdCxuKXt0aGlzLmdsQ29udGV4dC5iaW5kVGV4dHVyZVRvVW5pZm9ybShlLnRleHR1cmUsbix0KX1nZXRBdHRyaWJMb2NhdGlvbnMoZSl7cmV0dXJue3Bvc2l0aW9uOnRoaXMuZ2V0QXR0cmliTG9jYXRpb24oZSxcInBvc2l0aW9uXCIpLHRleHR1cmVDb29yZDp0aGlzLmdldEF0dHJpYkxvY2F0aW9uKGUsXCJ0ZXh0dXJlQ29vcmRcIil9fWdldFVuaWZvcm1Mb2NhdGlvbnMoZSx0LG4pe2NvbnN0IHI9W107aWYodClmb3IoY29uc3QgbiBvZiB0KXIucHVzaCh7bmFtZTpuLHR5cGU6XCJzYW1wbGVyMkRcIixsb2NhdGlvbjp0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbihlLG4pfSk7aWYobilmb3IoY29uc3QgdCBvZiBuKXIucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse2xvY2F0aW9uOnRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKGUsdC5uYW1lKX0pKTtyZXR1cm4gcn1nZXRVbmlmb3JtTG9jYXRpb24oZSx0KXtjb25zdCBuPXRoaXMuZ2xDb250ZXh0LmdsLmdldFVuaWZvcm1Mb2NhdGlvbihlLHQpO2lmKG51bGw9PT1uKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSAke3R9IG5vdCBmb3VuZC5gKTtyZXR1cm4gbn1nZXRBdHRyaWJMb2NhdGlvbihlLHQpe3JldHVybiB0aGlzLmdsQ29udGV4dC5nbC5nZXRBdHRyaWJMb2NhdGlvbihlLHQpfX19LDIxNzE6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuV2ViR0xTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDEzMTUpLG89big1ODgxKSxpPW4oNzg2MCkscz1uKDQxMTApLGE9bigyNzU3KSx1PW4oNzYxOCksbD1uKDUyNDMpO3QuV2ViR0xTZXNzaW9uSGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuYmFja2VuZD1lLHRoaXMuY29udGV4dD10LHRoaXMubGF5b3V0U3RyYXRlZ3k9bmV3IHUuUHJlZmVyTG9naWNhbFN0cmF0ZWd5KGUuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBhLlByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlcixlLmdsQ29udGV4dCx0aGlzLmxheW91dFN0cmF0ZWd5KSx0aGlzLnRleHR1cmVNYW5hZ2VyPW5ldyBsLlRleHR1cmVNYW5hZ2VyKGUuZ2xDb250ZXh0LHRoaXMubGF5b3V0U3RyYXRlZ3ksdGhpcy5jb250ZXh0LnByb2ZpbGVyLHtyZXVzZVRleHR1cmVzOlwiZnVsbFwiPT09ZS50ZXh0dXJlQ2FjaGVNb2RlfSksdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlPW5ldyBNYXAsdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGU9bmV3IE1hcCx0aGlzLnBhY2s9ZS5wYWNrLHRoaXMucGFjazJ1bnBhY2tNYXA9bmV3IE1hcCx0aGlzLnVucGFjazJwYWNrTWFwPW5ldyBNYXB9Y3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpe3JldHVybiBuZXcgaS5XZWJHTEluZmVyZW5jZUhhbmRsZXIodGhpcyl9b25HcmFwaEluaXRpYWxpemVkKGUpe2NvbnN0IHQ9ZS5nZXRWYWx1ZXMoKS5maWx0ZXIoKGU9Pi0xPT09ZS5mcm9tJiZlLnRlbnNvcikpLm1hcCgoZT0+ZS50ZW5zb3IuZGF0YUlkKSk7dGhpcy5pbml0aWFsaXplcnM9bmV3IFNldCh0KX1pc0luaXRpYWxpemVyKGUpe3JldHVybiEhdGhpcy5pbml0aWFsaXplcnMmJnRoaXMuaW5pdGlhbGl6ZXJzLmhhcyhlKX1hZGRJbml0aWFsaXplcihlKXt0aGlzLmluaXRpYWxpemVycy5hZGQoZSl9Z2V0VGV4dHVyZURhdGEoZSx0KXtyZXR1cm4gdD90aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KGUpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldChlKX1zZXRUZXh0dXJlRGF0YShlLHQsbj0hMSl7ci5Mb2dnZXIudmVyYm9zZShcIldlYkdMU2Vzc2lvbkhhbmRsZXJcIixcIlN0b3JpbmcgVGV4dHVyZSBkYXRhIGluIGNhY2hlXCIpLG4/dGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldChlLHQpOnRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldChlLHQpfWRpc3Bvc2UoKXt0aGlzLnByb2dyYW1NYW5hZ2VyLmRpc3Bvc2UoKSx0aGlzLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKSx0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCgoZT0+dGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZShlLCEwKSkpLHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwLHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmZvckVhY2goKGU9PnRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUoZSwhMCkpKSx0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZT1uZXcgTWFwfXJlc29sdmUoZSx0LG4pe2NvbnN0IHI9KDAsby5yZXNvbHZlT3BlcmF0b3IpKGUsdCxzLldFQkdMX09QX1JFU09MVkVfUlVMRVMpO3JldHVybntpbXBsOnIub3BJbXBsLGNvbnRleHQ6ci5vcEluaXQ/ci5vcEluaXQoZSxuKTplfX19fSw5NjIyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlVpbnQ4RGF0YUVuY29kZXI9dC5SR0JBRmxvYXREYXRhRW5jb2Rlcj10LlJlZEZsb2F0MzJEYXRhRW5jb2Rlcj12b2lkIDA7Y29uc3Qgcj1uKDEzMTUpO3QuUmVkRmxvYXQzMkRhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKGUsdD0xKXtpZigxPT09dCl0aGlzLmludGVybmFsRm9ybWF0PWUuUjMyRix0aGlzLmZvcm1hdD1lLlJFRCx0aGlzLnRleHR1cmVUeXBlPWUuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT10O2Vsc2V7aWYoNCE9PXQpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHt0fWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9ZS5SR0JBMzJGLHRoaXMuZm9ybWF0PWUuUkdCQSx0aGlzLnRleHR1cmVUeXBlPWUuRkxPQVQsdGhpcy5jaGFubmVsU2l6ZT10fX1lbmNvZGUoZSx0KXtsZXQgbixvO3JldHVybiBlLmNvbnN0cnVjdG9yIT09RmxvYXQzMkFycmF5JiYoci5Mb2dnZXIud2FybmluZyhcIkVuY29kZXJcIixcImRhdGEgd2FzIG5vdCBvZiB0eXBlIEZsb2F0MzI7IGNyZWF0aW5nIG5ldyBGbG9hdDMyQXJyYXlcIiksbz1uZXcgRmxvYXQzMkFycmF5KGUpKSx0KnRoaXMuY2hhbm5lbFNpemU+ZS5sZW5ndGg/KHIuTG9nZ2VyLndhcm5pbmcoXCJFbmNvZGVyXCIsXCJTb3VyY2UgZGF0YSB0b28gc21hbGwuIEFsbG9jYXRpbmcgbGFyZ2VyIGFycmF5XCIpLG89ZSxuPXRoaXMuYWxsb2NhdGUodCp0aGlzLmNoYW5uZWxTaXplKSxvLmZvckVhY2goKChlLHQpPT5uW3RdPWUpKSk6KG89ZSxuPW8pLG59YWxsb2NhdGUoZSl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCplKX1kZWNvZGUoZSx0KXtyZXR1cm4gMT09PXRoaXMuY2hhbm5lbFNpemU/ZS5maWx0ZXIoKChlLHQpPT50JTQ9PTApKS5zdWJhcnJheSgwLHQpOmUuc3ViYXJyYXkoMCx0KX19LHQuUkdCQUZsb2F0RGF0YUVuY29kZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0PTEsbil7aWYoMSE9PXQmJjQhPT10KXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7dH1gKTt0aGlzLmludGVybmFsRm9ybWF0PWUuUkdCQSx0aGlzLmZvcm1hdD1lLlJHQkEsdGhpcy5jaGFubmVsU2l6ZT10LHRoaXMudGV4dHVyZVR5cGU9bnx8ZS5GTE9BVH1lbmNvZGUoZSx0KXtsZXQgbj1lO3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZSYmKHIuTG9nZ2VyLnZlcmJvc2UoXCJFbmNvZGVyXCIsXCJFeHBsb2RpbmcgaW50byBhIGxhcmdlciBhcnJheVwiKSxuPXRoaXMuYWxsb2NhdGUodCksZS5mb3JFYWNoKCgoZSx0KT0+bls0KnRdPWUpKSksbn1hbGxvY2F0ZShlKXtyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0KmUpfWRlY29kZShlLHQpe3JldHVybiAxPT09dGhpcy5jaGFubmVsU2l6ZT9lLmZpbHRlcigoKGUsdCk9PnQlND09MCkpLnN1YmFycmF5KDAsdCk6ZS5zdWJhcnJheSgwLHQpfX0sdC5VaW50OERhdGFFbmNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKGUsdD0xKXtpZih0aGlzLmNoYW5uZWxTaXplPTQsMT09PXQpdGhpcy5pbnRlcm5hbEZvcm1hdD1lLkFMUEhBLHRoaXMuZm9ybWF0PWUuQUxQSEEsdGhpcy50ZXh0dXJlVHlwZT1lLlVOU0lHTkVEX0JZVEUsdGhpcy5jaGFubmVsU2l6ZT10O2Vsc2V7aWYoNCE9PXQpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBjaGFubmVsczogJHt0fWApO3RoaXMuaW50ZXJuYWxGb3JtYXQ9ZS5SR0JBLHRoaXMuZm9ybWF0PWUuUkdCQSx0aGlzLnRleHR1cmVUeXBlPWUuVU5TSUdORURfQllURSx0aGlzLmNoYW5uZWxTaXplPXR9fWVuY29kZShlLHQpe3JldHVybiBuZXcgVWludDhBcnJheShlLmJ1ZmZlcixlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoKX1hbGxvY2F0ZShlKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZSp0aGlzLmNoYW5uZWxTaXplKX1kZWNvZGUoZSx0KXtpZihlIGluc3RhbmNlb2YgVWludDhBcnJheSlyZXR1cm4gZS5zdWJhcnJheSgwLHQpO3Rocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcnJheSB0eXBlOiAke2UuY29uc3RydWN0b3J9YCl9fX0sNzYxODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRCYXRjaERpbT10LnNpemVUb1NxdWFyaXNoU2hhcGU9dC5nZXRSb3dzQ29scz10LnNpemVGcm9tU2hhcGU9dC5pc0ludD10LnBhcnNlQXhpc1BhcmFtPXQuc3F1ZWV6ZVNoYXBlPXQuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PXQuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PXZvaWQgMDtjb25zdCByPW4oMTMxNSksbz1uKDcyNzMpO2Z1bmN0aW9uIGkoZSx0KXtjb25zdCBuPVtdLHI9W10sbz1udWxsIT10JiZBcnJheS5pc0FycmF5KHQpJiYwPT09dC5sZW5ndGgsaT1udWxsPT10fHxvP251bGw6cyh0LGUpLnNvcnQoKTtsZXQgYT0wO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtpZihudWxsIT1pKXtpZihpW2FdPT09dCYmMSE9PWVbdF0pdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzcXVlZXplIGF4aXMgJHt0fSBzaW5jZSBpdHMgZGltICcke2VbdF19JyBpcyBub3QgMWApOyhudWxsPT1pW2FdfHxpW2FdPnQpJiYxPT09ZVt0XSYmKG4ucHVzaChlW3RdKSxyLnB1c2godCkpLGlbYV08PXQmJmErK30xIT09ZVt0XSYmKG4ucHVzaChlW3RdKSxyLnB1c2godCkpfXJldHVybntuZXdTaGFwZTpuLGtlcHREaW1zOnJ9fWZ1bmN0aW9uIHMoZSx0KXtjb25zdCBuPXQubGVuZ3RoO3JldHVybiBlPW51bGw9PWU/dC5tYXAoKChlLHQpPT50KSk6W10uY29uY2F0KGUpLCgwLG8uYXNzZXJ0KShlLmV2ZXJ5KChlPT5lPj0tbiYmZTxuKSksKCgpPT5gQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy0ke259LCAke259KSBidXQgZ290IGF4aXMgJHtlfWApKSwoMCxvLmFzc2VydCkoZS5ldmVyeShhKSwoKCk9PmBBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgJHtlfWApKSxlLm1hcCgoZT0+ZTwwP24rZTplKSl9ZnVuY3Rpb24gYShlKXtyZXR1cm4gZSUxPT0wfWZ1bmN0aW9uIHUoZSl7aWYoMD09PWUubGVuZ3RoKXJldHVybiAxO2xldCB0PWVbMF07Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDtuKyspdCo9ZVtuXTtyZXR1cm4gdH1mdW5jdGlvbiBsKGUpe2NvbnN0IHQ9TWF0aC5jZWlsKE1hdGguc3FydChlKSk7cmV0dXJuW3QsTWF0aC5jZWlsKGUvdCldfXQuQWx3YXlzS2VlcE9yaWdpbmFsU2l6ZVN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMubWF4VGV4dHVyZVNpemU9ZX1jb21wdXRlVGV4dHVyZVdIKGUsdCl7aWYoMD09PWUubGVuZ3RoKXJldHVyblsxLDFdO2NvbnN0IG49dGhpcy5tYXhUZXh0dXJlU2l6ZTtpZih0JiZ2b2lkIDAhPT10LmJyZWFrQXhpcyl7Y29uc3Qgbz10LmJyZWFrQXhpcz49ZS5sZW5ndGg/MTplLnNsaWNlKHQuYnJlYWtBeGlzKS5yZWR1Y2UoKChlLHQpPT5lKnQpKSxpPXQuYnJlYWtBeGlzPD0wPzE6ZS5zbGljZSgwLHQuYnJlYWtBeGlzKS5yZWR1Y2UoKChlLHQpPT5lKnQpKTtpZighKG8+bnx8aT5uKSlyZXR1cm5bbyxpXTtyLkxvZ2dlci52ZXJib3NlKFwiVGV4dHVyZUxheW91dFwiLGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7ZX0sIGJyZWFrQXhpczoke3QuYnJlYWtBeGlzfWApfWNvbnN0IG89ZS5yZWR1Y2UoKChlLHQpPT5lKnQpKTtsZXQgaT1NYXRoLmZsb29yKE1hdGguc3FydChvKSk7Zm9yKDtpPG4mJmk8byYmbyVpIT0wO2krKyk7aWYoaT49bnx8byVpIT0wKXRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGRpbWVuc2lvbnMgYXJlIG91dHNpZGUgdGhpcyBHUFUncyBib3VuZGFyaWVzOiAke2V9YCk7cmV0dXJuW2ksby9pXX19LHQuUHJlZmVyTG9naWNhbFN0cmF0ZWd5PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMubWF4VGV4dHVyZVNpemU9ZX1jb21wdXRlVGV4dHVyZVdIKGUsdCl7Y29uc3Qgbj10aGlzLmNvbXB1dGVUZXh0dXJlKGUsdCk7cmV0dXJuIHQmJnQuaXNQYWNrZWQmJihuWzBdLz0yLG5bMV0vPTIpLHQmJnQucmV2ZXJzZVdIP1tuWzFdLG5bMF1dOm59Y29tcHV0ZVRleHR1cmUoZSx0KXtjb25zdCBuPXQmJnQuaXNQYWNrZWQ7aWYoMD09PWUubGVuZ3RoKXJldHVybiBuP1syLDJdOlsxLDFdO2xldCBvPXRoaXMubWF4VGV4dHVyZVNpemU7aWYodCYmdm9pZCAwIT09dC5icmVha0F4aXMpe2NvbnN0IG49dC5icmVha0F4aXM+PWUubGVuZ3RoPzE6ZS5zbGljZSh0LmJyZWFrQXhpcykucmVkdWNlKCgoZSx0KT0+ZSp0KSksaT10LmJyZWFrQXhpczw9MD8xOmUuc2xpY2UoMCx0LmJyZWFrQXhpcykucmVkdWNlKCgoZSx0KT0+ZSp0KSk7aWYoIShuPm98fGk+bykpcmV0dXJuW24saV07ci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVMYXlvdXRcIixgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke2V9LCBicmVha0F4aXM6JHt0LmJyZWFrQXhpc31gKX1sZXQgcz1lLnNsaWNlKDApO2lmKG4mJihvKj0yLHM9cy5tYXAoKChlLHQpPT50Pj1zLmxlbmd0aC0yP3NbdF0lMj09MD9zW3RdOnNbdF0rMTpzW3RdKSksMT09PXMubGVuZ3RoJiYocz1bMixzWzBdXSkpLDIhPT1zLmxlbmd0aCl7Y29uc3QgZT1pKHMpO3M9ZS5uZXdTaGFwZX1jb25zdCBhPXUocyk7cmV0dXJuIHMubGVuZ3RoPD0xJiZhPD1vP1sxLGFdOjI9PT1zLmxlbmd0aCYmc1swXTw9byYmc1sxXTw9bz9zOjM9PT1zLmxlbmd0aCYmc1swXSpzWzFdPD1vJiZzWzJdPD1vP1tzWzBdKnNbMV0sc1syXV06Mz09PXMubGVuZ3RoJiZzWzBdPD1vJiZzWzFdKnNbMl08PW8/W3NbMF0sc1sxXSpzWzJdXTo0PT09cy5sZW5ndGgmJnNbMF0qc1sxXSpzWzJdPD1vJiZzWzNdPD1vP1tzWzBdKnNbMV0qc1syXSxzWzNdXTo0PT09cy5sZW5ndGgmJnNbMF08PW8mJnNbMV0qc1syXSpzWzNdPD1vP1tzWzBdLHNbMV0qc1syXSpzWzNdXTpuP2woYS80KS5tYXAoKGU9PjIqZSkpOmwoYSl9fSx0LnNxdWVlemVTaGFwZT1pLHQucGFyc2VBeGlzUGFyYW09cyx0LmlzSW50PWEsdC5zaXplRnJvbVNoYXBlPXUsdC5nZXRSb3dzQ29scz1mdW5jdGlvbihlKXtpZigwPT09ZS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVybltlLmxlbmd0aD4xP2VbZS5sZW5ndGgtMl06MSxlW2UubGVuZ3RoLTFdXX0sdC5zaXplVG9TcXVhcmlzaFNoYXBlPWwsdC5nZXRCYXRjaERpbT1mdW5jdGlvbihlLHQ9Mil7cmV0dXJuIHUoZS5zbGljZSgwLGUubGVuZ3RoLXQpKX19LDMzMTQ6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZT10LmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodD10LmNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGU9dm9pZCAwO2NvbnN0IHI9big3MjczKSxvPW4oNTYzOSk7dC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlPShlLG4scik9Pntjb25zdCBpPXI9PT1vLlRleHR1cmVUeXBlLnVucGFja2VkfHxyPT09by5UZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkPzE6NCxzPXI9PT1vLlRleHR1cmVUeXBlLnBhY2tlZCxhPXI9PT1vLlRleHR1cmVUeXBlLnVucGFja2VkUmV2ZXJzZWR8fHI9PT1vLlRleHR1cmVUeXBlLnBhY2tlZCx1PXI9PT1vLlRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24/bi5sZW5ndGgtMTp2b2lkIDAsbD1yPT09by5UZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uP24ubWFwKCgoZSx0KT0+dD09PW4ubGVuZ3RoLTE/NCplOmUpKTp2b2lkIDA7cmV0dXJuKDAsdC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKShlLG4saSxsLHtpc1BhY2tlZDpzLHJldmVyc2VXSDphLGJyZWFrQXhpczp1fSl9LHQuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0PShlLG4scik9Pntjb25zdCBvPSgwLHQuY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZSkoZSxuLHIpO3JldHVybltvLndpZHRoLG8uaGVpZ2h0XX0sdC5jcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlPShlLHQsbj0xLG8saSk9Pntjb25zdCBzPSEoIWl8fCFpLmlzUGFja2VkKSxbYSx1XT1lLmNvbXB1dGVUZXh0dXJlV0gocyYmb3x8dCxpKSxsPXQubGVuZ3RoO2xldCBjPXQuc2xpY2UoMCk7aWYoMD09PWwmJihjPVsxXSksMT09PW4pbz10O2Vsc2UgaWYocyl7aWYoNCE9PW4pdGhyb3cgbmV3IEVycm9yKFwiYSBwYWNrZWQgdGV4dHVyZSBtdXN0IGJlIDQtY2hhbm5lbFwiKTtvPXQsbD4wJiYoY1tsLTFdPU1hdGguY2VpbChjW2wtMV0vMikpLGw+MSYmKGNbbC0yXT1NYXRoLmNlaWwoY1tsLTJdLzIpKX1lbHNlIGlmKCFvKXRocm93IG5ldyBFcnJvcihcIlVucGFja2VkIHNoYXBlIGlzIG5lZWRlZCB3aGVuIHVzaW5nIGNoYW5uZWxzID4gMVwiKTtyZXR1cm57d2lkdGg6YSxoZWlnaHQ6dSxjaGFubmVsczpuLGlzUGFja2VkOnMsc2hhcGU6YyxzdHJpZGVzOnIuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGMpLHVucGFja2VkU2hhcGU6byxyZXZlcnNlZFdIOmkmJmkucmV2ZXJzZVdIfX19LDUyNDM6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVGV4dHVyZU1hbmFnZXI9dm9pZCAwO2NvbnN0IHI9bigxMzE1KTt0LlRleHR1cmVNYW5hZ2VyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCxuLHIpe3RoaXMuZ2xDb250ZXh0PWUsdGhpcy5sYXlvdXRTdHJhdGVneT10LHRoaXMucHJvZmlsZXI9bix0aGlzLmNvbmZpZz1yLHRoaXMucGVuZGluZ1JlYWQ9bmV3IE1hcCxyLnJldXNlVGV4dHVyZXMmJih0aGlzLmluVXNlVGV4dHVyZXM9bmV3IE1hcCx0aGlzLmlkbGVUZXh0dXJlcz1uZXcgTWFwLHRoaXMudGV4dHVyZUxvb2t1cD1uZXcgTWFwKX1jcmVhdGVUZXh0dXJlRnJvbUxheW91dChlLHQsbixvKXtjb25zdCBpPXRoaXMudG9FbmNvZGVyVHlwZShlKSxzPXRoaXMuZ2xDb250ZXh0LmdldEVuY29kZXIoaSx0LmNoYW5uZWxzfHwxLG8pO2lmKHQuaXNQYWNrZWQmJjE9PT1vKXRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjb25zdCBhPXQud2lkdGgsdT10LmhlaWdodDtsZXQgbCxjO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpe2w9YCR7YX14JHt1fV8ke3MuZm9ybWF0fV8ke3MuaW50ZXJuYWxGb3JtYXR9XyR7cy50ZXh0dXJlVHlwZX1gLGM9dGhpcy5pblVzZVRleHR1cmVzLmdldChsKSxjfHwoYz1bXSx0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGwsYykpO2NvbnN0IHQ9dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KGwpO2lmKHQmJnQubGVuZ3RoPjApe2NvbnN0IHI9dC5wb3AoKTtyZXR1cm4gYy5wdXNoKHIpLDE9PT1vJiZ0aGlzLmdsQ29udGV4dC51cGRhdGVUZXh0dXJlKHIsYSx1LHMsdGhpcy50b1RleHR1cmVEYXRhKGUsbikpLHJ9fXIuTG9nZ2VyLnZlcmJvc2UoXCJUZXh0dXJlTWFuYWdlclwiLGBDcmVhdGluZyBuZXcgdGV4dHVyZSBvZiBzaXplICR7dC53aWR0aH14JHt0LmhlaWdodH1gKTtjb25zdCBwPXRoaXMuZ2xDb250ZXh0LmFsbG9jYXRlVGV4dHVyZShhLHUscyx0aGlzLnRvVGV4dHVyZURhdGEoZSxuKSk7cmV0dXJuIHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihjLnB1c2gocCksdGhpcy50ZXh0dXJlTG9va3VwLnNldChwLGwpKSxwfXJlYWRUZXh0dXJlKGUsdCxuKXtyZXR1cm4gbnx8KG49MSksdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRUZXh0dXJlXCIsKCgpPT57Y29uc3Qgcj1lLnNoYXBlLnJlZHVjZSgoKGUsdCk9PmUqdCkpKm4sbz10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZShlLnRleHR1cmUsZS53aWR0aCxlLmhlaWdodCxyLHRoaXMudG9FbmNvZGVyVHlwZSh0KSxuKTtyZXR1cm4gdGhpcy50b1RlbnNvckRhdGEodCxvKX0pKX1hc3luYyByZWFkVGV4dHVyZUFzeW5jKGUsdCxuKXtjb25zdCByPWUudGVuc29yLmRhdGFJZDtpZihufHwobj0xKSx0aGlzLnBlbmRpbmdSZWFkLmhhcyhyKSl7Y29uc3QgZT10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gbmV3IFByb21pc2UoKHQ9Pm51bGw9PWU/dm9pZCAwOmUucHVzaCh0KSkpfXJldHVybiB0aGlzLnByb2ZpbGVyLmV2ZW50KFwiYmFja2VuZFwiLFwiVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luY1wiLChhc3luYygpPT57dGhpcy5wZW5kaW5nUmVhZC5zZXQocixbXSk7Y29uc3Qgbz1lLnNoYXBlLnJlZHVjZSgoKGUsdCk9PmUqdCkpKm47YXdhaXQgdGhpcy5nbENvbnRleHQuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCk7Y29uc3QgaT10aGlzLmdsQ29udGV4dC5yZWFkVGV4dHVyZShlLnRleHR1cmUsZS53aWR0aCxlLmhlaWdodCxvLHRoaXMudG9FbmNvZGVyVHlwZSh0KSxuKSxzPXRoaXMudG9UZW5zb3JEYXRhKHQsaSksYT10aGlzLnBlbmRpbmdSZWFkLmdldChyKTtyZXR1cm4gdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUociksbnVsbD09YXx8YS5mb3JFYWNoKChlPT5lKHMpKSksc30pKX1yZWFkVWludDhUZXh0dXJlQXNGbG9hdChlKXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcImJhY2tlbmRcIixcIlRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0XCIsKCgpPT57Y29uc3QgdD1lLnNoYXBlLnJlZHVjZSgoKGUsdCk9PmUqdCkpLG49dGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUoZS50ZXh0dXJlLGUud2lkdGgsZS5oZWlnaHQsNCp0LFwiYnl0ZVwiLDQpO3JldHVybiBuZXcgRmxvYXQzMkFycmF5KG4uYnVmZmVyLG4uYnl0ZU9mZnNldCx0KX0pKX1yZWxlYXNlVGV4dHVyZShlLHQpe2xldCBuO2lmKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMmJihuPXRoaXMudGV4dHVyZUxvb2t1cC5nZXQoZS50ZXh0dXJlKSxuKSl7dCYmdGhpcy50ZXh0dXJlTG9va3VwLmRlbGV0ZShuKTtjb25zdCByPXRoaXMuaW5Vc2VUZXh0dXJlcy5nZXQobik7aWYocil7Y29uc3QgdD1yLmluZGV4T2YoZS50ZXh0dXJlKTtpZigtMSE9PXQpe3Iuc3BsaWNlKHQsMSk7bGV0IG89dGhpcy5pZGxlVGV4dHVyZXMuZ2V0KG4pO298fChvPVtdLHRoaXMuaWRsZVRleHR1cmVzLnNldChuLG8pKSxvLnB1c2goZS50ZXh0dXJlKX19fW4mJiF0fHwoci5Mb2dnZXIudmVyYm9zZShcIlRleHR1cmVNYW5hZ2VyXCIsYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke2Uud2lkdGh9eCR7ZS5oZWlnaHR9YCksdGhpcy5nbENvbnRleHQuZGVsZXRlVGV4dHVyZShlLnRleHR1cmUpKX10b1RlbnNvckRhdGEoZSx0KXtzd2l0Y2goZSl7Y2FzZVwiaW50MTZcIjpyZXR1cm4gdCBpbnN0YW5jZW9mIEludDE2QXJyYXk/dDpJbnQxNkFycmF5LmZyb20odCk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gdCBpbnN0YW5jZW9mIEludDMyQXJyYXk/dDpJbnQzMkFycmF5LmZyb20odCk7Y2FzZVwiaW50OFwiOnJldHVybiB0IGluc3RhbmNlb2YgSW50OEFycmF5P3Q6SW50OEFycmF5LmZyb20odCk7Y2FzZVwidWludDE2XCI6cmV0dXJuIHQgaW5zdGFuY2VvZiBVaW50MTZBcnJheT90OlVpbnQxNkFycmF5LmZyb20odCk7Y2FzZVwidWludDMyXCI6cmV0dXJuIHQgaW5zdGFuY2VvZiBVaW50MzJBcnJheT90OlVpbnQzMkFycmF5LmZyb20odCk7Y2FzZVwidWludDhcIjpjYXNlXCJib29sXCI6cmV0dXJuIHQgaW5zdGFuY2VvZiBVaW50OEFycmF5P3Q6VWludDhBcnJheS5mcm9tKHQpO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT90OkZsb2F0MzJBcnJheS5mcm9tKHQpO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheT90OkZsb2F0NjRBcnJheS5mcm9tKHQpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBUZW5zb3JEYXRhIHR5cGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fXRvVGV4dHVyZURhdGEoZSx0KXtpZih0KXJldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5P3Q6bmV3IEZsb2F0MzJBcnJheSh0KX10b0VuY29kZXJUeXBlKGUpe3JldHVyblwiZmxvYXRcIn1jbGVhckFjdGl2ZVRleHR1cmVzKCl7dGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpfX19LDU2Mzk6KGUsdCk9PntcInVzZSBzdHJpY3RcIjt2YXIgbjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlRleHR1cmVUeXBlPXZvaWQgMCwobj10LlRleHR1cmVUeXBlfHwodC5UZXh0dXJlVHlwZT17fSkpW24udW5wYWNrZWQ9MF09XCJ1bnBhY2tlZFwiLG5bbi51bnBhY2tlZFJldmVyc2VkPTFdPVwidW5wYWNrZWRSZXZlcnNlZFwiLG5bbi5wYWNrZWQ9Ml09XCJwYWNrZWRcIixuW24uZG93bmxvYWRVaW50OEFzRmxvYXQ9M109XCJkb3dubG9hZFVpbnQ4QXNGbG9hdFwiLG5bbi5wYWNrZWRMYXN0RGltZW5zaW9uPTRdPVwicGFja2VkTGFzdERpbWVuc2lvblwifSw0MzI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0R2xDaGFubmVscz10LmdldENvb3Jkc0RhdGFUeXBlPXQuZ2V0U3F1ZWV6ZWRQYXJhbXM9dC5zcXVlZXplSW5wdXRTaGFwZT10LmdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzPXQuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lPXQucmVwZWF0ZWRUcnk9dC5nZXRQYWNrZWRTaGFwZT12b2lkIDA7Y29uc3Qgcj1uKDcyNzMpO3QuZ2V0UGFja2VkU2hhcGU9ZnVuY3Rpb24oZSl7Y29uc3QgdD1lLmxlbmd0aDtyZXR1cm4gZS5zbGljZSgwLHQtMSkuY29uY2F0KGVbdC0xXS80KX0sdC5yZXBlYXRlZFRyeT1hc3luYyBmdW5jdGlvbihlLHQ9KGU9PjApLG4pe3JldHVybiBuZXcgUHJvbWlzZSgoKHIsbyk9PntsZXQgaT0wO2NvbnN0IHM9KCk9PntpZihlKCkpcmV0dXJuIHZvaWQgcigpO2krKztjb25zdCBhPXQoaSk7bnVsbCE9biYmaT49bj9vKCk6c2V0VGltZW91dChzLGEpfTtzKCl9KSl9LHQuZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lPWZ1bmN0aW9uKGUpe3JldHVybigwLHIuYXNzZXJ0KSh2b2lkIDAhPT1lJiYwIT09ZS5sZW5ndGgsKCgpPT5cImVtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lXCIpKSxcImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKX0sdC5nZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWVBdE91dENvb3Jkcz1mdW5jdGlvbihlKXtyZXR1cm4oMCxyLmFzc2VydCkodm9pZCAwIT09ZSYmMCE9PWUubGVuZ3RoLCgoKT0+XCJlbXB0eSBzdHJpbmcgZm91bmQgZm9yIHNhbXBsZXIgbmFtZVwiKSksXCJnZXRcIitlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Uuc2xpY2UoMSkrXCJBdE91dENvb3Jkc1wifSx0LnNxdWVlemVJbnB1dFNoYXBlPWZ1bmN0aW9uKGUsdCl7bGV0IG49SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlKSk7cmV0dXJuIG49dCxufSx0LmdldFNxdWVlemVkUGFyYW1zPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQubWFwKCh0PT5lW3RdKSkuam9pbihcIiwgXCIpfSx0LmdldENvb3Jkc0RhdGFUeXBlPWZ1bmN0aW9uKGUpe2lmKGU8PTEpcmV0dXJuXCJpbnRcIjtpZigyPT09ZSlyZXR1cm5cIml2ZWMyXCI7aWYoMz09PWUpcmV0dXJuXCJpdmVjM1wiO2lmKDQ9PT1lKXJldHVyblwiaXZlYzRcIjtpZig1PT09ZSlyZXR1cm5cIml2ZWM1XCI7aWYoNj09PWUpcmV0dXJuXCJpdmVjNlwiO3Rocm93IEVycm9yKGBHUFUgZm9yIHJhbmsgJHtlfSBpcyBub3QgeWV0IHN1cHBvcnRlZGApfSx0LmdldEdsQ2hhbm5lbHM9ZnVuY3Rpb24oZT02KXtyZXR1cm5bXCJ4XCIsXCJ5XCIsXCJ6XCIsXCJ3XCIsXCJ1XCIsXCJ2XCJdLnNsaWNlKDAsZSl9fSwzMzg5OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNyZWF0ZU5ld1dlYkdMQ29udGV4dD10LmNyZWF0ZVdlYkdMQ29udGV4dD12b2lkIDA7Y29uc3Qgcj1uKDEzMTUpLG89bigzNTI0KSxpPXt9O2Z1bmN0aW9uIHMoZSx0KXtsZXQgbjtjb25zdCBpPXthbHBoYTohMSxkZXB0aDohMSxhbnRpYWxpYXM6ITEsc3RlbmNpbDohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEscHJlbXVsdGlwbGllZEFscGhhOiExLGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6ITF9O2lmKCghdHx8XCJ3ZWJnbDJcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbDJcIixpKSxuKSl0cnl7cmV0dXJuIG5ldyBvLldlYkdMQ29udGV4dChuLDIpfWNhdGNoKGUpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wyJy4gRXJyb3I6ICR7ZX1gKX1pZigoIXR8fFwid2ViZ2xcIj09PXQpJiYobj1lLmdldENvbnRleHQoXCJ3ZWJnbFwiLGkpfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixpKSxuKSl0cnl7cmV0dXJuIG5ldyBvLldlYkdMQ29udGV4dChuLDEpfWNhdGNoKGUpe3IuTG9nZ2VyLndhcm5pbmcoXCJHbENvbnRleHRGYWN0b3J5XCIsYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHtlfWApfXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWRcIil9dC5jcmVhdGVXZWJHTENvbnRleHQ9ZnVuY3Rpb24gZSh0KXtsZXQgbjtpZih0JiZcIndlYmdsMlwiIT09dHx8IShcIndlYmdsMlwiaW4gaSk/dCYmXCJ3ZWJnbFwiIT09dHx8IShcIndlYmdsXCJpbiBpKXx8KG49aS53ZWJnbCk6bj1pLndlYmdsMiwhbil0cnl7bj1zKGZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIE9mZnNjcmVlbkNhbnZhcyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZmFpbGVkIHRvIGNyZWF0ZSBvZmZzY3JlZW4gY2FudmFzOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpfSgpLHQpfWNhdGNoKGUpe249cyhmdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZmFpbGVkIHRvIGNyZWF0ZSBjYW52YXM6IGRvY3VtZW50IGlzIG5vdCBzdXBwb3J0ZWRcIik7Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3JldHVybiBlLndpZHRoPTEsZS5oZWlnaHQ9MSxlfSgpLHQpfXQ9dHx8MT09PW4udmVyc2lvbj9cIndlYmdsXCI6XCJ3ZWJnbDJcIjtjb25zdCByPW4uZ2w7cmV0dXJuIGlbdF09bixyLmlzQ29udGV4dExvc3QoKT8oZGVsZXRlIGlbdF0sZSh0KSk6KHIuZGlzYWJsZShyLkRFUFRIX1RFU1QpLHIuZGlzYWJsZShyLlNURU5DSUxfVEVTVCksci5kaXNhYmxlKHIuQkxFTkQpLHIuZGlzYWJsZShyLkRJVEhFUiksci5kaXNhYmxlKHIuUE9MWUdPTl9PRkZTRVRfRklMTCksci5kaXNhYmxlKHIuU0FNUExFX0NPVkVSQUdFKSxyLmVuYWJsZShyLlNDSVNTT1JfVEVTVCksci5lbmFibGUoci5DVUxMX0ZBQ0UpLHIuY3VsbEZhY2Uoci5CQUNLKSxuKX0sdC5jcmVhdGVOZXdXZWJHTENvbnRleHQ9c30sMzUyNDpmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxuKTtvJiYhKFwiZ2V0XCJpbiBvPyF0Ll9fZXNNb2R1bGU6by53cml0YWJsZXx8by5jb25maWd1cmFibGUpfHwobz17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLG8pfTpmdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKSxlW3JdPXRbbl19KSxvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KX06ZnVuY3Rpb24oZSx0KXtlLmRlZmF1bHQ9dH0pLGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgbiBpbiBlKVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbikmJnIodCxlLG4pO3JldHVybiBvKHQsZSksdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5XZWJHTENvbnRleHQ9dC5saW5lYXJTZWFyY2hMYXN0VHJ1ZT12b2lkIDA7Y29uc3Qgcz1uKDYyMDcpLGE9aShuKDk2MjIpKSx1PW4oNDMyKTtmdW5jdGlvbiBsKGUpe2xldCB0PTA7Zm9yKDt0PGUubGVuZ3RoJiZlW3RdKCk7Kyt0KTtyZXR1cm4gdC0xfXQubGluZWFyU2VhcmNoTGFzdFRydWU9bCx0LldlYkdMQ29udGV4dD1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuZnJhbWVCdWZmZXJCb3VuZD0hMSx0aGlzLml0ZW1zVG9Qb2xsPVtdLHRoaXMuZ2w9ZSx0aGlzLnZlcnNpb249dCx0aGlzLmdldEV4dGVuc2lvbnMoKSx0aGlzLnZlcnRleGJ1ZmZlcj10aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpLHRoaXMuZnJhbWVidWZmZXI9dGhpcy5jcmVhdGVGcmFtZWJ1ZmZlcigpLHRoaXMucXVlcnlWaXRhbFBhcmFtZXRlcnMoKX1hbGxvY2F0ZVRleHR1cmUoZSx0LG4scil7Y29uc3Qgbz10aGlzLmdsLGk9by5jcmVhdGVUZXh0dXJlKCk7by5iaW5kVGV4dHVyZShvLlRFWFRVUkVfMkQsaSksby50ZXhQYXJhbWV0ZXJpKG8uVEVYVFVSRV8yRCxvLlRFWFRVUkVfTUlOX0ZJTFRFUixvLk5FQVJFU1QpLG8udGV4UGFyYW1ldGVyaShvLlRFWFRVUkVfMkQsby5URVhUVVJFX01BR19GSUxURVIsby5ORUFSRVNUKSxvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELG8uVEVYVFVSRV9XUkFQX1Msby5DTEFNUF9UT19FREdFKSxvLnRleFBhcmFtZXRlcmkoby5URVhUVVJFXzJELG8uVEVYVFVSRV9XUkFQX1Qsby5DTEFNUF9UT19FREdFKTtjb25zdCBzPXI/bi5lbmNvZGUocixlKnQpOm51bGw7cmV0dXJuIG8udGV4SW1hZ2UyRChvLlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0LGUsdCwwLG4uZm9ybWF0LG4udGV4dHVyZVR5cGUscyksdGhpcy5jaGVja0Vycm9yKCksaX11cGRhdGVUZXh0dXJlKGUsdCxuLHIsbyl7Y29uc3QgaT10aGlzLmdsO2kuYmluZFRleHR1cmUoaS5URVhUVVJFXzJELGUpO2NvbnN0IHM9ci5lbmNvZGUobyx0Km4pO2kudGV4U3ViSW1hZ2UyRChpLlRFWFRVUkVfMkQsMCwwLDAsdCxuLHIuZm9ybWF0LHIudGV4dHVyZVR5cGUscyksdGhpcy5jaGVja0Vycm9yKCl9YXR0YWNoRnJhbWVidWZmZXIoZSx0LG4pe2NvbnN0IHI9dGhpcy5nbDtyLmJpbmRUZXh0dXJlKHIuVEVYVFVSRV8yRCxlKSxyLmJpbmRGcmFtZWJ1ZmZlcihyLkZSQU1FQlVGRkVSLHRoaXMuZnJhbWVidWZmZXIpLHIuZnJhbWVidWZmZXJUZXh0dXJlMkQoci5GUkFNRUJVRkZFUixyLkNPTE9SX0FUVEFDSE1FTlQwLHIuVEVYVFVSRV8yRCxlLDApLHRoaXMuY2hlY2tFcnJvcigpLHIudmlld3BvcnQoMCwwLHQsbiksci5zY2lzc29yKDAsMCx0LG4pfXJlYWRUZXh0dXJlKGUsdCxuLHIsbyxpKXtjb25zdCBzPXRoaXMuZ2w7aXx8KGk9MSksdGhpcy5mcmFtZUJ1ZmZlckJvdW5kfHx0aGlzLmF0dGFjaEZyYW1lYnVmZmVyKGUsdCxuKTtjb25zdCBhPXRoaXMuZ2V0RW5jb2RlcihvLGkpLHU9YS5hbGxvY2F0ZSh0Km4pO3JldHVybiBzLmJpbmRUZXh0dXJlKHMuVEVYVFVSRV8yRCxlKSxzLmZyYW1lYnVmZmVyVGV4dHVyZTJEKHMuRlJBTUVCVUZGRVIscy5DT0xPUl9BVFRBQ0hNRU5UMCxzLlRFWFRVUkVfMkQsZSwwKSxzLnJlYWRQaXhlbHMoMCwwLHQsbixzLlJHQkEsYS50ZXh0dXJlVHlwZSx1KSx0aGlzLmNoZWNrRXJyb3IoKSxhLmRlY29kZSh1LHIpfWlzRnJhbWVidWZmZXJSZWFkeSgpe3JldHVybiEwfWdldEFjdGl2ZVRleHR1cmUoKXtjb25zdCBlPXRoaXMuZ2w7cmV0dXJuXCJURVhUVVJFXCIrKGUuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuQUNUSVZFX1RFWFRVUkUpLWUuVEVYVFVSRTApfWdldFRleHR1cmVCaW5kaW5nKCl7cmV0dXJuIHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKX1nZXRGcmFtZWJ1ZmZlckJpbmRpbmcoKXtyZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKX1zZXRWZXJ0ZXhBdHRyaWJ1dGVzKGUsdCl7Y29uc3Qgbj10aGlzLmdsO24udmVydGV4QXR0cmliUG9pbnRlcihlLDMsbi5GTE9BVCwhMSwyMCwwKSxuLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGUpLC0xIT09dCYmKG4udmVydGV4QXR0cmliUG9pbnRlcih0LDIsbi5GTE9BVCwhMSwyMCwxMiksbi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0KSksdGhpcy5jaGVja0Vycm9yKCl9Y3JlYXRlUHJvZ3JhbShlLHQpe2NvbnN0IG49dGhpcy5nbCxyPW4uY3JlYXRlUHJvZ3JhbSgpO3JldHVybiBuLmF0dGFjaFNoYWRlcihyLGUpLG4uYXR0YWNoU2hhZGVyKHIsdCksbi5saW5rUHJvZ3JhbShyKSxyfWNvbXBpbGVTaGFkZXIoZSx0KXtjb25zdCBuPXRoaXMuZ2wscj1uLmNyZWF0ZVNoYWRlcih0KTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7dH1gKTtpZihuLnNoYWRlclNvdXJjZShyLGUpLG4uY29tcGlsZVNoYWRlcihyKSwhMT09PW4uZ2V0U2hhZGVyUGFyYW1ldGVyKHIsbi5DT01QSUxFX1NUQVRVUykpdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7bi5nZXRTaGFkZXJJbmZvTG9nKHIpfVxcblNoYWRlciBzb3VyY2U6XFxuJHtlfWApO3JldHVybiByfWRlbGV0ZVNoYWRlcihlKXt0aGlzLmdsLmRlbGV0ZVNoYWRlcihlKX1iaW5kVGV4dHVyZVRvVW5pZm9ybShlLHQsbil7Y29uc3Qgcj10aGlzLmdsO3IuYWN0aXZlVGV4dHVyZShyLlRFWFRVUkUwK3QpLHRoaXMuY2hlY2tFcnJvcigpLHIuYmluZFRleHR1cmUoci5URVhUVVJFXzJELGUpLHRoaXMuY2hlY2tFcnJvcigpLHIudW5pZm9ybTFpKG4sdCksdGhpcy5jaGVja0Vycm9yKCl9ZHJhdygpe3RoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLDAsNCksdGhpcy5jaGVja0Vycm9yKCl9Y2hlY2tFcnJvcigpe2lmKHMuZW52LmRlYnVnKXtjb25zdCBlPXRoaXMuZ2wsdD1lLmdldEVycm9yKCk7bGV0IG49XCJcIjtzd2l0Y2godCl7Y2FzZSBlLk5PX0VSUk9SOnJldHVybjtjYXNlIGUuSU5WQUxJRF9FTlVNOm49XCJJTlZBTElEX0VOVU1cIjticmVhaztjYXNlIGUuSU5WQUxJRF9WQUxVRTpuPVwiSU5WQUxJRF9WQUxVRVwiO2JyZWFrO2Nhc2UgZS5JTlZBTElEX09QRVJBVElPTjpuPVwiSU5WQUxJRF9PUEVSQVRJT05cIjticmVhaztjYXNlIGUuSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT046bj1cIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCI7YnJlYWs7Y2FzZSBlLk9VVF9PRl9NRU1PUlk6bj1cIk9VVF9PRl9NRU1PUllcIjticmVhaztjYXNlIGUuQ09OVEVYVF9MT1NUX1dFQkdMOm49XCJDT05URVhUX0xPU1RfV0VCR0xcIjticmVhaztkZWZhdWx0Om49YFVua25vd24gV2ViR0wgRXJyb3I6ICR7dC50b1N0cmluZygxNil9YH10aHJvdyBuZXcgRXJyb3Iobil9fWRlbGV0ZVRleHR1cmUoZSl7dGhpcy5nbC5kZWxldGVUZXh0dXJlKGUpfWRlbGV0ZVByb2dyYW0oZSl7dGhpcy5nbC5kZWxldGVQcm9ncmFtKGUpfWdldEVuY29kZXIoZSx0LG49MCl7aWYoMj09PXRoaXMudmVyc2lvbilyZXR1cm4gbmV3IGEuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wsdCk7c3dpdGNoKGUpe2Nhc2VcImZsb2F0XCI6cmV0dXJuIDE9PT1ufHx0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZD9uZXcgYS5SR0JBRmxvYXREYXRhRW5jb2Rlcih0aGlzLmdsLHQpOm5ldyBhLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsdCx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24uSEFMRl9GTE9BVF9PRVMpO2Nhc2VcImludFwiOnRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtjYXNlXCJieXRlXCI6cmV0dXJuIG5ldyBhLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCx0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhVHlwZTogJHtlfWApfX1jbGVhckFjdGl2ZVRleHR1cmVzKCl7Y29uc3QgZT10aGlzLmdsO2ZvcihsZXQgdD0wO3Q8dGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0czsrK3QpZS5hY3RpdmVUZXh0dXJlKGUuVEVYVFVSRTArdCksZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCl9ZGlzcG9zZSgpe2lmKHRoaXMuZGlzcG9zZWQpcmV0dXJuO2NvbnN0IGU9dGhpcy5nbDtlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpLGUuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlciksZS5iaW5kQnVmZmVyKGUuQVJSQVlfQlVGRkVSLG51bGwpLGUuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4YnVmZmVyKSxlLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKSxlLmZpbmlzaCgpLHRoaXMuZGlzcG9zZWQ9ITB9Y3JlYXRlRGVmYXVsdEdlb21ldHJ5KCl7cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWy0xLDEsMCwwLDEsLTEsLTEsMCwwLDAsMSwxLDAsMSwxLDEsLTEsMCwxLDBdKX1jcmVhdGVWZXJ0ZXhidWZmZXIoKXtjb25zdCBlPXRoaXMuZ2wsdD1lLmNyZWF0ZUJ1ZmZlcigpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUJ1ZmZlcigpIHJldHVybmVkIG51bGxcIik7Y29uc3Qgbj10aGlzLmNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpO3JldHVybiBlLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsdCksZS5idWZmZXJEYXRhKGUuQVJSQVlfQlVGRkVSLG4sZS5TVEFUSUNfRFJBVyksdGhpcy5jaGVja0Vycm9yKCksdH1jcmVhdGVGcmFtZWJ1ZmZlcigpe2NvbnN0IGU9dGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNyZWF0ZUZyYW1lYnVmZmVyIHJldHVybmVkIG51bGxcIik7cmV0dXJuIGV9cXVlcnlWaXRhbFBhcmFtZXRlcnMoKXtjb25zdCBlPXRoaXMuZ2w7aWYodGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyPXRoaXMuY2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpLHRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkPXRoaXMuY2hlY2tSZW5kZXJGbG9hdDMyKCksdGhpcy5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZD10aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCksMT09PXRoaXMudmVyc2lvbiYmIXRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiYmIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKXRocm93IG5ldyBFcnJvcihcImJvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZFwiKTt0aGlzLmlzQmxlbmRTdXBwb3J0ZWQ9IXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkfHx0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCksdGhpcy5tYXhUZXh0dXJlU2l6ZT1lLmdldFBhcmFtZXRlcihlLk1BWF9URVhUVVJFX1NJWkUpLHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM9ZS5nZXRQYXJhbWV0ZXIoZS5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksdGhpcy52ZXJzaW9ufWdldEV4dGVuc2lvbnMoKXsyPT09dGhpcy52ZXJzaW9uPyh0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2Zsb2F0XCIpLHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSk6KHRoaXMudGV4dHVyZUZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIiksdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfaGFsZl9mbG9hdFwiKSl9Y2hlY2tGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcigpe2NvbnN0IGU9dGhpcy5nbCx0PWUuY3JlYXRlVGV4dHVyZSgpO2UuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELHQpO2NvbnN0IG49Mj09PXRoaXMudmVyc2lvbj9lLlJHQkEzMkY6ZS5SR0JBO2UudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsMCxuLDEsMSwwLGUuUkdCQSxlLkZMT0FULG51bGwpO2NvbnN0IHI9ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpO2UuYmluZEZyYW1lYnVmZmVyKGUuRlJBTUVCVUZGRVIsciksZS5mcmFtZWJ1ZmZlclRleHR1cmUyRChlLkZSQU1FQlVGRkVSLGUuQ09MT1JfQVRUQUNITUVOVDAsZS5URVhUVVJFXzJELHQsMCk7Y29uc3Qgbz1lLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZS5GUkFNRUJVRkZFUik9PT1lLkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiBlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKSxlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpLGUuZGVsZXRlVGV4dHVyZSh0KSxlLmRlbGV0ZUZyYW1lYnVmZmVyKHIpLG99Y2hlY2tSZW5kZXJGbG9hdDMyKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNlIGlmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtyZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyfWNoZWNrRmxvYXQzMkRvd25sb2FkKCl7aWYoMj09PXRoaXMudmVyc2lvbil7aWYoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbilyZXR1cm4hMX1lbHNle2lmKCF0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbilyZXR1cm4hMTtpZighdGhpcy5nbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITF9cmV0dXJuIHRoaXMuaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcn1jaGVja0Zsb2F0MzJCbGVuZCgpe2NvbnN0IGU9dGhpcy5nbDtsZXQgdCxuLHIsbyxpO3RyeXt0PWUuY3JlYXRlVGV4dHVyZSgpLG49ZS5jcmVhdGVGcmFtZWJ1ZmZlcigpLGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELHQpO2NvbnN0IHM9Mj09PXRoaXMudmVyc2lvbj9lLlJHQkEzMkY6ZS5SR0JBO3JldHVybiBlLnRleEltYWdlMkQoZS5URVhUVVJFXzJELDAscywxLDEsMCxlLlJHQkEsZS5GTE9BVCxudWxsKSxlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG4pLGUuZnJhbWVidWZmZXJUZXh0dXJlMkQoZS5GUkFNRUJVRkZFUixlLkNPTE9SX0FUVEFDSE1FTlQwLGUuVEVYVFVSRV8yRCx0LDApLGUuZW5hYmxlKGUuQkxFTkQpLHI9ZS5jcmVhdGVTaGFkZXIoZS5WRVJURVhfU0hBREVSKSwhIXImJihlLnNoYWRlclNvdXJjZShyLFwidm9pZCBtYWluKCl7fVwiKSxlLmNvbXBpbGVTaGFkZXIociksbz1lLmNyZWF0ZVNoYWRlcihlLkZSQUdNRU5UX1NIQURFUiksISFvJiYoZS5zaGFkZXJTb3VyY2UobyxcInByZWNpc2lvbiBoaWdocCBmbG9hdDt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dmVjNCgwLjUpO31cIiksZS5jb21waWxlU2hhZGVyKG8pLGk9ZS5jcmVhdGVQcm9ncmFtKCksISFpJiYoZS5hdHRhY2hTaGFkZXIoaSxyKSxlLmF0dGFjaFNoYWRlcihpLG8pLGUubGlua1Byb2dyYW0oaSksZS51c2VQcm9ncmFtKGkpLGUuZHJhd0FycmF5cyhlLlBPSU5UUywwLDEpLGUuZ2V0RXJyb3IoKT09PWUuTk9fRVJST1IpKSl9ZmluYWxseXtlLmRpc2FibGUoZS5CTEVORCksaSYmZS5kZWxldGVQcm9ncmFtKGkpLHImJmUuZGVsZXRlU2hhZGVyKHIpLG8mJmUuZGVsZXRlU2hhZGVyKG8pLG4mJihlLmJpbmRGcmFtZWJ1ZmZlcihlLkZSQU1FQlVGRkVSLG51bGwpLGUuZGVsZXRlRnJhbWVidWZmZXIobikpLHQmJihlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKSxlLmRlbGV0ZVRleHR1cmUodCkpfX1iZWdpblRpbWVyKCl7aWYoMj09PXRoaXMudmVyc2lvbiYmdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pe2NvbnN0IGU9dGhpcy5nbCx0PXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uLG49ZS5jcmVhdGVRdWVyeSgpO3JldHVybiBlLmJlZ2luUXVlcnkodC5USU1FX0VMQVBTRURfRVhULG4pLG59dGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cIil9ZW5kVGltZXIoKXtpZigyIT09dGhpcy52ZXJzaW9ufHwhdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3QgZT10aGlzLmdsLHQ9dGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb247ZS5lbmRRdWVyeSh0LlRJTUVfRUxBUFNFRF9FWFQpfX1pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKGUpe2xldCB0PSExLG49ITE7aWYoMiE9PXRoaXMudmVyc2lvbnx8IXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKXRocm93IG5ldyBFcnJvcihcIldlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIik7e2NvbnN0IHI9dGhpcy5nbCxvPXRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO3Q9ci5nZXRRdWVyeVBhcmFtZXRlcihlLHIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSksbj1yLmdldFBhcmFtZXRlcihvLkdQVV9ESVNKT0lOVF9FWFQpfXJldHVybiB0JiYhbn1nZXRUaW1lclJlc3VsdChlKXtsZXQgdD0wO2lmKDIhPT10aGlzLnZlcnNpb24pdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFwiKTt7Y29uc3Qgbj10aGlzLmdsO3Q9bi5nZXRRdWVyeVBhcmFtZXRlcihlLG4uUVVFUllfUkVTVUxUKSxuLmRlbGV0ZVF1ZXJ5KGUpfXJldHVybiB0LzFlNn1hc3luYyB3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKGUpe3JldHVybiBhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+dGhpcy5pc1RpbWVyUmVzdWx0QXZhaWxhYmxlKGUpKSksdGhpcy5nZXRUaW1lclJlc3VsdChlKX1hc3luYyBjcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKXtjb25zdCBlPXRoaXMuY3JlYXRlRmVuY2UodGhpcy5nbCk7cmV0dXJuIHRoaXMucG9sbEZlbmNlKGUpfWNyZWF0ZUZlbmNlKGUpe2xldCB0O2NvbnN0IG49ZSxyPW4uZmVuY2VTeW5jKG4uU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUsMCk7cmV0dXJuIGUuZmx1c2goKSx0PW51bGw9PT1yPygpPT4hMDooKT0+e2NvbnN0IGU9bi5jbGllbnRXYWl0U3luYyhyLDAsMCk7cmV0dXJuIGU9PT1uLkFMUkVBRFlfU0lHTkFMRUR8fGU9PT1uLkNPTkRJVElPTl9TQVRJU0ZJRUR9LHtxdWVyeTpyLGlzRmVuY2VQYXNzZWQ6dH19YXN5bmMgcG9sbEZlbmNlKGUpe3JldHVybiBuZXcgUHJvbWlzZSgodD0+e3RoaXMuYWRkSXRlbVRvUG9sbCgoKCk9PmUuaXNGZW5jZVBhc3NlZCgpKSwoKCk9PnQoKSkpfSkpfXBvbGxJdGVtcygpe2NvbnN0IGU9bCh0aGlzLml0ZW1zVG9Qb2xsLm1hcCgoZT0+ZS5pc0RvbmVGbikpKTtmb3IobGV0IHQ9MDt0PD1lOysrdCl7Y29uc3R7cmVzb2x2ZUZuOmV9PXRoaXMuaXRlbXNUb1BvbGxbdF07ZSgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZShlKzEpfWFzeW5jIGFkZEl0ZW1Ub1BvbGwoZSx0KXt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOmUscmVzb2x2ZUZuOnR9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxhd2FpdCgwLHUucmVwZWF0ZWRUcnkpKCgoKT0+KHRoaXMucG9sbEl0ZW1zKCksMD09PXRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoKSkpfX19LDY0OTY6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRXhlY3V0aW9uUGxhbj12b2lkIDA7Y29uc3Qgcj1uKDEzMTUpO2NsYXNzIG97Y29uc3RydWN0b3IoZSx0KXt0aGlzLm9wPWUsdGhpcy5ub2RlPXR9fXQuRXhlY3V0aW9uUGxhbj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQsbil7dGhpcy5ncmFwaD1lLHRoaXMucHJvZmlsZXI9bix0aGlzLmluaXRpYWxpemUodCl9aW5pdGlhbGl6ZShlKXt0aGlzLnByb2ZpbGVyLmV2ZW50KFwic2Vzc2lvblwiLFwiRXhlY3V0aW9uUGxhbi5pbml0aWFsaXplXCIsKCgpPT57Y29uc3QgdD10aGlzLmdyYXBoLmdldE5vZGVzKCk7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2l6ZSBvZiBub2RlcyBhbmQgT1BzIGRvIG5vdCBtYXRjaC5cIik7dGhpcy5fb3BzPWUubWFwKCgoZSxuKT0+bmV3IG8oZSx0W25dKSkpLHRoaXMucmVzZXQoKSx0aGlzLl9zdGFydGVyPVtdLHRoaXMuX29wcy5mb3JFYWNoKCgoZSx0KT0+e2xldCBuPSEwO2Zvcihjb25zdCB0IG9mIGUubm9kZS5pbnB1dHMpaWYoIXRoaXMuX3ZhbHVlc1t0XSYmLTE9PT10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YodCkpe249ITE7YnJlYWt9biYmdGhpcy5fc3RhcnRlci5wdXNoKHQpfSkpfSkpfXJlc2V0KCl7dGhpcy5fdmFsdWVzPXRoaXMuZ3JhcGguZ2V0VmFsdWVzKCkubWFwKChlPT5lLnRlbnNvcikpfWFzeW5jIGV4ZWN1dGUoZSx0KXtyZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudChcInNlc3Npb25cIixcIkV4ZWN1dGlvblBsYW4uZXhlY3V0ZVwiLChhc3luYygpPT57dGhpcy5yZXNldCgpO2NvbnN0IG49ZS5jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCksbz10aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpO2lmKHQubGVuZ3RoIT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBudW1iZXIgb2YgaW5wdXQgdGVuc29ycyBkb24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyB0byB0aGUgbW9kZWw6IGFjdHVhbDogJHt0Lmxlbmd0aH0gZXhwZWN0ZWQ6ICR7by5sZW5ndGh9YCk7dC5mb3JFYWNoKCgoZSx0KT0+e2NvbnN0IG49b1t0XTt0aGlzLl92YWx1ZXNbbl09ZX0pKTtjb25zdCBpPXRoaXMuX3N0YXJ0ZXIuc2xpY2UoMCkscz10aGlzLmdyYXBoLmdldFZhbHVlcygpLGE9dGhpcy5ncmFwaC5nZXROb2RlcygpO2xldCB1PTA7Zm9yKDt1PGkubGVuZ3RoOyl7Y29uc3QgZT1pW3UrK10sdD10aGlzLl9vcHNbZV0sbz10Lm5vZGUuaW5wdXRzLm1hcCgoZT0+dGhpcy5fdmFsdWVzW2VdKSk7aWYoLTEhPT1vLmluZGV4T2Yodm9pZCAwKSl0aHJvdyBuZXcgRXJyb3IoYHVucmVzb2x2ZWQgaW5wdXQgZGV0ZWN0ZWQ6IG9wOiAke3Qubm9kZX1gKTtjb25zdCBsPW87ci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsYFJ1bmluZyBvcDoke3Qubm9kZS5uYW1lfSAoJHtsLm1hcCgoKGUsbik9PmAnJHt0Lm5vZGUuaW5wdXRzW25dfSc6ICR7ZS50eXBlfVske2UuZGltcy5qb2luKFwiLFwiKX1dYCkpLmpvaW4oXCIsIFwiKX0pYCk7Y29uc3QgYz1hd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFwibm9kZVwiLHQubm9kZS5uYW1lLChhc3luYygpPT50Lm9wLmltcGwobixsLHQub3AuY29udGV4dCkpKTtpZihjLmxlbmd0aCE9PXQubm9kZS5vdXRwdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgc2l6ZSBvZiBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggbW9kZWwgZGVmaW5pdGlvbi5cIik7Yy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IHI9dC5ub2RlLm91dHB1dHNbbl07aWYodGhpcy5fdmFsdWVzW3JdKXRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske3J9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHt0Lm5vZGUubmFtZX1gKTt0aGlzLl92YWx1ZXNbcl09ZX0pKTtjb25zdCBwPW5ldyBTZXQ7Yy5mb3JFYWNoKCgoZSxuKT0+e2NvbnN0IHI9dC5ub2RlLm91dHB1dHNbbl07Zm9yKGNvbnN0IGUgb2Ygc1tyXS50byl7Y29uc3QgdD1hW2VdO2xldCBuPSEwO2Zvcihjb25zdCBlIG9mIHQuaW5wdXRzKWlmKCF0aGlzLl92YWx1ZXNbZV0pe249ITE7YnJlYWt9biYmcC5hZGQoZSl9fSkpLGkucHVzaCguLi5wKX1jb25zdCBsPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKCkubGVuZ3RoO2UrKyl7Y29uc3QgdD10aGlzLmdyYXBoLmdldE91dHB1dEluZGljZXMoKVtlXSxuPXRoaXMuX3ZhbHVlc1t0XTtpZih2b2lkIDA9PT1uKXRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske3R9XSBkb2VzIG5vdCBoYXZlIHZhbHVlYCk7MD09PXQ/YXdhaXQgbi5nZXREYXRhKCk6bi5kYXRhLGwucHVzaChuKX1yZXR1cm4gci5Mb2dnZXIudmVyYm9zZShcIkV4ZWNQbGFuXCIsXCJkaXNwb3Npbmcgb2YgaW5mZXJlbmNlSGFuZGxlclwiKSxuLmRpc3Bvc2UoKSxsfSkpfX19LDQ2NjI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuR3JhcGg9dm9pZCAwO2NvbnN0IHI9big2ODc0KSxvPW4oNTEyNyksaT1uKDI0NDYpLHM9big5MjQwKSxhPW4oNzI3Myk7dmFyIHU9by5vbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO3QuR3JhcGg9e2Zyb206KGUsdCk9Pm5ldyBwKGUsdCl9O2NsYXNzIGx7Y29uc3RydWN0b3IoZSl7dGhpcy5fZnJvbT12b2lkIDAsdGhpcy5fdG89W10sdGhpcy50ZW5zb3I9dm9pZCAwLHRoaXMudHlwZT12b2lkIDAsZSYmKHRoaXMudHlwZT1hLlByb3RvVXRpbC50ZW5zb3JWYWx1ZVR5cGVGcm9tUHJvdG8oZS50eXBlLnRlbnNvclR5cGUpKX1nZXQgZnJvbSgpe3JldHVybiB0aGlzLl9mcm9tfWdldCB0bygpe3JldHVybiB0aGlzLl90b319Y2xhc3MgY3tjb25zdHJ1Y3RvcihlLHQpe2UgaW5zdGFuY2VvZiBpLm9ubnguTm9kZVByb3RvPyh0aGlzLm5hbWU9ZS5uYW1lLHRoaXMub3BUeXBlPWUub3BUeXBlLHRoaXMuYXR0cmlidXRlcz1uZXcgci5BdHRyaWJ1dGUoZS5hdHRyaWJ1dGUpKTplIGluc3RhbmNlb2YgdS5Ob2RlJiYodGhpcy5uYW1lPW51bGwhPXQ/dDplLm5hbWUoKSx0aGlzLm9wVHlwZT1lLm9wVHlwZSgpLHRoaXMuYXR0cmlidXRlcz1uZXcgci5BdHRyaWJ1dGUoYS5Qcm90b1V0aWwudGVuc29yQXR0cmlidXRlc0Zyb21PUlRGb3JtYXQoZSkpKSx0aGlzLmlucHV0cz1bXSx0aGlzLm91dHB1dHM9W10sdGhpcy5leGVjdXRlTm9kZT0hMH19Y2xhc3MgcHtjb25zdHJ1Y3RvcihlLHQpe2lmKCFlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJncmFwaCBpcyBlbXB0eVwiKTt0aGlzLmJ1aWxkR3JhcGgoZSksdGhpcy50cmFuc2Zvcm1HcmFwaCh0KSx0aGlzLmNoZWNrSXNBY3ljbGljKCl9Z2V0SW5wdXRJbmRpY2VzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0SW5kaWNlc31nZXRJbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXN9Z2V0T3V0cHV0SW5kaWNlcygpe3JldHVybiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzfWdldE91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX2FsbE91dHB1dE5hbWVzfWdldFZhbHVlcygpe3JldHVybiB0aGlzLl9hbGxEYXRhfWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVzfWJ1aWxkR3JhcGgoZSl7aWYoZSBpbnN0YW5jZW9mIGkub25ueC5HcmFwaFByb3RvKXRoaXMuYnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KGUpO2Vsc2V7aWYoIShlIGluc3RhbmNlb2YgdS5HcmFwaCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIik7dGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdChlKX19YnVpbGRHcmFwaEZyb21Pbm54Rm9ybWF0KGUpe2NvbnN0IHQ9bmV3IE1hcDt0aGlzLl9hbGxEYXRhPVtdLHRoaXMuX2FsbElucHV0SW5kaWNlcz1bXSx0aGlzLl9hbGxJbnB1dE5hbWVzPVtdLHRoaXMuX2FsbE91dHB1dEluZGljZXM9W10sdGhpcy5fYWxsT3V0cHV0TmFtZXM9W10sdGhpcy5fbm9kZXM9W107Y29uc3Qgbj1uZXcgTWFwO2lmKCFlLmlucHV0KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGlucHV0XCIpO2NvbnN0IHI9W107Zm9yKGNvbnN0IG4gb2YgZS5pbnB1dCl7aWYodC5oYXMobi5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtuLm5hbWV9YCk7Y29uc3QgZT10aGlzLl9hbGxEYXRhLnB1c2gobmV3IGwobikpLTE7dC5zZXQobi5uYW1lLGUpLHIucHVzaChuLm5hbWUpfWlmKCFlLmluaXRpYWxpemVyKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IGluaXRpYWxpemVyXCIpO2Zvcihjb25zdCBuIG9mIGUuaW5pdGlhbGl6ZXIpe2xldCBlPXQuZ2V0KG4ubmFtZSk7aWYodm9pZCAwPT09ZSl7Y29uc3Qgcj1uZXcgbDtyLnR5cGU9e3NoYXBlOntkaW1zOmEuUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8obi5kaW1zKX0sdGVuc29yVHlwZTphLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhuLmRhdGFUeXBlKX0sZT10aGlzLl9hbGxEYXRhLnB1c2gociktMSx0LnNldChuLm5hbWUsZSl9dGhpcy5fYWxsRGF0YVtlXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW2VdLnRlbnNvcj1zLlRlbnNvci5mcm9tUHJvdG8obil9Zm9yKGxldCBlPTA7ZTx0aGlzLl9hbGxEYXRhLmxlbmd0aDtlKyspdGhpcy5fYWxsRGF0YVtlXS50ZW5zb3J8fCh0aGlzLl9hbGxJbnB1dEluZGljZXMucHVzaChlKSx0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2gocltlXSkpO2lmKCFlLm91dHB1dCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBvdXRwdXRcIik7Zm9yKGNvbnN0IG4gb2YgZS5vdXRwdXQpe2lmKHQuaGFzKG4ubmFtZSkpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke24ubmFtZX1gKTtjb25zdCBlPXRoaXMuX2FsbERhdGEucHVzaChuZXcgbChuKSktMTt0LnNldChuLm5hbWUsZSksdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGUpLHRoaXMuX2FsbE91dHB1dE5hbWVzLnB1c2gobi5uYW1lKX1pZighZS5ub2RlKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGVcIik7Zm9yKGNvbnN0IHQgb2YgZS5ub2RlKXtpZighdC5uYW1lKWZvcihsZXQgZT0wOztlKyspe2NvbnN0IHI9YHVubmFtZWRfJHt0Lm9wVHlwZX1fJHtlfWA7aWYoIW4uaGFzKHIpKXt0Lm5hbWU9cjticmVha319aWYobi5oYXModC5uYW1lKSl0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgbm9kZSBuYW1lOiAke3QubmFtZX1gKTtjb25zdCBlPXRoaXMuX25vZGVzLnB1c2gobmV3IGModCkpLTE7bi5zZXQodC5uYW1lLGUpfWZvcihsZXQgbj0wO248dGhpcy5fbm9kZXMubGVuZ3RoO24rKyl7Y29uc3Qgcj10aGlzLl9ub2Rlc1tuXSxvPWUubm9kZVtuXTtpZighby5vdXRwdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIG91dHB1dCBmb3Igbm9kZTogJHtvLm5hbWV9YCk7Zm9yKGNvbnN0IGUgb2Ygby5vdXRwdXQpe2xldCBpPXQuZ2V0KGUpO2lmKHZvaWQgMD09PWkmJihpPXRoaXMuX2FsbERhdGEucHVzaChuZXcgbCktMSx0LnNldChlLGkpKSxyLm91dHB1dHMucHVzaChpKSx2b2lkIDAhPT10aGlzLl9hbGxEYXRhW2ldLl9mcm9tKXRocm93IG5ldyBFcnJvcihgbXVsdGlwbGUgbm9kZXMgb3V0cHV0IHRvIG9uZSBkYXRhIHZhbHVlOiAke2l9YCk7aWYodGhpcy5fYWxsRGF0YVtpXS5fZnJvbT1uLFwiQ29uc3RhbnRcIj09PW8ub3BUeXBlKXtpZighby5hdHRyaWJ1dGV8fDEhPT1vLmF0dHJpYnV0ZS5sZW5ndGh8fCFvLmF0dHJpYnV0ZVswXS50KXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO2lmKCFvLm91dHB1dHx8MSE9PW8ub3V0cHV0Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7ci5vdXRwdXRzLnBvcCgpLHIuZXhlY3V0ZU5vZGU9ITEsdGhpcy5fYWxsRGF0YVtpXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW2ldLnRlbnNvcj1zLlRlbnNvci5mcm9tUHJvdG8oby5hdHRyaWJ1dGVbMF0udCl9fX1mb3IobGV0IG49MDtuPHRoaXMuX25vZGVzLmxlbmd0aDtuKyspe2NvbnN0IHI9dGhpcy5fbm9kZXNbbl0sbz1lLm5vZGVbbl07aWYoIW8uaW5wdXQpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IGZvciBub2RlOiAke28ubmFtZX1gKTtmb3IoY29uc3QgZSBvZiBvLmlucHV0KXtjb25zdCBpPXQuZ2V0KGUpO2lmKHZvaWQgMD09PWkpe2lmKFwiXCI9PT1lJiYoMz09PW8uaW5wdXQubGVuZ3RofHw0PT09by5pbnB1dC5sZW5ndGgpJiZcIlJlc2l6ZVwiPT09by5vcFR5cGUpY29udGludWU7dGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7ZX0nIGZvciBub2RlOiAke28ubmFtZX1gKX1yLmlucHV0cy5wdXNoKGkpLHRoaXMuX2FsbERhdGFbaV0uX3RvLnB1c2gobil9fXJldHVybiEwfWJ1aWxkR3JhcGhGcm9tT3J0Rm9ybWF0KGUpe3ZhciB0LG4scjtjb25zdCBvPW5ldyBNYXA7dGhpcy5fYWxsRGF0YT1bXSx0aGlzLl9hbGxJbnB1dEluZGljZXM9W10sdGhpcy5fYWxsSW5wdXROYW1lcz1bXSx0aGlzLl9hbGxPdXRwdXRJbmRpY2VzPVtdLHRoaXMuX2FsbE91dHB1dE5hbWVzPVtdLHRoaXMuX25vZGVzPVtdO2NvbnN0IGk9bmV3IE1hcCxwPVtdO2ZvcihsZXQgaT0wO2k8ZS5pbnB1dHNMZW5ndGgoKTtpKyspe2NvbnN0IHM9ZS5pbnB1dHMoaSk7aWYoby5oYXMocykpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIGlucHV0IG5hbWU6ICR7c31gKTtmb3IobGV0IGk9MDtpPGUubm9kZUFyZ3NMZW5ndGgoKTtpKyspaWYoKG51bGw9PT0odD1lLm5vZGVBcmdzKGkpKXx8dm9pZCAwPT09dD92b2lkIDA6dC5uYW1lKCkpPT09cyl7Y29uc3QgdD1uZXcgbDtpZigobnVsbD09PShyPW51bGw9PT0obj1lLm5vZGVBcmdzKGkpKXx8dm9pZCAwPT09bj92b2lkIDA6bi50eXBlKCkpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyLnZhbHVlVHlwZSgpKSE9PXUuVHlwZUluZm9WYWx1ZS50ZW5zb3JfdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlIHR5cGUgZm9yIHRoZSBub2RlQXJnLlwiKTtjb25zdCBjPWUubm9kZUFyZ3MoaSkudHlwZSgpLnZhbHVlKG5ldyB1LlRlbnNvclR5cGVBbmRTaGFwZSksZD1hLlByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byhjLmVsZW1UeXBlKCkpLGY9Yy5zaGFwZSgpLGg9W107Zm9yKGxldCBlPTA7ZTxmLmRpbUxlbmd0aCgpO2UrKyloLnB1c2goYS5Mb25nVXRpbC5sb25nVG9OdW1iZXIoZi5kaW0oZSkudmFsdWUoKS5kaW1WYWx1ZSgpKSk7dC50eXBlPXtzaGFwZTp7ZGltczpofSx0ZW5zb3JUeXBlOmR9O2NvbnN0IGc9dGhpcy5fYWxsRGF0YS5wdXNoKHQpLTE7by5zZXQocyxnKSxwLnB1c2gocyl9fWZvcihsZXQgdD0wO3Q8ZS5pbml0aWFsaXplcnNMZW5ndGgoKTt0Kyspe2NvbnN0IG49ZS5pbml0aWFsaXplcnModCk7bGV0IHI9by5nZXQobi5uYW1lKCkpO2lmKHZvaWQgMD09PXIpe2NvbnN0IGU9bmV3IGwsdD1hLlByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChuKSxpPWEuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKG4uZGF0YVR5cGUoKSk7ZS50eXBlPXtzaGFwZTp7ZGltczp0fSx0ZW5zb3JUeXBlOml9LHI9dGhpcy5fYWxsRGF0YS5wdXNoKGUpLTEsby5zZXQobi5uYW1lKCkscil9dGhpcy5fYWxsRGF0YVtyXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW3JdLnRlbnNvcj1zLlRlbnNvci5mcm9tT3J0VGVuc29yKG4pfWZvcihsZXQgZT0wO2U8dGhpcy5fYWxsRGF0YS5sZW5ndGg7ZSsrKXRoaXMuX2FsbERhdGFbZV0udGVuc29yfHwodGhpcy5fYWxsSW5wdXRJbmRpY2VzLnB1c2goZSksdGhpcy5fYWxsSW5wdXROYW1lcy5wdXNoKHBbZV0pKTtmb3IobGV0IHQ9MDt0PGUub3V0cHV0c0xlbmd0aCgpO3QrKyl7Y29uc3Qgbj1lLm91dHB1dHModCk7aWYoby5oYXMobikpdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke259YCk7Y29uc3Qgcj10aGlzLl9hbGxEYXRhLnB1c2gobmV3IGwpLTE7by5zZXQobixyKSx0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLnB1c2gociksdGhpcy5fYWxsT3V0cHV0TmFtZXMucHVzaChuKX1pZighZS5ub2Rlcyl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBub2RlXCIpO2ZvcihsZXQgdD0wO3Q8ZS5ub2Rlc0xlbmd0aCgpO3QrKyl7Y29uc3Qgbj1lLm5vZGVzKHQpO2xldCByPW4ubmFtZSgpO2lmKCFyKWZvcihsZXQgZT0wO3I9YHVubmFtZWRfJHtuLm9wVHlwZSgpfV8ke2V9YCxpLmhhcyhyKTtlKyspO2lmKGkuaGFzKHIpKXRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBub2RlIG5hbWU6ICR7cn1gKTtjb25zdCBvPXRoaXMuX25vZGVzLnB1c2gobmV3IGMobixyKSktMTtpLnNldChyLG8pfWZvcihsZXQgdD0wO3Q8dGhpcy5fbm9kZXMubGVuZ3RoO3QrKyl7Y29uc3Qgbj10aGlzLl9ub2Rlc1t0XSxyPWUubm9kZXModCk7aWYobnVsbD09cil0aHJvdyBuZXcgRXJyb3IoYE5vIG5vZGUgZXhpc3RzIGF0IGluZGV4ICR7dH1gKTtpZigwPT09KG51bGw9PXI/dm9pZCAwOnIub3V0cHV0c0xlbmd0aCgpKSl0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke3IubmFtZX1gKTtmb3IobGV0IGU9MDtlPChudWxsPT1yP3ZvaWQgMDpyLm91dHB1dHNMZW5ndGgoKSk7ZSsrKXtjb25zdCBpPW51bGw9PXI/dm9pZCAwOnIub3V0cHV0cyhlKTtsZXQgYT1vLmdldChpKTtpZih2b2lkIDA9PT1hJiYoYT10aGlzLl9hbGxEYXRhLnB1c2gobmV3IGwpLTEsby5zZXQoaSxhKSksbi5vdXRwdXRzLnB1c2goYSksdm9pZCAwIT09dGhpcy5fYWxsRGF0YVthXS5fZnJvbSl0aHJvdyBuZXcgRXJyb3IoYG11bHRpcGxlIG5vZGVzIG91dHB1dCB0byBvbmUgZGF0YSB2YWx1ZTogJHthfWApO2lmKHRoaXMuX2FsbERhdGFbYV0uX2Zyb209dCxcIkNvbnN0YW50XCI9PT1yLm9wVHlwZSgpKXtpZigxIT09ci5hdHRyaWJ1dGVzTGVuZ3RoKCl8fCFyLmF0dHJpYnV0ZXMoMCkudCgpKXRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgYXR0cmlidXRlcyBvciBtaXNzaW5nIHRlbnNvciB2YWx1ZSBpbiBhdHRyaWJ1dGVzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yXCIpO2lmKDEhPT1yLm91dHB1dHNMZW5ndGgoKSl0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIG91dHB1dCBvciBpbmNvcnJlY3QgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3JcIik7bi5vdXRwdXRzLnBvcCgpLG4uZXhlY3V0ZU5vZGU9ITEsdGhpcy5fYWxsRGF0YVthXS5fZnJvbT0tMSx0aGlzLl9hbGxEYXRhW2FdLnRlbnNvcj1zLlRlbnNvci5mcm9tT3J0VGVuc29yKHIuYXR0cmlidXRlcygwKS50KCkpfX19Zm9yKGxldCB0PTA7dDx0aGlzLl9ub2Rlcy5sZW5ndGg7dCsrKXtjb25zdCBuPXRoaXMuX25vZGVzW3RdLHI9ZS5ub2Rlcyh0KTtpZigwPT09ci5pbnB1dHNMZW5ndGgoKSl0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgaW5wdXQgZm9yIG5vZGU6ICR7ci5uYW1lfWApO2ZvcihsZXQgZT0wO2U8ci5pbnB1dHNMZW5ndGgoKTtlKyspe2NvbnN0IGk9ci5pbnB1dHMoZSkscz1vLmdldChpKTtpZih2b2lkIDA9PT1zKXRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGlucHV0ICcke2l9JyBmb3Igbm9kZTogJHtyLm5hbWUoKX1gKTtuLmlucHV0cy5wdXNoKHMpLHRoaXMuX2FsbERhdGFbc10uX3RvLnB1c2godCl9fX1jaGVja0lzQWN5Y2xpYygpe2NvbnN0IGU9bmV3IFNldDt0aGlzLl9hbGxJbnB1dEluZGljZXMuZm9yRWFjaCgodD0+e3RoaXMuX2FsbERhdGFbdF0uX3RvLmZvckVhY2goKHQ9PntlLmFkZCh0KX0pKX0pKTtjb25zdCB0PUFycmF5LmZyb20oZSksbj1uZXcgQXJyYXkodGhpcy5fbm9kZXMubGVuZ3RoKS5maWxsKFwid2hpdGVcIik7Zm9yKDt0Lmxlbmd0aD4wOyl7Y29uc3QgZT10LnBvcCgpO1wiZ3JheVwiPT09bltlXT9uW2VdPVwiYmxhY2tcIjoodC5wdXNoKGUpLG5bZV09XCJncmF5XCIsdGhpcy5fbm9kZXNbZV0ub3V0cHV0cy5mb3JFYWNoKChyPT57Y29uc3Qgbz10aGlzLl9hbGxEYXRhW3JdO2lmKHZvaWQgMCE9PW8udGVuc29yKXRocm93IG5ldyBFcnJvcihcIm5vZGUgb3V0cHV0cyBzaG91bGQgbm90IGJlIGluaXRpYWxpemVkXCIpO2lmKG8uX2Zyb20hPT1lKXRocm93IG5ldyBFcnJvcihcImZyb20gcHJvcGVydHkgb2YgdGhlIFZhbHVlIG9iamVjdCBkb2Vzbid0IG1hdGNoIGluZGV4IG9mIE5vZGUgYmVpbmcgcHJvY2Vzc2VkXCIpO28uX3RvLmZvckVhY2goKGU9PntpZihcImdyYXlcIj09PW5bZV0pdGhyb3cgbmV3IEVycm9yKFwibW9kZWwgZ3JhcGggaXMgY3ljbGljXCIpO1wid2hpdGVcIj09PW5bZV0mJnQucHVzaChlKX0pKX0pKSl9fXRyYW5zZm9ybUdyYXBoKGUpe3RoaXMucmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpLHRoaXMucmVtb3ZlQWxsRHJvcG91dE5vZGVzKCksdGhpcy5mdXNlQ29udkFjdGl2YXRpb25Ob2RlcygpLGUmJmUudHJhbnNmb3JtR3JhcGgodGhpcyksdGhpcy5maW5hbGl6ZUdyYXBoKCl9ZmluYWxpemVHcmFwaCgpe2xldCBlPTA7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fbm9kZXMubGVuZ3RoLDApO2xldCBuPTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ub2Rlcy5sZW5ndGg7ZSsrKXRbZV09bix0aGlzLl9ub2Rlc1tlXS5leGVjdXRlTm9kZT8obiE9PWUmJih0aGlzLl9ub2Rlc1tuXT10aGlzLl9ub2Rlc1tlXSksbisrKTp0aGlzLl9ub2Rlc1tlXS5vdXRwdXRzLmZvckVhY2goKGU9Pnt0aGlzLl9hbGxEYXRhW2VdLl9mcm9tPS0yfSkpO3RoaXMuX25vZGVzLnNwbGljZShuLHRoaXMuX25vZGVzLmxlbmd0aC1uKTtmb3IobGV0IGU9MDtlPHRoaXMuX2FsbERhdGEubGVuZ3RoO2UrKyl7Y29uc3Qgbj10aGlzLl9hbGxEYXRhW2VdO3ZvaWQgMCE9PW4uX2Zyb20mJi0xIT09bi5fZnJvbSYmLTIhPT1uLl9mcm9tJiYobi5fZnJvbT10W24uX2Zyb21dKTtmb3IobGV0IGU9MDtlPG4uX3RvLmxlbmd0aDtlKyspe2lmKCEobi5fdG9bZV0+PTApKXRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgYSByZW1vdmVkIG5vZGVcIik7bi5fdG9bZV09dFtuLl90b1tlXV19fWU9MDtmb3IobGV0IHQ9MDt0PHRoaXMuX2FsbERhdGEubGVuZ3RoO3QrKylpZigtMiE9PXRoaXMuX2FsbERhdGFbdF0uZnJvbXx8LTEhPT10aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2YodCtlKSl7aWYoZT4wKXtsZXQgbj0tMTt2b2lkIDAhPT10aGlzLl9hbGxEYXRhW3RdLmZyb20mJi0xIT09dGhpcy5fYWxsRGF0YVt0XS5mcm9tPyhuPXRoaXMuX25vZGVzW3RoaXMuX2FsbERhdGFbdF0uZnJvbV0ub3V0cHV0cy5pbmRleE9mKHQrZSksLTEhPT1uJiYodGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVt0XS5mcm9tXS5vdXRwdXRzW25dPXQpKToobj10aGlzLl9hbGxJbnB1dEluZGljZXMuaW5kZXhPZih0K2UpLC0xIT09biYmKHRoaXMuX2FsbElucHV0SW5kaWNlc1tuXT10KSksdGhpcy5fYWxsRGF0YVt0XS50by5mb3JFYWNoKChyPT57bj10aGlzLl9ub2Rlc1tyXS5pbnB1dHMuaW5kZXhPZih0K2UpLC0xIT09biYmKHRoaXMuX25vZGVzW3JdLmlucHV0c1tuXT10KX0pKSwwPT09dGhpcy5fYWxsRGF0YVt0XS50by5sZW5ndGgmJihuPXRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZih0K2UpLC0xIT09biYmKHRoaXMuX2FsbE91dHB1dEluZGljZXNbbl09dCkpfX1lbHNlIGUrKyx0aGlzLl9hbGxEYXRhLnNwbGljZSh0LDEpLHQtLX1kZWxldGVOb2RlKGUpe2NvbnN0IHQ9dGhpcy5fbm9kZXNbZV07aWYodC5vdXRwdXRzLmxlbmd0aD4xKWZvcihsZXQgZT0xO2U8dC5vdXRwdXRzLmxlbmd0aDtlKyspaWYodGhpcy5fYWxsRGF0YVt0Lm91dHB1dHNbZV1dLnRvLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIk5vZGUgZGVsZXRpb24gd2l0aCBtb3JlIHRoYW4gb25lIG91dHB1dCBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXMgaXMgbm90IHN1cHBvcnRlZC4gXCIpO3QuZXhlY3V0ZU5vZGU9ITE7Y29uc3Qgbj10LmlucHV0c1swXSxyPXQub3V0cHV0c1swXSxvPXRoaXMuX2FsbERhdGFbcl0udG87Zm9yKGxldCBuPTA7bjx0LmlucHV0cy5sZW5ndGg7bisrKXtjb25zdCByPXRoaXMuX2FsbERhdGFbdC5pbnB1dHNbbl1dLnRvLmluZGV4T2YoZSk7aWYoLTE9PT1yKXRocm93IG5ldyBFcnJvcihcIlRoZSBWYWx1ZSBvYmplY3QgZG9lc24ndCBoYXZlIHRoZSBjdXJyZW50IE5vZGUgaW4gaXQncyAndG8nIHByb3BlcnR5IFwiKTt0aGlzLl9hbGxEYXRhW3QuaW5wdXRzW25dXS50by5zcGxpY2UociwxKX10aGlzLl9hbGxEYXRhW3JdLl90bz1bXTtjb25zdCBpPXRoaXMuX2FsbE91dHB1dEluZGljZXMuaW5kZXhPZihyKTtpZigtMSE9PWkmJih0aGlzLl9hbGxPdXRwdXRJbmRpY2VzW2ldPW4pLG8mJm8ubGVuZ3RoPjApZm9yKGNvbnN0IGUgb2Ygbyl7Y29uc3QgdD10aGlzLl9ub2Rlc1tlXS5pbnB1dHMuaW5kZXhPZihyKTtpZigtMT09PXQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIE5vZGUgb2JqZWN0IGRvZXNuJ3QgaGF2ZSB0aGUgb3V0cHV0IFZhbHVlIGluIGl0J3MgJ2lucHV0cycgcHJvcGVydHkgXCIpO3RoaXMuX25vZGVzW2VdLmlucHV0c1t0XT1uLHRoaXMuX2FsbERhdGFbbl0udG8ucHVzaChlKX19cmVtb3ZlQWxsRHJvcG91dE5vZGVzKCl7bGV0IGU9MDtmb3IoY29uc3QgdCBvZiB0aGlzLl9ub2Rlcyl7aWYoXCJEcm9wb3V0XCI9PT10Lm9wVHlwZSl7aWYoMSE9PXQuaW5wdXRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEcm9wb3V0IG5vZGVzIHNob3VsZCBvbmx5IGNvbnRhaW4gb25lIGlucHV0LiBcIik7aWYoMSE9PXQub3V0cHV0cy5sZW5ndGgmJjIhPT10Lm91dHB1dHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkRyb3BvdXQgbm9kZXMgc2hvdWxkIGNvbnRhaW4gZWl0aGVyIDEgb3IgMiBvdXRwdXQocylcIik7aWYoMj09PXQub3V0cHV0cy5sZW5ndGgmJjAhPT10aGlzLl9hbGxEYXRhW3Qub3V0cHV0c1sxXV0uX3RvLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJEcm9wb3V0IG5vZGVzJ3Mgc2Vjb25kIG91dHB1dCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZWQgYnkgb3RoZXIgbm9kZXNcIik7dGhpcy5kZWxldGVOb2RlKGUpfWUrK319cmVtb3ZlQWxsSWRlbnRpdHlOb2Rlcygpe2xldCBlPTA7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fbm9kZXMpXCJJZGVudGl0eVwiPT09dC5vcFR5cGUmJnRoaXMuZGVsZXRlTm9kZShlKSxlKyt9aXNBY3RpdmF0aW9uKGUpe3N3aXRjaChlLm9wVHlwZSl7Y2FzZVwiUmVsdVwiOmNhc2VcIlNpZ21vaWRcIjpjYXNlXCJDbGlwXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVzZUNvbnZBY3RpdmF0aW9uTm9kZXMoKXtmb3IoY29uc3QgZSBvZiB0aGlzLl9ub2RlcylpZihcIkNvbnZcIj09PWUub3BUeXBlKXtjb25zdCB0PXRoaXMuX2FsbERhdGFbZS5vdXRwdXRzWzBdXS5fdG87aWYoMT09PXQubGVuZ3RoJiZ0aGlzLmlzQWN0aXZhdGlvbih0aGlzLl9ub2Rlc1t0WzBdXSkpe2NvbnN0IG49dGhpcy5fbm9kZXNbdFswXV07aWYoXCJDbGlwXCI9PT1uLm9wVHlwZSlpZigxPT09bi5pbnB1dHMubGVuZ3RoKXRyeXtlLmF0dHJpYnV0ZXMuc2V0KFwiYWN0aXZhdGlvbl9wYXJhbXNcIixcImZsb2F0c1wiLFtuLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoXCJtaW5cIiksbi5hdHRyaWJ1dGVzLmdldEZsb2F0KFwibWF4XCIpXSl9Y2F0Y2godCl7ZS5hdHRyaWJ1dGVzLnNldChcImFjdGl2YXRpb25fcGFyYW1zXCIsXCJmbG9hdHNcIixbYS5NSU5fQ0xJUCxhLk1BWF9DTElQXSl9ZWxzZXtpZighKG4uaW5wdXRzLmxlbmd0aD49MyYmdm9pZCAwIT09dGhpcy5fYWxsRGF0YVtuLmlucHV0c1sxXV0udGVuc29yJiZ2b2lkIDAhPT10aGlzLl9hbGxEYXRhW24uaW5wdXRzWzJdXS50ZW5zb3IpKWNvbnRpbnVlO2UuYXR0cmlidXRlcy5zZXQoXCJhY3RpdmF0aW9uX3BhcmFtc1wiLFwiZmxvYXRzXCIsW3RoaXMuX2FsbERhdGFbbi5pbnB1dHNbMV1dLnRlbnNvci5mbG9hdERhdGFbMF0sdGhpcy5fYWxsRGF0YVtuLmlucHV0c1syXV0udGVuc29yLmZsb2F0RGF0YVswXV0pfWUuYXR0cmlidXRlcy5zZXQoXCJhY3RpdmF0aW9uXCIsXCJzdHJpbmdcIixuLm9wVHlwZSksdGhpcy5kZWxldGVOb2RlKHRbMF0pfX19fX0sMTMxNTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubm93PXQuUHJvZmlsZXI9dC5Mb2dnZXI9dm9pZCAwO2NvbnN0IG49e3ZlcmJvc2U6MWUzLGluZm86MmUzLHdhcm5pbmc6NGUzLGVycm9yOjVlMyxmYXRhbDo2ZTN9LHI9e25vbmU6bmV3IGNsYXNze2xvZyhlLHQsbil7fX0sY29uc29sZTpuZXcgY2xhc3N7bG9nKGUsdCxuKXtjb25zb2xlLmxvZyhgJHt0aGlzLmNvbG9yKGUpfSAke24/XCJcdTAwMWJbMzVtXCIrbitcIlx1MDAxYlswbSBcIjpcIlwifSR7dH1gKX1jb2xvcihlKXtzd2l0Y2goZSl7Y2FzZVwidmVyYm9zZVwiOnJldHVyblwiXHUwMDFiWzM0OzQwbXZcdTAwMWJbMG1cIjtjYXNlXCJpbmZvXCI6cmV0dXJuXCJcdTAwMWJbMzJtaVx1MDAxYlswbVwiO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm5cIlx1MDAxYlszMDs0M213XHUwMDFiWzBtXCI7Y2FzZVwiZXJyb3JcIjpyZXR1cm5cIlx1MDAxYlszMTs0MG1lXHUwMDFiWzBtXCI7Y2FzZVwiZmF0YWxcIjpyZXR1cm5cIlx1MDAxYlsxMDFtZlx1MDAxYlswbVwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBzZXZlcml0eTogJHtlfWApfX19fSxvPXtwcm92aWRlcjpcImNvbnNvbGVcIixtaW5pbWFsU2V2ZXJpdHk6XCJ3YXJuaW5nXCIsbG9nRGF0ZVRpbWU6ITAsbG9nU291cmNlTG9jYXRpb246ITF9O2xldCBpPXtcIlwiOm99O2Z1bmN0aW9uIHMoZSx0LG4scil7aWYodm9pZCAwPT09dClyZXR1cm4gbz1lLHt2ZXJib3NlOnMudmVyYm9zZS5iaW5kKG51bGwsbyksaW5mbzpzLmluZm8uYmluZChudWxsLG8pLHdhcm5pbmc6cy53YXJuaW5nLmJpbmQobnVsbCxvKSxlcnJvcjpzLmVycm9yLmJpbmQobnVsbCxvKSxmYXRhbDpzLmZhdGFsLmJpbmQobnVsbCxvKX07aWYodm9pZCAwPT09bilhKGUsdCk7ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgbiYmdm9pZCAwPT09cilhKGUsdCk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgbiYmdm9pZCAwPT09cilhKGUsbiwwLHQpO2Vsc2V7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIG58fFwibnVtYmVyXCIhPXR5cGVvZiByKXRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnB1dCBpcyB2YWxpZFwiKTthKGUsbiwwLHQpfXZhciBvfWZ1bmN0aW9uIGEoZSx0LG8scyl7Y29uc3QgYT1pW3N8fFwiXCJdfHxpW1wiXCJdO25bZV08blthLm1pbmltYWxTZXZlcml0eV18fChhLmxvZ0RhdGVUaW1lJiYodD1gJHsobmV3IERhdGUpLnRvSVNPU3RyaW5nKCl9fCR7dH1gKSxhLmxvZ1NvdXJjZUxvY2F0aW9uLHJbYS5wcm92aWRlcl0ubG9nKGUsdCxzKSl9IWZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSl7aT17fSxuKFwiXCIsZXx8e30pfWZ1bmN0aW9uIG4oZSxuKXtpZihcIipcIj09PWUpdChuKTtlbHNle2NvbnN0IHQ9aVtlXXx8bztpW2VdPXtwcm92aWRlcjpuLnByb3ZpZGVyfHx0LnByb3ZpZGVyLG1pbmltYWxTZXZlcml0eTpuLm1pbmltYWxTZXZlcml0eXx8dC5taW5pbWFsU2V2ZXJpdHksbG9nRGF0ZVRpbWU6dm9pZCAwPT09bi5sb2dEYXRlVGltZT90LmxvZ0RhdGVUaW1lOm4ubG9nRGF0ZVRpbWUsbG9nU291cmNlTG9jYXRpb246dm9pZCAwPT09bi5sb2dTb3VyY2VMb2NhdGlvbj90LmxvZ1NvdXJjZUxvY2F0aW9uOm4ubG9nU291cmNlTG9jYXRpb259fX1lLnZlcmJvc2U9ZnVuY3Rpb24odCxuKXtlKFwidmVyYm9zZVwiLHQsbil9LGUuaW5mbz1mdW5jdGlvbih0LG4pe2UoXCJpbmZvXCIsdCxuKX0sZS53YXJuaW5nPWZ1bmN0aW9uKHQsbil7ZShcIndhcm5pbmdcIix0LG4pfSxlLmVycm9yPWZ1bmN0aW9uKHQsbil7ZShcImVycm9yXCIsdCxuKX0sZS5mYXRhbD1mdW5jdGlvbih0LG4pe2UoXCJmYXRhbFwiLHQsbil9LGUucmVzZXQ9dCxlLnNldD1uLGUuc2V0V2l0aEVudj1mdW5jdGlvbihlKXtjb25zdCB0PXt9O2UubG9nTGV2ZWwmJih0Lm1pbmltYWxTZXZlcml0eT1lLmxvZ0xldmVsKSxuKFwiXCIsdCl9fShzfHwocz17fSkpLHQuTG9nZ2VyPXM7Y2xhc3MgdXtjb25zdHJ1Y3RvcihlLHQsbixyLG8saSl7dGhpcy5jYXRlZ29yeT1lLHRoaXMubmFtZT10LHRoaXMuc3RhcnRUaW1lPW4sdGhpcy5lbmRDYWxsYmFjaz1yLHRoaXMudGltZXI9byx0aGlzLmN0eD1pfWFzeW5jIGVuZCgpe3JldHVybiB0aGlzLmVuZENhbGxiYWNrKHRoaXMpfWFzeW5jIGNoZWNrVGltZXIoKXtpZih2b2lkIDA9PT10aGlzLmN0eHx8dm9pZCAwPT09dGhpcy50aW1lcil0aHJvdyBuZXcgRXJyb3IoXCJObyB3ZWJnbCB0aW1lciBmb3VuZFwiKTtyZXR1cm4gdGhpcy5jdHguZW5kVGltZXIoKSx0aGlzLmN0eC53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHRoaXMudGltZXIpfX1jbGFzcyBse2NvbnN0cnVjdG9yKGUsdCxuLHIpe3RoaXMuY2F0ZWdvcnk9ZSx0aGlzLm5hbWU9dCx0aGlzLnN0YXJ0VGltZT1uLHRoaXMuZW5kVGltZT1yfX10LlByb2ZpbGVyPWNsYXNze3N0YXRpYyBjcmVhdGUoZSl7cmV0dXJuIHZvaWQgMD09PWU/bmV3IHRoaXM6bmV3IHRoaXMoZS5tYXhOdW1iZXJFdmVudHMsZS5mbHVzaEJhdGNoU2l6ZSxlLmZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyl9Y29uc3RydWN0b3IoZSx0LG4pe3RoaXMuX3N0YXJ0ZWQ9ITEsdGhpcy5fZmx1c2hQb2ludGVyPTAsdGhpcy5fc3RhcnRlZD0hMSx0aGlzLl9tYXhOdW1iZXJFdmVudHM9dm9pZCAwPT09ZT8xZTQ6ZSx0aGlzLl9mbHVzaEJhdGNoU2l6ZT12b2lkIDA9PT10PzEwOnQsdGhpcy5fZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzPXZvaWQgMD09PW4/NWUzOm59c3RhcnQoKXt0aGlzLl9zdGFydGVkPSEwLHRoaXMuX3RpbWluZ0V2ZW50cz1bXSx0aGlzLl9mbHVzaFRpbWU9KDAsdC5ub3cpKCksdGhpcy5fZmx1c2hQb2ludGVyPTB9c3RvcCgpe2Zvcih0aGlzLl9zdGFydGVkPSExO3RoaXMuX2ZsdXNoUG9pbnRlcjx0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoO3RoaXMuX2ZsdXNoUG9pbnRlcisrKXRoaXMubG9nT25lRXZlbnQodGhpcy5fdGltaW5nRXZlbnRzW3RoaXMuX2ZsdXNoUG9pbnRlcl0pfWV2ZW50KGUsdCxuLHIpe2NvbnN0IG89dGhpcy5fc3RhcnRlZD90aGlzLmJlZ2luKGUsdCxyKTp2b2lkIDA7bGV0IGk9ITE7Y29uc3Qgcz1uKCk7aWYocyYmXCJmdW5jdGlvblwiPT10eXBlb2Ygcy50aGVuKXJldHVybiBpPSEwLG5ldyBQcm9taXNlKCgoZSx0KT0+e3MudGhlbigoYXN5bmMgdD0+e28mJmF3YWl0IG8uZW5kKCksZSh0KX0pLChhc3luYyBlPT57byYmYXdhaXQgby5lbmQoKSx0KGUpfSkpfSkpO2lmKCFpJiZvKXtjb25zdCBlPW8uZW5kKCk7aWYoZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS50aGVuKXJldHVybiBuZXcgUHJvbWlzZSgoKHQsbik9PntlLnRoZW4oKCgpPT57dChzKX0pLChlPT57bihlKX0pKX0pKX1yZXR1cm4gc31iZWdpbihlLG4scil7aWYoIXRoaXMuX3N0YXJ0ZWQpdGhyb3cgbmV3IEVycm9yKFwicHJvZmlsZXIgaXMgbm90IHN0YXJ0ZWQgeWV0XCIpO2lmKHZvaWQgMD09PXIpe2NvbnN0IHI9KDAsdC5ub3cpKCk7cmV0dXJuIHRoaXMuZmx1c2gociksbmV3IHUoZSxuLHIsKGU9PnRoaXMuZW5kU3luYyhlKSkpfXtjb25zdCB0PXIuYmVnaW5UaW1lcigpO3JldHVybiBuZXcgdShlLG4sMCwoYXN5bmMgZT0+dGhpcy5lbmQoZSkpLHQscil9fWFzeW5jIGVuZChlKXtjb25zdCB0PWF3YWl0IGUuY2hlY2tUaW1lcigpO3RoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGg8dGhpcy5fbWF4TnVtYmVyRXZlbnRzJiYodGhpcy5fdGltaW5nRXZlbnRzLnB1c2gobmV3IGwoZS5jYXRlZ29yeSxlLm5hbWUsZS5zdGFydFRpbWUsdCkpLHRoaXMuZmx1c2godCkpfWVuZFN5bmMoZSl7Y29uc3Qgbj0oMCx0Lm5vdykoKTt0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoPHRoaXMuX21heE51bWJlckV2ZW50cyYmKHRoaXMuX3RpbWluZ0V2ZW50cy5wdXNoKG5ldyBsKGUuY2F0ZWdvcnksZS5uYW1lLGUuc3RhcnRUaW1lLG4pKSx0aGlzLmZsdXNoKG4pKX1sb2dPbmVFdmVudChlKXt0LkxvZ2dlci52ZXJib3NlKGBQcm9maWxlci4ke2UuY2F0ZWdvcnl9YCxgJHsoZS5lbmRUaW1lLWUuc3RhcnRUaW1lKS50b0ZpeGVkKDIpfW1zIG9uIGV2ZW50ICcke2UubmFtZX0nIGF0ICR7ZS5lbmRUaW1lLnRvRml4ZWQoMil9YCl9Zmx1c2goZSl7aWYodGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aC10aGlzLl9mbHVzaFBvaW50ZXI+PXRoaXMuX2ZsdXNoQmF0Y2hTaXplfHxlLXRoaXMuX2ZsdXNoVGltZT49dGhpcy5fZmx1c2hJbnRlcnZhbEluTWlsbGlzZWNvbmRzKXtmb3IoY29uc3QgZT10aGlzLl9mbHVzaFBvaW50ZXI7dGhpcy5fZmx1c2hQb2ludGVyPGUrdGhpcy5fZmx1c2hCYXRjaFNpemUmJnRoaXMuX2ZsdXNoUG9pbnRlcjx0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoO3RoaXMuX2ZsdXNoUG9pbnRlcisrKXRoaXMubG9nT25lRXZlbnQodGhpcy5fdGltaW5nRXZlbnRzW3RoaXMuX2ZsdXNoUG9pbnRlcl0pO3RoaXMuX2ZsdXNoVGltZT0oMCx0Lm5vdykoKX19Z2V0IHN0YXJ0ZWQoKXtyZXR1cm4gdGhpcy5fc3RhcnRlZH19LHQubm93PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBwZXJmb3JtYW5jZSYmcGVyZm9ybWFuY2Uubm93PygpPT5wZXJmb3JtYW5jZS5ub3coKTpEYXRlLm5vd30sMTc0NTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Nb2RlbD12b2lkIDA7Y29uc3Qgcj1uKDU2ODYpLG89big0NjYyKSxpPW4oNTEyNykscz1uKDI0NDYpLGE9big3MjczKTt2YXIgdT1pLm9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7dC5Nb2RlbD1jbGFzc3tjb25zdHJ1Y3Rvcigpe31sb2FkKGUsdCxuKXtpZighbil0cnl7cmV0dXJuIHZvaWQgdGhpcy5sb2FkRnJvbU9ubnhGb3JtYXQoZSx0KX1jYXRjaChlKXtpZih2b2lkIDAhPT1uKXRocm93IGV9dGhpcy5sb2FkRnJvbU9ydEZvcm1hdChlLHQpfWxvYWRGcm9tT25ueEZvcm1hdChlLHQpe2NvbnN0IG49cy5vbm54Lk1vZGVsUHJvdG8uZGVjb2RlKGUpO2lmKGEuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG4uaXJWZXJzaW9uKTwzKXRocm93IG5ldyBFcnJvcihcIm9ubHkgc3VwcG9ydCBPTk5YIG1vZGVsIHdpdGggSVJfVkVSU0lPTj49M1wiKTt0aGlzLl9vcHNldHM9bi5vcHNldEltcG9ydC5tYXAoKGU9Pih7ZG9tYWluOmUuZG9tYWluLHZlcnNpb246YS5Mb25nVXRpbC5sb25nVG9OdW1iZXIoZS52ZXJzaW9uKX0pKSksdGhpcy5fZ3JhcGg9by5HcmFwaC5mcm9tKG4uZ3JhcGgsdCl9bG9hZEZyb21PcnRGb3JtYXQoZSx0KXtjb25zdCBuPW5ldyByLmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIoZSksaT11LkluZmVyZW5jZVNlc3Npb24uZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihuKS5tb2RlbCgpO2lmKGEuTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKGkuaXJWZXJzaW9uKCkpPDMpdGhyb3cgbmV3IEVycm9yKFwib25seSBzdXBwb3J0IE9OTlggbW9kZWwgd2l0aCBJUl9WRVJTSU9OPj0zXCIpO3RoaXMuX29wc2V0cz1bXTtmb3IobGV0IGU9MDtlPGkub3BzZXRJbXBvcnRMZW5ndGgoKTtlKyspe2NvbnN0IHQ9aS5vcHNldEltcG9ydChlKTt0aGlzLl9vcHNldHMucHVzaCh7ZG9tYWluOm51bGw9PXQ/dm9pZCAwOnQuZG9tYWluKCksdmVyc2lvbjphLkxvbmdVdGlsLmxvbmdUb051bWJlcih0LnZlcnNpb24oKSl9KX10aGlzLl9ncmFwaD1vLkdyYXBoLmZyb20oaS5ncmFwaCgpLHQpfWdldCBncmFwaCgpe3JldHVybiB0aGlzLl9ncmFwaH1nZXQgb3BzZXRzKCl7cmV0dXJuIHRoaXMuX29wc2V0c319fSw2MTQ1OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5GTE9BVF9UWVBFUz10LklOVF9UWVBFUz10Lk5VTUJFUl9UWVBFUz12b2lkIDAsdC5OVU1CRVJfVFlQRVM9W1wiZmxvYXQzMlwiLFwiZmxvYXQ2NFwiLFwiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sdC5JTlRfVFlQRVM9W1wiaW50MzJcIixcImludDE2XCIsXCJpbnQ4XCIsXCJ1aW50MTZcIixcInVpbnQzMlwiLFwidWludDhcIl0sdC5GTE9BVF9UWVBFUz1bXCJmbG9hdDMyXCIsXCJmbG9hdDY0XCJdfSw1ODgxOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gbihlLHQpe2lmKHQuZW5kc1dpdGgoXCIrXCIpKXtjb25zdCBuPU51bWJlci5wYXJzZUludCh0LnN1YnN0cmluZygwLHQubGVuZ3RoLTEpLDEwKTtyZXR1cm4haXNOYU4obikmJm48PWV9aWYoMj09PXQuc3BsaXQoXCItXCIpLmxlbmd0aCl7Y29uc3Qgbj10LnNwbGl0KFwiLVwiKSxyPU51bWJlci5wYXJzZUludChuWzBdLDEwKSxvPU51bWJlci5wYXJzZUludChuWzFdLDEwKTtyZXR1cm4haXNOYU4ocikmJiFpc05hTihvKSYmcjw9ZSYmZTw9b31yZXR1cm4gTnVtYmVyLnBhcnNlSW50KHQsMTApPT09ZX1PYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnJlc29sdmVPcGVyYXRvcj12b2lkIDAsdC5yZXNvbHZlT3BlcmF0b3I9ZnVuY3Rpb24oZSx0LHIpe2Zvcihjb25zdCBvIG9mIHIpe2NvbnN0IHI9b1swXSxpPW9bMV0scz1vWzJdLGE9b1szXSx1PW9bNF07aWYoZS5vcFR5cGU9PT1yKWZvcihjb25zdCBlIG9mIHQpaWYoKGUuZG9tYWluPT09aXx8XCJhaS5vbm54XCI9PT1lLmRvbWFpbiYmXCJcIj09PWkpJiZuKGUudmVyc2lvbixzKSlyZXR1cm57b3BJbXBsOmEsb3BJbml0OnV9fXRocm93IG5ldyBUeXBlRXJyb3IoYGNhbm5vdCByZXNvbHZlIG9wZXJhdG9yICcke2Uub3BUeXBlfScgd2l0aCBvcHNldHM6ICR7dC5tYXAoKGU9PmAke2UuZG9tYWlufHxcImFpLm9ubnhcIn0gdiR7ZS52ZXJzaW9ufWApKS5qb2luKFwiLCBcIil9YCl9fSw1MTI3OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lm9ubnhydW50aW1lPXZvaWQgMDtjb25zdCByPW4oNTY4Nik7dmFyIG8saTtvPXQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSxmdW5jdGlvbihlKXtsZXQgdDshZnVuY3Rpb24oZSl7ZVtlLlVOREVGSU5FRD0wXT1cIlVOREVGSU5FRFwiLGVbZS5GTE9BVD0xXT1cIkZMT0FUXCIsZVtlLklOVD0yXT1cIklOVFwiLGVbZS5TVFJJTkc9M109XCJTVFJJTkdcIixlW2UuVEVOU09SPTRdPVwiVEVOU09SXCIsZVtlLkdSQVBIPTVdPVwiR1JBUEhcIixlW2UuRkxPQVRTPTZdPVwiRkxPQVRTXCIsZVtlLklOVFM9N109XCJJTlRTXCIsZVtlLlNUUklOR1M9OF09XCJTVFJJTkdTXCIsZVtlLlRFTlNPUlM9OV09XCJURU5TT1JTXCIsZVtlLkdSQVBIUz0xMF09XCJHUkFQSFNcIixlW2UuU1BBUlNFX1RFTlNPUj0xMV09XCJTUEFSU0VfVEVOU09SXCIsZVtlLlNQQVJTRV9URU5TT1JTPTEyXT1cIlNQQVJTRV9URU5TT1JTXCJ9KHQ9ZS5BdHRyaWJ1dGVUeXBlfHwoZS5BdHRyaWJ1dGVUeXBlPXt9KSl9KChpPW8uZXhwZXJpbWVudGFsfHwoby5leHBlcmltZW50YWw9e30pKS5mYnN8fChpLmZicz17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7bGV0IHQ7IWZ1bmN0aW9uKGUpe2VbZS5VTktOT1dOPTBdPVwiVU5LTk9XTlwiLGVbZS5WQUxVRT0xXT1cIlZBTFVFXCIsZVtlLlBBUkFNPTJdPVwiUEFSQU1cIn0odD1lLkRpbWVuc2lvblZhbHVlVHlwZXx8KGUuRGltZW5zaW9uVmFsdWVUeXBlPXt9KSl9KGUuZmJzfHwoZS5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7bGV0IHQ7IWZ1bmN0aW9uKGUpe2VbZS5VTkRFRklORUQ9MF09XCJVTkRFRklORURcIixlW2UuRkxPQVQ9MV09XCJGTE9BVFwiLGVbZS5VSU5UOD0yXT1cIlVJTlQ4XCIsZVtlLklOVDg9M109XCJJTlQ4XCIsZVtlLlVJTlQxNj00XT1cIlVJTlQxNlwiLGVbZS5JTlQxNj01XT1cIklOVDE2XCIsZVtlLklOVDMyPTZdPVwiSU5UMzJcIixlW2UuSU5UNjQ9N109XCJJTlQ2NFwiLGVbZS5TVFJJTkc9OF09XCJTVFJJTkdcIixlW2UuQk9PTD05XT1cIkJPT0xcIixlW2UuRkxPQVQxNj0xMF09XCJGTE9BVDE2XCIsZVtlLkRPVUJMRT0xMV09XCJET1VCTEVcIixlW2UuVUlOVDMyPTEyXT1cIlVJTlQzMlwiLGVbZS5VSU5UNjQ9MTNdPVwiVUlOVDY0XCIsZVtlLkNPTVBMRVg2ND0xNF09XCJDT01QTEVYNjRcIixlW2UuQ09NUExFWDEyOD0xNV09XCJDT01QTEVYMTI4XCIsZVtlLkJGTE9BVDE2PTE2XT1cIkJGTE9BVDE2XCIsZVtlLkZMT0FUOEU0TTNGTj0xN109XCJGTE9BVDhFNE0zRk5cIixlW2UuRkxPQVQ4RTRNM0ZOVVo9MThdPVwiRkxPQVQ4RTRNM0ZOVVpcIixlW2UuRkxPQVQ4RTVNMj0xOV09XCJGTE9BVDhFNU0yXCIsZVtlLkZMT0FUOEU1TTJGTlVaPTIwXT1cIkZMT0FUOEU1TTJGTlVaXCJ9KHQ9ZS5UZW5zb3JEYXRhVHlwZXx8KGUuVGVuc29yRGF0YVR5cGU9e30pKX0oZS5mYnN8fChlLmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtsZXQgdDshZnVuY3Rpb24oZSl7ZVtlLlByaW1pdGl2ZT0wXT1cIlByaW1pdGl2ZVwiLGVbZS5GdXNlZD0xXT1cIkZ1c2VkXCJ9KHQ9ZS5Ob2RlVHlwZXx8KGUuTm9kZVR5cGU9e30pKX0oZS5mYnN8fChlLmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtsZXQgdDshZnVuY3Rpb24oZSl7ZVtlLk5PTkU9MF09XCJOT05FXCIsZVtlLnRlbnNvcl90eXBlPTFdPVwidGVuc29yX3R5cGVcIixlW2Uuc2VxdWVuY2VfdHlwZT0yXT1cInNlcXVlbmNlX3R5cGVcIixlW2UubWFwX3R5cGU9M109XCJtYXBfdHlwZVwifSh0PWUuVHlwZUluZm9WYWx1ZXx8KGUuVHlwZUluZm9WYWx1ZT17fSkpfShlLmZic3x8KGUuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzU2hhcGUoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2hhcGUoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWRpbSh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfWRpbUxlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdGF0aWMgc3RhcnRTaGFwZShlKXtlLnN0YXJ0T2JqZWN0KDEpfXN0YXRpYyBhZGREaW0oZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgY3JlYXRlRGltVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbVZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBlbmRTaGFwZShlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU2hhcGUoZSx0KXtyZXR1cm4gbi5zdGFydFNoYXBlKGUpLG4uYWRkRGltKGUsdCksbi5lbmRTaGFwZShlKX19dC5TaGFwZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvbihlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9dmFsdWUodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfWRlbm90YXRpb24oZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1zdGF0aWMgc3RhcnREaW1lbnNpb24oZSl7ZS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkVmFsdWUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkRGVub3RhdGlvbihlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBlbmREaW1lbnNpb24oZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvbihlLHQscil7cmV0dXJuIG4uc3RhcnREaW1lbnNpb24oZSksbi5hZGRWYWx1ZShlLHQpLG4uYWRkRGVub3RhdGlvbihlLHIpLG4uZW5kRGltZW5zaW9uKGUpfX10LkRpbWVuc2lvbj1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzRGltZW5zaW9uVmFsdWUoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWRpbVR5cGUoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDgodGhpcy5iYl9wb3MrdCk6ZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOfWRpbVZhbHVlKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcytlKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1QYXJhbShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXN0YXRpYyBzdGFydERpbWVuc2lvblZhbHVlKGUpe2Uuc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZERpbVR5cGUodCxuKXt0LmFkZEZpZWxkSW50OCgwLG4sZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZS5VTktOT1dOKX1zdGF0aWMgYWRkRGltVmFsdWUoZSx0KXtlLmFkZEZpZWxkSW50NjQoMSx0LGUuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkRGltUGFyYW0oZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgZW5kRGltZW5zaW9uVmFsdWUoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZURpbWVuc2lvblZhbHVlKGUsdCxyLG8pe3JldHVybiBuLnN0YXJ0RGltZW5zaW9uVmFsdWUoZSksbi5hZGREaW1UeXBlKGUsdCksbi5hZGREaW1WYWx1ZShlLHIpLG4uYWRkRGltUGFyYW0oZSxvKSxuLmVuZERpbWVuc2lvblZhbHVlKGUpfX10LkRpbWVuc2lvblZhbHVlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNUZW5zb3JUeXBlQW5kU2hhcGUoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yVHlwZUFuZFNoYXBlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1lbGVtVHlwZSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrdCk6ZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRH1zaGFwZSh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlNoYXBlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKGUpe2Uuc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEVsZW1UeXBlKHQsbil7dC5hZGRGaWVsZEludDMyKDAsbixlLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkU2hhcGUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgZW5kVGVuc29yVHlwZUFuZFNoYXBlKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3JUeXBlQW5kU2hhcGUoZSx0LHIpe3JldHVybiBuLnN0YXJ0VGVuc29yVHlwZUFuZFNoYXBlKGUpLG4uYWRkRWxlbVR5cGUoZSx0KSxuLmFkZFNoYXBlKGUsciksbi5lbmRUZW5zb3JUeXBlQW5kU2hhcGUoZSl9fXQuVGVuc29yVHlwZUFuZFNoYXBlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNNYXBUeXBlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01hcFR5cGUoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWtleVR5cGUoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK3QpOmUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9dmFsdWVUeXBlKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRNYXBUeXBlKGUpe2Uuc3RhcnRPYmplY3QoMil9c3RhdGljIGFkZEtleVR5cGUodCxuKXt0LmFkZEZpZWxkSW50MzIoMCxuLGUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRWYWx1ZVR5cGUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgZW5kTWFwVHlwZShlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTWFwVHlwZShlLHQscil7cmV0dXJuIG4uc3RhcnRNYXBUeXBlKGUpLG4uYWRkS2V5VHlwZShlLHQpLG4uYWRkVmFsdWVUeXBlKGUsciksbi5lbmRNYXBUeXBlKGUpfX10Lk1hcFR5cGU9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc1NlcXVlbmNlVHlwZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXF1ZW5jZVR5cGUoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWVsZW1UeXBlKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRTZXF1ZW5jZVR5cGUoZSl7ZS5zdGFydE9iamVjdCgxKX1zdGF0aWMgYWRkRWxlbVR5cGUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgZW5kU2VxdWVuY2VUeXBlKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVTZXF1ZW5jZVR5cGUoZSx0KXtyZXR1cm4gbi5zdGFydFNlcXVlbmNlVHlwZShlKSxuLmFkZEVsZW1UeXBlKGUsdCksbi5lbmRTZXF1ZW5jZVR5cGUoZSl9fXQuU2VxdWVuY2VUeXBlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXsoZS5mYnN8fChlLmZicz17fSkpLkVkZ2VFbmQ9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31ub2RlSW5kZXgoKXtyZXR1cm4gdGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zKX1zcmNBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys0KX1kc3RBcmdJbmRleCgpe3JldHVybiB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcys4KX1zdGF0aWMgY3JlYXRlRWRnZUVuZChlLHQsbixyKXtyZXR1cm4gZS5wcmVwKDQsMTIpLGUud3JpdGVJbnQzMihyKSxlLndyaXRlSW50MzIobiksZS53cml0ZUludDMyKHQpLGUub2Zmc2V0KCl9fX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlRWRnZShlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlRWRnZShlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9bm9kZUluZGV4KCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYl9wb3MrZSk6MH1pbnB1dEVkZ2VzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKS5fX2luaXQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSsxMip0LHRoaXMuYmIpOm51bGx9aW5wdXRFZGdlc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1vdXRwdXRFZGdlcyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCkuX19pbml0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrMTIqdCx0aGlzLmJiKTpudWxsfW91dHB1dEVkZ2VzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0YXRpYyBzdGFydE5vZGVFZGdlKGUpe2Uuc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE5vZGVJbmRleChlLHQpe2UuYWRkRmllbGRJbnQzMigwLHQsMCl9c3RhdGljIGFkZElucHV0RWRnZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgc3RhcnRJbnB1dEVkZ2VzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3RvcigxMix0LDQpfXN0YXRpYyBhZGRPdXRwdXRFZGdlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBzdGFydE91dHB1dEVkZ2VzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3RvcigxMix0LDQpfXN0YXRpYyBlbmROb2RlRWRnZShlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2UoZSx0LHIsbyl7cmV0dXJuIG4uc3RhcnROb2RlRWRnZShlKSxuLmFkZE5vZGVJbmRleChlLHQpLG4uYWRkSW5wdXRFZGdlcyhlLHIpLG4uYWRkT3V0cHV0RWRnZXMoZSxvKSxuLmVuZE5vZGVFZGdlKGUpfX10Lk5vZGVFZGdlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNOb2RlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc05vZGUoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfW5hbWUoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1kb2NTdHJpbmcoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1kb21haW4oZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1zaW5jZVZlcnNpb24oKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcytlKTowfWluZGV4KCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkVWludDMyKHRoaXMuYmJfcG9zK2UpOjB9b3BUeXBlKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXR5cGUoKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3Bvcyt0KTplLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlfWV4ZWN1dGlvblByb3ZpZGVyVHlwZShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1pbnB1dHMoZSx0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCplLHQpOm51bGx9aW5wdXRzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1vdXRwdXRzKGUsdCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqZSx0KTpudWxsfW91dHB1dHNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfWF0dHJpYnV0ZXModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9YXR0cmlidXRlc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9aW5wdXRBcmdDb3VudHMoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSs0KmUpOjB9aW5wdXRBcmdDb3VudHNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfWlucHV0QXJnQ291bnRzQXJyYXkoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI2KTtyZXR1cm4gZT9uZXcgSW50MzJBcnJheSh0aGlzLmJiLmJ5dGVzKCkuYnVmZmVyLHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0K3RoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrZSksdGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSkpOm51bGx9aW1wbGljaXRJbnB1dHMoZSx0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCplLHQpOm51bGx9aW1wbGljaXRJbnB1dHNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0YXRpYyBzdGFydE5vZGUoZSl7ZS5zdGFydE9iamVjdCgxMyl9c3RhdGljIGFkZE5hbWUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGFkZERvbWFpbihlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBhZGRTaW5jZVZlcnNpb24oZSx0KXtlLmFkZEZpZWxkSW50MzIoMyx0LDApfXN0YXRpYyBhZGRJbmRleChlLHQpe2UuYWRkRmllbGRJbnQzMig0LHQsMCl9c3RhdGljIGFkZE9wVHlwZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoNSx0LDApfXN0YXRpYyBhZGRUeXBlKHQsbil7dC5hZGRGaWVsZEludDMyKDYsbixlLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUuUHJpbWl0aXZlKX1zdGF0aWMgYWRkRXhlY3V0aW9uUHJvdmlkZXJUeXBlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg3LHQsMCl9c3RhdGljIGFkZElucHV0cyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoOCx0LDApfXN0YXRpYyBjcmVhdGVJbnB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW5wdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZE91dHB1dHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDksdCwwKX1zdGF0aWMgY3JlYXRlT3V0cHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRPdXRwdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZEF0dHJpYnV0ZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEwLHQsMCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0QXR0cmlidXRlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRJbnB1dEFyZ0NvdW50cyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMTEsdCwwKX1zdGF0aWMgY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRJbnQzMih0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRJbnB1dEFyZ0NvdW50c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRJbXBsaWNpdElucHV0cyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMTIsdCwwKX1zdGF0aWMgY3JlYXRlSW1wbGljaXRJbnB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW1wbGljaXRJbnB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgZW5kTm9kZShlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTm9kZShlLHQscixvLGkscyxhLHUsbCxjLHAsZCxmLGgpe3JldHVybiBuLnN0YXJ0Tm9kZShlKSxuLmFkZE5hbWUoZSx0KSxuLmFkZERvY1N0cmluZyhlLHIpLG4uYWRkRG9tYWluKGUsbyksbi5hZGRTaW5jZVZlcnNpb24oZSxpKSxuLmFkZEluZGV4KGUscyksbi5hZGRPcFR5cGUoZSxhKSxuLmFkZFR5cGUoZSx1KSxuLmFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZShlLGwpLG4uYWRkSW5wdXRzKGUsYyksbi5hZGRPdXRwdXRzKGUscCksbi5hZGRBdHRyaWJ1dGVzKGUsZCksbi5hZGRJbnB1dEFyZ0NvdW50cyhlLGYpLG4uYWRkSW1wbGljaXRJbnB1dHMoZSxoKSxuLmVuZE5vZGUoZSl9fXQuTm9kZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVmFsdWVJbmZvKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhbHVlSW5mbyhlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9bmFtZShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfWRvY1N0cmluZyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXR5cGUodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbykuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiX3BvcytuKSx0aGlzLmJiKTpudWxsfXN0YXRpYyBzdGFydFZhbHVlSW5mbyhlKXtlLnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGROYW1lKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgwLHQsMCl9c3RhdGljIGFkZERvY1N0cmluZyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBhZGRUeXBlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIGVuZFZhbHVlSW5mbyhlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlVmFsdWVJbmZvKGUsdCxyLG8pe3JldHVybiBuLnN0YXJ0VmFsdWVJbmZvKGUpLG4uYWRkTmFtZShlLHQpLG4uYWRkRG9jU3RyaW5nKGUsciksbi5hZGRUeXBlKGUsbyksbi5lbmRWYWx1ZUluZm8oZSl9fXQuVmFsdWVJbmZvPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNUeXBlSW5mbyhlLHQpe3JldHVybih0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUeXBlSW5mbyhlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9ZGVub3RhdGlvbihlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfXZhbHVlVHlwZSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkVWludDgodGhpcy5iYl9wb3MrdCk6ZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORX12YWx1ZShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiB0P3RoaXMuYmIuX191bmlvbihlLHRoaXMuYmJfcG9zK3QpOm51bGx9c3RhdGljIHN0YXJ0VHlwZUluZm8oZSl7ZS5zdGFydE9iamVjdCgzKX1zdGF0aWMgYWRkRGVub3RhdGlvbihlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGRWYWx1ZVR5cGUodCxuKXt0LmFkZEZpZWxkSW50OCgxLG4sZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUuTk9ORSl9c3RhdGljIGFkZFZhbHVlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIGVuZFR5cGVJbmZvKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUeXBlSW5mbyhlLHQscixvKXtyZXR1cm4gbi5zdGFydFR5cGVJbmZvKGUpLG4uYWRkRGVub3RhdGlvbihlLHQpLG4uYWRkVmFsdWVUeXBlKGUsciksbi5hZGRWYWx1ZShlLG8pLG4uZW5kVHlwZUluZm8oZSl9fXQuVHlwZUluZm89bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtjbGFzcyB0e2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc09wZXJhdG9yU2V0SWQoZSxuKXtyZXR1cm4obnx8bmV3IHQpLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzT3BlcmF0b3JTZXRJZChlLG4pe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyB0KS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9ZG9tYWluKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9dmVyc2lvbigpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrZSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9c3RhdGljIHN0YXJ0T3BlcmF0b3JTZXRJZChlKXtlLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGREb21haW4oZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkVmVyc2lvbihlLHQpe2UuYWRkRmllbGRJbnQ2NCgxLHQsZS5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBlbmRPcGVyYXRvclNldElkKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVPcGVyYXRvclNldElkKGUsbixyKXtyZXR1cm4gdC5zdGFydE9wZXJhdG9yU2V0SWQoZSksdC5hZGREb21haW4oZSxuKSx0LmFkZFZlcnNpb24oZSxyKSx0LmVuZE9wZXJhdG9yU2V0SWQoZSl9fWUuT3BlcmF0b3JTZXRJZD10fShlLmZic3x8KGUuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzVGVuc29yKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1RlbnNvcihlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9bmFtZShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfWRvY1N0cmluZyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfWRpbXMoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpKzgqZSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9ZGltc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1kYXRhVHlwZSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiB0P3RoaXMuYmIucmVhZEludDMyKHRoaXMuYmJfcG9zK3QpOmUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUR9cmF3RGF0YShlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gdD90aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3QpK2UpOjB9cmF3RGF0YUxlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9cmF3RGF0YUFycmF5KCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxMik7cmV0dXJuIGU/bmV3IFVpbnQ4QXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpKTpudWxsfXN0cmluZ0RhdGEoZSx0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCplLHQpOm51bGx9c3RyaW5nRGF0YUxlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9c3RhdGljIHN0YXJ0VGVuc29yKGUpe2Uuc3RhcnRPYmplY3QoNil9c3RhdGljIGFkZE5hbWUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkRG9jU3RyaW5nKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxLHQsMCl9c3RhdGljIGFkZERpbXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDIsdCwwKX1zdGF0aWMgY3JlYXRlRGltc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoOCx0Lmxlbmd0aCw4KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZEludDY0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydERpbXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDgsdCw4KX1zdGF0aWMgYWRkRGF0YVR5cGUodCxuKXt0LmFkZEZpZWxkSW50MzIoMyxuLGUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpfXN0YXRpYyBhZGRSYXdEYXRhKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg0LHQsMCl9c3RhdGljIGNyZWF0ZVJhd0RhdGFWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDEsdC5sZW5ndGgsMSk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRJbnQ4KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFJhd0RhdGFWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDEsdCwxKX1zdGF0aWMgYWRkU3RyaW5nRGF0YShlLHQpe2UuYWRkRmllbGRPZmZzZXQoNSx0LDApfXN0YXRpYyBjcmVhdGVTdHJpbmdEYXRhVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ0RhdGFWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgZW5kVGVuc29yKGUpe3JldHVybiBlLmVuZE9iamVjdCgpfXN0YXRpYyBjcmVhdGVUZW5zb3IoZSx0LHIsbyxpLHMsYSl7cmV0dXJuIG4uc3RhcnRUZW5zb3IoZSksbi5hZGROYW1lKGUsdCksbi5hZGREb2NTdHJpbmcoZSxyKSxuLmFkZERpbXMoZSxvKSxuLmFkZERhdGFUeXBlKGUsaSksbi5hZGRSYXdEYXRhKGUscyksbi5hZGRTdHJpbmdEYXRhKGUsYSksbi5lbmRUZW5zb3IoZSl9fXQuVGVuc29yPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNTcGFyc2VUZW5zb3IoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX12YWx1ZXModCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1pbmRpY2VzKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZGltcyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDgpO3JldHVybiB0P3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrdCkrOCplKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kaW1zTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0YXRpYyBzdGFydFNwYXJzZVRlbnNvcihlKXtlLnN0YXJ0T2JqZWN0KDMpfXN0YXRpYyBhZGRWYWx1ZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkSW5kaWNlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBhZGREaW1zKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIGNyZWF0ZURpbXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDgsdC5sZW5ndGgsOCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRJbnQ2NCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnREaW1zVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig4LHQsOCl9c3RhdGljIGVuZFNwYXJzZVRlbnNvcihlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlU3BhcnNlVGVuc29yKGUsdCxyLG8pe3JldHVybiBuLnN0YXJ0U3BhcnNlVGVuc29yKGUpLG4uYWRkVmFsdWVzKGUsdCksbi5hZGRJbmRpY2VzKGUsciksbi5hZGREaW1zKGUsbyksbi5lbmRTcGFyc2VUZW5zb3IoZSl9fXQuU3BhcnNlVGVuc29yPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNBdHRyaWJ1dGUoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzQXR0cmlidXRlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1uYW1lKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9ZG9jU3RyaW5nKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9dHlwZSgpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50MzIodGhpcy5iYl9wb3MrdCk6ZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEfWYoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEwKTtyZXR1cm4gZT90aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zK2UpOjB9aSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiBlP3RoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zK2UpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfXMoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9dCh0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE2KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1nKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTgpO3JldHVybiBuPyh0fHxuZXcgZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9ZmxvYXRzKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiB0P3RoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSs0KmUpOjB9ZmxvYXRzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1mbG9hdHNBcnJheSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjApO3JldHVybiBlP25ldyBGbG9hdDMyQXJyYXkodGhpcy5iYi5ieXRlcygpLmJ1ZmZlcix0aGlzLmJiLmJ5dGVzKCkuYnl0ZU9mZnNldCt0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK2UpLHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpKTpudWxsfWludHMoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyMik7cmV0dXJuIHQ/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSs4KmUpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWludHNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIyKTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0cmluZ3MoZSx0KXtsZXQgbj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI0KTtyZXR1cm4gbj90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrbikrNCplLHQpOm51bGx9c3RyaW5nc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjQpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9dGVuc29ycyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMjYpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcikuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH10ZW5zb3JzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywyNik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1ncmFwaHModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCkuX19pbml0KHRoaXMuYmIuX19pbmRpcmVjdCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK3IpKzQqdCksdGhpcy5iYik6bnVsbH1ncmFwaHNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDI4KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfXN0YXRpYyBzdGFydEF0dHJpYnV0ZShlKXtlLnN0YXJ0T2JqZWN0KDEzKX1zdGF0aWMgYWRkTmFtZShlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGREb2NTdHJpbmcoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgYWRkVHlwZSh0LG4pe3QuYWRkRmllbGRJbnQzMigyLG4sZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUuVU5ERUZJTkVEKX1zdGF0aWMgYWRkRihlLHQpe2UuYWRkRmllbGRGbG9hdDMyKDMsdCwwKX1zdGF0aWMgYWRkSShlLHQpe2UuYWRkRmllbGRJbnQ2NCg0LHQsZS5jcmVhdGVMb25nKDAsMCkpfXN0YXRpYyBhZGRTKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg1LHQsMCl9c3RhdGljIGFkZFQoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDYsdCwwKX1zdGF0aWMgYWRkRyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoNyx0LDApfXN0YXRpYyBhZGRGbG9hdHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDgsdCwwKX1zdGF0aWMgY3JlYXRlRmxvYXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkRmxvYXQzMih0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRGbG9hdHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkSW50cyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoOSx0LDApfXN0YXRpYyBjcmVhdGVJbnRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig4LHQubGVuZ3RoLDgpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkSW50NjQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0SW50c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoOCx0LDgpfXN0YXRpYyBhZGRTdHJpbmdzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgxMCx0LDApfXN0YXRpYyBjcmVhdGVTdHJpbmdzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN0cmluZ3NWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkVGVuc29ycyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMTEsdCwwKX1zdGF0aWMgY3JlYXRlVGVuc29yc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRUZW5zb3JzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZEdyYXBocyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMTIsdCwwKX1zdGF0aWMgY3JlYXRlR3JhcGhzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEdyYXBoc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBlbmRBdHRyaWJ1dGUoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUF0dHJpYnV0ZShlLHQscixvLGkscyxhLHUsbCxjLHAsZCxmLGgpe3JldHVybiBuLnN0YXJ0QXR0cmlidXRlKGUpLG4uYWRkTmFtZShlLHQpLG4uYWRkRG9jU3RyaW5nKGUsciksbi5hZGRUeXBlKGUsbyksbi5hZGRGKGUsaSksbi5hZGRJKGUscyksbi5hZGRTKGUsYSksbi5hZGRUKGUsdSksbi5hZGRHKGUsbCksbi5hZGRGbG9hdHMoZSxjKSxuLmFkZEludHMoZSxwKSxuLmFkZFN0cmluZ3MoZSxkKSxuLmFkZFRlbnNvcnMoZSxmKSxuLmFkZEdyYXBocyhlLGgpLG4uZW5kQXR0cmlidXRlKGUpfX10LkF0dHJpYnV0ZT1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzR3JhcGgoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWluaXRpYWxpemVycyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfWluaXRpYWxpemVyc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1ub2RlQXJncyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIHI/KG58fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfW5vZGVBcmdzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfW5vZGVzKHQsbil7bGV0IHI9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5Ob2RlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfW5vZGVzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gZT90aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKTowfW1heE5vZGVJbmRleCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiBlP3RoaXMuYmIucmVhZFVpbnQzMih0aGlzLmJiX3BvcytlKTowfW5vZGVFZGdlcyh0LG4pe2xldCByPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfW5vZGVFZGdlc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTIpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9aW5wdXRzKGUsdCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNCk7cmV0dXJuIG4/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zK24pKzQqZSx0KTpudWxsfWlucHV0c0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTQpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9b3V0cHV0cyhlLHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTYpO3JldHVybiBuP3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytuKSs0KmUsdCk6bnVsbH1vdXRwdXRzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zcGFyc2VJbml0aWFsaXplcnModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE4KTtyZXR1cm4gcj8obnx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3IpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9c3BhcnNlSW5pdGlhbGl6ZXJzTGVuZ3RoKCl7bGV0IGU9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdGF0aWMgc3RhcnRHcmFwaChlKXtlLnN0YXJ0T2JqZWN0KDgpfXN0YXRpYyBhZGRJbml0aWFsaXplcnMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgY3JlYXRlSW5pdGlhbGl6ZXJzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydEluaXRpYWxpemVyc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGROb2RlQXJncyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGROb2RlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMix0LDApfXN0YXRpYyBjcmVhdGVOb2Rlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZE9mZnNldCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnROb2Rlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRNYXhOb2RlSW5kZXgoZSx0KXtlLmFkZEZpZWxkSW50MzIoMyx0LDApfXN0YXRpYyBhZGROb2RlRWRnZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDQsdCwwKX1zdGF0aWMgY3JlYXRlTm9kZUVkZ2VzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVFZGdlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRJbnB1dHMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDUsdCwwKX1zdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydElucHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRPdXRwdXRzKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCg2LHQsMCl9c3RhdGljIGNyZWF0ZU91dHB1dHNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3V0cHV0c1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBhZGRTcGFyc2VJbml0aWFsaXplcnMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDcsdCwwKX1zdGF0aWMgY3JlYXRlU3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFNwYXJzZUluaXRpYWxpemVyc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBlbmRHcmFwaChlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlR3JhcGgoZSx0LHIsbyxpLHMsYSx1LGwpe3JldHVybiBuLnN0YXJ0R3JhcGgoZSksbi5hZGRJbml0aWFsaXplcnMoZSx0KSxuLmFkZE5vZGVBcmdzKGUsciksbi5hZGROb2RlcyhlLG8pLG4uYWRkTWF4Tm9kZUluZGV4KGUsaSksbi5hZGROb2RlRWRnZXMoZSxzKSxuLmFkZElucHV0cyhlLGEpLG4uYWRkT3V0cHV0cyhlLHUpLG4uYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKGUsbCksbi5lbmRHcmFwaChlKX19dC5HcmFwaD1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKSxmdW5jdGlvbihlKXshZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IoKXt0aGlzLmJiPW51bGwsdGhpcy5iYl9wb3M9MH1fX2luaXQoZSx0KXtyZXR1cm4gdGhpcy5iYl9wb3M9ZSx0aGlzLmJiPXQsdGhpc31zdGF0aWMgZ2V0Um9vdEFzTW9kZWwoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwoZSx0KXtyZXR1cm4gZS5zZXRQb3NpdGlvbihlLnBvc2l0aW9uKCkrci5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpLCh0fHxuZXcgbikuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfWlyVmVyc2lvbigpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/dGhpcy5iYi5yZWFkSW50NjQodGhpcy5iYl9wb3MrZSk6dGhpcy5iYi5jcmVhdGVMb25nKDAsMCl9b3BzZXRJbXBvcnQodCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytyKSs0KnQpLHRoaXMuYmIpOm51bGx9b3BzZXRJbXBvcnRMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9cHJvZHVjZXJOYW1lKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsOCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9cHJvZHVjZXJWZXJzaW9uKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsMTApO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfWRvbWFpbihlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDEyKTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1tb2RlbFZlcnNpb24oKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDE0KTtyZXR1cm4gZT90aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcytlKTp0aGlzLmJiLmNyZWF0ZUxvbmcoMCwwKX1kb2NTdHJpbmcoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxNik7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9Z3JhcGgodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywxOCk7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1ncmFwaERvY1N0cmluZyhlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDIwKTtyZXR1cm4gdD90aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zK3QsZSk6bnVsbH1zdGF0aWMgc3RhcnRNb2RlbChlKXtlLnN0YXJ0T2JqZWN0KDkpfXN0YXRpYyBhZGRJclZlcnNpb24oZSx0KXtlLmFkZEZpZWxkSW50NjQoMCx0LGUuY3JlYXRlTG9uZygwLDApKX1zdGF0aWMgYWRkT3BzZXRJbXBvcnQoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgY3JlYXRlT3BzZXRJbXBvcnRWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdC5sZW5ndGgsNCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRPZmZzZXQodFtuXSk7cmV0dXJuIGUuZW5kVmVjdG9yKCl9c3RhdGljIHN0YXJ0T3BzZXRJbXBvcnRWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDQsdCw0KX1zdGF0aWMgYWRkUHJvZHVjZXJOYW1lKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIGFkZFByb2R1Y2VyVmVyc2lvbihlLHQpe2UuYWRkRmllbGRPZmZzZXQoMyx0LDApfXN0YXRpYyBhZGREb21haW4oZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDQsdCwwKX1zdGF0aWMgYWRkTW9kZWxWZXJzaW9uKGUsdCl7ZS5hZGRGaWVsZEludDY0KDUsdCxlLmNyZWF0ZUxvbmcoMCwwKSl9c3RhdGljIGFkZERvY1N0cmluZyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoNix0LDApfXN0YXRpYyBhZGRHcmFwaChlLHQpe2UuYWRkRmllbGRPZmZzZXQoNyx0LDApfXN0YXRpYyBhZGRHcmFwaERvY1N0cmluZyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoOCx0LDApfXN0YXRpYyBlbmRNb2RlbChlKXtyZXR1cm4gZS5lbmRPYmplY3QoKX1zdGF0aWMgY3JlYXRlTW9kZWwoZSx0LHIsbyxpLHMsYSx1LGwsYyl7cmV0dXJuIG4uc3RhcnRNb2RlbChlKSxuLmFkZElyVmVyc2lvbihlLHQpLG4uYWRkT3BzZXRJbXBvcnQoZSxyKSxuLmFkZFByb2R1Y2VyTmFtZShlLG8pLG4uYWRkUHJvZHVjZXJWZXJzaW9uKGUsaSksbi5hZGREb21haW4oZSxzKSxuLmFkZE1vZGVsVmVyc2lvbihlLGEpLG4uYWRkRG9jU3RyaW5nKGUsdSksbi5hZGRHcmFwaChlLGwpLG4uYWRkR3JhcGhEb2NTdHJpbmcoZSxjKSxuLmVuZE1vZGVsKGUpfX10Lk1vZGVsPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXshZnVuY3Rpb24oZSl7Y2xhc3MgdHtjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyhlLG4pe3JldHVybihufHxuZXcgdCkuX19pbml0KGUucmVhZEludDMyKGUucG9zaXRpb24oKSkrZS5wb3NpdGlvbigpLGUpfXN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyhlLG4pe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKG58fG5ldyB0KS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9bm9kZUluZGljZXMoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw0KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRVaW50MzIodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSs0KmUpOjB9bm9kZUluZGljZXNMZW5ndGgoKXtsZXQgZT10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiBlP3RoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zK2UpOjB9bm9kZUluZGljZXNBcnJheSgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIGU/bmV3IFVpbnQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsdGhpcy5iYi5ieXRlcygpLmJ5dGVPZmZzZXQrdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcytlKSx0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcytlKSk6bnVsbH1rZXJuZWxEZWZIYXNoZXMoZSl7bGV0IHQ9dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw2KTtyZXR1cm4gdD90aGlzLmJiLnJlYWRVaW50NjQodGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3Bvcyt0KSs4KmUpOnRoaXMuYmIuY3JlYXRlTG9uZygwLDApfWtlcm5lbERlZkhhc2hlc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyhlKXtlLnN0YXJ0T2JqZWN0KDIpfXN0YXRpYyBhZGROb2RlSW5kaWNlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0Lmxlbmd0aCw0KTtmb3IobGV0IG49dC5sZW5ndGgtMTtuPj0wO24tLSllLmFkZEludDMyKHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydE5vZGVJbmRpY2VzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQsNCl9c3RhdGljIGFkZEtlcm5lbERlZkhhc2hlcyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMSx0LDApfXN0YXRpYyBjcmVhdGVLZXJuZWxEZWZIYXNoZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDgsdC5sZW5ndGgsOCk7Zm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pZS5hZGRJbnQ2NCh0W25dKTtyZXR1cm4gZS5lbmRWZWN0b3IoKX1zdGF0aWMgc3RhcnRLZXJuZWxEZWZIYXNoZXNWZWN0b3IoZSx0KXtlLnN0YXJ0VmVjdG9yKDgsdCw4KX1zdGF0aWMgZW5kS2VybmVsQ3JlYXRlSW5mb3MoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZUtlcm5lbENyZWF0ZUluZm9zKGUsbixyKXtyZXR1cm4gdC5zdGFydEtlcm5lbENyZWF0ZUluZm9zKGUpLHQuYWRkTm9kZUluZGljZXMoZSxuKSx0LmFkZEtlcm5lbERlZkhhc2hlcyhlLHIpLHQuZW5kS2VybmVsQ3JlYXRlSW5mb3MoZSl9fWUuS2VybmVsQ3JlYXRlSW5mb3M9dH0oZS5mYnN8fChlLmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKGUsdCl7cmV0dXJuKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1ncmFwaElkKGUpe2xldCB0PXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIHQ/dGhpcy5iYi5fX3N0cmluZyh0aGlzLmJiX3Bvcyt0LGUpOm51bGx9c2Vzc2lvblN0YXRlKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zK24pLHRoaXMuYmIpOm51bGx9c3RhdGljIHN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUoZSl7ZS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkR3JhcGhJZChlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGRTZXNzaW9uU3RhdGUoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgZW5kU3ViR3JhcGhTZXNzaW9uU3RhdGUoZSl7bGV0IHQ9ZS5lbmRPYmplY3QoKTtyZXR1cm4gZS5yZXF1aXJlZEZpZWxkKHQsNCksdH1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUoZSx0LHIpe3JldHVybiBuLnN0YXJ0U3ViR3JhcGhTZXNzaW9uU3RhdGUoZSksbi5hZGRHcmFwaElkKGUsdCksbi5hZGRTZXNzaW9uU3RhdGUoZSxyKSxuLmVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlKGUpfX10LlN1YkdyYXBoU2Vzc2lvblN0YXRlPW59KHQuZmJzfHwodC5mYnM9e30pKX0oZS5leHBlcmltZW50YWx8fChlLmV4cGVyaW1lbnRhbD17fSkpfSh0Lm9ubnhydW50aW1lfHwodC5vbm54cnVudGltZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbih0KXshZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcigpe3RoaXMuYmI9bnVsbCx0aGlzLmJiX3Bvcz0wfV9faW5pdChlLHQpe3JldHVybiB0aGlzLmJiX3Bvcz1lLHRoaXMuYmI9dCx0aGlzfXN0YXRpYyBnZXRSb290QXNTZXNzaW9uU3RhdGUoZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2Vzc2lvblN0YXRlKGUsdCl7cmV0dXJuIGUuc2V0UG9zaXRpb24oZS5wb3NpdGlvbigpK3IuZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKSwodHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1rZXJuZWxzKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNCk7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuS2VybmVsQ3JlYXRlSW5mb3MpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdWJHcmFwaFNlc3Npb25TdGF0ZXModCxuKXtsZXQgcj10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDYpO3JldHVybiByPyhufHxuZXcgZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MrcikrNCp0KSx0aGlzLmJiKTpudWxsfXN1YkdyYXBoU2Vzc2lvblN0YXRlc0xlbmd0aCgpe2xldCBlPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIGU/dGhpcy5iYi5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MrZSk6MH1zdGF0aWMgc3RhcnRTZXNzaW9uU3RhdGUoZSl7ZS5zdGFydE9iamVjdCgyKX1zdGF0aWMgYWRkS2VybmVscyhlLHQpe2UuYWRkRmllbGRPZmZzZXQoMCx0LDApfXN0YXRpYyBhZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXMoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKGUsdCl7ZS5zdGFydFZlY3Rvcig0LHQubGVuZ3RoLDQpO2ZvcihsZXQgbj10Lmxlbmd0aC0xO24+PTA7bi0tKWUuYWRkT2Zmc2V0KHRbbl0pO3JldHVybiBlLmVuZFZlY3RvcigpfXN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3RvcihlLHQpe2Uuc3RhcnRWZWN0b3IoNCx0LDQpfXN0YXRpYyBlbmRTZXNzaW9uU3RhdGUoZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGNyZWF0ZVNlc3Npb25TdGF0ZShlLHQscil7cmV0dXJuIG4uc3RhcnRTZXNzaW9uU3RhdGUoZSksbi5hZGRLZXJuZWxzKGUsdCksbi5hZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXMoZSxyKSxuLmVuZFNlc3Npb25TdGF0ZShlKX19dC5TZXNzaW9uU3RhdGU9bn0odC5mYnN8fCh0LmZicz17fSkpfShlLmV4cGVyaW1lbnRhbHx8KGUuZXhwZXJpbWVudGFsPXt9KSl9KHQub25ueHJ1bnRpbWV8fCh0Lm9ubnhydW50aW1lPXt9KSksZnVuY3Rpb24oZSl7IWZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKCl7dGhpcy5iYj1udWxsLHRoaXMuYmJfcG9zPTB9X19pbml0KGUsdCl7cmV0dXJuIHRoaXMuYmJfcG9zPWUsdGhpcy5iYj10LHRoaXN9c3RhdGljIGdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24oZSx0KXtyZXR1cm4odHx8bmV3IG4pLl9faW5pdChlLnJlYWRJbnQzMihlLnBvc2l0aW9uKCkpK2UucG9zaXRpb24oKSxlKX1zdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzSW5mZXJlbmNlU2Vzc2lvbihlLHQpe3JldHVybiBlLnNldFBvc2l0aW9uKGUucG9zaXRpb24oKStyLmZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCksKHR8fG5ldyBuKS5fX2luaXQoZS5yZWFkSW50MzIoZS5wb3NpdGlvbigpKStlLnBvc2l0aW9uKCksZSl9c3RhdGljIGJ1ZmZlckhhc0lkZW50aWZpZXIoZSl7cmV0dXJuIGUuX19oYXNfaWRlbnRpZmllcihcIk9SVE1cIil9b3J0VmVyc2lvbihlKXtsZXQgdD10aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLDQpO3JldHVybiB0P3RoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MrdCxlKTpudWxsfW1vZGVsKHQpe2xldCBuPXRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsNik7cmV0dXJuIG4/KHR8fG5ldyBlLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zZXNzaW9uU3RhdGUodCl7bGV0IG49dGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3Bvcyw4KTtyZXR1cm4gbj8odHx8bmV3IGUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MrbiksdGhpcy5iYik6bnVsbH1zdGF0aWMgc3RhcnRJbmZlcmVuY2VTZXNzaW9uKGUpe2Uuc3RhcnRPYmplY3QoMyl9c3RhdGljIGFkZE9ydFZlcnNpb24oZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDAsdCwwKX1zdGF0aWMgYWRkTW9kZWwoZSx0KXtlLmFkZEZpZWxkT2Zmc2V0KDEsdCwwKX1zdGF0aWMgYWRkU2Vzc2lvblN0YXRlKGUsdCl7ZS5hZGRGaWVsZE9mZnNldCgyLHQsMCl9c3RhdGljIGVuZEluZmVyZW5jZVNlc3Npb24oZSl7cmV0dXJuIGUuZW5kT2JqZWN0KCl9c3RhdGljIGZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIoZSx0KXtlLmZpbmlzaCh0LFwiT1JUTVwiKX1zdGF0aWMgZmluaXNoU2l6ZVByZWZpeGVkSW5mZXJlbmNlU2Vzc2lvbkJ1ZmZlcihlLHQpe2UuZmluaXNoKHQsXCJPUlRNXCIsITApfXN0YXRpYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uKGUsdCxyLG8pe3JldHVybiBuLnN0YXJ0SW5mZXJlbmNlU2Vzc2lvbihlKSxuLmFkZE9ydFZlcnNpb24oZSx0KSxuLmFkZE1vZGVsKGUsciksbi5hZGRTZXNzaW9uU3RhdGUoZSxvKSxuLmVuZEluZmVyZW5jZVNlc3Npb24oZSl9fXQuSW5mZXJlbmNlU2Vzc2lvbj1ufSh0LmZic3x8KHQuZmJzPXt9KSl9KGUuZXhwZXJpbWVudGFsfHwoZS5leHBlcmltZW50YWw9e30pKX0odC5vbm54cnVudGltZXx8KHQub25ueHJ1bnRpbWU9e30pKX0sMTcyMzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Pbm54anNTZXNzaW9uSGFuZGxlcj12b2lkIDA7Y29uc3Qgcj1uKDYyMDcpLG89big5MjQwKTt0Lk9ubnhqc1Nlc3Npb25IYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuc2Vzc2lvbj1lLHRoaXMuaW5wdXROYW1lcz10aGlzLnNlc3Npb24uaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzPXRoaXMuc2Vzc2lvbi5vdXRwdXROYW1lc31hc3luYyBkaXNwb3NlKCl7fWFzeW5jIHJ1bihlLHQsbil7Y29uc3QgaT1uZXcgTWFwO2Zvcihjb25zdCB0IGluIGUpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSx0KSl7Y29uc3Qgbj1lW3RdO2kuc2V0KHQsbmV3IG8uVGVuc29yKG4uZGltcyxuLnR5cGUsdm9pZCAwLHZvaWQgMCxuLmRhdGEpKX1jb25zdCBzPWF3YWl0IHRoaXMuc2Vzc2lvbi5ydW4oaSksYT17fTtyZXR1cm4gcy5mb3JFYWNoKCgoZSx0KT0+e2FbdF09bmV3IHIuVGVuc29yKGUudHlwZSxlLmRhdGEsZS5kaW1zKX0pKSxhfXN0YXJ0UHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLnN0YXJ0UHJvZmlsaW5nKCl9ZW5kUHJvZmlsaW5nKCl7dGhpcy5zZXNzaW9uLmVuZFByb2ZpbGluZygpfX19LDYwMjc6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuU2Vzc2lvbj12b2lkIDA7Y29uc3Qgcj1uKDYyMzEpLG89big2NDY0KSxpPW4oMTk3NSkscz1uKDY0OTYpLGE9bigxMzE1KSx1PW4oMTc0NSk7dC5TZXNzaW9uPWNsYXNze2NvbnN0cnVjdG9yKGU9e30pe3RoaXMuX2luaXRpYWxpemVkPSExLHRoaXMuYmFja2VuZEhpbnQ9ZS5iYWNrZW5kSGludCx0aGlzLnByb2ZpbGVyPWEuUHJvZmlsZXIuY3JlYXRlKGUucHJvZmlsZXIpLHRoaXMuY29udGV4dD17cHJvZmlsZXI6dGhpcy5wcm9maWxlcixncmFwaElucHV0VHlwZXM6W10sZ3JhcGhJbnB1dERpbXM6W119fWdldCBpbnB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0TmFtZXMoKX1nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKX1zdGFydFByb2ZpbGluZygpe3RoaXMucHJvZmlsZXIuc3RhcnQoKX1lbmRQcm9maWxpbmcoKXt0aGlzLnByb2ZpbGVyLnN0b3AoKX1hc3luYyBsb2FkTW9kZWwoZSx0LG4pe2F3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLmxvYWRNb2RlbFwiLChhc3luYygpPT57Y29uc3Qgcz1hd2FpdCgwLGkucmVzb2x2ZUJhY2tlbmQpKHRoaXMuYmFja2VuZEhpbnQpO2lmKHRoaXMuc2Vzc2lvbkhhbmRsZXI9cy5jcmVhdGVTZXNzaW9uSGFuZGxlcih0aGlzLmNvbnRleHQpLHRoaXMuX21vZGVsPW5ldyB1Lk1vZGVsLFwic3RyaW5nXCI9PXR5cGVvZiBlKXtjb25zdCB0PWUuZW5kc1dpdGgoXCIub3J0XCIpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzJiZwcm9jZXNzLnZlcnNpb25zJiZwcm9jZXNzLnZlcnNpb25zLm5vZGUpe2NvbnN0IG49YXdhaXQoMCxvLnByb21pc2lmeSkoci5yZWFkRmlsZSkoZSk7dGhpcy5pbml0aWFsaXplKG4sdCl9ZWxzZXtjb25zdCBuPWF3YWl0IGZldGNoKGUpLHI9YXdhaXQgbi5hcnJheUJ1ZmZlcigpO3RoaXMuaW5pdGlhbGl6ZShuZXcgVWludDhBcnJheShyKSx0KX19ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpdGhpcy5pbml0aWFsaXplKGUpO2Vsc2V7Y29uc3Qgcj1uZXcgVWludDhBcnJheShlLHR8fDAsbnx8ZS5ieXRlTGVuZ3RoKTt0aGlzLmluaXRpYWxpemUocil9fSkpfWluaXRpYWxpemUoZSx0KXtpZih0aGlzLl9pbml0aWFsaXplZCl0aHJvdyBuZXcgRXJyb3IoXCJhbHJlYWR5IGluaXRpYWxpemVkXCIpO3RoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLmluaXRpYWxpemVcIiwoKCk9Pntjb25zdCBuPXRoaXMuc2Vzc2lvbkhhbmRsZXIudHJhbnNmb3JtR3JhcGg/dGhpcy5zZXNzaW9uSGFuZGxlcjp2b2lkIDA7dGhpcy5fbW9kZWwubG9hZChlLG4sdCksdGhpcy5zZXNzaW9uSGFuZGxlci5vbkdyYXBoSW5pdGlhbGl6ZWQmJnRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKHRoaXMuX21vZGVsLmdyYXBoKSx0aGlzLmluaXRpYWxpemVPcHModGhpcy5fbW9kZWwuZ3JhcGgpLHRoaXMuX2V4ZWN1dGlvblBsYW49bmV3IHMuRXhlY3V0aW9uUGxhbih0aGlzLl9tb2RlbC5ncmFwaCx0aGlzLl9vcHMsdGhpcy5wcm9maWxlcil9KSksdGhpcy5faW5pdGlhbGl6ZWQ9ITB9YXN5bmMgcnVuKGUpe2lmKCF0aGlzLl9pbml0aWFsaXplZCl0aHJvdyBuZXcgRXJyb3IoXCJzZXNzaW9uIG5vdCBpbml0aWFsaXplZCB5ZXRcIik7cmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoXCJzZXNzaW9uXCIsXCJTZXNzaW9uLnJ1blwiLChhc3luYygpPT57Y29uc3QgdD10aGlzLm5vcm1hbGl6ZUFuZFZhbGlkYXRlSW5wdXRzKGUpLG49YXdhaXQgdGhpcy5fZXhlY3V0aW9uUGxhbi5leGVjdXRlKHRoaXMuc2Vzc2lvbkhhbmRsZXIsdCk7cmV0dXJuIHRoaXMuY3JlYXRlT3V0cHV0KG4pfSkpfW5vcm1hbGl6ZUFuZFZhbGlkYXRlSW5wdXRzKGUpe2NvbnN0IHQ9dGhpcy5fbW9kZWwuZ3JhcGguZ2V0SW5wdXROYW1lcygpO2lmKEFycmF5LmlzQXJyYXkoZSkpe2lmKGUubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbmNvcnJlY3QgaW5wdXQgYXJyYXkgbGVuZ3RoOiBleHBlY3RlZCAke3QubGVuZ3RofSBidXQgZ290ICR7ZS5sZW5ndGh9YCl9ZWxzZXtpZihlLnNpemUhPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBtYXAgc2l6ZTogZXhwZWN0ZWQgJHt0Lmxlbmd0aH0gYnV0IGdvdCAke2Uuc2l6ZX1gKTtjb25zdCBuPW5ldyBBcnJheShlLnNpemUpO2xldCByPTA7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDsrK28pe2NvbnN0IGk9ZS5nZXQodFtvXSk7aWYoIWkpdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IHRlbnNvciBmb3I6ICcke25hbWV9J2ApO25bcisrXT1pfWU9bn1pZih0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzJiYwIT09dGhpcy5jb250ZXh0LmdyYXBoSW5wdXRUeXBlcy5sZW5ndGgmJnRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcyYmMCE9PXRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcy5sZW5ndGgpdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yRGltcyh0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMsZSwhMSk7ZWxzZXtjb25zdCB0PXRoaXMuX21vZGVsLmdyYXBoLmdldElucHV0SW5kaWNlcygpLG49dGhpcy5fbW9kZWwuZ3JhcGguZ2V0VmFsdWVzKCkscj1uZXcgQXJyYXkodC5sZW5ndGgpO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7KytvKXtjb25zdCBpPW5bdFtvXV07cltvXT1pLnR5cGUuc2hhcGUuZGltcyx0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLnB1c2goaS50eXBlLnRlbnNvclR5cGUpLHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcy5wdXNoKGVbb10uZGltcyl9dGhpcy52YWxpZGF0ZUlucHV0VGVuc29yRGltcyhyLGUsITApfXJldHVybiB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyh0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzLGUpLGV9dmFsaWRhdGVJbnB1dFRlbnNvclR5cGVzKGUsdCl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHI9ZVtuXSxvPXRbbl0udHlwZTtpZihyIT09byl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IHRlbnNvclske259XSBjaGVjayBmYWlsZWQ6IGV4cGVjdGVkIHR5cGUgJyR7cn0nIGJ1dCBnb3QgJHtvfWApfX12YWxpZGF0ZUlucHV0VGVuc29yRGltcyhlLHQsbil7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IG89ZVtyXSxpPXRbcl0uZGltcztpZighdGhpcy5jb21wYXJlVGVuc29yRGltcyhvLGksbikpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtyfV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCBzaGFwZSAnWyR7by5qb2luKFwiLFwiKX1dJyBidXQgZ290IFske2kuam9pbihcIixcIil9XWApfX1jb21wYXJlVGVuc29yRGltcyhlLHQsbil7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcilpZihlW3JdIT09dFtyXSYmKCFufHwwIT09ZVtyXSkpcmV0dXJuITE7cmV0dXJuITB9Y3JlYXRlT3V0cHV0KGUpe2NvbnN0IHQ9dGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKTtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIG51bWJlciBvZiBvdXRwdXRzIGRvIG5vdCBtYXRjaCBudW1iZXIgb2YgZ2VuZXJhdGVkIG91dHB1dHNcIik7Y29uc3Qgbj1uZXcgTWFwO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7KytyKW4uc2V0KHRbcl0sZVtyXSk7cmV0dXJuIG59aW5pdGlhbGl6ZU9wcyhlKXtjb25zdCB0PWUuZ2V0Tm9kZXMoKTt0aGlzLl9vcHM9bmV3IEFycmF5KHQubGVuZ3RoKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl0aGlzLl9vcHNbbl09dGhpcy5zZXNzaW9uSGFuZGxlci5yZXNvbHZlKHRbbl0sdGhpcy5fbW9kZWwub3BzZXRzLGUpfX19LDkyNDA6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVGVuc29yPXZvaWQgMDtjb25zdCBvPW4oMzQ0MiksaT1yKG4oMTU4MykpLHM9big1MTI3KSxhPW4oMjQ0NiksdT1uKDcyNzMpO3ZhciBsPXMub25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicztjbGFzcyBje2dldCBkYXRhKCl7aWYodm9pZCAwPT09dGhpcy5jYWNoZSl7Y29uc3QgZT10aGlzLmRhdGFQcm92aWRlcih0aGlzLmRhdGFJZCk7aWYoZS5sZW5ndGghPT10aGlzLnNpemUpdGhyb3cgbmV3IEVycm9yKFwiTGVuZ3RoIG9mIGRhdGEgcHJvdmlkZWQgYnkgdGhlIERhdGEgUHJvdmlkZXIgaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIGRpbXMgb2YgdGhpcyBUZW5zb3IuXCIpO3RoaXMuY2FjaGU9ZX1yZXR1cm4gdGhpcy5jYWNoZX1nZXQgc3RyaW5nRGF0YSgpe2lmKFwic3RyaW5nXCIhPT10aGlzLnR5cGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGEgdHlwZSBpcyBub3Qgc3RyaW5nXCIpO3JldHVybiB0aGlzLmRhdGF9Z2V0IGludGVnZXJEYXRhKCl7c3dpdGNoKHRoaXMudHlwZSl7Y2FzZVwidWludDhcIjpjYXNlXCJpbnQ4XCI6Y2FzZVwidWludDE2XCI6Y2FzZVwiaW50MTZcIjpjYXNlXCJpbnQzMlwiOmNhc2VcInVpbnQzMlwiOmNhc2VcImJvb2xcIjpyZXR1cm4gdGhpcy5kYXRhO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGEgdHlwZSBpcyBub3QgaW50ZWdlciAodWludDgsIGludDgsIHVpbnQxNiwgaW50MTYsIGludDMyLCB1aW50MzIsIGJvb2wpXCIpfX1nZXQgZmxvYXREYXRhKCl7c3dpdGNoKHRoaXMudHlwZSl7Y2FzZVwiZmxvYXQzMlwiOmNhc2VcImZsb2F0NjRcIjpyZXR1cm4gdGhpcy5kYXRhO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGEgdHlwZSBpcyBub3QgZmxvYXQgKGZsb2F0MzIsIGZsb2F0NjQpXCIpfX1nZXQgbnVtYmVyRGF0YSgpe2lmKFwic3RyaW5nXCIhPT10aGlzLnR5cGUpcmV0dXJuIHRoaXMuZGF0YTt0aHJvdyBuZXcgVHlwZUVycm9yKFwidHlwZSBjYW5ub3QgYmUgbm9uLW51bWJlciAoc3RyaW5nKVwiKX1nZXQoZSl7cmV0dXJuIHRoaXMuZGF0YVt1LlNoYXBlVXRpbC5pbmRpY2VzVG9PZmZzZXQoZSx0aGlzLnN0cmlkZXMpXX1zZXQoZSx0KXt0aGlzLmRhdGFbdS5TaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGUsdGhpcy5zdHJpZGVzKV09dH1hc3luYyBnZXREYXRhKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMuY2FjaGUmJih0aGlzLmNhY2hlPWF3YWl0IHRoaXMuYXN5bmNEYXRhUHJvdmlkZXIodGhpcy5kYXRhSWQpKSx0aGlzLmNhY2hlfWdldCBzdHJpZGVzKCl7cmV0dXJuIHRoaXMuX3N0cmlkZXN8fCh0aGlzLl9zdHJpZGVzPXUuU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHRoaXMuZGltcykpLHRoaXMuX3N0cmlkZXN9Y29uc3RydWN0b3IoZSx0LG4scixpLHM9by5HdWlkLmNyZWF0ZSgpKXt0aGlzLmRpbXM9ZSx0aGlzLnR5cGU9dCx0aGlzLmRhdGFQcm92aWRlcj1uLHRoaXMuYXN5bmNEYXRhUHJvdmlkZXI9cix0aGlzLmNhY2hlPWksdGhpcy5kYXRhSWQ9cyx0aGlzLnNpemU9dS5TaGFwZVV0aWwudmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUoZSk7Y29uc3QgYT10aGlzLnNpemUsbD12b2lkIDA9PT1uJiZ2b2lkIDA9PT1yJiZ2b2lkIDA9PT1pO2lmKHZvaWQgMCE9PWkmJmkubGVuZ3RoIT09YSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIklucHV0IGRpbXMgZG9lc24ndCBtYXRjaCBkYXRhIGxlbmd0aC5cIik7aWYoXCJzdHJpbmdcIj09PXQpe2lmKCEodm9pZCAwPT09aXx8QXJyYXkuaXNBcnJheShpKSYmaS5ldmVyeSgoZT0+XCJzdHJpbmdcIj09dHlwZW9mIGUpKSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhY2hlIHNob3VsZCBiZSBhIHN0cmluZyBhcnJheVwiKTtsJiYodGhpcy5jYWNoZT1uZXcgQXJyYXkoYSkpfWVsc2V7aWYodm9pZCAwIT09aSl7Y29uc3QgZT1kKHQpO2lmKCEoaSBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoYGNhY2hlIHNob3VsZCBiZSB0eXBlICR7ZS5uYW1lfWApfWlmKGwpe2NvbnN0IGU9bmV3IEFycmF5QnVmZmVyKGEqZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcImJvb2xcIjpjYXNlXCJpbnQ4XCI6Y2FzZVwidWludDhcIjpyZXR1cm4gMTtjYXNlXCJpbnQxNlwiOmNhc2VcInVpbnQxNlwiOnJldHVybiAyO2Nhc2VcImludDMyXCI6Y2FzZVwidWludDMyXCI6Y2FzZVwiZmxvYXQzMlwiOnJldHVybiA0O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gODtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7ZX1gKX19KHQpKTt0aGlzLmNhY2hlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyhkKHQpKShlKX0oZSx0KX19fXN0YXRpYyBmcm9tUHJvdG8oZSl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnN0cnVjdCBWYWx1ZSBmcm9tIGFuIGVtcHR5IHRlbnNvclwiKTtjb25zdCB0PXUuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGUuZGF0YVR5cGUpLG49dS5Qcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byhlLmRpbXMpLHI9bmV3IGMobix0KTtpZihcInN0cmluZ1wiPT09dCllLnN0cmluZ0RhdGEuZm9yRWFjaCgoKGUsdCk9PntyLmRhdGFbdF09KDAsdS5kZWNvZGVVdGY4U3RyaW5nKShlKX0pKTtlbHNlIGlmKGUucmF3RGF0YSYmXCJudW1iZXJcIj09dHlwZW9mIGUucmF3RGF0YS5ieXRlTGVuZ3RoJiZlLnJhd0RhdGEuYnl0ZUxlbmd0aD4wKXtjb25zdCB0PXIuZGF0YSxuPW5ldyBEYXRhVmlldyhlLnJhd0RhdGEuYnVmZmVyLGUucmF3RGF0YS5ieXRlT2Zmc2V0LGUucmF3RGF0YS5ieXRlTGVuZ3RoKSxvPXAoZS5kYXRhVHlwZSksaT1lLnJhd0RhdGEuYnl0ZUxlbmd0aC9vO2lmKGUucmF3RGF0YS5ieXRlTGVuZ3RoJW8hPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBidWZmZXIgbGVuZ3RoXCIpO2lmKHQubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgbGVuZ3RoIG1pc21hdGNoXCIpO2ZvcihsZXQgcj0wO3I8aTtyKyspe2NvbnN0IGk9aChuLGUuZGF0YVR5cGUscipvKTt0W3JdPWl9fWVsc2V7bGV0IHQ7c3dpdGNoKGUuZGF0YVR5cGUpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOnQ9ZS5mbG9hdERhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDp0PWUuaW50MzJEYXRhO2JyZWFrO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OnQ9ZS5pbnQ2NERhdGE7YnJlYWs7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRE9VQkxFOnQ9ZS5kb3VibGVEYXRhO2JyZWFrO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6dD1lLnVpbnQ2NERhdGE7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJ1bnNwZWNpZmljIGVycm9yXCIpfWlmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwiZmFpbGVkIHRvIHBvcHVsYXRlIGRhdGEgZnJvbSBhIHRlbnNvcnByb3RvIHZhbHVlXCIpO2NvbnN0IG49ci5kYXRhO2lmKG4ubGVuZ3RoIT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgbGVuZ3RoIG1pc21hdGNoXCIpO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBvPXRbcl07aS5kZWZhdWx0LmlzTG9uZyhvKT9uW3JdPWYobyxlLmRhdGFUeXBlKTpuW3JdPW99fXJldHVybiByfXN0YXRpYyBmcm9tRGF0YShlLHQsbil7cmV0dXJuIG5ldyBjKHQsbix2b2lkIDAsdm9pZCAwLGUpfXN0YXRpYyBmcm9tT3J0VGVuc29yKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb25zdHJ1Y3QgVmFsdWUgZnJvbSBhbiBlbXB0eSB0ZW5zb3JcIik7Y29uc3QgdD11LlByb3RvVXRpbC50ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdChlKSxuPXUuUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGUuZGF0YVR5cGUoKSkscj1uZXcgYyh0LG4pO2lmKFwic3RyaW5nXCI9PT1uKWZvcihsZXQgdD0wO3Q8ZS5zdHJpbmdEYXRhTGVuZ3RoKCk7dCsrKXIuZGF0YVt0XT1lLnN0cmluZ0RhdGEodCk7ZWxzZSBpZihlLnJhd0RhdGFBcnJheSgpJiZcIm51bWJlclwiPT10eXBlb2YgZS5yYXdEYXRhTGVuZ3RoKCkmJmUucmF3RGF0YUxlbmd0aCgpPjApe2NvbnN0IHQ9ci5kYXRhLG49bmV3IERhdGFWaWV3KGUucmF3RGF0YUFycmF5KCkuYnVmZmVyLGUucmF3RGF0YUFycmF5KCkuYnl0ZU9mZnNldCxlLnJhd0RhdGFMZW5ndGgoKSksbz1wKGUuZGF0YVR5cGUoKSksaT1lLnJhd0RhdGFMZW5ndGgoKS9vO2lmKGUucmF3RGF0YUxlbmd0aCgpJW8hPTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBidWZmZXIgbGVuZ3RoXCIpO2lmKHQubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJidWZmZXIgbGVuZ3RoIG1pc21hdGNoXCIpO2ZvcihsZXQgcj0wO3I8aTtyKyspe2NvbnN0IGk9aChuLGUuZGF0YVR5cGUoKSxyKm8pO3Rbcl09aX19cmV0dXJuIHJ9fWZ1bmN0aW9uIHAoZSl7c3dpdGNoKGUpe2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpyZXR1cm4gMTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuIDI7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOnJldHVybiA0O2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0OmNhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6cmV0dXJuIDg7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBjYWxjdWxhdGUgc2l6ZW9mKCkgb24gdHlwZSAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVtlXX1gKX19ZnVuY3Rpb24gZChlKXtzd2l0Y2goZSl7Y2FzZVwiYm9vbFwiOmNhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gVWludDMyQXJyYXk7Y2FzZVwiaW50NjRcIjpyZXR1cm4gQmlnSW50NjRBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuc3BlY2lmaWVkIGVycm9yXCIpfX1mdW5jdGlvbiBmKGUsdCl7aWYodD09PWEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NHx8dD09PWwuVGVuc29yRGF0YVR5cGUuSU5UNjQpe2lmKGUuZ3JlYXRlclRoYW5PckVxdWFsKDIxNDc0ODM2NDgpfHxlLmxlc3NUaGFuKC0yMTQ3NDgzNjQ4KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW50NjQgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNle2lmKHQhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyJiZ0IT09bC5UZW5zb3JEYXRhVHlwZS5VSU5UMzImJnQhPT1hLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0JiZ0IT09bC5UZW5zb3JEYXRhVHlwZS5VSU5UNjQpdGhyb3cgbmV3IFR5cGVFcnJvcihgbm90IGEgTE9ORyB0eXBlOiAke2Eub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0XX1gKTtpZihlLmdyZWF0ZXJUaGFuT3JFcXVhbCg0Mjk0OTY3Mjk2KXx8ZS5sZXNzVGhhbigwKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwidWludDY0IGlzIG5vdCBzdXBwb3J0ZWRcIil9cmV0dXJuIGUudG9OdW1iZXIoKX1mdW5jdGlvbiBoKGUsdCxuKXtzd2l0Y2godCl7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UODpyZXR1cm4gZS5nZXRVaW50OChuKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OnJldHVybiBlLmdldEludDgobik7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OnJldHVybiBlLmdldFVpbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQxNjpyZXR1cm4gZS5nZXRJbnQxNihuLCEwKTtjYXNlIGEub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm4gZS5nZXRGbG9hdDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVybiBlLmdldEludDMyKG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpyZXR1cm4gZS5nZXRVaW50MzIobiwhMCk7Y2FzZSBhLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuIGYoaS5kZWZhdWx0LmZyb21CaXRzKGUuZ2V0VWludDMyKG4sITApLGUuZ2V0VWludDMyKG4rNCwhMCksITEpLHQpO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpyZXR1cm4gZS5nZXRGbG9hdDY0KG4sITApO2Nhc2UgYS5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm4gZihpLmRlZmF1bHQuZnJvbUJpdHMoZS5nZXRVaW50MzIobiwhMCksZS5nZXRVaW50MzIobis0LCEwKSwhMCksdCk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWFkIGZyb20gRGF0YVZpZXcgZm9yIHR5cGUgJHthLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGVbdF19YCl9fXQuVGVuc29yPWN9LDcyNzM6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVjb2RlVXRmOFN0cmluZz10Lk1BWF9DTElQPXQuTUlOX0NMSVA9dC5Qb29sQ29udlV0aWw9dC5SZWR1Y2VVdGlsPXQuU3BsaXRVdGlsPXQuTWF0aFV0aWw9dC5TaGFwZVV0aWw9dC5Mb25nVXRpbD10LlByb3RvVXRpbD10LkdlbW1VdGlsPXQuYXJyYXlDb3B5SGVscGVyPXQuQnJvYWRjYXN0VXRpbD10Lk1hdE11bFV0aWw9dC5BcnJheVV0aWw9dC5hc3NlcnQ9dC5jaGVja0lucHV0c1NoYXBlPXZvaWQgMDtjb25zdCBvPW4oNTY4NiksaT1yKG4oMTU4MykpLHM9bigyNDQ2KSxhPW4oOTI0MCk7dC5jaGVja0lucHV0c1NoYXBlPWZ1bmN0aW9uKGUsLi4udCl7aWYoIWV8fGUubGVuZ3RoIT09dC5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspaWYoIWVbbl0uZGltc3x8ZVtuXS5kaW1zLmxlbmd0aCE9PXRbbl0pcmV0dXJuITE7cmV0dXJuITB9LHQuYXNzZXJ0PWZ1bmN0aW9uKGUsdCl7aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nXCI9PXR5cGVvZiB0P3Q6dCgpKX0sdC5BcnJheVV0aWw9Y2xhc3N7c3RhdGljIGFycmF5c0VxdWFsKGUsdCl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKylpZihlW25dIT09dFtuXSlyZXR1cm4hMTtyZXR1cm4hMH19O2NsYXNzIHV7c3RhdGljIHByZXByb2Nlc3NJbnB1dFNoYXBlcyhlLHQpe3JldHVyblsxPT09ZS5sZW5ndGg/WzEsZVswXV06ZSwxPT09dC5sZW5ndGg/W3RbMF0sMV06dF19c3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUoZSx0LG4pezE9PT10JiZlLnNwbGljZShlLmxlbmd0aC0yLDEpLDE9PT1uJiZlLnBvcCgpfXN0YXRpYyBjYWxjTWF0TXVsU2hhcGUoZSx0KXtyZXR1cm4gZVsxXSE9PXRbMF0/dm9pZCAwOltlWzBdLHRbMV1dfX10Lk1hdE11bFV0aWw9dTtjbGFzcyBse3N0YXRpYyBjYWxjU2hhcGUoZSx0LG49ITEpe2NvbnN0IHI9ZS5sZW5ndGgsbz10Lmxlbmd0aDtpZigwPT09cilyZXR1cm4gdDtpZigwPT09bylyZXR1cm4gZTtjb25zdCBpPU1hdGgubWF4KGUubGVuZ3RoLHQubGVuZ3RoKSxzPW5ldyBBcnJheShpKTtpZihuKXtpZihyPDJ8fG88MilyZXR1cm47Y29uc3Qgbj11LmNhbGNNYXRNdWxTaGFwZShbZVtyLTJdLGVbci0xXV0sW3Rbby0yXSx0W28tMV1dKTtpZih2b2lkIDA9PT1uKXJldHVybjtbc1tpLTJdLHNbaS0xXV09bn1mb3IobGV0IGE9bj8zOjE7YTw9aTthKyspe2NvbnN0IG49ci1hPDA/MTplW3ItYV0sdT1vLWE8MD8xOnRbby1hXTtpZihuIT09dSYmbj4xJiZ1PjEpcmV0dXJuO3NbaS1hXT1NYXRoLm1heChuLHUpfXJldHVybiBzfXN0YXRpYyBpbmRleChlLHQpe2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoKTtyZXR1cm4gbC5maWxsSW5kZXgoZSx0LG4pLG59c3RhdGljIGZpbGxJbmRleChlLHQsbil7Y29uc3Qgcj1lLmxlbmd0aC10Lmxlbmd0aDtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rKyluW29dPWVbcitvXSV0W29dfXN0YXRpYyBjYWxjKGUsdCxuLHIsbyl7Y29uc3QgaT1sLmNhbGNTaGFwZShlLmRpbXMsdC5kaW1zKTtpZihpKXtpZihyJiYhZC5hcmVFcXVhbChpLGUuZGltcykpcmV0dXJuO2NvbnN0IHM9ZC5zaXplKGkpLHU9cj9lOm5ldyBhLlRlbnNvcihpLG98fGUudHlwZSk7aWYoMD09PWkubGVuZ3RoKXUuc2V0KFtdLG4oZS5nZXQoW10pLHQuZ2V0KFtdKSkpO2Vsc2V7Y29uc3Qgcj1uZXcgQXJyYXkoaS5sZW5ndGgpLG89bmV3IEFycmF5KGUuZGltcy5sZW5ndGgpLGE9bmV3IEFycmF5KHQuZGltcy5sZW5ndGgpO2xldCBjLHA9MCxkPTAsZj0hMSxoPSExOzA9PT1lLmRpbXMubGVuZ3RoJiYocD1lLmdldChbXSksZj0hMCksMD09PXQuZGltcy5sZW5ndGgmJihkPXQuZ2V0KFtdKSxoPSEwKTtmb3IobGV0IGc9MDtnPHM7ZysrKXtjPWc7Zm9yKGxldCBlPWkubGVuZ3RoLTE7ZT49MDtlLS0pcltlXT1jJWlbZV0sYz1NYXRoLmZsb29yKGMvaVtlXSk7Znx8KGwuZmlsbEluZGV4KHIsZS5kaW1zLG8pLHA9ZS5nZXQobykpLGh8fChsLmZpbGxJbmRleChyLHQuZGltcyxhKSxkPXQuZ2V0KGEpKSx1LnNldChyLG4ocCxkKSl9fXJldHVybiB1fX1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdChlLHQpe2NvbnN0IG49ZS5sZW5ndGgscj10Lmxlbmd0aDtpZihuPnIpcmV0dXJuITE7Zm9yKGxldCBvPTE7bzw9bjtvKyspaWYoMSE9PWVbbi1vXSYmZVtuLW9dIT09dFtyLW9dKXJldHVybiExO3JldHVybiEwfXN0YXRpYyBnZXRCcm9hZGNhc3REaW1zKGUsdCl7Y29uc3Qgbj1lLmxlbmd0aCxyPVtdO2ZvcihsZXQgbz0wO288bjtvKyspe2NvbnN0IGk9bi0xLW8scz1lW2ldfHwxOyh0W3QubGVuZ3RoLTEtb118fDEpPjEmJjE9PT1zJiZyLnVuc2hpZnQoaSl9cmV0dXJuIHJ9fXQuQnJvYWRjYXN0VXRpbD1sLHQuYXJyYXlDb3B5SGVscGVyPWZ1bmN0aW9uKGUsdCxuLHIsbyl7aWYocjwwfHxyPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK28+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK28+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IGk9MDtpPG87aSsrKWVbbitpXT10W3IraV19LHQuR2VtbVV0aWw9Y2xhc3N7c3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KGUsdCxuLHIsbyl7aWYoMiE9PWUubGVuZ3RofHwyIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDJcIik7bGV0IGkscyxhO3Q/KGk9ZVsxXSxzPWVbMF0pOihpPWVbMF0scz1lWzFdKTtsZXQgdT0tMTtpZihyPyhhPW5bMF0sdT0xKTooYT1uWzFdLHU9MCksblt1XSE9PXMpdGhyb3cgbmV3IEVycm9yKFwiZGltZW5zaW9uIG1pc21hdGNoXCIpO2lmKGk8PTB8fGE8PTB8fHM8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaGFwZSBzcGVjaWZpZWRcIik7aWYobyYmIWwuaXNWYWxpZEJyb2FkY2FzdChvLFtpLGFdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5baSxhLHNdfX07Y2xhc3MgY3tzdGF0aWMgdGVuc29yRGF0YVR5cGVGcm9tUHJvdG8oZSl7c3dpdGNoKGUpe2Nhc2Ugcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6cmV0dXJuXCJpbnQ4XCI7Y2FzZSBzLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6cmV0dXJuXCJ1aW50OFwiO2Nhc2Ugcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6cmV0dXJuXCJib29sXCI7Y2FzZSBzLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6cmV0dXJuXCJpbnQxNlwiO2Nhc2Ugcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpyZXR1cm5cInVpbnQxNlwiO2Nhc2Ugcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOnJldHVyblwiaW50MzJcIjtjYXNlIHMub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIHMub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIHMub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSBzLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOnJldHVyblwic3RyaW5nXCI7Y2FzZSBzLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6cmV0dXJuXCJpbnQzMlwiO2Nhc2Ugcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpyZXR1cm5cInVpbnQzMlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7cy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW2VdfWApfX1zdGF0aWMgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZSl7c3dpdGNoKGUpe2Nhc2VcImludDhcIjpyZXR1cm4gcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg7Y2FzZVwidWludDhcIjpyZXR1cm4gcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4O2Nhc2VcImJvb2xcIjpyZXR1cm4gcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7Y2FzZVwiaW50MTZcIjpyZXR1cm4gcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2O2Nhc2VcInVpbnQxNlwiOnJldHVybiBzLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2O2Nhc2VcImludDMyXCI6cmV0dXJuIHMub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIHMub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIHMub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHMub25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc7Y2FzZVwiaW50NjRcIjpyZXR1cm4gcy5vbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBzLm9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19c3RhdGljIHRlbnNvckRpbXNGcm9tUHJvdG8oZSl7cmV0dXJuIGUubWFwKChlPT5pLmRlZmF1bHQuaXNMb25nKGUpP2UudG9OdW1iZXIoKTplKSl9c3RhdGljIHRlbnNvclZhbHVlVHlwZUZyb21Qcm90byhlKXtyZXR1cm57dGVuc29yVHlwZTpjLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGUuZWxlbVR5cGUpLHNoYXBlOntkaW1zOmMudGVuc29yRGltc0Zyb21Qcm90byhlLnNoYXBlLmRpbS5tYXAoKGU9PmUuZGltVmFsdWUpKSl9fX1zdGF0aWMgdGVuc29yRGltc0Zyb21PUlRGb3JtYXQoZSl7Y29uc3QgdD1bXTtmb3IobGV0IG49MDtuPGUuZGltc0xlbmd0aCgpO24rKyl0LnB1c2gocC5sb25nVG9OdW1iZXIoZS5kaW1zKG4pKSk7cmV0dXJuIHR9c3RhdGljIHRlbnNvckF0dHJpYnV0ZXNGcm9tT1JURm9ybWF0KGUpe2NvbnN0IHQ9W107Zm9yKGxldCBuPTA7bjxlLmF0dHJpYnV0ZXNMZW5ndGgoKTtuKyspdC5wdXNoKGUuYXR0cmlidXRlcyhuKSk7cmV0dXJuIHR9fXQuUHJvdG9VdGlsPWM7Y2xhc3MgcHtzdGF0aWMgbG9uZ1RvTnVtYmVyKGUsdCl7cmV0dXJuIGkuZGVmYXVsdC5pc0xvbmcoZSk/ZS50b051bWJlcigpOmUgaW5zdGFuY2VvZiBvLmZsYXRidWZmZXJzLkxvbmc/aS5kZWZhdWx0LmZyb21WYWx1ZSh7bG93OmUubG93LGhpZ2g6ZS5oaWdoLHVuc2lnbmVkOm51bGwhPXQmJnR9KS50b051bWJlcigpOmV9c3RhdGljIGlzTG9uZyhlKXtyZXR1cm4gaS5kZWZhdWx0LmlzTG9uZyhlKXx8ZSBpbnN0YW5jZW9mIG8uZmxhdGJ1ZmZlcnMuTG9uZ319dC5Mb25nVXRpbD1wO2NsYXNzIGR7c3RhdGljIHNpemUoZSl7cmV0dXJuIGQuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShlLDAsZS5sZW5ndGgpfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbihlLHQpe2lmKHQ8MHx8dD5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7dH0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtlLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGUsdCxlLmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbihlLHQpe2lmKHQ8MHx8dD5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7dH0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZS5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGQuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShlLDAsdCl9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZSx0LG4pe2xldCByPTE7Zm9yKGxldCBvPXQ7bzxuO28rKyl7aWYoZVtvXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7cio9ZVtvXX1yZXR1cm4gcn1zdGF0aWMgY29tcHV0ZVN0cmlkZXMoZSl7Y29uc3QgdD1lLmxlbmd0aDtpZigwPT09dClyZXR1cm5bXTtpZigxPT09dClyZXR1cm5bMV07Y29uc3Qgbj1uZXcgQXJyYXkodCk7blt0LTFdPTEsblt0LTJdPWVbdC0xXTtmb3IobGV0IHI9dC0zO3I+PTA7LS1yKW5bcl09bltyKzFdKmVbcisxXTtyZXR1cm4gbn1zdGF0aWMgdHJhbnNwb3NlKGUpe3JldHVybiBlLnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBpbmRpY2VzVG9PZmZzZXQoZSx0LG4pe3ZvaWQgMD09PW4mJihuPWUubGVuZ3RoKTtsZXQgcj0wO2ZvcihsZXQgbz0wO288bjsrK28pcis9dFtvXSplW29dO3JldHVybiByfXN0YXRpYyBvZmZzZXRUb0luZGljZXMoZSx0KXtjb25zdCBuPXQubGVuZ3RoO2lmKDA9PT1uKXJldHVybltdO2lmKDE9PT1uKXJldHVybltlKnRbMF1dO2NvbnN0IHI9bmV3IEFycmF5KHQubGVuZ3RoKTtmb3IobGV0IG49MDtuPHIubGVuZ3RoLTE7KytuKXJbbl09TWF0aC5mbG9vcihlL3Rbbl0pLGUtPXJbbl0qdFtuXTtyZXR1cm4gcltyLmxlbmd0aC0xXT1lLHJ9c3RhdGljIG5vcm1hbGl6ZUF4aXMoZSx0KXtpZihlPC10JiZlPj10KXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gZTwwP2UrdDplfXN0YXRpYyBub3JtYWxpemVBeGVzKGUsdCl7cmV0dXJuIGUubWFwKChlPT50aGlzLm5vcm1hbGl6ZUF4aXMoZSx0KSkpfXN0YXRpYyBpbmNyZW1lbnRJbmRleChlLHQsbil7aWYoMD09PXQubGVuZ3RofHwwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggaW5jcmVtZW50aW5nIHVuc3VwcG9ydGVkIGZvciBzY2FsYXIgVGVuc29yXCIpO2lmKHZvaWQgMD09PW4pbj10Lmxlbmd0aDtlbHNlIGlmKG48PTB8fG4+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IGF4aXMgdG8gaW5jcmVtZW50IG9uXCIpO2ZvcihsZXQgcj1uLTE7cj49MCYmKGVbcl0rKywhKGVbcl08dFtyXSkpOy0tcillW3JdPTB9c3RhdGljIGNhbGN1bGF0ZVJlc2hhcGVkRGltcyhlLHQpe2lmKDA9PT10Lmxlbmd0aCl7aWYoMD09PWUubGVuZ3RofHwxPT09ZC5zaXplKGUpKXJldHVybltdO3Rocm93IG5ldyBFcnJvcihcImNhbm5vdCByZXNoYXBlIHRvIGEgc2NhbGFyIFRlbnNvclwiKX1jb25zdCBuPXQubGVuZ3RoLHI9bmV3IEFycmF5KG4pO2xldCBvPS0xLGk9MTtmb3IobGV0IHM9MDtzPG47cysrKXtpZih0W3NdPC0xKXRocm93IG5ldyBFcnJvcihcImEgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbm5vdCBiZSBsZXNzIHRoYW4gLTFcIik7aWYoLTE9PT10W3NdKXtpZigtMSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiYXQgbW9zdCBvbmUgZGltZW5zaW9uIGluIHNoYXBlIGhpbnRzIGNhbiBiZSAtMVwiKTtvPXN9ZWxzZXtpZigwPT09dFtzXSl7aWYocz49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvclwiKTtyW3NdPWVbc119ZWxzZSByW3NdPXRbc107aSo9cltzXX19Y29uc3Qgcz1kLnNpemUoZSk7aWYoLTEhPT1vKXtpZihzJWkhPTApdGhyb3cgbmV3IEVycm9yKGB0aGUgaW5wdXQgdGVuc29yIGNhbm5vdCBiZSByZXNoYXBlZCB0byB0aGUgcmVxdWVzdGVkIHNoYXBlLiBJbnB1dCBzaGFwZTogWyR7ZX1dIE91dHB1dCBzaGFwZTogWyR7dH1dYCk7cltvXT1zL2l9ZWxzZSBpZihpIT09cyl0aHJvdyBuZXcgRXJyb3IoXCJyZXNoYXBlZERpbXMgYW5kIG9yaWdpbmFsRGltcyBkb24ndCBoYXZlIG1hdGNoaW5nIHNpemVzXCIpO3JldHVybiByfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0oZSx0KXtyZXR1cm4gdD90Lm1hcCgodD0+ZVt0XSkpOmUuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKGUsdCl7Y29uc3Qgbj1lLmxlbmd0aDtyZXR1cm4gZS5tYXAoKChlLHIpPT5lK3Rbcl0rdFtyK25dKSl9c3RhdGljIGFyZUVxdWFsKGUsdCl7cmV0dXJuIGUubGVuZ3RoPT09dC5sZW5ndGgmJmUuZXZlcnkoKChlLG4pPT5lPT09dFtuXSkpfXN0YXRpYyB2YWxpZGF0ZURpbXNBbmRDYWxjU2l6ZShlKXtpZihlLmxlbmd0aD42KXRocm93IG5ldyBUeXBlRXJyb3IoXCJPbmx5IHJhbmsgMCB0byA2IGlzIHN1cHBvcnRlZCBmb3IgdGVuc29yIHNoYXBlLlwiKTtsZXQgdD0xO2Zvcihjb25zdCBuIG9mIGUpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtpZihuPDB8fG4+MjE0NzQ4MzY0Nyl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO3QqPW59cmV0dXJuIHR9c3RhdGljIGZsYXR0ZW5TaGFwZShlLHQpe3Q8MCYmKHQrPWUubGVuZ3RoKTtjb25zdCBuPWUucmVkdWNlKCgoZSx0KT0+ZSp0KSwxKSxyPWUuc2xpY2UodCkucmVkdWNlKCgoZSx0KT0+ZSp0KSwxKTtyZXR1cm5bbi9yLHJdfXN0YXRpYyBzcXVlZXplU2hhcGUoZSx0KXtjb25zdCBuPW5ldyBBcnJheTt0PWQubm9ybWFsaXplQXhlcyh0LGUubGVuZ3RoKTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7Y29uc3Qgbz10LmluZGV4T2Yocik+PTA7aWYobyYmMSE9PWVbcl0pdGhyb3cgbmV3IEVycm9yKFwic3F1ZWV6ZSBhbiBheGlzIG9mIHNpemUgZGlmZmVyZW50IHRoYW4gMVwiKTsoMD09PXQubGVuZ3RoJiZlW3JdPjF8fHQubGVuZ3RoPjAmJiFvKSYmbi5wdXNoKGVbcl0pfXJldHVybiBufXN0YXRpYyB1bnNxdWVlemVTaGFwZShlLHQpe2NvbnN0IG49bmV3IEFycmF5KGUubGVuZ3RoK3QubGVuZ3RoKTtuLmZpbGwoMCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IHI9ZC5ub3JtYWxpemVBeGlzKHRbZV0sbi5sZW5ndGgpO2lmKHI+PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIidheGVzJyBoYXMgYW4gb3V0IG9mIHJhbmdlIGF4aXNcIik7aWYoMCE9PW5bcl0pdGhyb3cgbmV3IEVycm9yKFwiJ2F4ZXMnIGhhcyBhIGR1cGxpY2F0ZSBheGlzXCIpO25bcl09MX1sZXQgcj0wO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKTA9PT1uW3RdJiYoblt0XT1lW3IrK10pO2lmKHIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgdW5zcXVlZXplZCBkaW1lbnNpb24gY291bGQgbm90IGJlIGVzdGFibGlzaGVkXCIpO3JldHVybiBufX10LlNoYXBlVXRpbD1kLHQuTWF0aFV0aWw9Y2xhc3N7c3RhdGljIHNxcihlLHQsbixyLG8pe2lmKHI8MHx8cj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitvPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitvPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBpPTA7aTxvO2krKyllW24raV0rPU1hdGgucG93KHRbcitpXSwyKX1zdGF0aWMgYXhweShlLHQsbixyLG8saSl7aWYocjwwfHxyPj10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MHx8bj49ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihyK28+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kc1wiKTtpZihuK28+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdFwiKTtmb3IobGV0IHM9MDtzPG87cysrKWVbbitzXSs9aSp0W3Irc119c3RhdGljIHBvd3goZSx0LG4scixvLGkpe2lmKHI8MHx8cj49dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic291cmNlSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldEluZGV4IG91dCBvZiBib3VuZHNcIik7aWYocitvPnQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHNcIik7aWYobitvPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHRcIik7Zm9yKGxldCBzPTA7czxvO3MrKyllW24rc109TWF0aC5wb3codFtyK3NdLGkpfXN0YXRpYyBtdWwoZSx0LG4scixvKXtpZihyPDB8fHI+PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNvdXJjZUluZGV4IG91dCBvZiBib3VuZHNcIik7aWYobjwwfHxuPj1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzXCIpO2lmKHIrbz50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzXCIpO2lmKG4rbz5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0XCIpO2ZvcihsZXQgaT0wO2k8bztpKyspZVtuK2ldPXRbcitpXSplW24raV19fTtjbGFzcyBme3N0YXRpYyBzcGxpdFNoYXBlKGUsdCxuLHIpe2lmKDA9PT1uLmxlbmd0aCl7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwibmVlZCB0byBrbm93IG51bWJlciBvZiBvdXRwdXRzIHdoZW4gdGhlICdzcGxpdCcgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWRcIik7Zi5kZXRlcm1pbmVTcGxpdChlW3RdLHIsbil9Y29uc3Qgbz1bXSxpPVswXTtmb3IobGV0IHI9MDtyPG4ubGVuZ3RoOysrcil7MCE9PXImJmkucHVzaChpW3ItMV0rbltyLTFdKTtjb25zdCBzPWUuc2xpY2UoKTtzW3RdPW5bcl0sby5wdXNoKHMpfXJldHVybltvLGldfXN0YXRpYyBkZXRlcm1pbmVTcGxpdChlLHQsbil7aWYoZSV0IT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzcGxpdCB0ZW5zb3IgdG8gZXF1YWwgc2l6ZWQgcGFydHNcIik7Zm9yKGxldCByPTA7cjx0OysrciluLnB1c2goZS90KX19dC5TcGxpdFV0aWw9ZjtjbGFzcyBoe3N0YXRpYyBjYWxjUmVkdWNlKGUsdCxuLHIsbyl7Y29uc3QgaT1lLmRpbXMuc2xpY2UoMCk7MD09PXQubGVuZ3RoJiZpLmZvckVhY2goKChlLG4pPT50LnB1c2gobikpKTtjb25zdCBzPWguY2FsY1JlZHVjZVNoYXBlKGksdCwhMCksdT1kLnNpemUocyksYz1uZXcgYS5UZW5zb3IocyxlLnR5cGUpLHA9ZC5jb21wdXRlU3RyaWRlcyhzKSxmPWQuY29tcHV0ZVN0cmlkZXMoaSksZz1uZXcgQXJyYXkoaS5sZW5ndGgpO2ZvcihsZXQgbj0wO248dTtuKyspe2NvbnN0IHM9ZC5vZmZzZXRUb0luZGljZXMobixwKTtsLmZpbGxJbmRleChzLGksZyksYy5zZXQocyxoLmNhbGNSZWR1Y2VCeUF4aXMoZS5udW1iZXJEYXRhLHQsaSwwLGQuaW5kaWNlc1RvT2Zmc2V0KGcsZikscixvKSl9cmV0dXJuIG4/YzpuZXcgYS5UZW5zb3IoaC5jYWxjUmVkdWNlU2hhcGUoaSx0LG4pLGMudHlwZSx2b2lkIDAsdm9pZCAwLGMuZGF0YSxjLmRhdGFJZCl9c3RhdGljIGNhbGNSZWR1Y2VCeUF4aXMoZSx0LG4scixvLGkscyl7bGV0IGE9MDtpZihyPj10Lmxlbmd0aClyZXR1cm4gaShlW29dKTtjb25zdCB1PXRbcl0sbD11Pj1uLmxlbmd0aD8xOmQuc2l6ZShuLnNsaWNlKHUrMSkpO2ZvcihsZXQgYz0wO2M8blt1XTtjKyspYT0wPT09Yz9oLmNhbGNSZWR1Y2VCeUF4aXMoZSx0LG4scisxLG8saSxzKTpzKGEsaC5jYWxjUmVkdWNlQnlBeGlzKGUsdCxuLHIrMSxvLGkscykpLG8rPWw7cmV0dXJuIGF9c3RhdGljIGNhbGNSZWR1Y2VTaGFwZShlLHQsbil7Y29uc3Qgcj1lLnNsaWNlKCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspclt0W2VdXT1uPzE6MDtyZXR1cm4gci5maWx0ZXIoKGU9PjAhPT1lKSl9fXQuUmVkdWNlVXRpbD1oO2NsYXNzIGd7c3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKGUsdCxuLHIsbyxpKXtpZighZSYmbi5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnNcIik7aWYoZSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTI7ZSsrKWU+PW4ubGVuZ3RoP24ucHVzaCh0W2UrMl0pOm5bZV09dFtlKzJdO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKWlmKGU8ci5sZW5ndGgpe2lmKHJbZV08MCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHIucHVzaCgxKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKylpZihlPG8ubGVuZ3RoKXtpZihvW2VdPDApdGhyb3cgbmV3IEVycm9yKFwiZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIG8ucHVzaCgxKTtmb3IobGV0IGU9MDtlPDIqbi5sZW5ndGg7ZSsrKWlmKGU8aS5sZW5ndGgpe2lmKGlbZV08MCl0aHJvdyBuZXcgRXJyb3IoXCJwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgaS5wdXNoKDApO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKXtpZihuW2VdPD0wKXRocm93IG5ldyBFcnJvcihcImtlcm5lbCBzaGFwZXMgbmVlZCB0byBiZSBncmVhdGVyIHRoYW4gMFwiKTtpZihpW2VdPj1uW2VdfHxpW2Urbi5sZW5ndGhdPj1uW2VdKXRocm93IG5ldyBFcnJvcihcInBhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWxcIil9fXN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoZSx0LG4scixvLGkpe2lmKGkpe2lmKG8ubGVuZ3RoIT09MiooZS5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoci5sZW5ndGghPT1lLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IHM9MDtzPGUubGVuZ3RoLTI7cysrKWcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoZVtzKzJdLHRbc10sbltzXSxyW3NdLG8scyxzK2UubGVuZ3RoLTIsaSl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKGUsdCxuLHIsbyxpLHMpe2lmKHQubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtjb25zdCBhPVt0WzBdLHRbMV1dO3JldHVybiBnLmNvbXB1dGVTaGFwZUhlbHBlcihlLHQsYSxuLHIsbyxpLHMpLGF9c3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUoZSx0LG4scixvLGkscyl7aWYoZS5sZW5ndGg8PTB8fHQubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXQgdGVuc29yIGRpbXMgb3IgaW52YWxpZCBmaWx0ZXIgdGVuc29yIGRpbXNcIik7Y29uc3QgYT1bZVswXSx0WzBdXTtyZXR1cm4gZy5jb21wdXRlU2hhcGVIZWxwZXIoITEsZSxhLG4scixvLGkscyksYX1zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKGUsdCxuLHIsbyxpLHMsYSl7aWYoZSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoLTI7ZSsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMjtlKyspbi5wdXNoKGcuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFtlKzJdLHJbZV0sb1tlXSxpW2VdLHMsZSxlK3QubGVuZ3RoLTIsYSkpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShlLHQsbixyLG8saSxzLGEpe2NvbnN0IHU9biooci0xKSsxO2lmKCFhfHxcIk5PVFNFVFwiPT09YSlyZXR1cm4gTWF0aC5mbG9vcigoZStvW2ldK29bc10tdSkvdCsxKTtzd2l0Y2goYSl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gb1tpXT0wLG9bc109MCxNYXRoLmZsb29yKChlLXUpL3QrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZigxIT09bil0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2NvbnN0IG49KChlK3QtMSkvdC0xKSp0K3ItZTtyZXR1cm4gb1tpXT1cIlNBTUVfTE9XRVJcIj09PWE/TWF0aC5mbG9vcigobisxKS8yKTpNYXRoLmZsb29yKG4vMiksb1tzXT1uLW9baV0sTWF0aC5mbG9vcigoZStuLXIpL3QrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9fX10LlBvb2xDb252VXRpbD1nLHQuTUlOX0NMSVA9LTM0MDI4MjM0NjYzODUyODg2ZTIyLHQuTUFYX0NMSVA9MzQwMjgyMzQ2NjM4NTI4ODZlMjIsdC5kZWNvZGVVdGY4U3RyaW5nPWZ1bmN0aW9uKGUpe3JldHVybihuZXcgVGV4dERlY29kZXIpLmRlY29kZShlKX19LDg0MDg6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnZlcnNpb249dm9pZCAwLHQudmVyc2lvbj1cIjEuMTYuM1wifSw5NTQ0OmZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcixvPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKTt2YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbik7byYmIShcImdldFwiaW4gbz8hdC5fX2VzTW9kdWxlOm8ud3JpdGFibGV8fG8uY29uZmlndXJhYmxlKXx8KG89e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbbl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixvKX06ZnVuY3Rpb24oZSx0LG4scil7dm9pZCAwPT09ciYmKHI9biksZVtyXT10W25dfSksaT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSl9OmZ1bmN0aW9uKGUsdCl7ZS5kZWZhdWx0PXR9KSxzPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIG4gaW4gZSlcImRlZmF1bHRcIiE9PW4mJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pJiZvKHQsZSxuKTtyZXR1cm4gaSh0LGUpLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZW5kUHJvZmlsaW5nPXQucnVuPXQucmVsZWFzZVNlc3Npb249dC5jcmVhdGVTZXNzaW9uPXQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPXQuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPXQuaW5pdGlhbGl6ZVJ1bnRpbWU9dC5pbml0aWFsaXplV2ViQXNzZW1ibHlJbnN0YW5jZT12b2lkIDA7Y29uc3QgYT1uKDYyMDcpLHU9cyhuKDEyNTkpKSxsPW4oMjYzKSxjPSgpPT4hIWEuZW52Lndhc20ucHJveHkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudDtsZXQgcCxkLGYsaD0hMSxnPSExLGI9ITE7Y29uc3QgbT1bXSx5PVtdLF89W10sdj1bXSxUPVtdLHg9W10sdz0oKT0+e2lmKGh8fCFnfHxifHwhcCl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxPPWU9Pntzd2l0Y2goZS5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOmg9ITEsZS5kYXRhLmVycj8oYj0hMCxkWzFdKGUuZGF0YS5lcnIpKTooZz0hMCxkWzBdKCkpO2JyZWFrO2Nhc2VcImluaXQtb3J0XCI6ZS5kYXRhLmVycj9mWzFdKGUuZGF0YS5lcnIpOmZbMF0oKTticmVhaztjYXNlXCJjcmVhdGVfYWxsb2NhdGVcIjplLmRhdGEuZXJyP20uc2hpZnQoKVsxXShlLmRhdGEuZXJyKTptLnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWs7Y2FzZVwiY3JlYXRlX2ZpbmFsaXplXCI6ZS5kYXRhLmVycj95LnNoaWZ0KClbMV0oZS5kYXRhLmVycik6eS5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImNyZWF0ZVwiOmUuZGF0YS5lcnI/Xy5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOl8uc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVhaztjYXNlXCJyZWxlYXNlXCI6ZS5kYXRhLmVycj92LnNoaWZ0KClbMV0oZS5kYXRhLmVycik6di5zaGlmdCgpWzBdKCk7YnJlYWs7Y2FzZVwicnVuXCI6ZS5kYXRhLmVycj9ULnNoaWZ0KClbMV0oZS5kYXRhLmVycik6VC5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjplLmRhdGEuZXJyP3guc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp4LnNoaWZ0KClbMF0oKX19LFM9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50P251bGw9PT0ocj1udWxsPT09ZG9jdW1lbnR8fHZvaWQgMD09PWRvY3VtZW50P3ZvaWQgMDpkb2N1bWVudC5jdXJyZW50U2NyaXB0KXx8dm9pZCAwPT09cj92b2lkIDA6ci5zcmM6dm9pZCAwO3QuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5SW5zdGFuY2U9YXN5bmMoKT0+e2lmKGMoKSl7aWYoZylyZXR1cm47aWYoaCl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKGIpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtyZXR1cm4gaD0hMCx2b2lkIDA9PT1hLmVudi53YXNtLndhc21QYXRocyYmUyYmMCE9PVMuaW5kZXhPZihcImJsb2I6XCIpJiYoYS5lbnYud2FzbS53YXNtUGF0aHM9Uy5zdWJzdHIoMCwrUy5sYXN0SW5kZXhPZihcIi9cIikrMSkpLG5ldyBQcm9taXNlKCgoZSx0KT0+e251bGw9PXB8fHAudGVybWluYXRlKCkscD1uKDgwNTApLlooKSxwLm9ubWVzc2FnZT1PLGQ9W2UsdF07Y29uc3Qgcj17dHlwZTpcImluaXQtd2FzbVwiLGluOmEuZW52Lndhc219O3AucG9zdE1lc3NhZ2Uocil9KSl9cmV0dXJuKDAsbC5pbml0aWFsaXplV2ViQXNzZW1ibHkpKGEuZW52Lndhc20pfSx0LmluaXRpYWxpemVSdW50aW1lPWFzeW5jIGU9PntpZihjKCkpcmV0dXJuIHcoKSxuZXcgUHJvbWlzZSgoKHQsbik9PntmPVt0LG5dO2NvbnN0IHI9e3R5cGU6XCJpbml0LW9ydFwiLGluOmV9O3AucG9zdE1lc3NhZ2Uocil9KSk7YXdhaXQgdS5pbml0UnVudGltZShlKX0sdC5jcmVhdGVTZXNzaW9uQWxsb2NhdGU9YXN5bmMgZT0+YygpPyh3KCksbmV3IFByb21pc2UoKCh0LG4pPT57bS5wdXNoKFt0LG5dKTtjb25zdCByPXt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsaW46e21vZGVsOmV9fTtwLnBvc3RNZXNzYWdlKHIsW2UuYnVmZmVyXSl9KSkpOnUuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKGUpLHQuY3JlYXRlU2Vzc2lvbkZpbmFsaXplPWFzeW5jKGUsdCk9PmMoKT8odygpLG5ldyBQcm9taXNlKCgobixyKT0+e3kucHVzaChbbixyXSk7Y29uc3Qgbz17dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLGluOnttb2RlbGRhdGE6ZSxvcHRpb25zOnR9fTtwLnBvc3RNZXNzYWdlKG8pfSkpKTp1LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZShlLHQpLHQuY3JlYXRlU2Vzc2lvbj1hc3luYyhlLHQpPT5jKCk/KHcoKSxuZXcgUHJvbWlzZSgoKG4scik9PntfLnB1c2goW24scl0pO2NvbnN0IG89e3R5cGU6XCJjcmVhdGVcIixpbjp7bW9kZWw6ZSxvcHRpb25zOnR9fTtwLnBvc3RNZXNzYWdlKG8sW2UuYnVmZmVyXSl9KSkpOnUuY3JlYXRlU2Vzc2lvbihlLHQpLHQucmVsZWFzZVNlc3Npb249YXN5bmMgZT0+e2lmKGMoKSlyZXR1cm4gdygpLG5ldyBQcm9taXNlKCgodCxuKT0+e3YucHVzaChbdCxuXSk7Y29uc3Qgcj17dHlwZTpcInJlbGVhc2VcIixpbjplfTtwLnBvc3RNZXNzYWdlKHIpfSkpO3UucmVsZWFzZVNlc3Npb24oZSl9LHQucnVuPWFzeW5jKGUsdCxuLHIsbyk9PmMoKT8odygpLG5ldyBQcm9taXNlKCgoaSxzKT0+e1QucHVzaChbaSxzXSk7Y29uc3QgYT17dHlwZTpcInJ1blwiLGluOntzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6dCxpbnB1dHM6bixvdXRwdXRJbmRpY2VzOnIsb3B0aW9uczpvfX07cC5wb3N0TWVzc2FnZShhLHUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMobikpfSkpKTp1LnJ1bihlLHQsbixyLG8pLHQuZW5kUHJvZmlsaW5nPWFzeW5jIGU9PntpZihjKCkpcmV0dXJuIHcoKSxuZXcgUHJvbWlzZSgoKHQsbik9Pnt4LnB1c2goW3Qsbl0pO2NvbnN0IHI9e3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsaW46ZX07cC5wb3N0TWVzc2FnZShyKX0pKTt1LmVuZFByb2ZpbGluZyhlKX19LDc5MTg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuc2V0UnVuT3B0aW9ucz12b2lkIDA7Y29uc3Qgcj1uKDI2Myksbz1uKDE0OTcpO3Quc2V0UnVuT3B0aW9ucz1lPT57Y29uc3QgdD0oMCxyLmdldEluc3RhbmNlKSgpO2xldCBuPTA7Y29uc3QgaT1bXSxzPWV8fHt9O3RyeXtpZih2b2lkIDA9PT0obnVsbD09ZT92b2lkIDA6ZS5sb2dTZXZlcml0eUxldmVsKSlzLmxvZ1NldmVyaXR5TGV2ZWw9MjtlbHNlIGlmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmxvZ1NldmVyaXR5TGV2ZWx8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nU2V2ZXJpdHlMZXZlbCl8fGUubG9nU2V2ZXJpdHlMZXZlbDwwfHxlLmxvZ1NldmVyaXR5TGV2ZWw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nU2V2ZXJpdHlMZXZlbH1gKTtpZih2b2lkIDA9PT0obnVsbD09ZT92b2lkIDA6ZS5sb2dWZXJib3NpdHlMZXZlbCkpcy5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWx8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTt2b2lkIDA9PT0obnVsbD09ZT92b2lkIDA6ZS50ZXJtaW5hdGUpJiYocy50ZXJtaW5hdGU9ITEpO2xldCByPTA7cmV0dXJuIHZvaWQgMCE9PShudWxsPT1lP3ZvaWQgMDplLnRhZykmJihyPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShlLnRhZyxpKSksbj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKHMubG9nU2V2ZXJpdHlMZXZlbCxzLmxvZ1ZlcmJvc2l0eUxldmVsLCEhcy50ZXJtaW5hdGUsciksMD09PW4mJigwLG8uY2hlY2tMYXN0RXJyb3IpKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSx2b2lkIDAhPT0obnVsbD09ZT92b2lkIDA6ZS5leHRyYSkmJigwLG8uaXRlcmF0ZUV4dHJhT3B0aW9ucykoZS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCgoZSxyKT0+e2NvbnN0IHM9KDAsby5hbGxvY1dhc21TdHJpbmcpKGUsaSksYT0oMCxvLmFsbG9jV2FzbVN0cmluZykocixpKTswIT09dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkobixzLGEpJiYoMCxvLmNoZWNrTGFzdEVycm9yKShgQ2FuJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtlfSAtICR7cn0uYCl9KSksW24saV19Y2F0Y2goZSl7dGhyb3cgMCE9PW4mJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLGkuZm9yRWFjaCgoZT0+dC5fZnJlZShlKSkpLGV9fX0sNjY0MDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Pbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXI9dm9pZCAwO2NvbnN0IHI9big2MjMxKSxvPW4oNjIwNyksaT1uKDY0NjQpLHM9big5NTQ0KTtsZXQgYTt0Lk9ubnhydW50aW1lV2ViQXNzZW1ibHlTZXNzaW9uSGFuZGxlcj1jbGFzc3thc3luYyBjcmVhdGVTZXNzaW9uQWxsb2NhdGUoZSl7Y29uc3QgdD1hd2FpdCBmZXRjaChlKTtpZigyMDAhPT10LnN0YXR1cyl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIG1vZGVsOiAke2V9YCk7Y29uc3Qgbj1hd2FpdCB0LmFycmF5QnVmZmVyKCk7cmV0dXJuKDAscy5jcmVhdGVTZXNzaW9uQWxsb2NhdGUpKG5ldyBVaW50OEFycmF5KG4pKX1hc3luYyBsb2FkTW9kZWwoZSx0KXtpZihhfHwoYXdhaXQoMCxzLmluaXRpYWxpemVSdW50aW1lKShvLmVudiksYT0hMCksXCJzdHJpbmdcIj09dHlwZW9mIGUpaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZSl7Y29uc3Qgbj1hd2FpdCgwLGkucHJvbWlzaWZ5KShyLnJlYWRGaWxlKShlKTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAscy5jcmVhdGVTZXNzaW9uKShuLHQpfWVsc2V7Y29uc3Qgbj1hd2FpdCB0aGlzLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZShlKTtbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0KDAscy5jcmVhdGVTZXNzaW9uRmluYWxpemUpKG4sdCl9ZWxzZVt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQoMCxzLmNyZWF0ZVNlc3Npb24pKGUsdCl9YXN5bmMgZGlzcG9zZSgpe3JldHVybigwLHMucmVsZWFzZVNlc3Npb24pKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4oZSx0LG4pe2NvbnN0IHI9W10saT1bXTtPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChlPT57Y29uc3QgdD1lWzBdLG49ZVsxXSxvPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKHQpO2lmKC0xPT09byl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7dH0nYCk7ci5wdXNoKG4pLGkucHVzaChvKX0pKTtjb25zdCBhPVtdO09iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKGU9Pntjb25zdCB0PWVbMF0sbj10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YodCk7aWYoLTE9PT1uKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7dH0nYCk7YS5wdXNoKG4pfSkpO2NvbnN0IHU9YXdhaXQoMCxzLnJ1bikodGhpcy5zZXNzaW9uSWQsaSxyLm1hcCgoZT0+W2UudHlwZSxlLmRpbXMsZS5kYXRhXSkpLGEsbiksbD17fTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKylsW3RoaXMub3V0cHV0TmFtZXNbYVtlXV1dPW5ldyBvLlRlbnNvcih1W2VdWzBdLHVbZV1bMl0sdVtlXVsxXSk7cmV0dXJuIGx9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7KDAscy5lbmRQcm9maWxpbmcpKHRoaXMuc2Vzc2lvbklkKX19fSw3NjIyOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnNldFNlc3Npb25PcHRpb25zPXZvaWQgMDtjb25zdCByPW4oMjYzKSxvPW4oMTQ5Nyk7dC5zZXRTZXNzaW9uT3B0aW9ucz1lPT57dmFyIHQsbixpLHM7Y29uc3QgYT0oMCxyLmdldEluc3RhbmNlKSgpO2xldCB1PTA7Y29uc3QgbD1bXSxjPWV8fHt9OyhlPT57ZS5leHRyYXx8KGUuZXh0cmE9e30pLGUuZXh0cmEuc2Vzc2lvbnx8KGUuZXh0cmEuc2Vzc2lvbj17fSk7Y29uc3QgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZSgoZT0+XCJ3ZWJncHVcIj09PShcInN0cmluZ1wiPT10eXBlb2YgZT9lOmUubmFtZSkpKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9KShjKTt0cnl7Y29uc3QgZT0oZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0pKG51bGwhPT0odD1jLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpJiZ2b2lkIDAhPT10P3Q6XCJhbGxcIikscD0oZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19KShudWxsIT09KG49Yy5leGVjdXRpb25Nb2RlKSYmdm9pZCAwIT09bj9uOlwic2VxdWVudGlhbFwiKSxkPVwic3RyaW5nXCI9PXR5cGVvZiBjLmxvZ0lkPygwLG8uYWxsb2NXYXNtU3RyaW5nKShjLmxvZ0lkLGwpOjAsZj1udWxsIT09KGk9Yy5sb2dTZXZlcml0eUxldmVsKSYmdm9pZCAwIT09aT9pOjI7aWYoIU51bWJlci5pc0ludGVnZXIoZil8fGY8MHx8Zj40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7Zn1gKTtjb25zdCBoPW51bGwhPT0ocz1jLmxvZ1ZlcmJvc2l0eUxldmVsKSYmdm9pZCAwIT09cz9zOjA7aWYoIU51bWJlci5pc0ludGVnZXIoaCl8fGg8MHx8aD40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7aH1gKTtjb25zdCBnPVwic3RyaW5nXCI9PXR5cGVvZiBjLm9wdGltaXplZE1vZGVsRmlsZVBhdGg/KDAsby5hbGxvY1dhc21TdHJpbmcpKGMub3B0aW1pemVkTW9kZWxGaWxlUGF0aCxsKTowO3JldHVybiB1PWEuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKGUsISFjLmVuYWJsZUNwdU1lbUFyZW5hLCEhYy5lbmFibGVNZW1QYXR0ZXJuLHAsISFjLmVuYWJsZVByb2ZpbGluZywwLGQsZixoLGcpLDA9PT11JiYoMCxvLmNoZWNrTGFzdEVycm9yKShcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpLGMuZXhlY3V0aW9uUHJvdmlkZXJzJiYoKGUsdCxuKT0+e2Zvcihjb25zdCBpIG9mIHQpe2xldCB0PVwic3RyaW5nXCI9PXR5cGVvZiBpP2k6aS5uYW1lO3N3aXRjaCh0KXtjYXNlXCJ4bm5wYWNrXCI6dD1cIlhOTlBBQ0tcIjticmVhaztjYXNlXCJ3ZWJublwiOmlmKHQ9XCJXRUJOTlwiLFwic3RyaW5nXCIhPXR5cGVvZiBpKXtjb25zdCB0PWk7aWYobnVsbD09dD92b2lkIDA6dC5kZXZpY2VUeXBlKXtjb25zdCBpPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShcImRldmljZVR5cGVcIixuKSxzPSgwLG8uYWxsb2NXYXNtU3RyaW5nKSh0LmRldmljZVR5cGUsbik7MCE9PSgwLHIuZ2V0SW5zdGFuY2UpKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGkscykmJigwLG8uY2hlY2tMYXN0RXJyb3IpKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHt0LmRldmljZVR5cGV9LmApfWlmKG51bGw9PXQ/dm9pZCAwOnQucG93ZXJQcmVmZXJlbmNlKXtjb25zdCBpPSgwLG8uYWxsb2NXYXNtU3RyaW5nKShcInBvd2VyUHJlZmVyZW5jZVwiLG4pLHM9KDAsby5hbGxvY1dhc21TdHJpbmcpKHQucG93ZXJQcmVmZXJlbmNlLG4pOzAhPT0oMCxyLmdldEluc3RhbmNlKSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxpLHMpJiYoMCxvLmNoZWNrTGFzdEVycm9yKShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwb3dlclByZWZlcmVuY2UnIC0gJHt0LnBvd2VyUHJlZmVyZW5jZX0uYCl9fWJyZWFrO2Nhc2VcIndlYmdwdVwiOnQ9XCJKU1wiO2JyZWFrO2Nhc2VcIndhc21cIjpjYXNlXCJjcHVcIjpjb250aW51ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7dH1gKX1jb25zdCBzPSgwLG8uYWxsb2NXYXNtU3RyaW5nKSh0LG4pOzAhPT0oMCxyLmdldEluc3RhbmNlKSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLHMpJiYoMCxvLmNoZWNrTGFzdEVycm9yKShgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHt0fS5gKX19KSh1LGMuZXhlY3V0aW9uUHJvdmlkZXJzLGwpLHZvaWQgMCE9PWMuZXh0cmEmJigwLG8uaXRlcmF0ZUV4dHJhT3B0aW9ucykoYy5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCgoZSx0KT0+e2NvbnN0IG49KDAsby5hbGxvY1dhc21TdHJpbmcpKGUsbCkscj0oMCxvLmFsbG9jV2FzbVN0cmluZykodCxsKTswIT09YS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHUsbixyKSYmKDAsby5jaGVja0xhc3RFcnJvcikoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2V9IC0gJHt0fS5gKX0pKSxbdSxsXX1jYXRjaChlKXt0aHJvdyAwIT09dSYmYS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHUpLGwuZm9yRWFjaCgoZT0+YS5fZnJlZShlKSkpLGV9fX0sNzkxNzooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubG9nTGV2ZWxTdHJpbmdUb0VudW09dC50ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3I9dC5nZXRUZW5zb3JFbGVtZW50U2l6ZT10LnRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nPXQudGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW09dm9pZCAwLHQudGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW09ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LHQudGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmc9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LHQuZ2V0VGVuc29yRWxlbWVudFNpemU9ZT0+W3ZvaWQgMCw0LDEsMSwyLDIsNCw4LHZvaWQgMCwxLDIsOCw0LDgsdm9pZCAwLHZvaWQgMCx2b2lkIDBdW2VdLHQudGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yPWU9Pntzd2l0Y2goZSl7Y2FzZVwiZmxvYXQxNlwiOmNhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOmNhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSx0LmxvZ0xldmVsU3RyaW5nVG9FbnVtPWU9Pntzd2l0Y2goZSl7Y2FzZVwidmVyYm9zZVwiOnJldHVybiAwO2Nhc2VcImluZm9cIjpyZXR1cm4gMTtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuIDI7Y2FzZVwiZXJyb3JcIjpyZXR1cm4gMztjYXNlXCJmYXRhbFwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCl9fX0sMTI1OTooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz10LmVuZFByb2ZpbGluZz10LnJ1bj10LnJlbGVhc2VTZXNzaW9uPXQuY3JlYXRlU2Vzc2lvbj10LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT10LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT10LmluaXRSdW50aW1lPXZvaWQgMDtjb25zdCByPW4oNzkxOCksbz1uKDc2MjIpLGk9big3OTE3KSxzPW4oMjYzKSxhPW4oMTQ5Nyk7dC5pbml0UnVudGltZT1hc3luYyBlPT57dmFyIHQsbjt0PWUud2FzbS5udW1UaHJlYWRzLG49KDAsaS5sb2dMZXZlbFN0cmluZ1RvRW51bSkoZS5sb2dMZXZlbCksMCE9PSgwLHMuZ2V0SW5zdGFuY2UpKCkuX09ydEluaXQodCxuKSYmKDAsYS5jaGVja0xhc3RFcnJvcikoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKX07Y29uc3QgdT1uZXcgTWFwO3QuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlPWU9Pntjb25zdCB0PSgwLHMuZ2V0SW5zdGFuY2UpKCksbj10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtpZigwPT09bil0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7ZS5ieXRlTGVuZ3RofS5gKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsbiksW24sZS5ieXRlTGVuZ3RoXX0sdC5jcmVhdGVTZXNzaW9uRmluYWxpemU9KGUsdCk9Pntjb25zdCBuPSgwLHMuZ2V0SW5zdGFuY2UpKCk7bGV0IHI9MCxpPTAsbD1bXTtjb25zdCBjPVtdLHA9W107dHJ5e1tpLGxdPSgwLG8uc2V0U2Vzc2lvbk9wdGlvbnMpKHQpLHI9bi5fT3J0Q3JlYXRlU2Vzc2lvbihlWzBdLGVbMV0saSksMD09PXImJigwLGEuY2hlY2tMYXN0RXJyb3IpKFwiQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIik7Y29uc3RbZCxmXT0oZT0+e2NvbnN0IHQ9KDAscy5nZXRJbnN0YW5jZSkoKSxuPXQuc3RhY2tTYXZlKCk7dHJ5e2NvbnN0IG49dC5zdGFja0FsbG9jKDgpO3JldHVybiAwIT09dC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLG4sbis0KSYmKDAsYS5jaGVja0xhc3RFcnJvcikoXCJDYW4ndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgY291bnQuXCIpLFt0LkhFQVAzMltuLzRdLHQuSEVBUDMyW24vNCsxXV19ZmluYWxseXt0LnN0YWNrUmVzdG9yZShuKX19KShyKSxoPVtdLGc9W107Zm9yKGxldCBlPTA7ZTxkO2UrKyl7Y29uc3QgdD1uLl9PcnRHZXRJbnB1dE5hbWUocixlKTswPT09dCYmKDAsYS5jaGVja0xhc3RFcnJvcikoXCJDYW4ndCBnZXQgYW4gaW5wdXQgbmFtZS5cIiksYy5wdXNoKHQpLGgucHVzaChuLlVURjhUb1N0cmluZyh0KSl9Zm9yKGxldCBlPTA7ZTxmO2UrKyl7Y29uc3QgdD1uLl9PcnRHZXRPdXRwdXROYW1lKHIsZSk7MD09PXQmJigwLGEuY2hlY2tMYXN0RXJyb3IpKFwiQ2FuJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLlwiKSxwLnB1c2godCksZy5wdXNoKG4uVVRGOFRvU3RyaW5nKHQpKX1yZXR1cm4gdS5zZXQocixbcixjLHBdKSxbcixoLGddfWNhdGNoKGUpe3Rocm93IGMuZm9yRWFjaCgoZT0+bi5fT3J0RnJlZShlKSkpLHAuZm9yRWFjaCgoZT0+bi5fT3J0RnJlZShlKSkpLDAhPT1yJiZuLl9PcnRSZWxlYXNlU2Vzc2lvbihyKSxlfWZpbmFsbHl7bi5fZnJlZShlWzBdKSwwIT09aSYmbi5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKGkpLGwuZm9yRWFjaCgoZT0+bi5fZnJlZShlKSkpfX0sdC5jcmVhdGVTZXNzaW9uPShlLG4pPT57Y29uc3Qgcj0oMCx0LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSkoZSk7cmV0dXJuKDAsdC5jcmVhdGVTZXNzaW9uRmluYWxpemUpKHIsbil9LHQucmVsZWFzZVNlc3Npb249ZT0+e2NvbnN0IHQ9KDAscy5nZXRJbnN0YW5jZSkoKSxuPXUuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7Y29uc3RbcixvLGldPW47by5mb3JFYWNoKChlPT50Ll9PcnRGcmVlKGUpKSksaS5mb3JFYWNoKChlPT50Ll9PcnRGcmVlKGUpKSksdC5fT3J0UmVsZWFzZVNlc3Npb24ociksdS5kZWxldGUoZSl9LHQucnVuPWFzeW5jKGUsdCxuLG8sbCk9Pntjb25zdCBjPSgwLHMuZ2V0SW5zdGFuY2UpKCkscD11LmdldChlKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtjb25zdFtkLGYsaF09cCxnPXQubGVuZ3RoLGI9by5sZW5ndGg7bGV0IG09MCx5PVtdO2NvbnN0IF89W10sdj1bXTt0cnl7W20seV09KDAsci5zZXRSdW5PcHRpb25zKShsKTtmb3IobGV0IGU9MDtlPGc7ZSsrKXtjb25zdCB0PW5bZV1bMF0scj1uW2VdWzFdLG89bltlXVsyXTtsZXQgcyx1O2lmKEFycmF5LmlzQXJyYXkobykpe3U9NCpvLmxlbmd0aCxzPWMuX21hbGxvYyh1KSx2LnB1c2gocyk7bGV0IGU9cy80O2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKXtpZihcInN0cmluZ1wiIT10eXBlb2Ygb1t0XSl0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke3R9IGlzIG5vdCBhIHN0cmluZ2ApO2MuSEVBUFUzMltlKytdPSgwLGEuYWxsb2NXYXNtU3RyaW5nKShvW3RdLHYpfX1lbHNlIHU9by5ieXRlTGVuZ3RoLHM9Yy5fbWFsbG9jKHUpLHYucHVzaChzKSxjLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoby5idWZmZXIsby5ieXRlT2Zmc2V0LHUpLHMpO2NvbnN0IGw9Yy5zdGFja1NhdmUoKSxwPWMuc3RhY2tBbGxvYyg0KnIubGVuZ3RoKTt0cnl7bGV0IG49cC80O3IuZm9yRWFjaCgoZT0+Yy5IRUFQMzJbbisrXT1lKSk7Y29uc3Qgbz1jLl9PcnRDcmVhdGVUZW5zb3IoKDAsaS50ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSkodCkscyx1LHAsci5sZW5ndGgpOzA9PT1vJiYoMCxhLmNoZWNrTGFzdEVycm9yKShgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXRbJHtlfV0uYCksXy5wdXNoKG8pfWZpbmFsbHl7Yy5zdGFja1Jlc3RvcmUobCl9fWNvbnN0IGU9Yy5zdGFja1NhdmUoKSxzPWMuc3RhY2tBbGxvYyg0KmcpLHU9Yy5zdGFja0FsbG9jKDQqZykscD1jLnN0YWNrQWxsb2MoNCpiKSxUPWMuc3RhY2tBbGxvYyg0KmIpO3RyeXtsZXQgZT1zLzQsbj11LzQscj1wLzQsbD1ULzQ7Zm9yKGxldCByPTA7cjxnO3IrKyljLkhFQVBVMzJbZSsrXT1fW3JdLGMuSEVBUFUzMltuKytdPWZbdFtyXV07Zm9yKGxldCBlPTA7ZTxiO2UrKyljLkhFQVBVMzJbcisrXT0wLGMuSEVBUFUzMltsKytdPWhbb1tlXV07bGV0IHk9Yy5fT3J0UnVuKGQsdSxzLGcsVCxiLHAsbSk7Y29uc3Qgdj1jLmpzZXBSdW5Qcm9taXNlO3YmJnZvaWQgMCE9PXYudGhlbiYmKHk9YXdhaXQgdik7Y29uc3QgeD1bXTswIT09eSYmKDAsYS5jaGVja0xhc3RFcnJvcikoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7Zm9yKGxldCBlPTA7ZTxiO2UrKyl7Y29uc3QgdD1jLkhFQVBVMzJbcC80K2VdLG49Yy5zdGFja1NhdmUoKSxyPWMuc3RhY2tBbGxvYygxNik7bGV0IG8scz0wO3RyeXt5PWMuX09ydEdldFRlbnNvckRhdGEodCxyLHIrNCxyKzgscisxMiksMCE9PXkmJigwLGEuY2hlY2tMYXN0RXJyb3IpKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7ZX0uYCk7bGV0IG49ci80O2NvbnN0IHU9Yy5IRUFQVTMyW24rK107cz1jLkhFQVBVMzJbbisrXTtjb25zdCBsPWMuSEVBUFUzMltuKytdLHA9Yy5IRUFQVTMyW24rK10sZD1bXTtmb3IobGV0IGU9MDtlPHA7ZSsrKWQucHVzaChjLkhFQVBVMzJbbC80K2VdKTtjLl9PcnRGcmVlKGwpO2NvbnN0IGY9MD09PWQubGVuZ3RoPzE6ZC5yZWR1Y2UoKChlLHQpPT5lKnQpKTtpZihvPSgwLGkudGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcpKHUpLFwic3RyaW5nXCI9PT1vKXtjb25zdCBlPVtdO2xldCB0PXMvNDtmb3IobGV0IG49MDtuPGY7bisrKXtjb25zdCByPWMuSEVBUFUzMlt0KytdLG89bj09PWYtMT92b2lkIDA6Yy5IRUFQVTMyW3RdLXI7ZS5wdXNoKGMuVVRGOFRvU3RyaW5nKHIsbykpfXgucHVzaChbbyxkLGVdKX1lbHNle2NvbnN0IGU9bmV3KCgwLGkudGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKShvKSkoZik7bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCkuc2V0KGMuSEVBUFU4LnN1YmFycmF5KHMscytlLmJ5dGVMZW5ndGgpKSx4LnB1c2goW28sZCxlXSl9fWZpbmFsbHl7Yy5zdGFja1Jlc3RvcmUobiksXCJzdHJpbmdcIj09PW8mJnMmJmMuX2ZyZWUocyksYy5fT3J0UmVsZWFzZVRlbnNvcih0KX19cmV0dXJuIHh9ZmluYWxseXtjLnN0YWNrUmVzdG9yZShlKX19ZmluYWxseXtfLmZvckVhY2goKGU9PmMuX09ydFJlbGVhc2VUZW5zb3IoZSkpKSx2LmZvckVhY2goKGU9PmMuX2ZyZWUoZSkpKSwwIT09bSYmYy5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMobSkseS5mb3JFYWNoKChlPT5jLl9mcmVlKGUpKSl9fSx0LmVuZFByb2ZpbGluZz1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLG49dS5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IHI9blswXSxvPXQuX09ydEVuZFByb2ZpbGluZyhyKTswPT09byYmKDAsYS5jaGVja0xhc3RFcnJvcikoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpLHQuX09ydEZyZWUobyl9LHQuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnM9ZT0+e2NvbnN0IHQ9W107Zm9yKGNvbnN0IG4gb2YgZSl7Y29uc3QgZT1uWzJdOyFBcnJheS5pc0FycmF5KGUpJiZlLmJ1ZmZlciYmdC5wdXNoKGUuYnVmZmVyKX1yZXR1cm4gdH19LDI2MzpmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxuLHIpe3ZvaWQgMD09PXImJihyPW4pO3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxuKTtvJiYhKFwiZ2V0XCJpbiBvPyF0Ll9fZXNNb2R1bGU6by53cml0YWJsZXx8by5jb25maWd1cmFibGUpfHwobz17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtuXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLG8pfTpmdW5jdGlvbihlLHQsbixyKXt2b2lkIDA9PT1yJiYocj1uKSxlW3JdPXRbbl19KSxvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOnR9KX06ZnVuY3Rpb24oZSx0KXtlLmRlZmF1bHQ9dH0pLGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgdD17fTtpZihudWxsIT1lKWZvcih2YXIgbiBpbiBlKVwiZGVmYXVsdFwiIT09biYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbikmJnIodCxlLG4pO3JldHVybiBvKHQsZSksdH07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kaXNwb3NlPXQuZ2V0SW5zdGFuY2U9dC5pbml0aWFsaXplV2ViQXNzZW1ibHk9dm9pZCAwO2NvbnN0IHM9aShuKDE0MjMpKSxhPW4oOTMyKSx1PW4oMzQ3NCk7bGV0IGwsYz0hMSxwPSExLGQ9ITE7dC5pbml0aWFsaXplV2ViQXNzZW1ibHk9YXN5bmMgZT0+e2lmKGMpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKHApdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoZCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtwPSEwO2NvbnN0IHQ9ZS5pbml0VGltZW91dCxyPWUubnVtVGhyZWFkcyxvPWUuc2ltZCxpPXI+MSYmKCgpPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpKX1jYXRjaChlKXtyZXR1cm4hMX19KSgpLGY9byYmKCgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaChlKXtyZXR1cm4hMX19KSgpLGg9ZS53YXNtUGF0aHMsZz1cInN0cmluZ1wiPT10eXBlb2YgaD9oOnZvaWQgMCxiPSgoZSx0KT0+dD9lP1wib3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtXCI6XCJvcnQtd2FzbS10aHJlYWRlZC53YXNtXCI6ZT9cIm9ydC13YXNtLXNpbWQud2FzbVwiOlwib3J0LXdhc20ud2FzbVwiKShmLGkpLG09XCJvYmplY3RcIj09dHlwZW9mIGg/aFtiXTp2b2lkIDA7bGV0IHk9ITE7Y29uc3QgXz1bXTtpZih0PjAmJl8ucHVzaChuZXcgUHJvbWlzZSgoZT0+e3NldFRpbWVvdXQoKCgpPT57eT0hMCxlKCl9KSx0KX0pKSksXy5wdXNoKG5ldyBQcm9taXNlKCgoZSx0KT0+e2NvbnN0IHI9aT91OmEsbz17bG9jYXRlRmlsZTooZSx0KT0+aSYmZS5lbmRzV2l0aChcIi53b3JrZXIuanNcIikmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBCbG9iP1VSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW24oNDE1NCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk6ZS5lbmRzV2l0aChcIi53YXNtXCIpP218fChudWxsIT1nP2c6dCkrYjp0K2V9O2lmKGkpaWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2Ipby5tYWluU2NyaXB0VXJsT3JCbG9iPXMuam9pbihfX2Rpcm5hbWUsXCJvcnQtd2FzbS10aHJlYWRlZC5qc1wiKTtlbHNle2NvbnN0IGU9YHZhciBvcnRXYXNtVGhyZWFkZWQ9KGZ1bmN0aW9uKCl7dmFyIF9zY3JpcHREaXI7cmV0dXJuICR7ci50b1N0cmluZygpfX0pKCk7YDtvLm1haW5TY3JpcHRVcmxPckJsb2I9bmV3IEJsb2IoW2VdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KX1yKG8pLnRoZW4oKHQ9PntwPSExLGM9ITAsbD10LGUoKX0pLChlPT57cD0hMSxkPSEwLHQoZSl9KSl9KSkpLGF3YWl0IFByb21pc2UucmFjZShfKSx5KXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3R9bXNgKX0sdC5nZXRJbnN0YW5jZT0oKT0+e2lmKGMmJmwpcmV0dXJuIGw7dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9LHQuZGlzcG9zZT0oKT0+e3ZhciBlOyFjfHxwfHxkfHwocD0hMCxudWxsPT09KGU9bC5QVGhyZWFkKXx8dm9pZCAwPT09ZXx8ZS50ZXJtaW5hdGVBbGxUaHJlYWRzKCksbD12b2lkIDAscD0hMSxjPSExLGQ9ITApfX0sMTQ5NzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5jaGVja0xhc3RFcnJvcj10Lml0ZXJhdGVFeHRyYU9wdGlvbnM9dC5hbGxvY1dhc21TdHJpbmc9dm9pZCAwO2NvbnN0IHI9bigyNjMpO3QuYWxsb2NXYXNtU3RyaW5nPShlLHQpPT57Y29uc3Qgbj0oMCxyLmdldEluc3RhbmNlKSgpLG89bi5sZW5ndGhCeXRlc1VURjgoZSkrMSxpPW4uX21hbGxvYyhvKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgoZSxpLG8pLHQucHVzaChpKSxpfSx0Lml0ZXJhdGVFeHRyYU9wdGlvbnM9KGUsbixyLG8pPT57aWYoXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lKXtpZihyLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtyLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKCgoW2UsaV0pPT57Y29uc3Qgcz1uP24rZTplO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBpKSgwLHQuaXRlcmF0ZUV4dHJhT3B0aW9ucykoaSxzK1wiLlwiLHIsbyk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgaXx8XCJudW1iZXJcIj09dHlwZW9mIGkpbyhzLGkudG9TdHJpbmcoKSk7ZWxzZXtpZihcImJvb2xlYW5cIiE9dHlwZW9mIGkpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiBcIit0eXBlb2YgaSk7byhzLGk/XCIxXCI6XCIwXCIpfX0pKX0sdC5jaGVja0xhc3RFcnJvcj1lPT57Y29uc3QgdD0oMCxyLmdldEluc3RhbmNlKSgpLG49dC5zdGFja1NhdmUoKTt0cnl7Y29uc3Qgbj10LnN0YWNrQWxsb2MoOCk7dC5fT3J0R2V0TGFzdEVycm9yKG4sbis0KTtjb25zdCByPXQuSEVBUDMyW24vNF0sbz10LkhFQVBVMzJbbi80KzFdLGk9bz90LlVURjhUb1N0cmluZyhvKTpcIlwiO3Rocm93IG5ldyBFcnJvcihgJHtlfSBFUlJPUl9DT0RFOiAke3J9LCBFUlJPUl9NRVNTQUdFOiAke2l9YCl9ZmluYWxseXt0LnN0YWNrUmVzdG9yZShuKX19fSw4MDUwOihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtuLmQodCx7WjooKT0+aX0pO3ZhciByPW4oNjYxNCksbz1uLm4ocik7ZnVuY3Rpb24gaSgpe3JldHVybiBvKCkoJy8qIVxcbiogT05OWCBSdW50aW1lIFdlYiB2MS4xNi4zXFxuKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cXG4qL1xcbigoKT0+e3ZhciBlPXs5MTg6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuc2V0UnVuT3B0aW9ucz12b2lkIDA7Y29uc3Qgbj1yKDI2MyksYT1yKDQ5Nyk7dC5zZXRSdW5PcHRpb25zPWU9Pntjb25zdCB0PSgwLG4uZ2V0SW5zdGFuY2UpKCk7bGV0IHI9MDtjb25zdCBvPVtdLHM9ZXx8e307dHJ5e2lmKHZvaWQgMD09PShudWxsPT1lP3ZvaWQgMDplLmxvZ1NldmVyaXR5TGV2ZWwpKXMubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYoXCJudW1iZXJcIiE9dHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKHZvaWQgMD09PShudWxsPT1lP3ZvaWQgMDplLmxvZ1ZlcmJvc2l0eUxldmVsKSlzLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZihcIm51bWJlclwiIT10eXBlb2YgZS5sb2dWZXJib3NpdHlMZXZlbHx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1ZlcmJvc2l0eUxldmVsfWApO3ZvaWQgMD09PShudWxsPT1lP3ZvaWQgMDplLnRlcm1pbmF0ZSkmJihzLnRlcm1pbmF0ZT0hMSk7bGV0IG49MDtyZXR1cm4gdm9pZCAwIT09KG51bGw9PWU/dm9pZCAwOmUudGFnKSYmKG49KDAsYS5hbGxvY1dhc21TdHJpbmcpKGUudGFnLG8pKSxyPXQuX09ydENyZWF0ZVJ1bk9wdGlvbnMocy5sb2dTZXZlcml0eUxldmVsLHMubG9nVmVyYm9zaXR5TGV2ZWwsISFzLnRlcm1pbmF0ZSxuKSwwPT09ciYmKDAsYS5jaGVja0xhc3RFcnJvcikoXCJDYW5cXCd0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIiksdm9pZCAwIT09KG51bGw9PWU/dm9pZCAwOmUuZXh0cmEpJiYoMCxhLml0ZXJhdGVFeHRyYU9wdGlvbnMpKGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoKGUsbik9Pntjb25zdCBzPSgwLGEuYWxsb2NXYXNtU3RyaW5nKShlLG8pLGk9KDAsYS5hbGxvY1dhc21TdHJpbmcpKG4sbyk7MCE9PXQuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KHIscyxpKSYmKDAsYS5jaGVja0xhc3RFcnJvcikoYENhblxcJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtlfSAtICR7bn0uYCl9KSksW3Isb119Y2F0Y2goZSl7dGhyb3cgMCE9PXImJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKHIpLG8uZm9yRWFjaCgoZT0+dC5fZnJlZShlKSkpLGV9fX0sNjIyOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LnNldFNlc3Npb25PcHRpb25zPXZvaWQgMDtjb25zdCBuPXIoMjYzKSxhPXIoNDk3KTt0LnNldFNlc3Npb25PcHRpb25zPWU9Pnt2YXIgdCxyLG8scztjb25zdCBpPSgwLG4uZ2V0SW5zdGFuY2UpKCk7bGV0IHU9MDtjb25zdCBjPVtdLGw9ZXx8e307KGU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtjb25zdCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKChlPT5cIndlYmdwdVwiPT09KFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZS5uYW1lKSkpJiYoZS5lbmFibGVNZW1QYXR0ZXJuPSExKX0pKGwpO3RyeXtjb25zdCBlPShlPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSkobnVsbCE9PSh0PWwuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCkmJnZvaWQgMCE9PXQ/dDpcImFsbFwiKSxmPShlPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0pKG51bGwhPT0ocj1sLmV4ZWN1dGlvbk1vZGUpJiZ2b2lkIDAhPT1yP3I6XCJzZXF1ZW50aWFsXCIpLGQ9XCJzdHJpbmdcIj09dHlwZW9mIGwubG9nSWQ/KDAsYS5hbGxvY1dhc21TdHJpbmcpKGwubG9nSWQsYyk6MCxwPW51bGwhPT0obz1sLmxvZ1NldmVyaXR5TGV2ZWwpJiZ2b2lkIDAhPT1vP286MjtpZighTnVtYmVyLmlzSW50ZWdlcihwKXx8cDwwfHxwPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtwfWApO2NvbnN0IGc9bnVsbCE9PShzPWwubG9nVmVyYm9zaXR5TGV2ZWwpJiZ2b2lkIDAhPT1zP3M6MDtpZighTnVtYmVyLmlzSW50ZWdlcihnKXx8ZzwwfHxnPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtnfWApO2NvbnN0IGg9XCJzdHJpbmdcIj09dHlwZW9mIGwub3B0aW1pemVkTW9kZWxGaWxlUGF0aD8oMCxhLmFsbG9jV2FzbVN0cmluZykobC5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLGMpOjA7cmV0dXJuIHU9aS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMoZSwhIWwuZW5hYmxlQ3B1TWVtQXJlbmEsISFsLmVuYWJsZU1lbVBhdHRlcm4sZiwhIWwuZW5hYmxlUHJvZmlsaW5nLDAsZCxwLGcsaCksMD09PXUmJigwLGEuY2hlY2tMYXN0RXJyb3IpKFwiQ2FuXFwndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKSxsLmV4ZWN1dGlvblByb3ZpZGVycyYmKChlLHQscik9Pntmb3IoY29uc3QgbyBvZiB0KXtsZXQgdD1cInN0cmluZ1wiPT10eXBlb2Ygbz9vOm8ubmFtZTtzd2l0Y2godCl7Y2FzZVwieG5ucGFja1wiOnQ9XCJYTk5QQUNLXCI7YnJlYWs7Y2FzZVwid2Vibm5cIjppZih0PVwiV0VCTk5cIixcInN0cmluZ1wiIT10eXBlb2Ygbyl7Y29uc3QgdD1vO2lmKG51bGw9PXQ/dm9pZCAwOnQuZGV2aWNlVHlwZSl7Y29uc3Qgbz0oMCxhLmFsbG9jV2FzbVN0cmluZykoXCJkZXZpY2VUeXBlXCIscikscz0oMCxhLmFsbG9jV2FzbVN0cmluZykodC5kZXZpY2VUeXBlLHIpOzAhPT0oMCxuLmdldEluc3RhbmNlKSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxvLHMpJiYoMCxhLmNoZWNrTGFzdEVycm9yKShgQ2FuXFwndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogXFwnZGV2aWNlVHlwZVxcJyAtICR7dC5kZXZpY2VUeXBlfS5gKX1pZihudWxsPT10P3ZvaWQgMDp0LnBvd2VyUHJlZmVyZW5jZSl7Y29uc3Qgbz0oMCxhLmFsbG9jV2FzbVN0cmluZykoXCJwb3dlclByZWZlcmVuY2VcIixyKSxzPSgwLGEuYWxsb2NXYXNtU3RyaW5nKSh0LnBvd2VyUHJlZmVyZW5jZSxyKTswIT09KDAsbi5nZXRJbnN0YW5jZSkoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsbyxzKSYmKDAsYS5jaGVja0xhc3RFcnJvcikoYENhblxcJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6IFxcJ3Bvd2VyUHJlZmVyZW5jZVxcJyAtICR7dC5wb3dlclByZWZlcmVuY2V9LmApfX1icmVhaztjYXNlXCJ3ZWJncHVcIjp0PVwiSlNcIjticmVhaztjYXNlXCJ3YXNtXCI6Y2FzZVwiY3B1XCI6Y29udGludWU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke3R9YCl9Y29uc3Qgcz0oMCxhLmFsbG9jV2FzbVN0cmluZykodCxyKTswIT09KDAsbi5nZXRJbnN0YW5jZSkoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSxzKSYmKDAsYS5jaGVja0xhc3RFcnJvcikoYENhblxcJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHt0fS5gKX19KSh1LGwuZXhlY3V0aW9uUHJvdmlkZXJzLGMpLHZvaWQgMCE9PWwuZXh0cmEmJigwLGEuaXRlcmF0ZUV4dHJhT3B0aW9ucykobC5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCgoZSx0KT0+e2NvbnN0IHI9KDAsYS5hbGxvY1dhc21TdHJpbmcpKGUsYyksbj0oMCxhLmFsbG9jV2FzbVN0cmluZykodCxjKTswIT09aS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHUscixuKSYmKDAsYS5jaGVja0xhc3RFcnJvcikoYENhblxcJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7ZX0gLSAke3R9LmApfSkpLFt1LGNdfWNhdGNoKGUpe3Rocm93IDAhPT11JiZpLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnModSksYy5mb3JFYWNoKChlPT5pLl9mcmVlKGUpKSksZX19fSw5MTc6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmxvZ0xldmVsU3RyaW5nVG9FbnVtPXQudGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yPXQuZ2V0VGVuc29yRWxlbWVudFNpemU9dC50ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZz10LnRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtPXZvaWQgMCx0LnRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtPWU9Pntzd2l0Y2goZSl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiAxMDtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSx0LnRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nPWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSx0LmdldFRlbnNvckVsZW1lbnRTaXplPWU9Plt2b2lkIDAsNCwxLDEsMiwyLDQsOCx2b2lkIDAsMSwyLDgsNCw4LHZvaWQgMCx2b2lkIDAsdm9pZCAwXVtlXSx0LnRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZVwidWludDhcIjpjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHtlfWApfX0sdC5sb2dMZXZlbFN0cmluZ1RvRW51bT1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX19LDI1OTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz10LmVuZFByb2ZpbGluZz10LnJ1bj10LnJlbGVhc2VTZXNzaW9uPXQuY3JlYXRlU2Vzc2lvbj10LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZT10LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT10LmluaXRSdW50aW1lPXZvaWQgMDtjb25zdCBuPXIoOTE4KSxhPXIoNjIyKSxvPXIoOTE3KSxzPXIoMjYzKSxpPXIoNDk3KTt0LmluaXRSdW50aW1lPWFzeW5jIGU9Pnt2YXIgdCxyO3Q9ZS53YXNtLm51bVRocmVhZHMscj0oMCxvLmxvZ0xldmVsU3RyaW5nVG9FbnVtKShlLmxvZ0xldmVsKSwwIT09KDAscy5nZXRJbnN0YW5jZSkoKS5fT3J0SW5pdCh0LHIpJiYoMCxpLmNoZWNrTGFzdEVycm9yKShcIkNhblxcJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS5cIil9O2NvbnN0IHU9bmV3IE1hcDt0LmNyZWF0ZVNlc3Npb25BbGxvY2F0ZT1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLHI9dC5fbWFsbG9jKGUuYnl0ZUxlbmd0aCk7aWYoMD09PXIpdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7ZS5ieXRlTGVuZ3RofS5gKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsciksW3IsZS5ieXRlTGVuZ3RoXX0sdC5jcmVhdGVTZXNzaW9uRmluYWxpemU9KGUsdCk9Pntjb25zdCByPSgwLHMuZ2V0SW5zdGFuY2UpKCk7bGV0IG49MCxvPTAsYz1bXTtjb25zdCBsPVtdLGY9W107dHJ5e1tvLGNdPSgwLGEuc2V0U2Vzc2lvbk9wdGlvbnMpKHQpLG49ci5fT3J0Q3JlYXRlU2Vzc2lvbihlWzBdLGVbMV0sbyksMD09PW4mJigwLGkuY2hlY2tMYXN0RXJyb3IpKFwiQ2FuXFwndCBjcmVhdGUgYSBzZXNzaW9uLlwiKTtjb25zdFtkLHBdPShlPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7Y29uc3Qgcj10LnN0YWNrQWxsb2MoOCk7cmV0dXJuIDAhPT10Ll9PcnRHZXRJbnB1dE91dHB1dENvdW50KGUscixyKzQpJiYoMCxpLmNoZWNrTGFzdEVycm9yKShcIkNhblxcJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKSxbdC5IRUFQMzJbci80XSx0LkhFQVAzMltyLzQrMV1dfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fSkobiksZz1bXSxoPVtdO2ZvcihsZXQgZT0wO2U8ZDtlKyspe2NvbnN0IHQ9ci5fT3J0R2V0SW5wdXROYW1lKG4sZSk7MD09PXQmJigwLGkuY2hlY2tMYXN0RXJyb3IpKFwiQ2FuXFwndCBnZXQgYW4gaW5wdXQgbmFtZS5cIiksbC5wdXNoKHQpLGcucHVzaChyLlVURjhUb1N0cmluZyh0KSl9Zm9yKGxldCBlPTA7ZTxwO2UrKyl7Y29uc3QgdD1yLl9PcnRHZXRPdXRwdXROYW1lKG4sZSk7MD09PXQmJigwLGkuY2hlY2tMYXN0RXJyb3IpKFwiQ2FuXFwndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLGYucHVzaCh0KSxoLnB1c2goci5VVEY4VG9TdHJpbmcodCkpfXJldHVybiB1LnNldChuLFtuLGwsZl0pLFtuLGcsaF19Y2F0Y2goZSl7dGhyb3cgbC5mb3JFYWNoKChlPT5yLl9PcnRGcmVlKGUpKSksZi5mb3JFYWNoKChlPT5yLl9PcnRGcmVlKGUpKSksMCE9PW4mJnIuX09ydFJlbGVhc2VTZXNzaW9uKG4pLGV9ZmluYWxseXtyLl9mcmVlKGVbMF0pLDAhPT1vJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobyksYy5mb3JFYWNoKChlPT5yLl9mcmVlKGUpKSl9fSx0LmNyZWF0ZVNlc3Npb249KGUscik9Pntjb25zdCBuPSgwLHQuY3JlYXRlU2Vzc2lvbkFsbG9jYXRlKShlKTtyZXR1cm4oMCx0LmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkobixyKX0sdC5yZWxlYXNlU2Vzc2lvbj1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLHI9dS5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVsZWFzZSBzZXNzaW9uLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtjb25zdFtuLGEsb109cjthLmZvckVhY2goKGU9PnQuX09ydEZyZWUoZSkpKSxvLmZvckVhY2goKGU9PnQuX09ydEZyZWUoZSkpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihuKSx1LmRlbGV0ZShlKX0sdC5ydW49YXN5bmMoZSx0LHIsYSxjKT0+e2NvbnN0IGw9KDAscy5nZXRJbnN0YW5jZSkoKSxmPXUuZ2V0KGUpO2lmKCFmKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2NvbnN0W2QscCxnXT1mLGg9dC5sZW5ndGgsbT1hLmxlbmd0aDtsZXQgeT0wLHY9W107Y29uc3QgYj1bXSx3PVtdO3RyeXtbeSx2XT0oMCxuLnNldFJ1bk9wdGlvbnMpKGMpO2ZvcihsZXQgZT0wO2U8aDtlKyspe2NvbnN0IHQ9cltlXVswXSxuPXJbZV1bMV0sYT1yW2VdWzJdO2xldCBzLHU7aWYoQXJyYXkuaXNBcnJheShhKSl7dT00KmEubGVuZ3RoLHM9bC5fbWFsbG9jKHUpLHcucHVzaChzKTtsZXQgZT1zLzQ7Zm9yKGxldCB0PTA7dDxhLmxlbmd0aDt0Kyspe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBhW3RdKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7dH0gaXMgbm90IGEgc3RyaW5nYCk7bC5IRUFQVTMyW2UrK109KDAsaS5hbGxvY1dhc21TdHJpbmcpKGFbdF0sdyl9fWVsc2UgdT1hLmJ5dGVMZW5ndGgscz1sLl9tYWxsb2ModSksdy5wdXNoKHMpLGwuSEVBUFU4LnNldChuZXcgVWludDhBcnJheShhLmJ1ZmZlcixhLmJ5dGVPZmZzZXQsdSkscyk7Y29uc3QgYz1sLnN0YWNrU2F2ZSgpLGY9bC5zdGFja0FsbG9jKDQqbi5sZW5ndGgpO3RyeXtsZXQgcj1mLzQ7bi5mb3JFYWNoKChlPT5sLkhFQVAzMltyKytdPWUpKTtjb25zdCBhPWwuX09ydENyZWF0ZVRlbnNvcigoMCxvLnRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKSh0KSxzLHUsZixuLmxlbmd0aCk7MD09PWEmJigwLGkuY2hlY2tMYXN0RXJyb3IpKGBDYW5cXCd0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0WyR7ZX1dLmApLGIucHVzaChhKX1maW5hbGx5e2wuc3RhY2tSZXN0b3JlKGMpfX1jb25zdCBlPWwuc3RhY2tTYXZlKCkscz1sLnN0YWNrQWxsb2MoNCpoKSx1PWwuc3RhY2tBbGxvYyg0KmgpLGY9bC5zdGFja0FsbG9jKDQqbSksXz1sLnN0YWNrQWxsb2MoNCptKTt0cnl7bGV0IGU9cy80LHI9dS80LG49Zi80LGM9Xy80O2ZvcihsZXQgbj0wO248aDtuKyspbC5IRUFQVTMyW2UrK109YltuXSxsLkhFQVBVMzJbcisrXT1wW3Rbbl1dO2ZvcihsZXQgZT0wO2U8bTtlKyspbC5IRUFQVTMyW24rK109MCxsLkhFQVBVMzJbYysrXT1nW2FbZV1dO2xldCB2PWwuX09ydFJ1bihkLHUscyxoLF8sbSxmLHkpO2NvbnN0IHc9bC5qc2VwUnVuUHJvbWlzZTt3JiZ2b2lkIDAhPT13LnRoZW4mJih2PWF3YWl0IHcpO2NvbnN0IE89W107MCE9PXYmJigwLGkuY2hlY2tMYXN0RXJyb3IpKFwiZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuXCIpO2ZvcihsZXQgZT0wO2U8bTtlKyspe2NvbnN0IHQ9bC5IRUFQVTMyW2YvNCtlXSxyPWwuc3RhY2tTYXZlKCksbj1sLnN0YWNrQWxsb2MoMTYpO2xldCBhLHM9MDt0cnl7dj1sLl9PcnRHZXRUZW5zb3JEYXRhKHQsbixuKzQsbis4LG4rMTIpLDAhPT12JiYoMCxpLmNoZWNrTGFzdEVycm9yKShgQ2FuXFwndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7ZX0uYCk7bGV0IHI9bi80O2NvbnN0IHU9bC5IRUFQVTMyW3IrK107cz1sLkhFQVBVMzJbcisrXTtjb25zdCBjPWwuSEVBUFUzMltyKytdLGY9bC5IRUFQVTMyW3IrK10sZD1bXTtmb3IobGV0IGU9MDtlPGY7ZSsrKWQucHVzaChsLkhFQVBVMzJbYy80K2VdKTtsLl9PcnRGcmVlKGMpO2NvbnN0IHA9MD09PWQubGVuZ3RoPzE6ZC5yZWR1Y2UoKChlLHQpPT5lKnQpKTtpZihhPSgwLG8udGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcpKHUpLFwic3RyaW5nXCI9PT1hKXtjb25zdCBlPVtdO2xldCB0PXMvNDtmb3IobGV0IHI9MDtyPHA7cisrKXtjb25zdCBuPWwuSEVBUFUzMlt0KytdLGE9cj09PXAtMT92b2lkIDA6bC5IRUFQVTMyW3RdLW47ZS5wdXNoKGwuVVRGOFRvU3RyaW5nKG4sYSkpfU8ucHVzaChbYSxkLGVdKX1lbHNle2NvbnN0IGU9bmV3KCgwLG8udGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKShhKSkocCk7bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aCkuc2V0KGwuSEVBUFU4LnN1YmFycmF5KHMscytlLmJ5dGVMZW5ndGgpKSxPLnB1c2goW2EsZCxlXSl9fWZpbmFsbHl7bC5zdGFja1Jlc3RvcmUociksXCJzdHJpbmdcIj09PWEmJnMmJmwuX2ZyZWUocyksbC5fT3J0UmVsZWFzZVRlbnNvcih0KX19cmV0dXJuIE99ZmluYWxseXtsLnN0YWNrUmVzdG9yZShlKX19ZmluYWxseXtiLmZvckVhY2goKGU9PmwuX09ydFJlbGVhc2VUZW5zb3IoZSkpKSx3LmZvckVhY2goKGU9PmwuX2ZyZWUoZSkpKSwwIT09eSYmbC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoeSksdi5mb3JFYWNoKChlPT5sLl9mcmVlKGUpKSl9fSx0LmVuZFByb2ZpbGluZz1lPT57Y29uc3QgdD0oMCxzLmdldEluc3RhbmNlKSgpLHI9dS5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2NvbnN0IG49clswXSxhPXQuX09ydEVuZFByb2ZpbGluZyhuKTswPT09YSYmKDAsaS5jaGVja0xhc3RFcnJvcikoXCJDYW5cXCd0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS5cIiksdC5fT3J0RnJlZShhKX0sdC5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycz1lPT57Y29uc3QgdD1bXTtmb3IoY29uc3QgciBvZiBlKXtjb25zdCBlPXJbMl07IUFycmF5LmlzQXJyYXkoZSkmJmUuYnVmZmVyJiZ0LnB1c2goZS5idWZmZXIpfXJldHVybiB0fX0sMjYzOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsbil7dm9pZCAwPT09biYmKG49cik7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO2EmJiEoXCJnZXRcImluIGE/IXQuX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSl8fChhPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4sYSl9OmZ1bmN0aW9uKGUsdCxyLG4pe3ZvaWQgMD09PW4mJihuPXIpLGVbbl09dFtyXX0pLGE9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pfTpmdW5jdGlvbihlLHQpe2UuZGVmYXVsdD10fSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCIhPT1yJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmbih0LGUscik7cmV0dXJuIGEodCxlKSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRpc3Bvc2U9dC5nZXRJbnN0YW5jZT10LmluaXRpYWxpemVXZWJBc3NlbWJseT12b2lkIDA7Y29uc3Qgcz1vKHIoMTcpKSxpPXIoOTMyKSx1PXIoNDc0KTtsZXQgYyxsPSExLGY9ITEsZD0hMTt0LmluaXRpYWxpemVXZWJBc3NlbWJseT1hc3luYyBlPT57aWYobClyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYoZil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBkZXRlY3RlZC5cIik7aWYoZCl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvIFxcJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpXFwnIGZhaWxlZC5cIik7Zj0hMDtjb25zdCB0PWUuaW5pdFRpbWVvdXQsbj1lLm51bVRocmVhZHMsYT1lLnNpbWQsbz1uPjEmJigoKT0+e3RyeXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXImJihcInVuZGVmaW5lZFwiIT10eXBlb2YgTWVzc2FnZUNoYW5uZWwmJihuZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKSl9Y2F0Y2goZSl7cmV0dXJuITF9fSkoKSxwPWEmJigoKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2goZSl7cmV0dXJuITF9fSkoKSxnPWUud2FzbVBhdGhzLGg9XCJzdHJpbmdcIj09dHlwZW9mIGc/Zzp2b2lkIDAsbT0oKGUsdCk9PnQ/ZT9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQud2FzbVwiOlwib3J0LXdhc20tdGhyZWFkZWQud2FzbVwiOmU/XCJvcnQtd2FzbS1zaW1kLndhc21cIjpcIm9ydC13YXNtLndhc21cIikocCxvKSx5PVwib2JqZWN0XCI9PXR5cGVvZiBnP2dbbV06dm9pZCAwO2xldCB2PSExO2NvbnN0IGI9W107aWYodD4wJiZiLnB1c2gobmV3IFByb21pc2UoKGU9PntzZXRUaW1lb3V0KCgoKT0+e3Y9ITAsZSgpfSksdCl9KSkpLGIucHVzaChuZXcgUHJvbWlzZSgoKGUsdCk9Pntjb25zdCBuPW8/dTppLGE9e2xvY2F0ZUZpbGU6KGUsdCk9Pm8mJmUuZW5kc1dpdGgoXCIud29ya2VyLmpzXCIpJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgQmxvYj9VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtyKDE1NCldLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSk6ZS5lbmRzV2l0aChcIi53YXNtXCIpP3l8fChudWxsIT1oP2g6dCkrbTp0K2V9O2lmKG8paWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIEJsb2IpYS5tYWluU2NyaXB0VXJsT3JCbG9iPXMuam9pbihfX2Rpcm5hbWUsXCJvcnQtd2FzbS10aHJlYWRlZC5qc1wiKTtlbHNle2NvbnN0IGU9YHZhciBvcnRXYXNtVGhyZWFkZWQ9KGZ1bmN0aW9uKCl7dmFyIF9zY3JpcHREaXI7cmV0dXJuICR7bi50b1N0cmluZygpfX0pKCk7YDthLm1haW5TY3JpcHRVcmxPckJsb2I9bmV3IEJsb2IoW2VdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KX1uKGEpLnRoZW4oKHQ9PntmPSExLGw9ITAsYz10LGUoKX0pLChlPT57Zj0hMSxkPSEwLHQoZSl9KSl9KSkpLGF3YWl0IFByb21pc2UucmFjZShiKSx2KXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3R9bXNgKX0sdC5nZXRJbnN0YW5jZT0oKT0+e2lmKGwmJmMpcmV0dXJuIGM7dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9LHQuZGlzcG9zZT0oKT0+e3ZhciBlOyFsfHxmfHxkfHwoZj0hMCxudWxsPT09KGU9Yy5QVGhyZWFkKXx8dm9pZCAwPT09ZXx8ZS50ZXJtaW5hdGVBbGxUaHJlYWRzKCksYz12b2lkIDAsZj0hMSxsPSExLGQ9ITApfX0sNDk3OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmNoZWNrTGFzdEVycm9yPXQuaXRlcmF0ZUV4dHJhT3B0aW9ucz10LmFsbG9jV2FzbVN0cmluZz12b2lkIDA7Y29uc3Qgbj1yKDI2Myk7dC5hbGxvY1dhc21TdHJpbmc9KGUsdCk9Pntjb25zdCByPSgwLG4uZ2V0SW5zdGFuY2UpKCksYT1yLmxlbmd0aEJ5dGVzVVRGOChlKSsxLG89ci5fbWFsbG9jKGEpO3JldHVybiByLnN0cmluZ1RvVVRGOChlLG8sYSksdC5wdXNoKG8pLG99LHQuaXRlcmF0ZUV4dHJhT3B0aW9ucz0oZSxyLG4sYSk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgZSYmbnVsbCE9PWUpe2lmKG4uaGFzKGUpKXRocm93IG5ldyBFcnJvcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zXCIpO24uYWRkKGUpfU9iamVjdC5lbnRyaWVzKGUpLmZvckVhY2goKChbZSxvXSk9Pntjb25zdCBzPXI/citlOmU7aWYoXCJvYmplY3RcIj09dHlwZW9mIG8pKDAsdC5pdGVyYXRlRXh0cmFPcHRpb25zKShvLHMrXCIuXCIsbixhKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBvfHxcIm51bWJlclwiPT10eXBlb2YgbylhKHMsby50b1N0cmluZygpKTtlbHNle2lmKFwiYm9vbGVhblwiIT10eXBlb2Ygbyl0aHJvdyBuZXcgRXJyb3IoXCJDYW5cXCd0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogXCIrdHlwZW9mIG8pO2EocyxvP1wiMVwiOlwiMFwiKX19KSl9LHQuY2hlY2tMYXN0RXJyb3I9ZT0+e2NvbnN0IHQ9KDAsbi5nZXRJbnN0YW5jZSkoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2NvbnN0IHI9dC5zdGFja0FsbG9jKDgpO3QuX09ydEdldExhc3RFcnJvcihyLHIrNCk7Y29uc3Qgbj10LkhFQVAzMltyLzRdLGE9dC5IRUFQVTMyW3IvNCsxXSxvPWE/dC5VVEY4VG9TdHJpbmcoYSk6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHtufSwgRVJST1JfTUVTU0FHRTogJHtvfWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fX0sNDc0OihlLHQscik9Pnt2YXIgX3NjcmlwdERpcixuPShfc2NyaXB0RGlyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDAsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIF9fZmlsZW5hbWUmJihfc2NyaXB0RGlyPV9zY3JpcHREaXJ8fF9fZmlsZW5hbWUpLGZ1bmN0aW9uKGU9e30pe2Z1bmN0aW9uIHQoKXtyZXR1cm4gay5idWZmZXIhPUQuYnVmZmVyJiZZKCksRH1mdW5jdGlvbiBuKCl7cmV0dXJuIGsuYnVmZmVyIT1ELmJ1ZmZlciYmWSgpLEl9ZnVuY3Rpb24gYSgpe3JldHVybiBrLmJ1ZmZlciE9RC5idWZmZXImJlkoKSxVfWZ1bmN0aW9uIG8oKXtyZXR1cm4gay5idWZmZXIhPUQuYnVmZmVyJiZZKCksTH1mdW5jdGlvbiBzKCl7cmV0dXJuIGsuYnVmZmVyIT1ELmJ1ZmZlciYmWSgpLFd9dmFyIGksdSxjPWU7Yy5yZWFkeT1uZXcgUHJvbWlzZSgoKGUsdCk9PntpPWUsdT10fSkpO3ZhciBsLGYsZCxwPU9iamVjdC5hc3NpZ24oe30sYyksZz1cIi4vdGhpcy5wcm9ncmFtXCIsaD0oZSx0KT0+e3Rocm93IHR9LG09XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyx5PVwiZnVuY3Rpb25cIj09dHlwZW9mIGltcG9ydFNjcmlwdHMsdj1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUsYj1jLkVOVklST05NRU5UX0lTX1BUSFJFQUR8fCExLHc9XCJcIjtmdW5jdGlvbiBfKGUpe3JldHVybiBjLmxvY2F0ZUZpbGU/Yy5sb2NhdGVGaWxlKGUsdyk6dytlfWlmKHYpe3ZhciBPPXIoMTQ3KSxTPXIoMTcpO2xldCB0O3c9eT9TLmRpcm5hbWUodykrXCIvXCI6X19kaXJuYW1lK1wiL1wiLGw9KGUsdCk9PihlPWUuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChlKTpTLm5vcm1hbGl6ZShlKSxPLnJlYWRGaWxlU3luYyhlLHQ/dm9pZCAwOlwidXRmOFwiKSksZD1lPT4oKGU9bChlLCEwKSkuYnVmZmVyfHwoZT1uZXcgVWludDhBcnJheShlKSksZSksZj0oZSx0LHIsbj0hMCk9PntlPWUuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik/bmV3IFVSTChlKTpTLm5vcm1hbGl6ZShlKSxPLnJlYWRGaWxlKGUsbj92b2lkIDA6XCJ1dGY4XCIsKChlLGEpPT57ZT9yKGUpOnQobj9hLmJ1ZmZlcjphKX0pKX0sIWMudGhpc1Byb2dyYW0mJjE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKGc9cHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFxcXFxcL2csXCIvXCIpKSxwcm9jZXNzLmFyZ3Yuc2xpY2UoMiksaD0oZSx0KT0+e3Rocm93IHByb2Nlc3MuZXhpdENvZGU9ZSx0fSxjLmluc3BlY3Q9KCk9PlwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIjt0cnl7dD1yKDI2Nyl9Y2F0Y2goZSl7dGhyb3cgY29uc29sZS5lcnJvcihcXCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD9cXCcpLGV9Z2xvYmFsLldvcmtlcj10Lldvcmtlcn1lbHNlKG18fHkpJiYoeT93PXNlbGYubG9jYXRpb24uaHJlZjpcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJih3PWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxfc2NyaXB0RGlyJiYodz1fc2NyaXB0RGlyKSx3PTAhPT13LmluZGV4T2YoXCJibG9iOlwiKT93LnN1YnN0cigwLHcucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIix2fHwobD1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oXCJHRVRcIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LHkmJihkPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSxmPShlLHQscik9Pnt2YXIgbj1uZXcgWE1MSHR0cFJlcXVlc3Q7bi5vcGVuKFwiR0VUXCIsZSwhMCksbi5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLG4ub25sb2FkPSgpPT57MjAwPT1uLnN0YXR1c3x8MD09bi5zdGF0dXMmJm4ucmVzcG9uc2U/dChuLnJlc3BvbnNlKTpyKCl9LG4ub25lcnJvcj1yLG4uc2VuZChudWxsKX0pKTt2JiZcInVuZGVmaW5lZFwiPT10eXBlb2YgcGVyZm9ybWFuY2UmJihnbG9iYWwucGVyZm9ybWFuY2U9cig3NCkucGVyZm9ybWFuY2UpO3ZhciBFPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksQT1jb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7diYmKEU9KC4uLmUpPT5PLndyaXRlU3luYygxLGUuam9pbihcIiBcIikrXCJcXFxcblwiKSxBPSguLi5lKT0+Ty53cml0ZVN5bmMoMixlLmpvaW4oXCIgXCIpK1wiXFxcXG5cIikpO3ZhciBULE09Yy5wcmludHx8RSxSPWMucHJpbnRFcnJ8fEE7T2JqZWN0LmFzc2lnbihjLHApLHA9bnVsbCxjLnRoaXNQcm9ncmFtJiYoZz1jLnRoaXNQcm9ncmFtKSxjLnF1aXQmJihoPWMucXVpdCksYy53YXNtQmluYXJ5JiYoVD1jLndhc21CaW5hcnkpO3ZhciBGPWMubm9FeGl0UnVudGltZXx8ITA7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZ0ZShcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7dmFyIGssQyx4LFAsRCxJLFUsTCxXLEg9ITE7ZnVuY3Rpb24gWSgpe3ZhciBlPWsuYnVmZmVyO2MuSEVBUDg9RD1uZXcgSW50OEFycmF5KGUpLGMuSEVBUDE2PW5ldyBJbnQxNkFycmF5KGUpLGMuSEVBUDMyPVU9bmV3IEludDMyQXJyYXkoZSksYy5IRUFQVTg9ST1uZXcgVWludDhBcnJheShlKSxjLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGUpLGMuSEVBUFUzMj1MPW5ldyBVaW50MzJBcnJheShlKSxjLkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShlKSxjLkhFQVBGNjQ9Vz1uZXcgRmxvYXQ2NEFycmF5KGUpfXZhciBqPWMuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2lmKDUyNDI4ODA8PWp8fHRlKFwiSU5JVElBTF9NRU1PUlkgc2hvdWxkIGJlIGxhcmdlciB0aGFuIFNUQUNLX1NJWkUsIHdhcyBcIitqK1wiISAoU1RBQ0tfU0laRT01MjQyODgwKVwiKSxiKWs9Yy53YXNtTWVtb3J5O2Vsc2UgaWYoYy53YXNtTWVtb3J5KWs9Yy53YXNtTWVtb3J5O2Vsc2UgaWYoISgoaz1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmovNjU1MzYsbWF4aW11bTo2NTUzNixzaGFyZWQ6ITB9KSkuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKXRocm93IFIoXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksdiYmUihcIihvbiBub2RlIHlvdSBtYXkgbmVlZDogLS1leHBlcmltZW50YWwtd2FzbS10aHJlYWRzIC0tZXhwZXJpbWVudGFsLXdhc20tYnVsay1tZW1vcnkgYW5kL29yIHJlY2VudCB2ZXJzaW9uKVwiKSxFcnJvcihcImJhZCBtZW1vcnlcIik7WSgpLGo9ay5idWZmZXIuYnl0ZUxlbmd0aDt2YXIgeixHPVtdLE49W10sQj1bXSwkPTA7ZnVuY3Rpb24gcSgpe3JldHVybiBGfHwwPCR9dmFyIFYsSixYPTAsSz1udWxsLFo9bnVsbDtmdW5jdGlvbiBRKCl7WCsrLGMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmYy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKFgpfWZ1bmN0aW9uIGVlKCl7aWYoWC0tLGMubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmYy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKFgpLDA9PVgmJihudWxsIT09SyYmKGNsZWFySW50ZXJ2YWwoSyksSz1udWxsKSxaKSl7dmFyIGU9WjtaPW51bGwsZSgpfX1mdW5jdGlvbiB0ZShlKXt0aHJvdyBjLm9uQWJvcnQmJmMub25BYm9ydChlKSxSKGU9XCJBYm9ydGVkKFwiK2UrXCIpXCIpLEg9ITAsUD0xLGU9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihlK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSx1KGUpLGV9ZnVuY3Rpb24gcmUoZSl7cmV0dXJuIGUuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9ZnVuY3Rpb24gbmUoZSl7aWYoZT09ViYmVClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoVCk7aWYoZClyZXR1cm4gZChlKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1mdW5jdGlvbiBhZShlLHQscil7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKCFUJiYobXx8eSkpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGZldGNoJiYhZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSlyZXR1cm4gZmV0Y2goZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigodD0+e2lmKCF0Lm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK2UrXCJcXCdcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKCgoKT0+bmUoZSkpKTtpZihmKXJldHVybiBuZXcgUHJvbWlzZSgoKHQscik9PntmKGUsKGU9PnQobmV3IFVpbnQ4QXJyYXkoZSkpKSxyKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKCk9Pm5lKGUpKSl9KGUpLnRoZW4oKGU9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCkpKS50aGVuKChlPT5lKSkudGhlbihyLChlPT57UihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK2UpLHRlKGUpfSkpfWZ1bmN0aW9uIG9lKGUpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtlfSlgLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gc2UoZSl7ZS50ZXJtaW5hdGUoKSxlLm9ubWVzc2FnZT0oKT0+e319ZnVuY3Rpb24gaWUoZSl7KGU9Z2UuRmFbZV0pfHx0ZSgpLGdlLmZiKGUpfWZ1bmN0aW9uIHVlKGUpe3ZhciB0PWdlLlphKCk7aWYoIXQpcmV0dXJuIDY7Z2UuSWEucHVzaCh0KSxnZS5GYVtlLkhhXT10LHQuSGE9ZS5IYTt2YXIgcj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTplLmdiLGFyZzplLllhLHB0aHJlYWRfcHRyOmUuSGF9O3JldHVybiB2JiZ0LnVucmVmKCksdC5wb3N0TWVzc2FnZShyLGUubWIpLDB9cmUoVj1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIil8fChWPV8oVikpO3ZhciBjZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsbGU9KGUsdCxyKT0+e3ZhciBuPSh0Pj4+PTApK3I7Zm9yKHI9dDtlW3JdJiYhKHI+PW4pOykrK3I7aWYoMTY8ci10JiZlLmJ1ZmZlciYmY2UpcmV0dXJuIGNlLmRlY29kZShlLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyP2Uuc2xpY2UodCxyKTplLnN1YmFycmF5KHQscikpO2ZvcihuPVwiXCI7dDxyOyl7dmFyIGE9ZVt0KytdO2lmKDEyOCZhKXt2YXIgbz02MyZlW3QrK107aWYoMTkyPT0oMjI0JmEpKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJmEpPDw2fG8pO2Vsc2V7dmFyIHM9NjMmZVt0KytdOzY1NTM2PihhPTIyND09KDI0MCZhKT8oMTUmYSk8PDEyfG88PDZ8czooNyZhKTw8MTh8bzw8MTJ8czw8Nnw2MyZlW3QrK10pP24rPVN0cmluZy5mcm9tQ2hhckNvZGUoYSk6KGEtPTY1NTM2LG4rPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8YT4+MTAsNTYzMjB8MTAyMyZhKSl9fWVsc2Ugbis9U3RyaW5nLmZyb21DaGFyQ29kZShhKX1yZXR1cm4gbn0sZmU9KGUsdCk9PihlPj4+PTApP2xlKG4oKSxlLHQpOlwiXCI7ZnVuY3Rpb24gZGUoZSl7aWYoYilyZXR1cm4gcWUoMSwxLGUpO1A9ZSxxKCl8fChnZS5oYigpLGMub25FeGl0JiZjLm9uRXhpdChlKSxIPSEwKSxoKGUsbmV3IG9lKGUpKX12YXIgcGU9ZT0+e2lmKFA9ZSxiKXRocm93IG1lKGUpLFwidW53aW5kXCI7ZGUoZSl9LGdlPXtMYTpbXSxJYTpbXSxUYTpbXSxGYTp7fSxQYTpmdW5jdGlvbigpe2I/Z2UuYWIoKTpnZS4kYSgpfSwkYTpmdW5jdGlvbigpe0cudW5zaGlmdCgoKCk9PntRKCksZ2UuYmIoKCgpPT5lZSgpKSl9KSl9LGFiOmZ1bmN0aW9uKCl7Z2UucmVjZWl2ZU9iamVjdFRyYW5zZmVyPWdlLmViLGdlLnRocmVhZEluaXRUTFM9Z2UuU2EsZ2Uuc2V0RXhpdFN0YXR1cz1nZS5SYSxGPSExfSxSYTpmdW5jdGlvbihlKXtQPWV9LHJiOltcIiR0ZXJtaW5hdGVXb3JrZXJcIl0saGI6ZnVuY3Rpb24oKXtmb3IodmFyIGUgb2YgZ2UuSWEpc2UoZSk7Zm9yKGUgb2YgZ2UuTGEpc2UoZSk7Z2UuTGE9W10sZ2UuSWE9W10sZ2UuRmE9W119LGZiOmZ1bmN0aW9uKGUpe3ZhciB0PWUuSGE7ZGVsZXRlIGdlLkZhW3RdLGdlLkxhLnB1c2goZSksZ2UuSWEuc3BsaWNlKGdlLklhLmluZGV4T2YoZSksMSksZS5IYT0wLHl0KHQpfSxlYjpmdW5jdGlvbigpe30sU2E6ZnVuY3Rpb24oKXtnZS5UYS5mb3JFYWNoKChlPT5lKCkpKX0sY2I6ZT0+bmV3IFByb21pc2UoKHQ9PntlLm9ubWVzc2FnZT1yPT57dmFyIG49KHI9ci5kYXRhKS5jbWQ7aWYoci50YXJnZXRUaHJlYWQmJnIudGFyZ2V0VGhyZWFkIT1kdCgpKXt2YXIgYT1nZS5GYVtyLnFiXTthP2EucG9zdE1lc3NhZ2UocixyLnRyYW5zZmVyTGlzdCk6UihcXCdJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiXFwnK24rXFwnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgXFwnK3IudGFyZ2V0VGhyZWFkK1wiLCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFcIil9ZWxzZVwiY2hlY2tNYWlsYm94XCI9PT1uP0hlKCk6XCJzcGF3blRocmVhZFwiPT09bj91ZShyKTpcImNsZWFudXBUaHJlYWRcIj09PW4/aWUoci50aHJlYWQpOlwia2lsbFRocmVhZFwiPT09bj8ocj1yLnRocmVhZCxuPWdlLkZhW3JdLGRlbGV0ZSBnZS5GYVtyXSxzZShuKSx5dChyKSxnZS5JYS5zcGxpY2UoZ2UuSWEuaW5kZXhPZihuKSwxKSxuLkhhPTApOlwiY2FuY2VsVGhyZWFkXCI9PT1uP2dlLkZhW3IudGhyZWFkXS5wb3N0TWVzc2FnZSh7Y21kOlwiY2FuY2VsXCJ9KTpcImxvYWRlZFwiPT09bj8oZS5sb2FkZWQ9ITAsdChlKSk6XCJhbGVydFwiPT09bj9hbGVydChcIlRocmVhZCBcIityLnRocmVhZElkK1wiOiBcIityLnRleHQpOlwic2V0aW1tZWRpYXRlXCI9PT1yLnRhcmdldD9lLnBvc3RNZXNzYWdlKHIpOlwiY2FsbEhhbmRsZXJcIj09PW4/Y1tyLmhhbmRsZXJdKC4uLnIuYXJncyk6biYmUihcIndvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCBcIituKX0sZS5vbmVycm9yPWU9Pnt0aHJvdyBSKFwid29ya2VyIHNlbnQgYW4gZXJyb3IhIFwiK2UuZmlsZW5hbWUrXCI6XCIrZS5saW5lbm8rXCI6IFwiK2UubWVzc2FnZSksZX0sdiYmKGUub24oXCJtZXNzYWdlXCIsKGZ1bmN0aW9uKHQpe2Uub25tZXNzYWdlKHtkYXRhOnR9KX0pKSxlLm9uKFwiZXJyb3JcIiwoZnVuY3Rpb24odCl7ZS5vbmVycm9yKHQpfSkpKTt2YXIgcixuPVtdO2ZvcihyIG9mW1wib25FeGl0XCIsXCJvbkFib3J0XCIsXCJwcmludFwiLFwicHJpbnRFcnJcIl0pYy5oYXNPd25Qcm9wZXJ0eShyKSYmbi5wdXNoKHIpO2UucG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRcIixoYW5kbGVyczpuLHVybE9yQmxvYjpjLm1haW5TY3JpcHRVcmxPckJsb2J8fF9zY3JpcHREaXIsd2FzbU1lbW9yeTprLHdhc21Nb2R1bGU6eH0pfSkpLGJiOmZ1bmN0aW9uKGUpe2UoKX0sWGE6ZnVuY3Rpb24oKXt2YXIgZT1fKFwib3J0LXdhc20tdGhyZWFkZWQud29ya2VyLmpzXCIpO2U9bmV3IFdvcmtlcihlKSxnZS5MYS5wdXNoKGUpfSxaYTpmdW5jdGlvbigpe3JldHVybiAwPT1nZS5MYS5sZW5ndGgmJihnZS5YYSgpLGdlLmNiKGdlLkxhWzBdKSksZ2UuTGEucG9wKCl9fTtjLlBUaHJlYWQ9Z2U7dmFyIGhlPWU9Pntmb3IoOzA8ZS5sZW5ndGg7KWUuc2hpZnQoKShjKX07ZnVuY3Rpb24gbWUoZSl7aWYoYilyZXR1cm4gcWUoMiwwLGUpO3BlKGUpfWMuZXN0YWJsaXNoU3RhY2tTcGFjZT1mdW5jdGlvbigpe3ZhciBlPWR0KCksdD1hKClbZSs1Mj4+Mj4+PjBdO2U9YSgpW2UrNTY+PjI+Pj4wXSxfdCh0LHQtZSksU3QodCl9O3ZhciB5ZT1bXTtmdW5jdGlvbiB2ZShlKXt0aGlzLk9hPWUtMjQsdGhpcy5XYT1mdW5jdGlvbihlKXtvKClbdGhpcy5PYSs0Pj4yPj4+MF09ZX0sdGhpcy5WYT1mdW5jdGlvbihlKXtvKClbdGhpcy5PYSs4Pj4yPj4+MF09ZX0sdGhpcy5QYT1mdW5jdGlvbihlLHQpe3RoaXMuVWEoKSx0aGlzLldhKGUpLHRoaXMuVmEodCl9LHRoaXMuVWE9ZnVuY3Rpb24oKXtvKClbdGhpcy5PYSsxNj4+Mj4+PjBdPTB9fWZ1bmN0aW9uIGJlKGUsdCxyLG4pe3JldHVybiBiP3FlKDMsMSxlLHQscixuKTp3ZShlLHQscixuKX1mdW5jdGlvbiB3ZShlLHQscixuKXtpZihlPj4+PTAsdD4+Pj0wLHI+Pj49MCxuPj4+PTAsXCJ1bmRlZmluZWRcIj09dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyKXJldHVybiBSKFwiQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFNoYXJlZEFycmF5QnVmZmVyLCBwdGhyZWFkcyBhcmUgbm90IGF2YWlsYWJsZSFcIiksNjt2YXIgYT1bXTtyZXR1cm4gYiYmMD09PWEubGVuZ3RoP2JlKGUsdCxyLG4pOihlPXtnYjpyLEhhOmUsWWE6bixtYjphfSxiPyhlLm9iPVwic3Bhd25UaHJlYWRcIixwb3N0TWVzc2FnZShlLGEpLDApOnVlKGUpKX1mdW5jdGlvbiBfZShlLHQscil7cmV0dXJuIGI/cWUoNCwxLGUsdCxyKTowfWZ1bmN0aW9uIE9lKGUsdCl7aWYoYilyZXR1cm4gcWUoNSwxLGUsdCl9Yy5pbnZva2VFbnRyeVBvaW50PWZ1bmN0aW9uKGUsdCl7dmFyIHI9eWVbZV07cnx8KGU+PXllLmxlbmd0aCYmKHllLmxlbmd0aD1lKzEpLHllW2VdPXI9ei5nZXQoZSkpLGU9cih0KSxxKCk/Z2UuUmEoZSk6dnQoZSl9O3ZhciBTZT1lPT57Zm9yKHZhciB0PTAscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbj1lLmNoYXJDb2RlQXQocik7MTI3Pj1uP3QrKzoyMDQ3Pj1uP3QrPTI6NTUyOTY8PW4mJjU3MzQzPj1uPyh0Kz00LCsrcik6dCs9M31yZXR1cm4gdH0sRWU9KGUsdCxyLG4pPT57aWYoISgwPG4pKXJldHVybiAwO3ZhciBhPXI+Pj49MDtuPXIrbi0xO2Zvcih2YXIgbz0wO288ZS5sZW5ndGg7KytvKXt2YXIgcz1lLmNoYXJDb2RlQXQobyk7aWYoNTUyOTY8PXMmJjU3MzQzPj1zJiYocz02NTUzNisoKDEwMjMmcyk8PDEwKXwxMDIzJmUuY2hhckNvZGVBdCgrK28pKSwxMjc+PXMpe2lmKHI+PW4pYnJlYWs7dFtyKys+Pj4wXT1zfWVsc2V7aWYoMjA0Nz49cyl7aWYocisxPj1uKWJyZWFrO3RbcisrPj4+MF09MTkyfHM+PjZ9ZWxzZXtpZig2NTUzNT49cyl7aWYocisyPj1uKWJyZWFrO3RbcisrPj4+MF09MjI0fHM+PjEyfWVsc2V7aWYociszPj1uKWJyZWFrO3RbcisrPj4+MF09MjQwfHM+PjE4LHRbcisrPj4+MF09MTI4fHM+PjEyJjYzfXRbcisrPj4+MF09MTI4fHM+PjYmNjN9dFtyKys+Pj4wXT0xMjh8NjMmc319cmV0dXJuIHRbcj4+PjBdPTAsci1hfSxBZT0oZSx0LHIpPT5FZShlLG4oKSx0LHIpO2Z1bmN0aW9uIFRlKGUsdCl7aWYoYilyZXR1cm4gcWUoNiwxLGUsdCl9ZnVuY3Rpb24gTWUoZSx0LHIpe2lmKGIpcmV0dXJuIHFlKDcsMSxlLHQscil9ZnVuY3Rpb24gUmUoZSx0LHIpe3JldHVybiBiP3FlKDgsMSxlLHQscik6MH1mdW5jdGlvbiBGZShlLHQpe2lmKGIpcmV0dXJuIHFlKDksMSxlLHQpfWZ1bmN0aW9uIGtlKGUsdCxyKXtpZihiKXJldHVybiBxZSgxMCwxLGUsdCxyKX1mdW5jdGlvbiBDZShlLHQscixuKXtpZihiKXJldHVybiBxZSgxMSwxLGUsdCxyLG4pfWZ1bmN0aW9uIHhlKGUsdCxyLG4pe2lmKGIpcmV0dXJuIHFlKDEyLDEsZSx0LHIsbil9ZnVuY3Rpb24gUGUoZSx0LHIsbil7aWYoYilyZXR1cm4gcWUoMTMsMSxlLHQscixuKX1mdW5jdGlvbiBEZShlKXtpZihiKXJldHVybiBxZSgxNCwxLGUpfWZ1bmN0aW9uIEllKGUsdCl7aWYoYilyZXR1cm4gcWUoMTUsMSxlLHQpfWZ1bmN0aW9uIFVlKGUsdCxyKXtpZihiKXJldHVybiBxZSgxNiwxLGUsdCxyKX12YXIgTGU9ZT0+e2lmKCFIKXRyeXtpZihlKCksIXEoKSl0cnl7Yj92dChQKTpwZShQKX1jYXRjaChlKXtlIGluc3RhbmNlb2Ygb2V8fFwidW53aW5kXCI9PWV8fGgoMSxlKX19Y2F0Y2goZSl7ZSBpbnN0YW5jZW9mIG9lfHxcInVud2luZFwiPT1lfHxoKDEsZSl9fTtmdW5jdGlvbiBXZShlKXtlPj4+PTAsXCJmdW5jdGlvblwiPT10eXBlb2YgQXRvbWljcy5uYiYmKEF0b21pY3MubmIoYSgpLGU+PjIsZSkudmFsdWUudGhlbihIZSksZSs9MTI4LEF0b21pY3Muc3RvcmUoYSgpLGU+PjIsMSkpfWZ1bmN0aW9uIEhlKCl7dmFyIGU9ZHQoKTtlJiYoV2UoZSksTGUoKCgpPT5idCgpKSkpfWMuX19lbXNjcmlwdGVuX3RocmVhZF9tYWlsYm94X2F3YWl0PVdlLGMuY2hlY2tNYWlsYm94PUhlO3ZhciBZZT1lPT4wPT1lJTQmJigwIT1lJTEwMHx8MD09ZSU0MDApLGplPVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLHplPVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdO2Z1bmN0aW9uIEdlKGUsdCxyLG4sYSxvLHMsaSl7cmV0dXJuIGI/cWUoMTcsMSxlLHQscixuLGEsbyxzLGkpOi01Mn1mdW5jdGlvbiBOZShlLHQscixuLGEsbyxzKXtpZihiKXJldHVybiBxZSgxOCwxLGUsdCxyLG4sYSxvLHMpfXZhciBCZT1lPT57dmFyIHQ9U2UoZSkrMSxyPXB0KHQpO3JldHVybiByJiZBZShlLHIsdCkscn0sJGU9ZT0+e3ZhciB0PU90KCk7cmV0dXJuIGU9ZSgpLFN0KHQpLGV9O2Z1bmN0aW9uIHFlKGUsdCl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aC0yLG49YXJndW1lbnRzO3JldHVybiAkZSgoKCk9Pntmb3IodmFyIGE9RXQoOCpyKSxvPWE+PjMsaT0wO2k8cjtpKyspe3ZhciB1PW5bMitpXTtzKClbbytpPj4+MF09dX1yZXR1cm4gbXQoZSxyLGEsdCl9KSl9dmFyIFZlLEplPVtdLFhlPXt9LEtlPSgpPT57aWYoIVZlKXt2YXIgZSx0PXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOmd8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKGUgaW4gWGUpdm9pZCAwPT09WGVbZV0/ZGVsZXRlIHRbZV06dFtlXT1YZVtlXTt2YXIgcj1bXTtmb3IoZSBpbiB0KXIucHVzaChgJHtlfT0ke3RbZV19YCk7VmU9cn1yZXR1cm4gVmV9O2Z1bmN0aW9uIFplKGUscil7aWYoYilyZXR1cm4gcWUoMTksMSxlLHIpO2U+Pj49MCxyPj4+PTA7dmFyIG49MDtyZXR1cm4gS2UoKS5mb3JFYWNoKChmdW5jdGlvbihhLHMpe3ZhciBpPXIrbjtmb3Iocz1vKClbZSs0KnM+PjI+Pj4wXT1pLGk9MDtpPGEubGVuZ3RoOysraSl0KClbcysrPj4wPj4+MF09YS5jaGFyQ29kZUF0KGkpO3QoKVtzPj4wPj4+MF09MCxuKz1hLmxlbmd0aCsxfSkpLDB9ZnVuY3Rpb24gUWUoZSx0KXtpZihiKXJldHVybiBxZSgyMCwxLGUsdCk7ZT4+Pj0wLHQ+Pj49MDt2YXIgcj1LZSgpO28oKVtlPj4yPj4+MF09ci5sZW5ndGg7dmFyIG49MDtyZXR1cm4gci5mb3JFYWNoKChmdW5jdGlvbihlKXtuKz1lLmxlbmd0aCsxfSkpLG8oKVt0Pj4yPj4+MF09biwwfWZ1bmN0aW9uIGV0KGUpe3JldHVybiBiP3FlKDIxLDEsZSk6NTJ9ZnVuY3Rpb24gdHQoZSx0LHIsbil7cmV0dXJuIGI/cWUoMjIsMSxlLHQscixuKTo1Mn1mdW5jdGlvbiBydChlLHQscixuLGEpe3JldHVybiBiP3FlKDIzLDEsZSx0LHIsbixhKTo3MH12YXIgbnQ9W251bGwsW10sW11dO2Z1bmN0aW9uIGF0KGUsdCxyLGEpe2lmKGIpcmV0dXJuIHFlKDI0LDEsZSx0LHIsYSk7dD4+Pj0wLHI+Pj49MCxhPj4+PTA7Zm9yKHZhciBzPTAsaT0wO2k8cjtpKyspe3ZhciB1PW8oKVt0Pj4yPj4+MF0sYz1vKClbdCs0Pj4yPj4+MF07dCs9ODtmb3IodmFyIGw9MDtsPGM7bCsrKXt2YXIgZj1uKClbdStsPj4+MF0sZD1udFtlXTswPT09Znx8MTA9PT1mPygoMT09PWU/TTpSKShsZShkLDApKSxkLmxlbmd0aD0wKTpkLnB1c2goZil9cys9Y31yZXR1cm4gbygpW2E+PjI+Pj4wXT1zLDB9dmFyIG90PWU9PihvdD0oKCk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXJldHVybiBlPT4oZS5zZXQoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShlLmJ5dGVMZW5ndGgpKSksZSk7aWYodil0cnl7dmFyIGU9cigxMTMpO2lmKGUucmFuZG9tRmlsbFN5bmMpcmV0dXJuIHQ9PmUucmFuZG9tRmlsbFN5bmModCk7dmFyIHQ9ZS5yYW5kb21CeXRlcztyZXR1cm4gZT0+KGUuc2V0KHQoZS5ieXRlTGVuZ3RoKSksZSl9Y2F0Y2goZSl7fXRlKFwiaW5pdFJhbmRvbURldmljZVwiKX0pKCkpKGUpLHN0PVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0saXQ9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSx1dD0oZSxyKT0+e3QoKS5zZXQoZSxyPj4+MCl9O2Z1bmN0aW9uIGN0KGUsdCxyLG4pe2Z1bmN0aW9uIG8oZSx0LHIpe2ZvcihlPVwibnVtYmVyXCI9PXR5cGVvZiBlP2UudG9TdHJpbmcoKTplfHxcIlwiO2UubGVuZ3RoPHQ7KWU9clswXStlO3JldHVybiBlfWZ1bmN0aW9uIHMoZSx0KXtyZXR1cm4gbyhlLHQsXCIwXCIpfWZ1bmN0aW9uIGkoZSx0KXtmdW5jdGlvbiByKGUpe3JldHVybiAwPmU/LTE6MDxlPzE6MH12YXIgbjtyZXR1cm4gMD09PShuPXIoZS5nZXRGdWxsWWVhcigpLXQuZ2V0RnVsbFllYXIoKSkpJiYwPT09KG49cihlLmdldE1vbnRoKCktdC5nZXRNb250aCgpKSkmJihuPXIoZS5nZXREYXRlKCktdC5nZXREYXRlKCkpKSxufWZ1bmN0aW9uIHUoZSl7c3dpdGNoKGUuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gZTtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gYyhlKXt2YXIgdD1lLkphO2ZvcihlPW5ldyBEYXRlKG5ldyBEYXRlKGUuS2ErMTkwMCwwLDEpLmdldFRpbWUoKSk7MDx0Oyl7dmFyIHI9ZS5nZXRNb250aCgpLG49KFllKGUuZ2V0RnVsbFllYXIoKSk/c3Q6aXQpW3JdO2lmKCEodD5uLWUuZ2V0RGF0ZSgpKSl7ZS5zZXREYXRlKGUuZ2V0RGF0ZSgpK3QpO2JyZWFrfXQtPW4tZS5nZXREYXRlKCkrMSxlLnNldERhdGUoMSksMTE+cj9lLnNldE1vbnRoKHIrMSk6KGUuc2V0TW9udGgoMCksZS5zZXRGdWxsWWVhcihlLmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiByPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSsxLDAsNCksdD11KG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDQpKSxyPXUociksMD49aSh0LGUpPzA+PWkocixlKT9lLmdldEZ1bGxZZWFyKCkrMTplLmdldEZ1bGxZZWFyKCk6ZS5nZXRGdWxsWWVhcigpLTF9ZT4+Pj0wLHQ+Pj49MCxyPj4+PTAsbj4+Pj0wO3ZhciBsPWEoKVtuKzQwPj4yPj4+MF07Zm9yKHZhciBmIGluIG49e2tiOmEoKVtuPj4yPj4+MF0samI6YSgpW24rND4+Mj4+PjBdLE1hOmEoKVtuKzg+PjI+Pj4wXSxRYTphKClbbisxMj4+Mj4+PjBdLE5hOmEoKVtuKzE2Pj4yPj4+MF0sS2E6YSgpW24rMjA+PjI+Pj4wXSxHYTphKClbbisyND4+Mj4+PjBdLEphOmEoKVtuKzI4Pj4yPj4+MF0sc2I6YSgpW24rMzI+PjI+Pj4wXSxpYjphKClbbiszNj4+Mj4+PjBdLGxiOmw/ZmUobCk6XCJcIn0scj1mZShyKSxsPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn0pcj1yLnJlcGxhY2UobmV3IFJlZ0V4cChmLFwiZ1wiKSxsW2ZdKTt2YXIgZD1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLHA9XCJKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXCIuc3BsaXQoXCIgXCIpO2ZvcihmIGluIGw9e1wiJWFcIjplPT5kW2UuR2FdLnN1YnN0cmluZygwLDMpLFwiJUFcIjplPT5kW2UuR2FdLFwiJWJcIjplPT5wW2UuTmFdLnN1YnN0cmluZygwLDMpLFwiJUJcIjplPT5wW2UuTmFdLFwiJUNcIjplPT5zKChlLkthKzE5MDApLzEwMHwwLDIpLFwiJWRcIjplPT5zKGUuUWEsMiksXCIlZVwiOmU9Pm8oZS5RYSwyLFwiIFwiKSxcIiVnXCI6ZT0+YyhlKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVHXCI6ZT0+YyhlKSxcIiVIXCI6ZT0+cyhlLk1hLDIpLFwiJUlcIjplPT4oMD09KGU9ZS5NYSk/ZT0xMjoxMjxlJiYoZS09MTIpLHMoZSwyKSksXCIlalwiOmU9Pntmb3IodmFyIHQ9MCxyPTA7cjw9ZS5OYS0xO3QrPShZZShlLkthKzE5MDApP3N0Oml0KVtyKytdKTtyZXR1cm4gcyhlLlFhK3QsMyl9LFwiJW1cIjplPT5zKGUuTmErMSwyKSxcIiVNXCI6ZT0+cyhlLmpiLDIpLFwiJW5cIjooKT0+XCJcXFxcblwiLFwiJXBcIjplPT4wPD1lLk1hJiYxMj5lLk1hP1wiQU1cIjpcIlBNXCIsXCIlU1wiOmU9PnMoZS5rYiwyKSxcIiV0XCI6KCk9PlwiXFxcXHRcIixcIiV1XCI6ZT0+ZS5HYXx8NyxcIiVVXCI6ZT0+cyhNYXRoLmZsb29yKChlLkphKzctZS5HYSkvNyksMiksXCIlVlwiOmU9Pnt2YXIgdD1NYXRoLmZsb29yKChlLkphKzctKGUuR2ErNiklNykvNyk7aWYoMj49KGUuR2ErMzcxLWUuSmEtMiklNyYmdCsrLHQpNTM9PXQmJig0PT0ocj0oZS5HYSszNzEtZS5KYSklNyl8fDM9PXImJlllKGUuS2EpfHwodD0xKSk7ZWxzZXt0PTUyO3ZhciByPShlLkdhKzctZS5KYS0xKSU3Oyg0PT1yfHw1PT1yJiZZZShlLkthJTQwMC0xKSkmJnQrK31yZXR1cm4gcyh0LDIpfSxcIiV3XCI6ZT0+ZS5HYSxcIiVXXCI6ZT0+cyhNYXRoLmZsb29yKChlLkphKzctKGUuR2ErNiklNykvNyksMiksXCIleVwiOmU9PihlLkthKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJVlcIjplPT5lLkthKzE5MDAsXCIlelwiOmU9Pnt2YXIgdD0wPD0oZT1lLmliKTtyZXR1cm4gZT1NYXRoLmFicyhlKS82MCwodD9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyhlLzYwKjEwMCtlJTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZT0+ZS5sYixcIiUlXCI6KCk9PlwiJVwifSxyPXIucmVwbGFjZSgvJSUvZyxcIlxcXFwwXFxcXDBcIiksbClyLmluY2x1ZGVzKGYpJiYocj1yLnJlcGxhY2UobmV3IFJlZ0V4cChmLFwiZ1wiKSxsW2ZdKG4pKSk7cmV0dXJuIGY9ZnVuY3Rpb24oZSl7dmFyIHQ9QXJyYXkoU2UoZSkrMSk7cmV0dXJuIEVlKGUsdCwwLHQubGVuZ3RoKSx0fShyPXIucmVwbGFjZSgvXFxcXDBcXFxcMC9nLFwiJVwiKSksZi5sZW5ndGg+dD8wOih1dChmLGUpLGYubGVuZ3RoLTEpfWdlLlBhKCk7dmFyIGx0PVtudWxsLGRlLG1lLGJlLF9lLE9lLFRlLE1lLFJlLEZlLGtlLENlLHhlLFBlLERlLEllLFVlLEdlLE5lLFplLFFlLGV0LHR0LHJ0LGF0XSxmdD17YjpmdW5jdGlvbihlLHQscil7dGhyb3cgbmV3IHZlKGU+Pj49MCkuUGEodD4+PjAscj4+PjApLGV9LE46ZnVuY3Rpb24oZSl7Z3QoZT4+PjAsIXksMSwhbSwxMzEwNzIsITEpLGdlLlNhKCl9LGs6ZnVuY3Rpb24oZSl7ZT4+Pj0wLGI/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6ZX0pOmllKGUpfSxJOndlLGg6X2UsVDpPZSxFOlRlLEc6TWUsVTpSZSxSOkZlLEo6a2UsUTpDZSxvOnhlLEY6UGUsQzpEZSxTOkllLEQ6VWUscTooKT0+ITAsQTpmdW5jdGlvbihlLHQpeyhlPj4+PTApPT10Pj4+MD9zZXRUaW1lb3V0KCgoKT0+SGUoKSkpOmI/cG9zdE1lc3NhZ2Uoe3RhcmdldFRocmVhZDplLGNtZDpcImNoZWNrTWFpbGJveFwifSk6KGU9Z2UuRmFbZV0pJiZlLnBvc3RNZXNzYWdlKHtjbWQ6XCJjaGVja01haWxib3hcIn0pfSxMOmZ1bmN0aW9uKCl7cmV0dXJuLTF9LE06V2UscDpmdW5jdGlvbihlKXt2JiZnZS5GYVtlPj4+MF0ucmVmKCl9LHQ6ZnVuY3Rpb24oZSx0LHIpe2U9dCsyMDk3MTUyPj4+MDw0MTk0MzA1LSEhZT8oZT4+PjApKzQyOTQ5NjcyOTYqdDpOYU4scj4+Pj0wLGU9bmV3IERhdGUoMWUzKmUpLGEoKVtyPj4yPj4+MF09ZS5nZXRVVENTZWNvbmRzKCksYSgpW3IrND4+Mj4+PjBdPWUuZ2V0VVRDTWludXRlcygpLGEoKVtyKzg+PjI+Pj4wXT1lLmdldFVUQ0hvdXJzKCksYSgpW3IrMTI+PjI+Pj4wXT1lLmdldFVUQ0RhdGUoKSxhKClbcisxNj4+Mj4+PjBdPWUuZ2V0VVRDTW9udGgoKSxhKClbcisyMD4+Mj4+PjBdPWUuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLGEoKVtyKzI0Pj4yPj4+MF09ZS5nZXRVVENEYXkoKSxlPShlLmdldFRpbWUoKS1EYXRlLlVUQyhlLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGEoKVtyKzI4Pj4yPj4+MF09ZX0sdTpmdW5jdGlvbihlLHQscil7ZT10KzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFlPyhlPj4+MCkrNDI5NDk2NzI5Nip0Ok5hTixyPj4+PTAsZT1uZXcgRGF0ZSgxZTMqZSksYSgpW3I+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxhKClbcis0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksYSgpW3IrOD4+Mj4+PjBdPWUuZ2V0SG91cnMoKSxhKClbcisxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLGEoKVtyKzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLGEoKVtyKzIwPj4yPj4+MF09ZS5nZXRGdWxsWWVhcigpLTE5MDAsYSgpW3IrMjQ+PjI+Pj4wXT1lLmdldERheSgpLHQ9KFllKGUuZ2V0RnVsbFllYXIoKSk/amU6emUpW2UuZ2V0TW9udGgoKV0rZS5nZXREYXRlKCktMXwwLGEoKVtyKzI4Pj4yPj4+MF09dCxhKClbciszNj4+Mj4+PjBdPS02MCplLmdldFRpbWV6b25lT2Zmc2V0KCksdD1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBuPW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7ZT0wfCh0IT1uJiZlLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4sdCkpLGEoKVtyKzMyPj4yPj4+MF09ZX0sdjpmdW5jdGlvbihlKXtlPj4+PTA7dmFyIHQ9bmV3IERhdGUoYSgpW2UrMjA+PjI+Pj4wXSsxOTAwLGEoKVtlKzE2Pj4yPj4+MF0sYSgpW2UrMTI+PjI+Pj4wXSxhKClbZSs4Pj4yPj4+MF0sYSgpW2UrND4+Mj4+PjBdLGEoKVtlPj4yPj4+MF0sMCkscj1hKClbZSszMj4+Mj4+PjBdLG49dC5nZXRUaW1lem9uZU9mZnNldCgpLG89bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxzPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCksaT1NYXRoLm1pbihzLG8pO3JldHVybiAwPnI/YSgpW2UrMzI+PjI+Pj4wXT1OdW1iZXIobyE9cyYmaT09bik6MDxyIT0oaT09bikmJihvPU1hdGgubWF4KHMsbyksdC5zZXRUaW1lKHQuZ2V0VGltZSgpKzZlNCooKDA8cj9pOm8pLW4pKSksYSgpW2UrMjQ+PjI+Pj4wXT10LmdldERheSgpLHI9KFllKHQuZ2V0RnVsbFllYXIoKSk/amU6emUpW3QuZ2V0TW9udGgoKV0rdC5nZXREYXRlKCktMXwwLGEoKVtlKzI4Pj4yPj4+MF09cixhKClbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLGEoKVtlKzQ+PjI+Pj4wXT10LmdldE1pbnV0ZXMoKSxhKClbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLGEoKVtlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksYSgpW2UrMTY+PjI+Pj4wXT10LmdldE1vbnRoKCksYSgpW2UrMjA+PjI+Pj4wXT10LmdldFllYXIoKSxlPXQuZ2V0VGltZSgpLzFlMyx3dCgoSj1lLDE8PStNYXRoLmFicyhKKT8wPEo/K01hdGguZmxvb3IoSi80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChKLSsofn5KPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKSksZT4+PjB9LHI6R2UsczpOZSx6OmZ1bmN0aW9uKGUsdCxyKXtmdW5jdGlvbiBuKGUpe3JldHVybihlPWUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcXFwoKFtBLVphLXogXSspXFxcXCkkLykpP2VbMV06XCJHTVRcIn1lPj4+PTAsdD4+Pj0wLHI+Pj49MDt2YXIgcz0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCksaT1uZXcgRGF0ZShzLDAsMSksdT1uZXcgRGF0ZShzLDYsMSk7cz1pLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGM9dS5nZXRUaW1lem9uZU9mZnNldCgpLGw9TWF0aC5tYXgocyxjKTtvKClbZT4+Mj4+PjBdPTYwKmwsYSgpW3Q+PjI+Pj4wXT1OdW1iZXIocyE9YyksZT1uKGkpLHQ9bih1KSxlPUJlKGUpLHQ9QmUodCksYzxzPyhvKClbcj4+Mj4+PjBdPWUsbygpW3IrND4+Mj4+PjBdPXQpOihvKClbcj4+Mj4+PjBdPXQsbygpW3IrND4+Mj4+PjBdPWUpfSxjOigpPT57dGUoXCJcIil9LGw6ZnVuY3Rpb24oKXt9LGk6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sVjooKT0+e3Rocm93ICQrPTEsXCJ1bndpbmRcIn0sQjpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxlOigpPT5wZXJmb3JtYW5jZS50aW1lT3JpZ2luK3BlcmZvcm1hbmNlLm5vdygpLGY6ZnVuY3Rpb24oKXtyZXR1cm4gdj9yKDM3KS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5fSxLOmZ1bmN0aW9uKGUsdCxyLG4pe2ZvcihnZS5wYj10Pj4+MCxKZS5sZW5ndGg9cix0PW4+Pj4wPj4zLG49MDtuPHI7bisrKUplW25dPXMoKVt0K24+Pj4wXTtyZXR1cm4gbHRbZV0uYXBwbHkobnVsbCxKZSl9LHk6ZnVuY3Rpb24oZSl7ZT4+Pj0wO3ZhciB0PW4oKS5sZW5ndGg7aWYoZTw9dHx8NDI5NDkwMTc2MDxlKXJldHVybiExO2Zvcih2YXIgcj0xOzQ+PXI7cio9Mil7dmFyIGE9dCooMSsuMi9yKTthPU1hdGgubWluKGEsZSsxMDA2NjMyOTYpO3ZhciBvPU1hdGg7YT1NYXRoLm1heChlLGEpO2U6e289by5taW4uY2FsbChvLDQyOTQ5MDE3NjAsYSsoNjU1MzYtYSU2NTUzNiklNjU1MzYpLWsuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNjt0cnl7ay5ncm93KG8pLFkoKTt2YXIgcz0xO2JyZWFrIGV9Y2F0Y2goZSl7fXM9dm9pZCAwfWlmKHMpcmV0dXJuITB9cmV0dXJuITF9LE86WmUsUDpRZSxqOnBlLGc6ZXQsbjp0dCx3OnJ0LG06YXQseDpmdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdD4+Pj0wLG90KG4oKS5zdWJhcnJheShlPj4+MCxlK3Q+Pj4wKSksMH0sYTprfHxjLndhc21NZW1vcnksSDpjdCxkOmZ1bmN0aW9uKGUsdCxyLG4pe3JldHVybiBjdChlPj4+MCx0Pj4+MCxyPj4+MCxuPj4+MCl9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7cmV0dXJuIGU9ZS5leHBvcnRzLEM9ZT1mdW5jdGlvbihlKXt2YXIgdD1lPT4oKT0+ZSgpPj4+MCxyPWU9PnQ9PmUodCk+Pj4wO3JldHVybihlPU9iamVjdC5hc3NpZ24oe30sZSkpLl9fZXJybm9fbG9jYXRpb249dChlLl9fZXJybm9fbG9jYXRpb24pLGUucHRocmVhZF9zZWxmPXQoZS5wdGhyZWFkX3NlbGYpLGUubWFsbG9jPXIoZS5tYWxsb2MpLGUuc3RhY2tTYXZlPXQoZS5zdGFja1NhdmUpLGUuc3RhY2tBbGxvYz1yKGUuc3RhY2tBbGxvYyksZX0oZSksZ2UuVGEucHVzaChDLnNhKSx6PUMudGEsTi51bnNoaWZ0KEMuVykseD10LGVlKCksZX12YXIgdD17YTpmdH07aWYoUSgpLGMuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gYy5pbnN0YW50aWF0ZVdhc20odCxlKX1jYXRjaChlKXtSKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSksdShlKX0oZnVuY3Rpb24oZSx0KXt2YXIgcj1WO3JldHVybiBUfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8cmUocil8fHIuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fHZ8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP2FlKHIsZSx0KTpmZXRjaChyLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChuPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhuLGUpLnRoZW4odCwoZnVuY3Rpb24obil7cmV0dXJuIFIoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrbiksUihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLGFlKHIsZSx0KX0pKSkpfSkodCwoZnVuY3Rpb24odCl7ZSh0Lmluc3RhbmNlLHQubW9kdWxlKX0pKS5jYXRjaCh1KX0oKSxjLl9PcnRJbml0PShlLHQpPT4oYy5fT3J0SW5pdD1DLlgpKGUsdCksYy5fT3J0R2V0TGFzdEVycm9yPShlLHQpPT4oYy5fT3J0R2V0TGFzdEVycm9yPUMuWSkoZSx0KSxjLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0oZSx0LHIsbixhLG8scyxpLHUsbCk9PihjLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1DLlopKGUsdCxyLG4sYSxvLHMsaSx1LGwpLGMuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShlLHQpPT4oYy5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9Qy5fKShlLHQpLGMuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0oZSx0LHIpPT4oYy5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PUMuJCkoZSx0LHIpLGMuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1lPT4oYy5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPUMuYWEpKGUpLGMuX09ydENyZWF0ZVNlc3Npb249KGUsdCxyKT0+KGMuX09ydENyZWF0ZVNlc3Npb249Qy5iYSkoZSx0LHIpLGMuX09ydFJlbGVhc2VTZXNzaW9uPWU9PihjLl9PcnRSZWxlYXNlU2Vzc2lvbj1DLmNhKShlKSxjLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PShlLHQscik9PihjLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PUMuZGEpKGUsdCxyKSxjLl9PcnRHZXRJbnB1dE5hbWU9KGUsdCk9PihjLl9PcnRHZXRJbnB1dE5hbWU9Qy5lYSkoZSx0KSxjLl9PcnRHZXRPdXRwdXROYW1lPShlLHQpPT4oYy5fT3J0R2V0T3V0cHV0TmFtZT1DLmZhKShlLHQpLGMuX09ydEZyZWU9ZT0+KGMuX09ydEZyZWU9Qy5nYSkoZSksYy5fT3J0Q3JlYXRlVGVuc29yPShlLHQscixuLGEpPT4oYy5fT3J0Q3JlYXRlVGVuc29yPUMuaGEpKGUsdCxyLG4sYSksYy5fT3J0R2V0VGVuc29yRGF0YT0oZSx0LHIsbixhKT0+KGMuX09ydEdldFRlbnNvckRhdGE9Qy5pYSkoZSx0LHIsbixhKSxjLl9PcnRSZWxlYXNlVGVuc29yPWU9PihjLl9PcnRSZWxlYXNlVGVuc29yPUMuamEpKGUpLGMuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KGUsdCxyLG4pPT4oYy5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1DLmthKShlLHQscixuKSxjLl9PcnRBZGRSdW5Db25maWdFbnRyeT0oZSx0LHIpPT4oYy5fT3J0QWRkUnVuQ29uZmlnRW50cnk9Qy5sYSkoZSx0LHIpLGMuX09ydFJlbGVhc2VSdW5PcHRpb25zPWU9PihjLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1DLm1hKShlKSxjLl9PcnRSdW49KGUsdCxyLG4sYSxvLHMsaSk9PihjLl9PcnRSdW49Qy5uYSkoZSx0LHIsbixhLG8scyxpKSxjLl9PcnRFbmRQcm9maWxpbmc9ZT0+KGMuX09ydEVuZFByb2ZpbGluZz1DLm9hKShlKTt2YXIgZHQ9Yy5fcHRocmVhZF9zZWxmPSgpPT4oZHQ9Yy5fcHRocmVhZF9zZWxmPUMucGEpKCkscHQ9Yy5fbWFsbG9jPWU9PihwdD1jLl9tYWxsb2M9Qy5xYSkoZSk7Yy5fZnJlZT1lPT4oYy5fZnJlZT1DLnJhKShlKSxjLl9fZW1zY3JpcHRlbl90bHNfaW5pdD0oKT0+KGMuX19lbXNjcmlwdGVuX3Rsc19pbml0PUMuc2EpKCk7dmFyIGd0PWMuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PShlLHQscixuLGEsbyk9PihndD1jLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD1DLnVhKShlLHQscixuLGEsbyk7Yy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9KCk9PihjLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD1DLnZhKSgpO3ZhciBodCxtdD0oZSx0LHIsbik9PihtdD1DLndhKShlLHQscixuKSx5dD1lPT4oeXQ9Qy54YSkoZSksdnQ9Yy5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZT0+KHZ0PWMuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PUMueWEpKGUpLGJ0PWMuX19lbXNjcmlwdGVuX2NoZWNrX21haWxib3g9KCk9PihidD1jLl9fZW1zY3JpcHRlbl9jaGVja19tYWlsYm94PUMuemEpKCksd3Q9ZT0+KHd0PUMuQWEpKGUpLF90PShlLHQpPT4oX3Q9Qy5CYSkoZSx0KSxPdD0oKT0+KE90PUMuQ2EpKCksU3Q9ZT0+KFN0PUMuRGEpKGUpLEV0PWU9PihFdD1DLkVhKShlKTtmdW5jdGlvbiBBdCgpe2Z1bmN0aW9uIGUoKXtpZighaHQmJihodD0hMCxjLmNhbGxlZFJ1bj0hMCwhSCkmJihifHxoZShOKSxpKGMpLGMub25SdW50aW1lSW5pdGlhbGl6ZWQmJmMub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwhYikpe2lmKGMucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgYy5wb3N0UnVuJiYoYy5wb3N0UnVuPVtjLnBvc3RSdW5dKTtjLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIGU9Yy5wb3N0UnVuLnNoaWZ0KCk7Qi51bnNoaWZ0KGUpfWhlKEIpfX1pZighKDA8WCkpaWYoYilpKGMpLGJ8fGhlKE4pLHN0YXJ0V29ya2VyKGMpO2Vsc2V7aWYoYy5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGMucHJlUnVuJiYoYy5wcmVSdW49W2MucHJlUnVuXSk7Yy5wcmVSdW4ubGVuZ3RoOylHLnVuc2hpZnQoYy5wcmVSdW4uc2hpZnQoKSk7aGUoRyksMDxYfHwoYy5zZXRTdGF0dXM/KGMuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7Yy5zZXRTdGF0dXMoXCJcIil9KSwxKSxlKCl9KSwxKSk6ZSgpKX19aWYoYy5rZWVwUnVudGltZUFsaXZlPXEsYy53YXNtTWVtb3J5PWssYy5zdGFja0FsbG9jPUV0LGMuc3RhY2tTYXZlPU90LGMuc3RhY2tSZXN0b3JlPVN0LGMuVVRGOFRvU3RyaW5nPWZlLGMuc3RyaW5nVG9VVEY4PUFlLGMubGVuZ3RoQnl0ZXNVVEY4PVNlLGMuRXhpdFN0YXR1cz1vZSxjLlBUaHJlYWQ9Z2UsWj1mdW5jdGlvbiBlKCl7aHR8fEF0KCksaHR8fChaPWUpfSxjLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGMucHJlSW5pdCYmKGMucHJlSW5pdD1bYy5wcmVJbml0XSk7MDxjLnByZUluaXQubGVuZ3RoOyljLnByZUluaXQucG9wKCkoKTtyZXR1cm4gQXQoKSxlLnJlYWR5fSk7ZS5leHBvcnRzPW59LDkzMjooZSx0LHIpPT57dmFyIF9zY3JpcHREaXIsbj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBfX2ZpbGVuYW1lJiYoX3NjcmlwdERpcj1fc2NyaXB0RGlyfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbihlPXt9KXt2YXIgdCxuLGE9ZTthLnJlYWR5PW5ldyBQcm9taXNlKCgoZSxyKT0+e3Q9ZSxuPXJ9KSk7dmFyIG8scyxpLHU9T2JqZWN0LmFzc2lnbih7fSxhKSxjPVwiLi90aGlzLnByb2dyYW1cIixsPShlLHQpPT57dGhyb3cgdH0sZj1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LGQ9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxwPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxnPVwiXCI7aWYocCl7dmFyIGg9cigxNDcpLG09cigxNyk7Zz1kP20uZGlybmFtZShnKStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsbz0oZSx0KT0+KGU9ZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGUpOm0ubm9ybWFsaXplKGUpLGgucmVhZEZpbGVTeW5jKGUsdD92b2lkIDA6XCJ1dGY4XCIpKSxpPWU9PigoZT1vKGUsITApKS5idWZmZXJ8fChlPW5ldyBVaW50OEFycmF5KGUpKSxlKSxzPShlLHQscixuPSEwKT0+e2U9ZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGUpOm0ubm9ybWFsaXplKGUpLGgucmVhZEZpbGUoZSxuP3ZvaWQgMDpcInV0ZjhcIiwoKGUsYSk9PntlP3IoZSk6dChuP2EuYnVmZmVyOmEpfSkpfSwhYS50aGlzUHJvZ3JhbSYmMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoYz1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXFxcXFwvZyxcIi9cIikpLHByb2Nlc3MuYXJndi5zbGljZSgyKSxsPShlLHQpPT57dGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1lLHR9LGEuaW5zcGVjdD0oKT0+XCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifWVsc2UoZnx8ZCkmJihkP2c9c2VsZi5sb2NhdGlvbi5ocmVmOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKGc9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLF9zY3JpcHREaXImJihnPV9zY3JpcHREaXIpLGc9MCE9PWcuaW5kZXhPZihcImJsb2I6XCIpP2cuc3Vic3RyKDAsZy5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpcIlwiLG89ZT0+e3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKFwiR0VUXCIsZSwhMSksdC5zZW5kKG51bGwpLHQucmVzcG9uc2VUZXh0fSxkJiYoaT1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oXCJHRVRcIixlLCExKSx0LnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsdC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpfSkscz0oZSx0LHIpPT57dmFyIG49bmV3IFhNTEh0dHBSZXF1ZXN0O24ub3BlbihcIkdFVFwiLGUsITApLG4ucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixuLm9ubG9hZD0oKT0+ezIwMD09bi5zdGF0dXN8fDA9PW4uc3RhdHVzJiZuLnJlc3BvbnNlP3Qobi5yZXNwb25zZSk6cigpfSxuLm9uZXJyb3I9cixuLnNlbmQobnVsbCl9KTt2YXIgeSx2PWEucHJpbnR8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksYj1hLnByaW50RXJyfHxjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihhLHUpLHU9bnVsbCxhLnRoaXNQcm9ncmFtJiYoYz1hLnRoaXNQcm9ncmFtKSxhLnF1aXQmJihsPWEucXVpdCksYS53YXNtQmluYXJ5JiYoeT1hLndhc21CaW5hcnkpO3ZhciB3PWEubm9FeGl0UnVudGltZXx8ITA7XCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZXKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgXyxPLFMsRSxBLFQsTT0hMTtmdW5jdGlvbiBSKCl7dmFyIGU9Xy5idWZmZXI7YS5IRUFQOD1TPW5ldyBJbnQ4QXJyYXkoZSksYS5IRUFQMTY9bmV3IEludDE2QXJyYXkoZSksYS5IRUFQMzI9QT1uZXcgSW50MzJBcnJheShlKSxhLkhFQVBVOD1FPW5ldyBVaW50OEFycmF5KGUpLGEuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoZSksYS5IRUFQVTMyPVQ9bmV3IFVpbnQzMkFycmF5KGUpLGEuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGUpLGEuSEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KGUpfXZhciBGPVtdLGs9W10sQz1bXTtmdW5jdGlvbiB4KCl7dmFyIGU9YS5wcmVSdW4uc2hpZnQoKTtGLnVuc2hpZnQoZSl9dmFyIFAsRCxJPTAsVT1udWxsLEw9bnVsbDtmdW5jdGlvbiBXKGUpe3Rocm93IGEub25BYm9ydCYmYS5vbkFib3J0KGUpLGIoZT1cIkFib3J0ZWQoXCIrZStcIilcIiksTT0hMCxlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoZStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbihlKSxlfWZ1bmN0aW9uIEgoZSl7cmV0dXJuIGUuc3RhcnRzV2l0aChcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIil9aWYoIUgoUD1cIm9ydC13YXNtLndhc21cIikpe3ZhciBZPVA7UD1hLmxvY2F0ZUZpbGU/YS5sb2NhdGVGaWxlKFksZyk6ZytZfWZ1bmN0aW9uIGooZSl7aWYoZT09UCYmeSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeSk7aWYoaSlyZXR1cm4gaShlKTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1mdW5jdGlvbiB6KGUsdCxyKXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXkmJihmfHxkKSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZmV0Y2gmJiFlLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpKXJldHVybiBmZXRjaChlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKCh0PT57aWYoIXQub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrZStcIlxcJ1wiO3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKCgpPT5qKGUpKSk7aWYocylyZXR1cm4gbmV3IFByb21pc2UoKCh0LHIpPT57cyhlLChlPT50KG5ldyBVaW50OEFycmF5KGUpKSkscil9KSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCgpPT5qKGUpKSl9KGUpLnRoZW4oKGU9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCkpKS50aGVuKChlPT5lKSkudGhlbihyLChlPT57YihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK2UpLFcoZSl9KSl9ZnVuY3Rpb24gRyhlKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7ZX0pYCx0aGlzLnN0YXR1cz1lfXZhciBOPWU9Pntmb3IoOzA8ZS5sZW5ndGg7KWUuc2hpZnQoKShhKX07ZnVuY3Rpb24gQihlKXt0aGlzLnFhPWUtMjQsdGhpcy52YT1mdW5jdGlvbihlKXtUW3RoaXMucWErND4+Mj4+PjBdPWV9LHRoaXMudWE9ZnVuY3Rpb24oZSl7VFt0aGlzLnFhKzg+PjI+Pj4wXT1lfSx0aGlzLnNhPWZ1bmN0aW9uKGUsdCl7dGhpcy50YSgpLHRoaXMudmEoZSksdGhpcy51YSh0KX0sdGhpcy50YT1mdW5jdGlvbigpe1RbdGhpcy5xYSsxNj4+Mj4+PjBdPTB9fXZhciAkLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwLFY9KGUsdCxyKT0+e3ZhciBuPSh0Pj4+PTApK3I7Zm9yKHI9dDtlW3JdJiYhKHI+PW4pOykrK3I7aWYoMTY8ci10JiZlLmJ1ZmZlciYmcSlyZXR1cm4gcS5kZWNvZGUoZS5zdWJhcnJheSh0LHIpKTtmb3Iobj1cIlwiO3Q8cjspe3ZhciBhPWVbdCsrXTtpZigxMjgmYSl7dmFyIG89NjMmZVt0KytdO2lmKDE5Mj09KDIyNCZhKSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZhKTw8NnxvKTtlbHNle3ZhciBzPTYzJmVbdCsrXTs2NTUzNj4oYT0yMjQ9PSgyNDAmYSk/KDE1JmEpPDwxMnxvPDw2fHM6KDcmYSk8PDE4fG88PDEyfHM8PDZ8NjMmZVt0KytdKT9uKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpOihhLT02NTUzNixuKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGE+PjEwLDU2MzIwfDEwMjMmYSkpfX1lbHNlIG4rPVN0cmluZy5mcm9tQ2hhckNvZGUoYSl9cmV0dXJuIG59LEo9KGUsdCk9PihlPj4+PTApP1YoRSxlLHQpOlwiXCIsWD1lPT57Zm9yKHZhciB0PTAscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbj1lLmNoYXJDb2RlQXQocik7MTI3Pj1uP3QrKzoyMDQ3Pj1uP3QrPTI6NTUyOTY8PW4mJjU3MzQzPj1uPyh0Kz00LCsrcik6dCs9M31yZXR1cm4gdH0sSz0oZSx0LHIsbik9PntpZighKDA8bikpcmV0dXJuIDA7dmFyIGE9cj4+Pj0wO249cituLTE7Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDsrK28pe3ZhciBzPWUuY2hhckNvZGVBdChvKTtpZig1NTI5Njw9cyYmNTczNDM+PXMmJihzPTY1NTM2KygoMTAyMyZzKTw8MTApfDEwMjMmZS5jaGFyQ29kZUF0KCsrbykpLDEyNz49cyl7aWYocj49bilicmVhazt0W3IrKz4+PjBdPXN9ZWxzZXtpZigyMDQ3Pj1zKXtpZihyKzE+PW4pYnJlYWs7dFtyKys+Pj4wXT0xOTJ8cz4+Nn1lbHNle2lmKDY1NTM1Pj1zKXtpZihyKzI+PW4pYnJlYWs7dFtyKys+Pj4wXT0yMjR8cz4+MTJ9ZWxzZXtpZihyKzM+PW4pYnJlYWs7dFtyKys+Pj4wXT0yNDB8cz4+MTgsdFtyKys+Pj4wXT0xMjh8cz4+MTImNjN9dFtyKys+Pj4wXT0xMjh8cz4+NiY2M310W3IrKz4+PjBdPTEyOHw2MyZzfX1yZXR1cm4gdFtyPj4+MF09MCxyLWF9LFo9ZT0+MD09ZSU0JiYoMCE9ZSUxMDB8fDA9PWUlNDAwKSxRPVswLDMxLDYwLDkxLDEyMSwxNTIsMTgyLDIxMywyNDQsMjc0LDMwNSwzMzVdLGVlPVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdLHRlPWU9Pnt2YXIgdD1YKGUpKzEscj1sZSh0KTtyZXR1cm4gciYmSyhlLEUscix0KSxyfSxyZT17fSxuZT0oKT0+e2lmKCEkKXt2YXIgZSx0PXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOmN8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKGUgaW4gcmUpdm9pZCAwPT09cmVbZV0/ZGVsZXRlIHRbZV06dFtlXT1yZVtlXTt2YXIgcj1bXTtmb3IoZSBpbiB0KXIucHVzaChgJHtlfT0ke3RbZV19YCk7JD1yfXJldHVybiAkfSxhZT1bbnVsbCxbXSxbXV0sb2U9ZT0+KG9lPSgoKT0+e2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjcnlwdG8mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpcmV0dXJuIGU9PmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoZSk7aWYocCl0cnl7dmFyIGU9cigxMTMpO2lmKGUucmFuZG9tRmlsbFN5bmMpcmV0dXJuIHQ9PmUucmFuZG9tRmlsbFN5bmModCk7dmFyIHQ9ZS5yYW5kb21CeXRlcztyZXR1cm4gZT0+KGUuc2V0KHQoZS5ieXRlTGVuZ3RoKSksZSl9Y2F0Y2goZSl7fVcoXCJpbml0UmFuZG9tRGV2aWNlXCIpfSkoKSkoZSksc2U9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxpZT1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIHVlKGUsdCxyLG4pe2Z1bmN0aW9uIGEoZSx0LHIpe2ZvcihlPVwibnVtYmVyXCI9PXR5cGVvZiBlP2UudG9TdHJpbmcoKTplfHxcIlwiO2UubGVuZ3RoPHQ7KWU9clswXStlO3JldHVybiBlfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4gYShlLHQsXCIwXCIpfWZ1bmN0aW9uIHMoZSx0KXtmdW5jdGlvbiByKGUpe3JldHVybiAwPmU/LTE6MDxlPzE6MH12YXIgbjtyZXR1cm4gMD09PShuPXIoZS5nZXRGdWxsWWVhcigpLXQuZ2V0RnVsbFllYXIoKSkpJiYwPT09KG49cihlLmdldE1vbnRoKCktdC5nZXRNb250aCgpKSkmJihuPXIoZS5nZXREYXRlKCktdC5nZXREYXRlKCkpKSxufWZ1bmN0aW9uIGkoZSl7c3dpdGNoKGUuZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gZTtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gdShlKXt2YXIgdD1lLm1hO2ZvcihlPW5ldyBEYXRlKG5ldyBEYXRlKGUubmErMTkwMCwwLDEpLmdldFRpbWUoKSk7MDx0Oyl7dmFyIHI9ZS5nZXRNb250aCgpLG49KFooZS5nZXRGdWxsWWVhcigpKT9zZTppZSlbcl07aWYoISh0Pm4tZS5nZXREYXRlKCkpKXtlLnNldERhdGUoZS5nZXREYXRlKCkrdCk7YnJlYWt9dC09bi1lLmdldERhdGUoKSsxLGUuc2V0RGF0ZSgxKSwxMT5yP2Uuc2V0TW9udGgocisxKTooZS5zZXRNb250aCgwKSxlLnNldEZ1bGxZZWFyKGUuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIHI9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpKzEsMCw0KSx0PWkobmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsNCkpLHI9aShyKSwwPj1zKHQsZSk/MD49cyhyLGUpP2UuZ2V0RnVsbFllYXIoKSsxOmUuZ2V0RnVsbFllYXIoKTplLmdldEZ1bGxZZWFyKCktMX1lPj4+PTAsdD4+Pj0wLHI+Pj49MDt2YXIgYz1BWzQwKyhuPj4+PTApPj4yPj4+MF07Zm9yKHZhciBsIGluIG49e3lhOkFbbj4+Mj4+PjBdLHhhOkFbbis0Pj4yPj4+MF0sb2E6QVtuKzg+PjI+Pj4wXSxyYTpBW24rMTI+PjI+Pj4wXSxwYTpBW24rMTY+PjI+Pj4wXSxuYTpBW24rMjA+PjI+Pj4wXSxoYTpBW24rMjQ+PjI+Pj4wXSxtYTpBW24rMjg+PjI+Pj4wXSxBYTpBW24rMzI+PjI+Pj4wXSx3YTpBW24rMzY+PjI+Pj4wXSx6YTpjP0ooYyk6XCJcIn0scj1KKHIpLGM9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlyPXIucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLGNbbF0pO3ZhciBmPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksZD1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKGwgaW4gYz17XCIlYVwiOmU9PmZbZS5oYV0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOmU9PmZbZS5oYV0sXCIlYlwiOmU9PmRbZS5wYV0uc3Vic3RyaW5nKDAsMyksXCIlQlwiOmU9PmRbZS5wYV0sXCIlQ1wiOmU9Pm8oKGUubmErMTkwMCkvMTAwfDAsMiksXCIlZFwiOmU9Pm8oZS5yYSwyKSxcIiVlXCI6ZT0+YShlLnJhLDIsXCIgXCIpLFwiJWdcIjplPT51KGUpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjplPT51KGUpLFwiJUhcIjplPT5vKGUub2EsMiksXCIlSVwiOmU9PigwPT0oZT1lLm9hKT9lPTEyOjEyPGUmJihlLT0xMiksbyhlLDIpKSxcIiVqXCI6ZT0+e2Zvcih2YXIgdD0wLHI9MDtyPD1lLnBhLTE7dCs9KFooZS5uYSsxOTAwKT9zZTppZSlbcisrXSk7cmV0dXJuIG8oZS5yYSt0LDMpfSxcIiVtXCI6ZT0+byhlLnBhKzEsMiksXCIlTVwiOmU9Pm8oZS54YSwyKSxcIiVuXCI6KCk9PlwiXFxcXG5cIixcIiVwXCI6ZT0+MDw9ZS5vYSYmMTI+ZS5vYT9cIkFNXCI6XCJQTVwiLFwiJVNcIjplPT5vKGUueWEsMiksXCIldFwiOigpPT5cIlxcXFx0XCIsXCIldVwiOmU9PmUuaGF8fDcsXCIlVVwiOmU9Pm8oTWF0aC5mbG9vcigoZS5tYSs3LWUuaGEpLzcpLDIpLFwiJVZcIjplPT57dmFyIHQ9TWF0aC5mbG9vcigoZS5tYSs3LShlLmhhKzYpJTcpLzcpO2lmKDI+PShlLmhhKzM3MS1lLm1hLTIpJTcmJnQrKyx0KTUzPT10JiYoND09KHI9KGUuaGErMzcxLWUubWEpJTcpfHwzPT1yJiZaKGUubmEpfHwodD0xKSk7ZWxzZXt0PTUyO3ZhciByPShlLmhhKzctZS5tYS0xKSU3Oyg0PT1yfHw1PT1yJiZaKGUubmElNDAwLTEpKSYmdCsrfXJldHVybiBvKHQsMil9LFwiJXdcIjplPT5lLmhhLFwiJVdcIjplPT5vKE1hdGguZmxvb3IoKGUubWErNy0oZS5oYSs2KSU3KS83KSwyKSxcIiV5XCI6ZT0+KGUubmErMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOmU9PmUubmErMTkwMCxcIiV6XCI6ZT0+e3ZhciB0PTA8PShlPWUud2EpO3JldHVybiBlPU1hdGguYWJzKGUpLzYwLCh0P1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrKGUvNjAqMTAwK2UlNjApKS5zbGljZSgtNCl9LFwiJVpcIjplPT5lLnphLFwiJSVcIjooKT0+XCIlXCJ9LHI9ci5yZXBsYWNlKC8lJS9nLFwiXFxcXDBcXFxcMFwiKSxjKXIuaW5jbHVkZXMobCkmJihyPXIucmVwbGFjZShuZXcgUmVnRXhwKGwsXCJnXCIpLGNbbF0obikpKTtyZXR1cm4gbD1mdW5jdGlvbihlKXt2YXIgdD1BcnJheShYKGUpKzEpO3JldHVybiBLKGUsdCwwLHQubGVuZ3RoKSx0fShyPXIucmVwbGFjZSgvXFxcXDBcXFxcMC9nLFwiJVwiKSksbC5sZW5ndGg+dD8wOihTLnNldChsLGU+Pj4wKSxsLmxlbmd0aC0xKX12YXIgY2U9e2E6ZnVuY3Rpb24oZSx0LHIpe3Rocm93IG5ldyBCKGU+Pj49MCkuc2EodD4+PjAscj4+PjApLGV9LGU6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sSTpmdW5jdGlvbigpe30seTpmdW5jdGlvbigpe30sQTpmdW5jdGlvbigpe30sSzpmdW5jdGlvbigpe3JldHVybiAwfSxHOmZ1bmN0aW9uKCl7fSxCOmZ1bmN0aW9uKCl7fSxGOmZ1bmN0aW9uKCl7fSxnOmZ1bmN0aW9uKCl7fSx6OmZ1bmN0aW9uKCl7fSx3OmZ1bmN0aW9uKCl7fSxIOmZ1bmN0aW9uKCl7fSx4OmZ1bmN0aW9uKCl7fSxrOigpPT4hMCxuOmZ1bmN0aW9uKGUsdCxyKXtlPXQrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWU/KGU+Pj4wKSs0Mjk0OTY3Mjk2KnQ6TmFOLHI+Pj49MCxlPW5ldyBEYXRlKDFlMyplKSxBW3I+PjI+Pj4wXT1lLmdldFVUQ1NlY29uZHMoKSxBW3IrND4+Mj4+PjBdPWUuZ2V0VVRDTWludXRlcygpLEFbcis4Pj4yPj4+MF09ZS5nZXRVVENIb3VycygpLEFbcisxMj4+Mj4+PjBdPWUuZ2V0VVRDRGF0ZSgpLEFbcisxNj4+Mj4+PjBdPWUuZ2V0VVRDTW9udGgoKSxBW3IrMjA+PjI+Pj4wXT1lLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxBW3IrMjQ+PjI+Pj4wXT1lLmdldFVUQ0RheSgpLEFbcisyOD4+Mj4+PjBdPShlLmdldFRpbWUoKS1EYXRlLlVUQyhlLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwfSxvOmZ1bmN0aW9uKGUsdCxyKXtlPXQrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWU/KGU+Pj4wKSs0Mjk0OTY3Mjk2KnQ6TmFOLHI+Pj49MCxlPW5ldyBEYXRlKDFlMyplKSxBW3I+PjI+Pj4wXT1lLmdldFNlY29uZHMoKSxBW3IrND4+Mj4+PjBdPWUuZ2V0TWludXRlcygpLEFbcis4Pj4yPj4+MF09ZS5nZXRIb3VycygpLEFbcisxMj4+Mj4+PjBdPWUuZ2V0RGF0ZSgpLEFbcisxNj4+Mj4+PjBdPWUuZ2V0TW9udGgoKSxBW3IrMjA+PjI+Pj4wXT1lLmdldEZ1bGxZZWFyKCktMTkwMCxBW3IrMjQ+PjI+Pj4wXT1lLmdldERheSgpLEFbcisyOD4+Mj4+PjBdPShaKGUuZ2V0RnVsbFllYXIoKSk/UTplZSlbZS5nZXRNb250aCgpXStlLmdldERhdGUoKS0xfDAsQVtyKzM2Pj4yPj4+MF09LTYwKmUuZ2V0VGltZXpvbmVPZmZzZXQoKSx0PW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIG49bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtBW3IrMzI+PjI+Pj4wXT0wfCh0IT1uJiZlLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG4sdCkpfSxwOmZ1bmN0aW9uKGUpe2U+Pj49MDt2YXIgdD1uZXcgRGF0ZShBW2UrMjA+PjI+Pj4wXSsxOTAwLEFbZSsxNj4+Mj4+PjBdLEFbZSsxMj4+Mj4+PjBdLEFbZSs4Pj4yPj4+MF0sQVtlKzQ+PjI+Pj4wXSxBW2U+PjI+Pj4wXSwwKSxyPUFbZSszMj4+Mj4+PjBdLG49dC5nZXRUaW1lem9uZU9mZnNldCgpLGE9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxvPW5ldyBEYXRlKHQuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCkscz1NYXRoLm1pbihvLGEpO3JldHVybiAwPnI/QVtlKzMyPj4yPj4+MF09TnVtYmVyKGEhPW8mJnM9PW4pOjA8ciE9KHM9PW4pJiYoYT1NYXRoLm1heChvLGEpLHQuc2V0VGltZSh0LmdldFRpbWUoKSs2ZTQqKCgwPHI/czphKS1uKSkpLEFbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCksQVtlKzI4Pj4yPj4+MF09KFoodC5nZXRGdWxsWWVhcigpKT9ROmVlKVt0LmdldE1vbnRoKCldK3QuZ2V0RGF0ZSgpLTF8MCxBW2U+PjI+Pj4wXT10LmdldFNlY29uZHMoKSxBW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLEFbZSs4Pj4yPj4+MF09dC5nZXRIb3VycygpLEFbZSsxMj4+Mj4+PjBdPXQuZ2V0RGF0ZSgpLEFbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSxBW2UrMjA+PjI+Pj4wXT10LmdldFllYXIoKSxlPXQuZ2V0VGltZSgpLzFlMyxkZSgoRD1lLDE8PStNYXRoLmFicyhEKT8wPEQ/K01hdGguZmxvb3IoRC80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKChELSsofn5EPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKSksZT4+PjB9LGw6ZnVuY3Rpb24oKXtyZXR1cm4tNTJ9LG06ZnVuY3Rpb24oKXt9LHU6ZnVuY3Rpb24oZSx0LHIpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuKGU9ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFxcXCgoW0EtWmEteiBdKylcXFxcKSQvKSk/ZVsxXTpcIkdNVFwifXI+Pj49MDt2YXIgYT0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCksbz1uZXcgRGF0ZShhLDAsMSkscz1uZXcgRGF0ZShhLDYsMSk7YT1vLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGk9cy5nZXRUaW1lem9uZU9mZnNldCgpO1RbZT4+PjA+PjI+Pj4wXT02MCpNYXRoLm1heChhLGkpLEFbdD4+PjA+PjI+Pj4wXT1OdW1iZXIoYSE9aSksZT1uKG8pLHQ9bihzKSxlPXRlKGUpLHQ9dGUodCksaTxhPyhUW3I+PjI+Pj4wXT1lLFRbcis0Pj4yPj4+MF09dCk6KFRbcj4+Mj4+PjBdPXQsVFtyKzQ+PjI+Pj4wXT1lKX0sZDooKT0+e1coXCJcIil9LGg6ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX0sdjpmdW5jdGlvbigpe3JldHVybiA0Mjk0OTAxNzYwfSxiOigpPT5wZXJmb3JtYW5jZS5ub3coKSxKOmZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gdD4+Pj0wLEUuY29weVdpdGhpbihlPj4+MD4+PjAsdD4+PjAsdCsocj4+PjApPj4+MCl9LHQ6ZnVuY3Rpb24oZSl7ZT4+Pj0wO3ZhciB0PUUubGVuZ3RoO2lmKDQyOTQ5MDE3NjA8ZSlyZXR1cm4hMTtmb3IodmFyIHI9MTs0Pj1yO3IqPTIpe3ZhciBuPXQqKDErLjIvcik7bj1NYXRoLm1pbihuLGUrMTAwNjYzMjk2KTt2YXIgYT1NYXRoO249TWF0aC5tYXgoZSxuKTtlOnthPWEubWluLmNhbGwoYSw0Mjk0OTAxNzYwLG4rKDY1NTM2LW4lNjU1MzYpJTY1NTM2KS1fLmJ1ZmZlci5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTY7dHJ5e18uZ3JvdyhhKSxSKCk7dmFyIG89MTticmVhayBlfWNhdGNoKGUpe31vPXZvaWQgMH1pZihvKXJldHVybiEwfXJldHVybiExfSxEOmZ1bmN0aW9uKGUsdCl7ZT4+Pj0wLHQ+Pj49MDt2YXIgcj0wO3JldHVybiBuZSgpLmZvckVhY2goKGZ1bmN0aW9uKG4sYSl7dmFyIG89dCtyO2ZvcihhPVRbZSs0KmE+PjI+Pj4wXT1vLG89MDtvPG4ubGVuZ3RoOysrbylTW2ErKz4+MD4+PjBdPW4uY2hhckNvZGVBdChvKTtTW2E+PjA+Pj4wXT0wLHIrPW4ubGVuZ3RoKzF9KSksMH0sRTpmdW5jdGlvbihlLHQpe2U+Pj49MCx0Pj4+PTA7dmFyIHI9bmUoKTtUW2U+PjI+Pj4wXT1yLmxlbmd0aDt2YXIgbj0wO3JldHVybiByLmZvckVhY2goKGZ1bmN0aW9uKGUpe24rPWUubGVuZ3RoKzF9KSksVFt0Pj4yPj4+MF09biwwfSxzOmU9Pnt3fHwoYS5vbkV4aXQmJmEub25FeGl0KGUpLE09ITApLGwoZSxuZXcgRyhlKSl9LGY6KCk9PjUyLGo6ZnVuY3Rpb24oKXtyZXR1cm4gNTJ9LHE6ZnVuY3Rpb24oKXtyZXR1cm4gNzB9LGk6ZnVuY3Rpb24oZSx0LHIsbil7dD4+Pj0wLHI+Pj49MCxuPj4+PTA7Zm9yKHZhciBhPTAsbz0wO288cjtvKyspe3ZhciBzPVRbdD4+Mj4+PjBdLGk9VFt0KzQ+PjI+Pj4wXTt0Kz04O2Zvcih2YXIgdT0wO3U8aTt1Kyspe3ZhciBjPUVbcyt1Pj4+MF0sbD1hZVtlXTswPT09Y3x8MTA9PT1jPygoMT09PWU/djpiKShWKGwsMCkpLGwubGVuZ3RoPTApOmwucHVzaChjKX1hKz1pfXJldHVybiBUW24+PjI+Pj4wXT1hLDB9LHI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLG9lKEUuc3ViYXJyYXkoZT4+PjAsZSsodD4+PjApPj4+MCkpLDB9LEM6dWUsYzpmdW5jdGlvbihlLHQscixuKXtyZXR1cm4gdWUoZT4+PjAsdD4+PjAscj4+PjAsbj4+PjApfX07IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlPWUuZXhwb3J0cyxPPWU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZT0+KCk9PmUoKT4+PjAscj1lPT50PT5lKHQpPj4+MDtyZXR1cm4oZT1PYmplY3QuYXNzaWduKHt9LGUpKS5fX2Vycm5vX2xvY2F0aW9uPXQoZS5fX2Vycm5vX2xvY2F0aW9uKSxlLm1hbGxvYz1yKGUubWFsbG9jKSxlLnN0YWNrU2F2ZT10KGUuc3RhY2tTYXZlKSxlLnN0YWNrQWxsb2M9cihlLnN0YWNrQWxsb2MpLGV9KGUpLF89Ty5MLFIoKSxrLnVuc2hpZnQoTy5NKSxJLS0sYS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZhLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoSSksMD09SSYmKG51bGwhPT1VJiYoY2xlYXJJbnRlcnZhbChVKSxVPW51bGwpLEwpKXt2YXIgdD1MO0w9bnVsbCx0KCl9cmV0dXJuIGV9dmFyIHQ9e2E6Y2V9O2lmKEkrKyxhLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhJKSxhLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGEuaW5zdGFudGlhdGVXYXNtKHQsZSl9Y2F0Y2goZSl7YihcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK2UpLG4oZSl9KGZ1bmN0aW9uKGUsdCl7dmFyIHI9UDtyZXR1cm4geXx8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fEgocil8fHIuc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fHB8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP3oocixlLHQpOmZldGNoKHIse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKG49PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKG4sZSkudGhlbih0LChmdW5jdGlvbihuKXtyZXR1cm4gYihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIituKSxiKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIikseihyLGUsdCl9KSkpKX0pKHQsKGZ1bmN0aW9uKHQpe2UodC5pbnN0YW5jZSl9KSkuY2F0Y2gobil9KCksYS5fT3J0SW5pdD0oZSx0KT0+KGEuX09ydEluaXQ9Ty5OKShlLHQpLGEuX09ydEdldExhc3RFcnJvcj0oZSx0KT0+KGEuX09ydEdldExhc3RFcnJvcj1PLk8pKGUsdCksYS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9KGUsdCxyLG4sbyxzLGksdSxjLGwpPT4oYS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnM9Ty5QKShlLHQscixuLG8scyxpLHUsYyxsKSxhLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0oZSx0KT0+KGEuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPU8uUSkoZSx0KSxhLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9KGUsdCxyKT0+KGEuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT1PLlIpKGUsdCxyKSxhLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9ZT0+KGEuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1PLlMpKGUpLGEuX09ydENyZWF0ZVNlc3Npb249KGUsdCxyKT0+KGEuX09ydENyZWF0ZVNlc3Npb249Ty5UKShlLHQsciksYS5fT3J0UmVsZWFzZVNlc3Npb249ZT0+KGEuX09ydFJlbGVhc2VTZXNzaW9uPU8uVSkoZSksYS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0oZSx0LHIpPT4oYS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1PLlYpKGUsdCxyKSxhLl9PcnRHZXRJbnB1dE5hbWU9KGUsdCk9PihhLl9PcnRHZXRJbnB1dE5hbWU9Ty5XKShlLHQpLGEuX09ydEdldE91dHB1dE5hbWU9KGUsdCk9PihhLl9PcnRHZXRPdXRwdXROYW1lPU8uWCkoZSx0KSxhLl9PcnRGcmVlPWU9PihhLl9PcnRGcmVlPU8uWSkoZSksYS5fT3J0Q3JlYXRlVGVuc29yPShlLHQscixuLG8pPT4oYS5fT3J0Q3JlYXRlVGVuc29yPU8uWikoZSx0LHIsbixvKSxhLl9PcnRHZXRUZW5zb3JEYXRhPShlLHQscixuLG8pPT4oYS5fT3J0R2V0VGVuc29yRGF0YT1PLl8pKGUsdCxyLG4sbyksYS5fT3J0UmVsZWFzZVRlbnNvcj1lPT4oYS5fT3J0UmVsZWFzZVRlbnNvcj1PLiQpKGUpLGEuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KGUsdCxyLG4pPT4oYS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz1PLmFhKShlLHQscixuKSxhLl9PcnRBZGRSdW5Db25maWdFbnRyeT0oZSx0LHIpPT4oYS5fT3J0QWRkUnVuQ29uZmlnRW50cnk9Ty5iYSkoZSx0LHIpLGEuX09ydFJlbGVhc2VSdW5PcHRpb25zPWU9PihhLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1PLmNhKShlKSxhLl9PcnRSdW49KGUsdCxyLG4sbyxzLGksdSk9PihhLl9PcnRSdW49Ty5kYSkoZSx0LHIsbixvLHMsaSx1KSxhLl9PcnRFbmRQcm9maWxpbmc9ZT0+KGEuX09ydEVuZFByb2ZpbGluZz1PLmVhKShlKTt2YXIgbGU9YS5fbWFsbG9jPWU9PihsZT1hLl9tYWxsb2M9Ty5mYSkoZSk7YS5fZnJlZT1lPT4oYS5fZnJlZT1PLmdhKShlKTt2YXIgZmUsZGU9ZT0+KGRlPU8uaWEpKGUpLHBlPSgpPT4ocGU9Ty5qYSkoKSxnZT1lPT4oZ2U9Ty5rYSkoZSksaGU9ZT0+KGhlPU8ubGEpKGUpO2Z1bmN0aW9uIG1lKCl7ZnVuY3Rpb24gZSgpe2lmKCFmZSYmKGZlPSEwLGEuY2FsbGVkUnVuPSEwLCFNKSl7aWYoTihrKSx0KGEpLGEub25SdW50aW1lSW5pdGlhbGl6ZWQmJmEub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxhLnBvc3RSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGEucG9zdFJ1biYmKGEucG9zdFJ1bj1bYS5wb3N0UnVuXSk7YS5wb3N0UnVuLmxlbmd0aDspe3ZhciBlPWEucG9zdFJ1bi5zaGlmdCgpO0MudW5zaGlmdChlKX1OKEMpfX1pZighKDA8SSkpe2lmKGEucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLnByZVJ1biYmKGEucHJlUnVuPVthLnByZVJ1bl0pO2EucHJlUnVuLmxlbmd0aDspeCgpO04oRiksMDxJfHwoYS5zZXRTdGF0dXM/KGEuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7YS5zZXRTdGF0dXMoXCJcIil9KSwxKSxlKCl9KSwxKSk6ZSgpKX19aWYoYS5zdGFja0FsbG9jPWhlLGEuc3RhY2tTYXZlPXBlLGEuc3RhY2tSZXN0b3JlPWdlLGEuVVRGOFRvU3RyaW5nPUosYS5zdHJpbmdUb1VURjg9KGUsdCxyKT0+SyhlLEUsdCxyKSxhLmxlbmd0aEJ5dGVzVVRGOD1YLEw9ZnVuY3Rpb24gZSgpe2ZlfHxtZSgpLGZlfHwoTD1lKX0sYS5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLnByZUluaXQmJihhLnByZUluaXQ9W2EucHJlSW5pdF0pOzA8YS5wcmVJbml0Lmxlbmd0aDspYS5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIG1lKCksZS5yZWFkeX0pO2UuZXhwb3J0cz1ufSwxNTQ6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1cXCdcInVzZSBzdHJpY3RcIjt2YXIgZT17fSxhPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZTtpZihhKXt2YXIgcj1yZXF1aXJlKFwid29ya2VyX3RocmVhZHNcIiksdD1yLnBhcmVudFBvcnQ7dC5vbihcIm1lc3NhZ2VcIiwoZT0+b25tZXNzYWdlKHtkYXRhOmV9KSkpO3ZhciBzPXJlcXVpcmUoXCJmc1wiKTtPYmplY3QuYXNzaWduKGdsb2JhbCx7c2VsZjpnbG9iYWwscmVxdWlyZTpyZXF1aXJlLE1vZHVsZTplLGxvY2F0aW9uOntocmVmOl9fZmlsZW5hbWV9LFdvcmtlcjpyLldvcmtlcixpbXBvcnRTY3JpcHRzOmU9PigwLGV2YWwpKHMucmVhZEZpbGVTeW5jKGUsXCJ1dGY4XCIpK1wiLy8jIHNvdXJjZVVSTD1cIitlKSxwb3N0TWVzc2FnZTplPT50LnBvc3RNZXNzYWdlKGUpLHBlcmZvcm1hbmNlOmdsb2JhbC5wZXJmb3JtYW5jZXx8e25vdzpEYXRlLm5vd319KX12YXIgbz0hMSxkPWZ1bmN0aW9uKCl7dmFyIGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTthP3Mud3JpdGVTeW5jKDIsZStcIlxcXFxcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OmEsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KGEscik9Pnt2YXIgdD1lLndhc21Nb2R1bGU7cmV0dXJuIGUud2FzbU1vZHVsZT1udWxsLHIobmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKHQsYSkpfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbj8/ZX0sc2VsZi5vbm1lc3NhZ2U9ZnVuY3Rpb24gYShyKXt0cnl7aWYoXCJsb2FkXCI9PT1yLmRhdGEuY21kKXtsZXQgcz1bXTtzZWxmLm9ubWVzc2FnZT1lPT5zLnB1c2goZSksc2VsZi5zdGFydFdvcmtlcj1yPT57ZT1yLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2ZvcihsZXQgZSBvZiBzKWEoZSk7c2VsZi5vbm1lc3NhZ2U9YX0sZS53YXNtTW9kdWxlPXIuZGF0YS53YXNtTW9kdWxlO2Zvcihjb25zdCBhIG9mIHIuZGF0YS5oYW5kbGVycyllW2FdPSguLi5lKT0+e3Bvc3RNZXNzYWdlKHtjbWQ6XCJjYWxsSGFuZGxlclwiLGhhbmRsZXI6YSxhcmdzOmV9KX07aWYoZS53YXNtTWVtb3J5PXIuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiByLmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHMoci5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgdD1VUkwuY3JlYXRlT2JqZWN0VVJMKHIuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHModCksVVJMLnJldm9rZU9iamVjdFVSTCh0KX1vcnRXYXNtVGhyZWFkZWQoZSl9ZWxzZSBpZihcInJ1blwiPT09ci5kYXRhLmNtZCl7ZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQoci5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdChyLmRhdGEucHRocmVhZF9wdHIpLGUuZXN0YWJsaXNoU3RhY2tTcGFjZSgpLGUuUFRocmVhZC5yZWNlaXZlT2JqZWN0VHJhbnNmZXIoci5kYXRhKSxlLlBUaHJlYWQudGhyZWFkSW5pdFRMUygpLG98fChvPSEwKTt0cnl7ZS5pbnZva2VFbnRyeVBvaW50KHIuZGF0YS5zdGFydF9yb3V0aW5lLHIuZGF0YS5hcmcpfWNhdGNoKGUpe2lmKFwidW53aW5kXCIhPWUpdGhyb3cgZX19ZWxzZVwiY2FuY2VsXCI9PT1yLmRhdGEuY21kP2UuX3B0aHJlYWRfc2VsZigpJiZlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCgtMSk6XCJzZXRpbW1lZGlhdGVcIj09PXIuZGF0YS50YXJnZXR8fChcImNoZWNrTWFpbGJveFwiPT09ci5kYXRhLmNtZD9vJiZlLmNoZWNrTWFpbGJveCgpOnIuZGF0YS5jbWQmJihkKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIityLmRhdGEuY21kKSxkKHIuZGF0YSkpKX1jYXRjaChhKXt0aHJvdyBlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSxhfX07XFxcXG5cXCd9LDExMzplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJjcnlwdG9cIil9LDE0NzplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJmc1wiKX0sMzc6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwib3NcIil9LDE3OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9cmVxdWlyZShcInBhdGhcIil9LDc0OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9cmVxdWlyZShcInBlcmZfaG9va3NcIil9LDI2NzplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJ3b3JrZXJfdGhyZWFkc1wiKX19LHQ9e307ZnVuY3Rpb24gcihuKXt2YXIgYT10W25dO2lmKHZvaWQgMCE9PWEpcmV0dXJuIGEuZXhwb3J0czt2YXIgbz10W25dPXtleHBvcnRzOnt9fTtyZXR1cm4gZVtuXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxyKSxvLmV4cG9ydHN9KCgpPT57XCJ1c2Ugc3RyaWN0XCI7Y29uc3QgZT1yKDI1OSksdD1yKDI2Myk7c2VsZi5vbm1lc3NhZ2U9cj0+e3N3aXRjaChyLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6dHJ5eygwLHQuaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KShyLmRhdGEuaW4pLnRoZW4oKCgpPT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwifSkpLChlPT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwiLGVycjplfSkpKX1jYXRjaChlKXtwb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtd2FzbVwiLGVycjplfSl9YnJlYWs7Y2FzZVwiaW5pdC1vcnRcIjp0cnl7KDAsZS5pbml0UnVudGltZSkoci5kYXRhLmluKS50aGVuKCgoKT0+cG9zdE1lc3NhZ2Uoe3R5cGU6XCJpbml0LW9ydFwifSkpLChlPT5wb3N0TWVzc2FnZSh7dHlwZTpcImluaXQtb3J0XCIsZXJyOmV9KSkpLHBvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC1vcnRcIn0pfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiaW5pdC1vcnRcIixlcnI6ZX0pfWJyZWFrO2Nhc2VcImNyZWF0ZV9hbGxvY2F0ZVwiOnRyeXtjb25zdHttb2RlbDp0fT1yLmRhdGEuaW4sbj0oMCxlLmNyZWF0ZVNlc3Npb25BbGxvY2F0ZSkodCk7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfYWxsb2NhdGVcIixvdXQ6bn0pfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlX2FsbG9jYXRlXCIsZXJyOmV9KX1icmVhaztjYXNlXCJjcmVhdGVfZmluYWxpemVcIjp0cnl7Y29uc3R7bW9kZWxkYXRhOnQsb3B0aW9uczpufT1yLmRhdGEuaW4sYT0oMCxlLmNyZWF0ZVNlc3Npb25GaW5hbGl6ZSkodCxuKTtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZV9maW5hbGl6ZVwiLG91dDphfSl9Y2F0Y2goZSl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJjcmVhdGVfZmluYWxpemVcIixlcnI6ZX0pfWJyZWFrO2Nhc2VcImNyZWF0ZVwiOnRyeXtjb25zdHttb2RlbDp0LG9wdGlvbnM6bn09ci5kYXRhLmluLGE9KDAsZS5jcmVhdGVTZXNzaW9uKSh0LG4pO3Bvc3RNZXNzYWdlKHt0eXBlOlwiY3JlYXRlXCIsb3V0OmF9KX1jYXRjaChlKXtwb3N0TWVzc2FnZSh7dHlwZTpcImNyZWF0ZVwiLGVycjplfSl9YnJlYWs7Y2FzZVwicmVsZWFzZVwiOnRyeXtjb25zdCB0PXIuZGF0YS5pbjsoMCxlLnJlbGVhc2VTZXNzaW9uKSh0KSxwb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIn0pfWNhdGNoKGUpe3Bvc3RNZXNzYWdlKHt0eXBlOlwicmVsZWFzZVwiLGVycjplfSl9YnJlYWs7Y2FzZVwicnVuXCI6dHJ5e2NvbnN0e3Nlc3Npb25JZDp0LGlucHV0SW5kaWNlczpuLGlucHV0czphLG91dHB1dEluZGljZXM6byxvcHRpb25zOnN9PXIuZGF0YS5pbjsoMCxlLnJ1bikodCxuLGEsbyxzKS50aGVuKCh0PT57cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixvdXQ6dH0sKDAsZS5leHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycykodCkpfSksKGU9Pntwb3N0TWVzc2FnZSh7dHlwZTpcInJ1blwiLGVycjplfSl9KSl9Y2F0Y2goZSl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJydW5cIixlcnI6ZX0pfWJyZWFrO2Nhc2VcImVuZC1wcm9maWxpbmdcIjp0cnl7Y29uc3QgdD1yLmRhdGEuaW47KDAsZS5lbmRQcm9maWxpbmcpKHQpLHBvc3RNZXNzYWdlKHt0eXBlOlwiZW5kLXByb2ZpbGluZ1wifSl9Y2F0Y2goZSl7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsZXJyOmV9KX19fX0pKCl9KSgpO1xcbicsXCJXb3JrZXJcIix2b2lkIDAsdm9pZCAwKX19LDY2MTQ6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbihlLHQsbixyKXt2YXIgbz1zZWxmfHx3aW5kb3c7dHJ5e3RyeXt2YXIgaTt0cnl7aT1uZXcgby5CbG9iKFtlXSl9Y2F0Y2godCl7KGk9bmV3KG8uQmxvYkJ1aWxkZXJ8fG8uV2ViS2l0QmxvYkJ1aWxkZXJ8fG8uTW96QmxvYkJ1aWxkZXJ8fG8uTVNCbG9iQnVpbGRlcikpLmFwcGVuZChlKSxpPWkuZ2V0QmxvYigpfXZhciBzPW8uVVJMfHxvLndlYmtpdFVSTCxhPXMuY3JlYXRlT2JqZWN0VVJMKGkpLHU9bmV3IG9bdF0oYSxuKTtyZXR1cm4gcy5yZXZva2VPYmplY3RVUkwoYSksdX1jYXRjaChyKXtyZXR1cm4gbmV3IG9bdF0oXCJkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQsXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChlKSksbil9fWNhdGNoKGUpe2lmKCFyKXRocm93IEVycm9yKFwiSW5saW5lIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBuZXcgb1t0XShyLG4pfX19LDI0NDY6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO3ZhciByLG8saSxzPW4oMjEwMCksYT1zLlJlYWRlcix1PXMuV3JpdGVyLGw9cy51dGlsLGM9cy5yb290cy5kZWZhdWx0fHwocy5yb290cy5kZWZhdWx0PXt9KTtjLm9ubng9KChpPXt9KS5WZXJzaW9uPShyPXt9LChvPU9iamVjdC5jcmVhdGUocikpW3JbMF09XCJfU1RBUlRfVkVSU0lPTlwiXT0wLG9bclsxXT1cIklSX1ZFUlNJT05fMjAxN18xMF8xMFwiXT0xLG9bclsyXT1cIklSX1ZFUlNJT05fMjAxN18xMF8zMFwiXT0yLG9bclszXT1cIklSX1ZFUlNJT05fMjAxN18xMV8zXCJdPTMsb1tyWzRdPVwiSVJfVkVSU0lPTl8yMDE5XzFfMjJcIl09NCxvW3JbNV09XCJJUl9WRVJTSU9OXzIwMTlfM18xOFwiXT01LG9bcls2XT1cIklSX1ZFUlNJT05fMjAxOV85XzE5XCJdPTYsb1tyWzddPVwiSVJfVkVSU0lPTl8yMDIwXzVfOFwiXT03LG9bcls4XT1cIklSX1ZFUlNJT05fMjAyMV83XzMwXCJdPTgsb1tyWzldPVwiSVJfVkVSU0lPTlwiXT05LG8pLGkuQXR0cmlidXRlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMuZmxvYXRzPVtdLHRoaXMuaW50cz1bXSx0aGlzLnN0cmluZ3M9W10sdGhpcy50ZW5zb3JzPVtdLHRoaXMuZ3JhcGhzPVtdLHRoaXMuc3BhcnNlVGVuc29ycz1bXSx0aGlzLnR5cGVQcm90b3M9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5uYW1lPVwiXCIsZS5wcm90b3R5cGUucmVmQXR0ck5hbWU9XCJcIixlLnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIixlLnByb3RvdHlwZS50eXBlPTAsZS5wcm90b3R5cGUuZj0wLGUucHJvdG90eXBlLmk9bC5Mb25nP2wuTG9uZy5mcm9tQml0cygwLDAsITEpOjAsZS5wcm90b3R5cGUucz1sLm5ld0J1ZmZlcihbXSksZS5wcm90b3R5cGUudD1udWxsLGUucHJvdG90eXBlLmc9bnVsbCxlLnByb3RvdHlwZS5zcGFyc2VUZW5zb3I9bnVsbCxlLnByb3RvdHlwZS50cD1udWxsLGUucHJvdG90eXBlLmZsb2F0cz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuaW50cz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuc3RyaW5ncz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudGVuc29ycz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZ3JhcGhzPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5zcGFyc2VUZW5zb3JzPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS50eXBlUHJvdG9zPWwuZW1wdHlBcnJheSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5uYW1lJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwibmFtZVwiKSYmdC51aW50MzIoMTApLnN0cmluZyhlLm5hbWUpLG51bGwhPWUuZiYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImZcIikmJnQudWludDMyKDIxKS5mbG9hdChlLmYpLG51bGwhPWUuaSYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImlcIikmJnQudWludDMyKDI0KS5pbnQ2NChlLmkpLG51bGwhPWUucyYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInNcIikmJnQudWludDMyKDM0KS5ieXRlcyhlLnMpLG51bGwhPWUudCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInRcIikmJmMub25ueC5UZW5zb3JQcm90by5lbmNvZGUoZS50LHQudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPWUuZyYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImdcIikmJmMub25ueC5HcmFwaFByb3RvLmVuY29kZShlLmcsdC51aW50MzIoNTApLmZvcmsoKSkubGRlbGltKCksbnVsbCE9ZS5mbG9hdHMmJmUuZmxvYXRzLmxlbmd0aCl7dC51aW50MzIoNTgpLmZvcmsoKTtmb3IodmFyIG49MDtuPGUuZmxvYXRzLmxlbmd0aDsrK24pdC5mbG9hdChlLmZsb2F0c1tuXSk7dC5sZGVsaW0oKX1pZihudWxsIT1lLmludHMmJmUuaW50cy5sZW5ndGgpe2Zvcih0LnVpbnQzMig2NikuZm9yaygpLG49MDtuPGUuaW50cy5sZW5ndGg7KytuKXQuaW50NjQoZS5pbnRzW25dKTt0LmxkZWxpbSgpfWlmKG51bGwhPWUuc3RyaW5ncyYmZS5zdHJpbmdzLmxlbmd0aClmb3Iobj0wO248ZS5zdHJpbmdzLmxlbmd0aDsrK24pdC51aW50MzIoNzQpLmJ5dGVzKGUuc3RyaW5nc1tuXSk7aWYobnVsbCE9ZS50ZW5zb3JzJiZlLnRlbnNvcnMubGVuZ3RoKWZvcihuPTA7bjxlLnRlbnNvcnMubGVuZ3RoOysrbiljLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKGUudGVuc29yc1tuXSx0LnVpbnQzMig4MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLmdyYXBocyYmZS5ncmFwaHMubGVuZ3RoKWZvcihuPTA7bjxlLmdyYXBocy5sZW5ndGg7KytuKWMub25ueC5HcmFwaFByb3RvLmVuY29kZShlLmdyYXBoc1tuXSx0LnVpbnQzMig5MCkuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLmRvY1N0cmluZyYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvY1N0cmluZ1wiKSYmdC51aW50MzIoMTA2KS5zdHJpbmcoZS5kb2NTdHJpbmcpLG51bGwhPWUudHAmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJ0cFwiKSYmYy5vbm54LlR5cGVQcm90by5lbmNvZGUoZS50cCx0LnVpbnQzMigxMTQpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9ZS50eXBlUHJvdG9zJiZlLnR5cGVQcm90b3MubGVuZ3RoKWZvcihuPTA7bjxlLnR5cGVQcm90b3MubGVuZ3RoOysrbiljLm9ubnguVHlwZVByb3RvLmVuY29kZShlLnR5cGVQcm90b3Nbbl0sdC51aW50MzIoMTIyKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPWUudHlwZSYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInR5cGVcIikmJnQudWludDMyKDE2MCkuaW50MzIoZS50eXBlKSxudWxsIT1lLnJlZkF0dHJOYW1lJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwicmVmQXR0ck5hbWVcIikmJnQudWludDMyKDE3MCkuc3RyaW5nKGUucmVmQXR0ck5hbWUpLG51bGwhPWUuc3BhcnNlVGVuc29yJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwic3BhcnNlVGVuc29yXCIpJiZjLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZW5jb2RlKGUuc3BhcnNlVGVuc29yLHQudWludDMyKDE3OCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT1lLnNwYXJzZVRlbnNvcnMmJmUuc3BhcnNlVGVuc29ycy5sZW5ndGgpZm9yKG49MDtuPGUuc3BhcnNlVGVuc29ycy5sZW5ndGg7KytuKWMub25ueC5TcGFyc2VUZW5zb3JQcm90by5lbmNvZGUoZS5zcGFyc2VUZW5zb3JzW25dLHQudWludDMyKDE4NikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgYXx8KGU9YS5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LkF0dHJpYnV0ZVByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjE6ci5yZWZBdHRyTmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMTM6ci5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVhaztjYXNlIDIwOnIudHlwZT1lLmludDMyKCk7YnJlYWs7Y2FzZSAyOnIuZj1lLmZsb2F0KCk7YnJlYWs7Y2FzZSAzOnIuaT1lLmludDY0KCk7YnJlYWs7Y2FzZSA0OnIucz1lLmJ5dGVzKCk7YnJlYWs7Y2FzZSA1OnIudD1jLm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSA2OnIuZz1jLm9ubnguR3JhcGhQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDIyOnIuc3BhcnNlVGVuc29yPWMub25ueC5TcGFyc2VUZW5zb3JQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDE0OnIudHA9Yy5vbm54LlR5cGVQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDc6aWYoci5mbG9hdHMmJnIuZmxvYXRzLmxlbmd0aHx8KHIuZmxvYXRzPVtdKSwyPT0oNyZvKSlmb3IodmFyIGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLmZsb2F0cy5wdXNoKGUuZmxvYXQoKSk7ZWxzZSByLmZsb2F0cy5wdXNoKGUuZmxvYXQoKSk7YnJlYWs7Y2FzZSA4OmlmKHIuaW50cyYmci5pbnRzLmxlbmd0aHx8KHIuaW50cz1bXSksMj09KDcmbykpZm9yKGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLmludHMucHVzaChlLmludDY0KCkpO2Vsc2Ugci5pbnRzLnB1c2goZS5pbnQ2NCgpKTticmVhaztjYXNlIDk6ci5zdHJpbmdzJiZyLnN0cmluZ3MubGVuZ3RofHwoci5zdHJpbmdzPVtdKSxyLnN0cmluZ3MucHVzaChlLmJ5dGVzKCkpO2JyZWFrO2Nhc2UgMTA6ci50ZW5zb3JzJiZyLnRlbnNvcnMubGVuZ3RofHwoci50ZW5zb3JzPVtdKSxyLnRlbnNvcnMucHVzaChjLm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTE6ci5ncmFwaHMmJnIuZ3JhcGhzLmxlbmd0aHx8KHIuZ3JhcGhzPVtdKSxyLmdyYXBocy5wdXNoKGMub25ueC5HcmFwaFByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDIzOnIuc3BhcnNlVGVuc29ycyYmci5zcGFyc2VUZW5zb3JzLmxlbmd0aHx8KHIuc3BhcnNlVGVuc29ycz1bXSksci5zcGFyc2VUZW5zb3JzLnB1c2goYy5vbm54LlNwYXJzZVRlbnNvclByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDE1OnIudHlwZVByb3RvcyYmci50eXBlUHJvdG9zLmxlbmd0aHx8KHIudHlwZVByb3Rvcz1bXSksci50eXBlUHJvdG9zLnB1c2goYy5vbm54LlR5cGVQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGF8fChlPW5ldyBhKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYhbC5pc1N0cmluZyhlLm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5yZWZBdHRyTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpJiYhbC5pc1N0cmluZyhlLnJlZkF0dHJOYW1lKSlyZXR1cm5cInJlZkF0dHJOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWwuaXNTdHJpbmcoZS5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKXN3aXRjaChlLnR5cGUpe2RlZmF1bHQ6cmV0dXJuXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6Y2FzZSAzOmNhc2UgNDpjYXNlIDU6Y2FzZSAxMTpjYXNlIDEzOmNhc2UgNjpjYXNlIDc6Y2FzZSA4OmNhc2UgOTpjYXNlIDEwOmNhc2UgMTI6Y2FzZSAxNDp9aWYobnVsbCE9ZS5mJiZlLmhhc093blByb3BlcnR5KFwiZlwiKSYmXCJudW1iZXJcIiE9dHlwZW9mIGUuZilyZXR1cm5cImY6IG51bWJlciBleHBlY3RlZFwiO2lmKG51bGwhPWUuaSYmZS5oYXNPd25Qcm9wZXJ0eShcImlcIikmJiEobC5pc0ludGVnZXIoZS5pKXx8ZS5pJiZsLmlzSW50ZWdlcihlLmkubG93KSYmbC5pc0ludGVnZXIoZS5pLmhpZ2gpKSlyZXR1cm5cImk6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPWUucyYmZS5oYXNPd25Qcm9wZXJ0eShcInNcIikmJiEoZS5zJiZcIm51bWJlclwiPT10eXBlb2YgZS5zLmxlbmd0aHx8bC5pc1N0cmluZyhlLnMpKSlyZXR1cm5cInM6IGJ1ZmZlciBleHBlY3RlZFwiO2lmKG51bGwhPWUudCYmZS5oYXNPd25Qcm9wZXJ0eShcInRcIikmJihuPWMub25ueC5UZW5zb3JQcm90by52ZXJpZnkoZS50KSkpcmV0dXJuXCJ0LlwiK247aWYobnVsbCE9ZS5nJiZlLmhhc093blByb3BlcnR5KFwiZ1wiKSYmKG49Yy5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KGUuZykpKXJldHVyblwiZy5cIituO2lmKG51bGwhPWUuc3BhcnNlVGVuc29yJiZlLmhhc093blByb3BlcnR5KFwic3BhcnNlVGVuc29yXCIpJiYobj1jLm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KGUuc3BhcnNlVGVuc29yKSkpcmV0dXJuXCJzcGFyc2VUZW5zb3IuXCIrbjtpZihudWxsIT1lLnRwJiZlLmhhc093blByb3BlcnR5KFwidHBcIikmJihuPWMub25ueC5UeXBlUHJvdG8udmVyaWZ5KGUudHApKSlyZXR1cm5cInRwLlwiK247aWYobnVsbCE9ZS5mbG9hdHMmJmUuaGFzT3duUHJvcGVydHkoXCJmbG9hdHNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZmxvYXRzKSlyZXR1cm5cImZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHQ9MDt0PGUuZmxvYXRzLmxlbmd0aDsrK3QpaWYoXCJudW1iZXJcIiE9dHlwZW9mIGUuZmxvYXRzW3RdKXJldHVyblwiZmxvYXRzOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPWUuaW50cyYmZS5oYXNPd25Qcm9wZXJ0eShcImludHNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50cykpcmV0dXJuXCJpbnRzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmludHMubGVuZ3RoOysrdClpZighKGwuaXNJbnRlZ2VyKGUuaW50c1t0XSl8fGUuaW50c1t0XSYmbC5pc0ludGVnZXIoZS5pbnRzW3RdLmxvdykmJmwuaXNJbnRlZ2VyKGUuaW50c1t0XS5oaWdoKSkpcmV0dXJuXCJpbnRzOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPWUuc3RyaW5ncyYmZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ3NcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuc3RyaW5ncykpcmV0dXJuXCJzdHJpbmdzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnN0cmluZ3MubGVuZ3RoOysrdClpZighKGUuc3RyaW5nc1t0XSYmXCJudW1iZXJcIj09dHlwZW9mIGUuc3RyaW5nc1t0XS5sZW5ndGh8fGwuaXNTdHJpbmcoZS5zdHJpbmdzW3RdKSkpcmV0dXJuXCJzdHJpbmdzOiBidWZmZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPWUudGVuc29ycyYmZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvcnNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUudGVuc29ycykpcmV0dXJuXCJ0ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnRlbnNvcnMubGVuZ3RoOysrdClpZihuPWMub25ueC5UZW5zb3JQcm90by52ZXJpZnkoZS50ZW5zb3JzW3RdKSlyZXR1cm5cInRlbnNvcnMuXCIrbn1pZihudWxsIT1lLmdyYXBocyYmZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5ncmFwaHMpKXJldHVyblwiZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmdyYXBocy5sZW5ndGg7Kyt0KWlmKG49Yy5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KGUuZ3JhcGhzW3RdKSlyZXR1cm5cImdyYXBocy5cIitufWlmKG51bGwhPWUuc3BhcnNlVGVuc29ycyYmZS5oYXNPd25Qcm9wZXJ0eShcInNwYXJzZVRlbnNvcnNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuc3BhcnNlVGVuc29ycykpcmV0dXJuXCJzcGFyc2VUZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOysrdClpZihuPWMub25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnkoZS5zcGFyc2VUZW5zb3JzW3RdKSlyZXR1cm5cInNwYXJzZVRlbnNvcnMuXCIrbn1pZihudWxsIT1lLnR5cGVQcm90b3MmJmUuaGFzT3duUHJvcGVydHkoXCJ0eXBlUHJvdG9zXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnR5cGVQcm90b3MpKXJldHVyblwidHlwZVByb3RvczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS50eXBlUHJvdG9zLmxlbmd0aDsrK3Qpe3ZhciBuO2lmKG49Yy5vbm54LlR5cGVQcm90by52ZXJpZnkoZS50eXBlUHJvdG9zW3RdKSlyZXR1cm5cInR5cGVQcm90b3MuXCIrbn19cmV0dXJuIG51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LkF0dHJpYnV0ZVByb3RvKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguQXR0cmlidXRlUHJvdG87c3dpdGNoKG51bGwhPWUubmFtZSYmKHQubmFtZT1TdHJpbmcoZS5uYW1lKSksbnVsbCE9ZS5yZWZBdHRyTmFtZSYmKHQucmVmQXR0ck5hbWU9U3RyaW5nKGUucmVmQXR0ck5hbWUpKSxudWxsIT1lLmRvY1N0cmluZyYmKHQuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLGUudHlwZSl7ZGVmYXVsdDppZihcIm51bWJlclwiPT10eXBlb2YgZS50eXBlKXt0LnR5cGU9ZS50eXBlO2JyZWFrfWJyZWFrO2Nhc2VcIlVOREVGSU5FRFwiOmNhc2UgMDp0LnR5cGU9MDticmVhaztjYXNlXCJGTE9BVFwiOmNhc2UgMTp0LnR5cGU9MTticmVhaztjYXNlXCJJTlRcIjpjYXNlIDI6dC50eXBlPTI7YnJlYWs7Y2FzZVwiU1RSSU5HXCI6Y2FzZSAzOnQudHlwZT0zO2JyZWFrO2Nhc2VcIlRFTlNPUlwiOmNhc2UgNDp0LnR5cGU9NDticmVhaztjYXNlXCJHUkFQSFwiOmNhc2UgNTp0LnR5cGU9NTticmVhaztjYXNlXCJTUEFSU0VfVEVOU09SXCI6Y2FzZSAxMTp0LnR5cGU9MTE7YnJlYWs7Y2FzZVwiVFlQRV9QUk9UT1wiOmNhc2UgMTM6dC50eXBlPTEzO2JyZWFrO2Nhc2VcIkZMT0FUU1wiOmNhc2UgNjp0LnR5cGU9NjticmVhaztjYXNlXCJJTlRTXCI6Y2FzZSA3OnQudHlwZT03O2JyZWFrO2Nhc2VcIlNUUklOR1NcIjpjYXNlIDg6dC50eXBlPTg7YnJlYWs7Y2FzZVwiVEVOU09SU1wiOmNhc2UgOTp0LnR5cGU9OTticmVhaztjYXNlXCJHUkFQSFNcIjpjYXNlIDEwOnQudHlwZT0xMDticmVhaztjYXNlXCJTUEFSU0VfVEVOU09SU1wiOmNhc2UgMTI6dC50eXBlPTEyO2JyZWFrO2Nhc2VcIlRZUEVfUFJPVE9TXCI6Y2FzZSAxNDp0LnR5cGU9MTR9aWYobnVsbCE9ZS5mJiYodC5mPU51bWJlcihlLmYpKSxudWxsIT1lLmkmJihsLkxvbmc/KHQuaT1sLkxvbmcuZnJvbVZhbHVlKGUuaSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmk/dC5pPXBhcnNlSW50KGUuaSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuaT90Lmk9ZS5pOlwib2JqZWN0XCI9PXR5cGVvZiBlLmkmJih0Lmk9bmV3IGwuTG9uZ0JpdHMoZS5pLmxvdz4+PjAsZS5pLmhpZ2g+Pj4wKS50b051bWJlcigpKSksbnVsbCE9ZS5zJiYoXCJzdHJpbmdcIj09dHlwZW9mIGUucz9sLmJhc2U2NC5kZWNvZGUoZS5zLHQucz1sLm5ld0J1ZmZlcihsLmJhc2U2NC5sZW5ndGgoZS5zKSksMCk6ZS5zLmxlbmd0aD49MCYmKHQucz1lLnMpKSxudWxsIT1lLnQpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnQpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udDogb2JqZWN0IGV4cGVjdGVkXCIpO3QudD1jLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLnQpfWlmKG51bGwhPWUuZyl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuZyl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5nOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5nPWMub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3QoZS5nKX1pZihudWxsIT1lLnNwYXJzZVRlbnNvcil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuc3BhcnNlVGVuc29yKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnNwYXJzZVRlbnNvcjogb2JqZWN0IGV4cGVjdGVkXCIpO3Quc3BhcnNlVGVuc29yPWMub25ueC5TcGFyc2VUZW5zb3JQcm90by5mcm9tT2JqZWN0KGUuc3BhcnNlVGVuc29yKX1pZihudWxsIT1lLnRwKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS50cCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50cDogb2JqZWN0IGV4cGVjdGVkXCIpO3QudHA9Yy5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KGUudHApfWlmKGUuZmxvYXRzKXtpZighQXJyYXkuaXNBcnJheShlLmZsb2F0cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZmxvYXRzOiBhcnJheSBleHBlY3RlZFwiKTt0LmZsb2F0cz1bXTtmb3IodmFyIG49MDtuPGUuZmxvYXRzLmxlbmd0aDsrK24pdC5mbG9hdHNbbl09TnVtYmVyKGUuZmxvYXRzW25dKX1pZihlLmludHMpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50cykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uaW50czogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuaW50cz1bXSxuPTA7bjxlLmludHMubGVuZ3RoOysrbilsLkxvbmc/KHQuaW50c1tuXT1sLkxvbmcuZnJvbVZhbHVlKGUuaW50c1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmludHNbbl0/dC5pbnRzW25dPXBhcnNlSW50KGUuaW50c1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuaW50c1tuXT90LmludHNbbl09ZS5pbnRzW25dOlwib2JqZWN0XCI9PXR5cGVvZiBlLmludHNbbl0mJih0LmludHNbbl09bmV3IGwuTG9uZ0JpdHMoZS5pbnRzW25dLmxvdz4+PjAsZS5pbnRzW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZihlLnN0cmluZ3Mpe2lmKCFBcnJheS5pc0FycmF5KGUuc3RyaW5ncykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uc3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuc3RyaW5ncz1bXSxuPTA7bjxlLnN0cmluZ3MubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgZS5zdHJpbmdzW25dP2wuYmFzZTY0LmRlY29kZShlLnN0cmluZ3Nbbl0sdC5zdHJpbmdzW25dPWwubmV3QnVmZmVyKGwuYmFzZTY0Lmxlbmd0aChlLnN0cmluZ3Nbbl0pKSwwKTplLnN0cmluZ3Nbbl0ubGVuZ3RoPj0wJiYodC5zdHJpbmdzW25dPWUuc3RyaW5nc1tuXSl9aWYoZS50ZW5zb3JzKXtpZighQXJyYXkuaXNBcnJheShlLnRlbnNvcnMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnRlbnNvcnM9W10sbj0wO248ZS50ZW5zb3JzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnRlbnNvcnNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udGVuc29yczogb2JqZWN0IGV4cGVjdGVkXCIpO3QudGVuc29yc1tuXT1jLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLnRlbnNvcnNbbl0pfX1pZihlLmdyYXBocyl7aWYoIUFycmF5LmlzQXJyYXkoZS5ncmFwaHMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmdyYXBoczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuZ3JhcGhzPVtdLG49MDtuPGUuZ3JhcGhzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmdyYXBoc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IG9iamVjdCBleHBlY3RlZFwiKTt0LmdyYXBoc1tuXT1jLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KGUuZ3JhcGhzW25dKX19aWYoZS5zcGFyc2VUZW5zb3JzKXtpZighQXJyYXkuaXNBcnJheShlLnNwYXJzZVRlbnNvcnMpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnNwYXJzZVRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnNwYXJzZVRlbnNvcnM9W10sbj0wO248ZS5zcGFyc2VUZW5zb3JzLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnNwYXJzZVRlbnNvcnNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uc3BhcnNlVGVuc29yczogb2JqZWN0IGV4cGVjdGVkXCIpO3Quc3BhcnNlVGVuc29yc1tuXT1jLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLnNwYXJzZVRlbnNvcnNbbl0pfX1pZihlLnR5cGVQcm90b3Mpe2lmKCFBcnJheS5pc0FycmF5KGUudHlwZVByb3RvcykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udHlwZVByb3RvczogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQudHlwZVByb3Rvcz1bXSxuPTA7bjxlLnR5cGVQcm90b3MubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUudHlwZVByb3Rvc1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by50eXBlUHJvdG9zOiBvYmplY3QgZXhwZWN0ZWRcIik7dC50eXBlUHJvdG9zW25dPWMub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChlLnR5cGVQcm90b3Nbbl0pfX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZigodC5hcnJheXN8fHQuZGVmYXVsdHMpJiYobi5mbG9hdHM9W10sbi5pbnRzPVtdLG4uc3RyaW5ncz1bXSxuLnRlbnNvcnM9W10sbi5ncmFwaHM9W10sbi50eXBlUHJvdG9zPVtdLG4uc3BhcnNlVGVuc29ycz1bXSksdC5kZWZhdWx0cyl7aWYobi5uYW1lPVwiXCIsbi5mPTAsbC5Mb25nKXt2YXIgcj1uZXcgbC5Mb25nKDAsMCwhMSk7bi5pPXQubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOnQubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLmk9dC5sb25ncz09PVN0cmluZz9cIjBcIjowO3QuYnl0ZXM9PT1TdHJpbmc/bi5zPVwiXCI6KG4ucz1bXSx0LmJ5dGVzIT09QXJyYXkmJihuLnM9bC5uZXdCdWZmZXIobi5zKSkpLG4udD1udWxsLG4uZz1udWxsLG4uZG9jU3RyaW5nPVwiXCIsbi50cD1udWxsLG4udHlwZT10LmVudW1zPT09U3RyaW5nP1wiVU5ERUZJTkVEXCI6MCxuLnJlZkF0dHJOYW1lPVwiXCIsbi5zcGFyc2VUZW5zb3I9bnVsbH1pZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPWUubmFtZSksbnVsbCE9ZS5mJiZlLmhhc093blByb3BlcnR5KFwiZlwiKSYmKG4uZj10Lmpzb24mJiFpc0Zpbml0ZShlLmYpP1N0cmluZyhlLmYpOmUuZiksbnVsbCE9ZS5pJiZlLmhhc093blByb3BlcnR5KFwiaVwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBlLmk/bi5pPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuaSk6ZS5pOm4uaT10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmkpOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5pLmxvdz4+PjAsZS5pLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuaSksbnVsbCE9ZS5zJiZlLmhhc093blByb3BlcnR5KFwic1wiKSYmKG4ucz10LmJ5dGVzPT09U3RyaW5nP2wuYmFzZTY0LmVuY29kZShlLnMsMCxlLnMubGVuZ3RoKTp0LmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5zKTplLnMpLG51bGwhPWUudCYmZS5oYXNPd25Qcm9wZXJ0eShcInRcIikmJihuLnQ9Yy5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUudCx0KSksbnVsbCE9ZS5nJiZlLmhhc093blByb3BlcnR5KFwiZ1wiKSYmKG4uZz1jLm9ubnguR3JhcGhQcm90by50b09iamVjdChlLmcsdCkpLGUuZmxvYXRzJiZlLmZsb2F0cy5sZW5ndGgpe24uZmxvYXRzPVtdO2Zvcih2YXIgbz0wO288ZS5mbG9hdHMubGVuZ3RoOysrbyluLmZsb2F0c1tvXT10Lmpzb24mJiFpc0Zpbml0ZShlLmZsb2F0c1tvXSk/U3RyaW5nKGUuZmxvYXRzW29dKTplLmZsb2F0c1tvXX1pZihlLmludHMmJmUuaW50cy5sZW5ndGgpZm9yKG4uaW50cz1bXSxvPTA7bzxlLmludHMubGVuZ3RoOysrbylcIm51bWJlclwiPT10eXBlb2YgZS5pbnRzW29dP24uaW50c1tvXT10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLmludHNbb10pOmUuaW50c1tvXTpuLmludHNbb109dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS5pbnRzW29dKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUuaW50c1tvXS5sb3c+Pj4wLGUuaW50c1tvXS5oaWdoPj4+MCkudG9OdW1iZXIoKTplLmludHNbb107aWYoZS5zdHJpbmdzJiZlLnN0cmluZ3MubGVuZ3RoKWZvcihuLnN0cmluZ3M9W10sbz0wO288ZS5zdHJpbmdzLmxlbmd0aDsrK28pbi5zdHJpbmdzW29dPXQuYnl0ZXM9PT1TdHJpbmc/bC5iYXNlNjQuZW5jb2RlKGUuc3RyaW5nc1tvXSwwLGUuc3RyaW5nc1tvXS5sZW5ndGgpOnQuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLnN0cmluZ3Nbb10pOmUuc3RyaW5nc1tvXTtpZihlLnRlbnNvcnMmJmUudGVuc29ycy5sZW5ndGgpZm9yKG4udGVuc29ycz1bXSxvPTA7bzxlLnRlbnNvcnMubGVuZ3RoOysrbyluLnRlbnNvcnNbb109Yy5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUudGVuc29yc1tvXSx0KTtpZihlLmdyYXBocyYmZS5ncmFwaHMubGVuZ3RoKWZvcihuLmdyYXBocz1bXSxvPTA7bzxlLmdyYXBocy5sZW5ndGg7KytvKW4uZ3JhcGhzW29dPWMub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KGUuZ3JhcGhzW29dLHQpO2lmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLG51bGwhPWUudHAmJmUuaGFzT3duUHJvcGVydHkoXCJ0cFwiKSYmKG4udHA9Yy5vbm54LlR5cGVQcm90by50b09iamVjdChlLnRwLHQpKSxlLnR5cGVQcm90b3MmJmUudHlwZVByb3Rvcy5sZW5ndGgpZm9yKG4udHlwZVByb3Rvcz1bXSxvPTA7bzxlLnR5cGVQcm90b3MubGVuZ3RoOysrbyluLnR5cGVQcm90b3Nbb109Yy5vbm54LlR5cGVQcm90by50b09iamVjdChlLnR5cGVQcm90b3Nbb10sdCk7aWYobnVsbCE9ZS50eXBlJiZlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSYmKG4udHlwZT10LmVudW1zPT09U3RyaW5nP3ZvaWQgMD09PWMub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW2UudHlwZV0/ZS50eXBlOmMub25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW2UudHlwZV06ZS50eXBlKSxudWxsIT1lLnJlZkF0dHJOYW1lJiZlLmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikmJihuLnJlZkF0dHJOYW1lPWUucmVmQXR0ck5hbWUpLG51bGwhPWUuc3BhcnNlVGVuc29yJiZlLmhhc093blByb3BlcnR5KFwic3BhcnNlVGVuc29yXCIpJiYobi5zcGFyc2VUZW5zb3I9Yy5vbm54LlNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0KGUuc3BhcnNlVGVuc29yLHQpKSxlLnNwYXJzZVRlbnNvcnMmJmUuc3BhcnNlVGVuc29ycy5sZW5ndGgpZm9yKG4uc3BhcnNlVGVuc29ycz1bXSxvPTA7bzxlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOysrbyluLnNwYXJzZVRlbnNvcnNbb109Yy5vbm54LlNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0KGUuc3BhcnNlVGVuc29yc1tvXSx0KTtyZXR1cm4gbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxzLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5BdHRyaWJ1dGVQcm90b1wifSxlLkF0dHJpYnV0ZVR5cGU9ZnVuY3Rpb24oKXt2YXIgZT17fSx0PU9iamVjdC5jcmVhdGUoZSk7cmV0dXJuIHRbZVswXT1cIlVOREVGSU5FRFwiXT0wLHRbZVsxXT1cIkZMT0FUXCJdPTEsdFtlWzJdPVwiSU5UXCJdPTIsdFtlWzNdPVwiU1RSSU5HXCJdPTMsdFtlWzRdPVwiVEVOU09SXCJdPTQsdFtlWzVdPVwiR1JBUEhcIl09NSx0W2VbMTFdPVwiU1BBUlNFX1RFTlNPUlwiXT0xMSx0W2VbMTNdPVwiVFlQRV9QUk9UT1wiXT0xMyx0W2VbNl09XCJGTE9BVFNcIl09Nix0W2VbN109XCJJTlRTXCJdPTcsdFtlWzhdPVwiU1RSSU5HU1wiXT04LHRbZVs5XT1cIlRFTlNPUlNcIl09OSx0W2VbMTBdPVwiR1JBUEhTXCJdPTEwLHRbZVsxMl09XCJTUEFSU0VfVEVOU09SU1wiXT0xMix0W2VbMTRdPVwiVFlQRV9QUk9UT1NcIl09MTQsdH0oKSxlfSgpLGkuVmFsdWVJbmZvUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUubmFtZT1cIlwiLGUucHJvdG90eXBlLnR5cGU9bnVsbCxlLnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIixlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUubmFtZSYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcIm5hbWVcIikmJnQudWludDMyKDEwKS5zdHJpbmcoZS5uYW1lKSxudWxsIT1lLnR5cGUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJ0eXBlXCIpJiZjLm9ubnguVHlwZVByb3RvLmVuY29kZShlLnR5cGUsdC51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9ZS5kb2NTdHJpbmcmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkb2NTdHJpbmdcIikmJnQudWludDMyKDI2KS5zdHJpbmcoZS5kb2NTdHJpbmcpLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIGF8fChlPWEuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5WYWx1ZUluZm9Qcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpyLm5hbWU9ZS5zdHJpbmcoKTticmVhaztjYXNlIDI6ci50eXBlPWMub25ueC5UeXBlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOnIuZG9jU3RyaW5nPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGF8fChlPW5ldyBhKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYhbC5pc1N0cmluZyhlLm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS50eXBlJiZlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSl7dmFyIHQ9Yy5vbm54LlR5cGVQcm90by52ZXJpZnkoZS50eXBlKTtpZih0KXJldHVyblwidHlwZS5cIit0fXJldHVybiBudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWwuaXNTdHJpbmcoZS5kb2NTdHJpbmcpP1wiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5WYWx1ZUluZm9Qcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlZhbHVlSW5mb1Byb3RvO2lmKG51bGwhPWUubmFtZSYmKHQubmFtZT1TdHJpbmcoZS5uYW1lKSksbnVsbCE9ZS50eXBlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS50eXBlKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlZhbHVlSW5mb1Byb3RvLnR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTt0LnR5cGU9Yy5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KGUudHlwZSl9cmV0dXJuIG51bGwhPWUuZG9jU3RyaW5nJiYodC5kb2NTdHJpbmc9U3RyaW5nKGUuZG9jU3RyaW5nKSksdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtyZXR1cm4gdC5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4udHlwZT1udWxsLG4uZG9jU3RyaW5nPVwiXCIpLG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9ZS5uYW1lKSxudWxsIT1lLnR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpJiYobi50eXBlPWMub25ueC5UeXBlUHJvdG8udG9PYmplY3QoZS50eXBlLHQpKSxudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPWUuZG9jU3RyaW5nKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLHMudXRpbC50b0pTT05PcHRpb25zKX0sZS5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54LlZhbHVlSW5mb1Byb3RvXCJ9LGV9KCksaS5Ob2RlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMuaW5wdXQ9W10sdGhpcy5vdXRwdXQ9W10sdGhpcy5hdHRyaWJ1dGU9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5pbnB1dD1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUub3V0cHV0PWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5uYW1lPVwiXCIsZS5wcm90b3R5cGUub3BUeXBlPVwiXCIsZS5wcm90b3R5cGUuZG9tYWluPVwiXCIsZS5wcm90b3R5cGUuYXR0cmlidXRlPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5kb2NTdHJpbmc9XCJcIixlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5pbnB1dCYmZS5pbnB1dC5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLmlucHV0Lmxlbmd0aDsrK24pdC51aW50MzIoMTApLnN0cmluZyhlLmlucHV0W25dKTtpZihudWxsIT1lLm91dHB1dCYmZS5vdXRwdXQubGVuZ3RoKWZvcihuPTA7bjxlLm91dHB1dC5sZW5ndGg7KytuKXQudWludDMyKDE4KS5zdHJpbmcoZS5vdXRwdXRbbl0pO2lmKG51bGwhPWUubmFtZSYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcIm5hbWVcIikmJnQudWludDMyKDI2KS5zdHJpbmcoZS5uYW1lKSxudWxsIT1lLm9wVHlwZSYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcIm9wVHlwZVwiKSYmdC51aW50MzIoMzQpLnN0cmluZyhlLm9wVHlwZSksbnVsbCE9ZS5hdHRyaWJ1dGUmJmUuYXR0cmlidXRlLmxlbmd0aClmb3Iobj0wO248ZS5hdHRyaWJ1dGUubGVuZ3RoOysrbiljLm9ubnguQXR0cmlidXRlUHJvdG8uZW5jb2RlKGUuYXR0cmlidXRlW25dLHQudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiBudWxsIT1lLmRvY1N0cmluZyYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvY1N0cmluZ1wiKSYmdC51aW50MzIoNTApLnN0cmluZyhlLmRvY1N0cmluZyksbnVsbCE9ZS5kb21haW4mJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkb21haW5cIikmJnQudWludDMyKDU4KS5zdHJpbmcoZS5kb21haW4pLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIGF8fChlPWEuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5Ob2RlUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5pbnB1dCYmci5pbnB1dC5sZW5ndGh8fChyLmlucHV0PVtdKSxyLmlucHV0LnB1c2goZS5zdHJpbmcoKSk7YnJlYWs7Y2FzZSAyOnIub3V0cHV0JiZyLm91dHB1dC5sZW5ndGh8fChyLm91dHB1dD1bXSksci5vdXRwdXQucHVzaChlLnN0cmluZygpKTticmVhaztjYXNlIDM6ci5uYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSA0OnIub3BUeXBlPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSA3OnIuZG9tYWluPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSA1OnIuYXR0cmlidXRlJiZyLmF0dHJpYnV0ZS5sZW5ndGh8fChyLmF0dHJpYnV0ZT1bXSksci5hdHRyaWJ1dGUucHVzaChjLm9ubnguQXR0cmlidXRlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgNjpyLmRvY1N0cmluZz1lLnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBhfHwoZT1uZXcgYShlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5pbnB1dCYmZS5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKXtpZighQXJyYXkuaXNBcnJheShlLmlucHV0KSlyZXR1cm5cImlucHV0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgdD0wO3Q8ZS5pbnB1dC5sZW5ndGg7Kyt0KWlmKCFsLmlzU3RyaW5nKGUuaW5wdXRbdF0pKXJldHVyblwiaW5wdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9ZS5vdXRwdXQmJmUuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KGUub3V0cHV0KSlyZXR1cm5cIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5vdXRwdXQubGVuZ3RoOysrdClpZighbC5pc1N0cmluZyhlLm91dHB1dFt0XSkpcmV0dXJuXCJvdXRwdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWwuaXNTdHJpbmcoZS5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUub3BUeXBlJiZlLmhhc093blByb3BlcnR5KFwib3BUeXBlXCIpJiYhbC5pc1N0cmluZyhlLm9wVHlwZSkpcmV0dXJuXCJvcFR5cGU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUuZG9tYWluJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYhbC5pc1N0cmluZyhlLmRvbWFpbikpcmV0dXJuXCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUuYXR0cmlidXRlJiZlLmhhc093blByb3BlcnR5KFwiYXR0cmlidXRlXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmF0dHJpYnV0ZSkpcmV0dXJuXCJhdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUuYXR0cmlidXRlLmxlbmd0aDsrK3Qpe3ZhciBuPWMub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkoZS5hdHRyaWJ1dGVbdF0pO2lmKG4pcmV0dXJuXCJhdHRyaWJ1dGUuXCIrbn19cmV0dXJuIG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhbC5pc1N0cmluZyhlLmRvY1N0cmluZyk/XCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54Lk5vZGVQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54Lk5vZGVQcm90bztpZihlLmlucHV0KXtpZighQXJyYXkuaXNBcnJheShlLmlucHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCIpO3QuaW5wdXQ9W107Zm9yKHZhciBuPTA7bjxlLmlucHV0Lmxlbmd0aDsrK24pdC5pbnB1dFtuXT1TdHJpbmcoZS5pbnB1dFtuXSl9aWYoZS5vdXRwdXQpe2lmKCFBcnJheS5pc0FycmF5KGUub3V0cHV0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5vdXRwdXQ9W10sbj0wO248ZS5vdXRwdXQubGVuZ3RoOysrbil0Lm91dHB1dFtuXT1TdHJpbmcoZS5vdXRwdXRbbl0pfWlmKG51bGwhPWUubmFtZSYmKHQubmFtZT1TdHJpbmcoZS5uYW1lKSksbnVsbCE9ZS5vcFR5cGUmJih0Lm9wVHlwZT1TdHJpbmcoZS5vcFR5cGUpKSxudWxsIT1lLmRvbWFpbiYmKHQuZG9tYWluPVN0cmluZyhlLmRvbWFpbikpLGUuYXR0cmlidXRlKXtpZighQXJyYXkuaXNBcnJheShlLmF0dHJpYnV0ZSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLmF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuYXR0cmlidXRlPVtdLG49MDtuPGUuYXR0cmlidXRlLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmF0dHJpYnV0ZVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Ob2RlUHJvdG8uYXR0cmlidXRlOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5hdHRyaWJ1dGVbbl09Yy5vbm54LkF0dHJpYnV0ZVByb3RvLmZyb21PYmplY3QoZS5hdHRyaWJ1dGVbbl0pfX1yZXR1cm4gbnVsbCE9ZS5kb2NTdHJpbmcmJih0LmRvY1N0cmluZz1TdHJpbmcoZS5kb2NTdHJpbmcpKSx0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O2lmKCh0LmFycmF5c3x8dC5kZWZhdWx0cykmJihuLmlucHV0PVtdLG4ub3V0cHV0PVtdLG4uYXR0cmlidXRlPVtdKSx0LmRlZmF1bHRzJiYobi5uYW1lPVwiXCIsbi5vcFR5cGU9XCJcIixuLmRvY1N0cmluZz1cIlwiLG4uZG9tYWluPVwiXCIpLGUuaW5wdXQmJmUuaW5wdXQubGVuZ3RoKXtuLmlucHV0PVtdO2Zvcih2YXIgcj0wO3I8ZS5pbnB1dC5sZW5ndGg7KytyKW4uaW5wdXRbcl09ZS5pbnB1dFtyXX1pZihlLm91dHB1dCYmZS5vdXRwdXQubGVuZ3RoKWZvcihuLm91dHB1dD1bXSxyPTA7cjxlLm91dHB1dC5sZW5ndGg7KytyKW4ub3V0cHV0W3JdPWUub3V0cHV0W3JdO2lmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJihuLm5hbWU9ZS5uYW1lKSxudWxsIT1lLm9wVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSYmKG4ub3BUeXBlPWUub3BUeXBlKSxlLmF0dHJpYnV0ZSYmZS5hdHRyaWJ1dGUubGVuZ3RoKWZvcihuLmF0dHJpYnV0ZT1bXSxyPTA7cjxlLmF0dHJpYnV0ZS5sZW5ndGg7KytyKW4uYXR0cmlidXRlW3JdPWMub25ueC5BdHRyaWJ1dGVQcm90by50b09iamVjdChlLmF0dHJpYnV0ZVtyXSx0KTtyZXR1cm4gbnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz1lLmRvY1N0cmluZyksbnVsbCE9ZS5kb21haW4mJmUuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikmJihuLmRvbWFpbj1lLmRvbWFpbiksbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxzLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5Ob2RlUHJvdG9cIn0sZX0oKSxpLlRyYWluaW5nSW5mb1Byb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLmluaXRpYWxpemF0aW9uQmluZGluZz1bXSx0aGlzLnVwZGF0ZUJpbmRpbmc9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5pbml0aWFsaXphdGlvbj1udWxsLGUucHJvdG90eXBlLmFsZ29yaXRobT1udWxsLGUucHJvdG90eXBlLmluaXRpYWxpemF0aW9uQmluZGluZz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudXBkYXRlQmluZGluZz1sLmVtcHR5QXJyYXksZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe2lmKHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuaW5pdGlhbGl6YXRpb24mJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJpbml0aWFsaXphdGlvblwiKSYmYy5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKGUuaW5pdGlhbGl6YXRpb24sdC51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCksbnVsbCE9ZS5hbGdvcml0aG0mJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJhbGdvcml0aG1cIikmJmMub25ueC5HcmFwaFByb3RvLmVuY29kZShlLmFsZ29yaXRobSx0LnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT1lLmluaXRpYWxpemF0aW9uQmluZGluZyYmZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOysrbiljLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoZS5pbml0aWFsaXphdGlvbkJpbmRpbmdbbl0sdC51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS51cGRhdGVCaW5kaW5nJiZlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoKWZvcihuPTA7bjxlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOysrbiljLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoZS51cGRhdGVCaW5kaW5nW25dLHQudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO3JldHVybiB0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBhfHwoZT1hLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguVHJhaW5pbmdJbmZvUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5pbml0aWFsaXphdGlvbj1jLm9ubnguR3JhcGhQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDI6ci5hbGdvcml0aG09Yy5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSAzOnIuaW5pdGlhbGl6YXRpb25CaW5kaW5nJiZyLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGh8fChyLmluaXRpYWxpemF0aW9uQmluZGluZz1bXSksci5pbml0aWFsaXphdGlvbkJpbmRpbmcucHVzaChjLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSA0OnIudXBkYXRlQmluZGluZyYmci51cGRhdGVCaW5kaW5nLmxlbmd0aHx8KHIudXBkYXRlQmluZGluZz1bXSksci51cGRhdGVCaW5kaW5nLnB1c2goYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBhfHwoZT1uZXcgYShlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5pbml0aWFsaXphdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImluaXRpYWxpemF0aW9uXCIpJiYobj1jLm9ubnguR3JhcGhQcm90by52ZXJpZnkoZS5pbml0aWFsaXphdGlvbikpKXJldHVyblwiaW5pdGlhbGl6YXRpb24uXCIrbjtpZihudWxsIT1lLmFsZ29yaXRobSYmZS5oYXNPd25Qcm9wZXJ0eShcImFsZ29yaXRobVwiKSYmKG49Yy5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KGUuYWxnb3JpdGhtKSkpcmV0dXJuXCJhbGdvcml0aG0uXCIrbjtpZihudWxsIT1lLmluaXRpYWxpemF0aW9uQmluZGluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImluaXRpYWxpemF0aW9uQmluZGluZ1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbml0aWFsaXphdGlvbkJpbmRpbmcpKXJldHVyblwiaW5pdGlhbGl6YXRpb25CaW5kaW5nOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgdD0wO3Q8ZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOysrdClpZihuPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShlLmluaXRpYWxpemF0aW9uQmluZGluZ1t0XSkpcmV0dXJuXCJpbml0aWFsaXphdGlvbkJpbmRpbmcuXCIrbn1pZihudWxsIT1lLnVwZGF0ZUJpbmRpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJ1cGRhdGVCaW5kaW5nXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnVwZGF0ZUJpbmRpbmcpKXJldHVyblwidXBkYXRlQmluZGluZzogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS51cGRhdGVCaW5kaW5nLmxlbmd0aDsrK3Qpe3ZhciBuO2lmKG49Yy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KGUudXBkYXRlQmluZGluZ1t0XSkpcmV0dXJuXCJ1cGRhdGVCaW5kaW5nLlwiK259fXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UcmFpbmluZ0luZm9Qcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlRyYWluaW5nSW5mb1Byb3RvO2lmKG51bGwhPWUuaW5pdGlhbGl6YXRpb24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmluaXRpYWxpemF0aW9uKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmluaXRpYWxpemF0aW9uOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5pbml0aWFsaXphdGlvbj1jLm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KGUuaW5pdGlhbGl6YXRpb24pfWlmKG51bGwhPWUuYWxnb3JpdGhtKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5hbGdvcml0aG0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uYWxnb3JpdGhtOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5hbGdvcml0aG09Yy5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChlLmFsZ29yaXRobSl9aWYoZS5pbml0aWFsaXphdGlvbkJpbmRpbmcpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UcmFpbmluZ0luZm9Qcm90by5pbml0aWFsaXphdGlvbkJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCIpO3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nPVtdO2Zvcih2YXIgbj0wO248ZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmluaXRpYWxpemF0aW9uQmluZGluZzogb2JqZWN0IGV4cGVjdGVkXCIpO3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nW25dPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoZS5pbml0aWFsaXphdGlvbkJpbmRpbmdbbl0pfX1pZihlLnVwZGF0ZUJpbmRpbmcpe2lmKCFBcnJheS5pc0FycmF5KGUudXBkYXRlQmluZGluZykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udXBkYXRlQmluZGluZzogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQudXBkYXRlQmluZGluZz1bXSxuPTA7bjxlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUudXBkYXRlQmluZGluZ1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UcmFpbmluZ0luZm9Qcm90by51cGRhdGVCaW5kaW5nOiBvYmplY3QgZXhwZWN0ZWRcIik7dC51cGRhdGVCaW5kaW5nW25dPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoZS51cGRhdGVCaW5kaW5nW25dKX19cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYoKHQuYXJyYXlzfHx0LmRlZmF1bHRzKSYmKG4uaW5pdGlhbGl6YXRpb25CaW5kaW5nPVtdLG4udXBkYXRlQmluZGluZz1bXSksdC5kZWZhdWx0cyYmKG4uaW5pdGlhbGl6YXRpb249bnVsbCxuLmFsZ29yaXRobT1udWxsKSxudWxsIT1lLmluaXRpYWxpemF0aW9uJiZlLmhhc093blByb3BlcnR5KFwiaW5pdGlhbGl6YXRpb25cIikmJihuLmluaXRpYWxpemF0aW9uPWMub25ueC5HcmFwaFByb3RvLnRvT2JqZWN0KGUuaW5pdGlhbGl6YXRpb24sdCkpLG51bGwhPWUuYWxnb3JpdGhtJiZlLmhhc093blByb3BlcnR5KFwiYWxnb3JpdGhtXCIpJiYobi5hbGdvcml0aG09Yy5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QoZS5hbGdvcml0aG0sdCkpLGUuaW5pdGlhbGl6YXRpb25CaW5kaW5nJiZlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGgpe24uaW5pdGlhbGl6YXRpb25CaW5kaW5nPVtdO2Zvcih2YXIgcj0wO3I8ZS5pbml0aWFsaXphdGlvbkJpbmRpbmcubGVuZ3RoOysrciluLmluaXRpYWxpemF0aW9uQmluZGluZ1tyXT1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by50b09iamVjdChlLmluaXRpYWxpemF0aW9uQmluZGluZ1tyXSx0KX1pZihlLnVwZGF0ZUJpbmRpbmcmJmUudXBkYXRlQmluZGluZy5sZW5ndGgpZm9yKG4udXBkYXRlQmluZGluZz1bXSxyPTA7cjxlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOysrciluLnVwZGF0ZUJpbmRpbmdbcl09Yy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QoZS51cGRhdGVCaW5kaW5nW3JdLHQpO3JldHVybiBufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLHMudXRpbC50b0pTT05PcHRpb25zKX0sZS5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54LlRyYWluaW5nSW5mb1Byb3RvXCJ9LGV9KCksaS5Nb2RlbFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLm9wc2V0SW1wb3J0PVtdLHRoaXMubWV0YWRhdGFQcm9wcz1bXSx0aGlzLnRyYWluaW5nSW5mbz1bXSx0aGlzLmZ1bmN0aW9ucz1bXSxlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLmlyVmVyc2lvbj1sLkxvbmc/bC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCxlLnByb3RvdHlwZS5vcHNldEltcG9ydD1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUucHJvZHVjZXJOYW1lPVwiXCIsZS5wcm90b3R5cGUucHJvZHVjZXJWZXJzaW9uPVwiXCIsZS5wcm90b3R5cGUuZG9tYWluPVwiXCIsZS5wcm90b3R5cGUubW9kZWxWZXJzaW9uPWwuTG9uZz9sLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLGUucHJvdG90eXBlLmdyYXBoPW51bGwsZS5wcm90b3R5cGUubWV0YWRhdGFQcm9wcz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudHJhaW5pbmdJbmZvPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5mdW5jdGlvbnM9bC5lbXB0eUFycmF5LGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmlyVmVyc2lvbiYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImlyVmVyc2lvblwiKSYmdC51aW50MzIoOCkuaW50NjQoZS5pclZlcnNpb24pLG51bGwhPWUucHJvZHVjZXJOYW1lJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwicHJvZHVjZXJOYW1lXCIpJiZ0LnVpbnQzMigxOCkuc3RyaW5nKGUucHJvZHVjZXJOYW1lKSxudWxsIT1lLnByb2R1Y2VyVmVyc2lvbiYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInByb2R1Y2VyVmVyc2lvblwiKSYmdC51aW50MzIoMjYpLnN0cmluZyhlLnByb2R1Y2VyVmVyc2lvbiksbnVsbCE9ZS5kb21haW4mJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkb21haW5cIikmJnQudWludDMyKDM0KS5zdHJpbmcoZS5kb21haW4pLG51bGwhPWUubW9kZWxWZXJzaW9uJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwibW9kZWxWZXJzaW9uXCIpJiZ0LnVpbnQzMig0MCkuaW50NjQoZS5tb2RlbFZlcnNpb24pLG51bGwhPWUuZG9jU3RyaW5nJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZG9jU3RyaW5nXCIpJiZ0LnVpbnQzMig1MCkuc3RyaW5nKGUuZG9jU3RyaW5nKSxudWxsIT1lLmdyYXBoJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZ3JhcGhcIikmJmMub25ueC5HcmFwaFByb3RvLmVuY29kZShlLmdyYXBoLHQudWludDMyKDU4KS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPWUub3BzZXRJbXBvcnQmJmUub3BzZXRJbXBvcnQubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5vcHNldEltcG9ydC5sZW5ndGg7KytuKWMub25ueC5PcGVyYXRvclNldElkUHJvdG8uZW5jb2RlKGUub3BzZXRJbXBvcnRbbl0sdC51aW50MzIoNjYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS5tZXRhZGF0YVByb3BzJiZlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKWZvcihuPTA7bjxlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbiljLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUoZS5tZXRhZGF0YVByb3BzW25dLHQudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLnRyYWluaW5nSW5mbyYmZS50cmFpbmluZ0luZm8ubGVuZ3RoKWZvcihuPTA7bjxlLnRyYWluaW5nSW5mby5sZW5ndGg7KytuKWMub25ueC5UcmFpbmluZ0luZm9Qcm90by5lbmNvZGUoZS50cmFpbmluZ0luZm9bbl0sdC51aW50MzIoMTYyKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPWUuZnVuY3Rpb25zJiZlLmZ1bmN0aW9ucy5sZW5ndGgpZm9yKG49MDtuPGUuZnVuY3Rpb25zLmxlbmd0aDsrK24pYy5vbm54LkZ1bmN0aW9uUHJvdG8uZW5jb2RlKGUuZnVuY3Rpb25zW25dLHQudWludDMyKDIwMikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgYXx8KGU9YS5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54Lk1vZGVsUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5pclZlcnNpb249ZS5pbnQ2NCgpO2JyZWFrO2Nhc2UgODpyLm9wc2V0SW1wb3J0JiZyLm9wc2V0SW1wb3J0Lmxlbmd0aHx8KHIub3BzZXRJbXBvcnQ9W10pLHIub3BzZXRJbXBvcnQucHVzaChjLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDI6ci5wcm9kdWNlck5hbWU9ZS5zdHJpbmcoKTticmVhaztjYXNlIDM6ci5wcm9kdWNlclZlcnNpb249ZS5zdHJpbmcoKTticmVhaztjYXNlIDQ6ci5kb21haW49ZS5zdHJpbmcoKTticmVhaztjYXNlIDU6ci5tb2RlbFZlcnNpb249ZS5pbnQ2NCgpO2JyZWFrO2Nhc2UgNjpyLmRvY1N0cmluZz1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNzpyLmdyYXBoPWMub25ueC5HcmFwaFByb3RvLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgMTQ6ci5tZXRhZGF0YVByb3BzJiZyLm1ldGFkYXRhUHJvcHMubGVuZ3RofHwoci5tZXRhZGF0YVByb3BzPVtdKSxyLm1ldGFkYXRhUHJvcHMucHVzaChjLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAyMDpyLnRyYWluaW5nSW5mbyYmci50cmFpbmluZ0luZm8ubGVuZ3RofHwoci50cmFpbmluZ0luZm89W10pLHIudHJhaW5pbmdJbmZvLnB1c2goYy5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDI1OnIuZnVuY3Rpb25zJiZyLmZ1bmN0aW9ucy5sZW5ndGh8fChyLmZ1bmN0aW9ucz1bXSksci5mdW5jdGlvbnMucHVzaChjLm9ubnguRnVuY3Rpb25Qcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGF8fChlPW5ldyBhKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmlyVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImlyVmVyc2lvblwiKSYmIShsLmlzSW50ZWdlcihlLmlyVmVyc2lvbil8fGUuaXJWZXJzaW9uJiZsLmlzSW50ZWdlcihlLmlyVmVyc2lvbi5sb3cpJiZsLmlzSW50ZWdlcihlLmlyVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJpclZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPWUub3BzZXRJbXBvcnQmJmUuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5vcHNldEltcG9ydCkpcmV0dXJuXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodmFyIHQ9MDt0PGUub3BzZXRJbXBvcnQubGVuZ3RoOysrdClpZihuPWMub25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5KGUub3BzZXRJbXBvcnRbdF0pKXJldHVyblwib3BzZXRJbXBvcnQuXCIrbn1pZihudWxsIT1lLnByb2R1Y2VyTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSYmIWwuaXNTdHJpbmcoZS5wcm9kdWNlck5hbWUpKXJldHVyblwicHJvZHVjZXJOYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnByb2R1Y2VyVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmIWwuaXNTdHJpbmcoZS5wcm9kdWNlclZlcnNpb24pKXJldHVyblwicHJvZHVjZXJWZXJzaW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmIWwuaXNTdHJpbmcoZS5kb21haW4pKXJldHVyblwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLm1vZGVsVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSYmIShsLmlzSW50ZWdlcihlLm1vZGVsVmVyc2lvbil8fGUubW9kZWxWZXJzaW9uJiZsLmlzSW50ZWdlcihlLm1vZGVsVmVyc2lvbi5sb3cpJiZsLmlzSW50ZWdlcihlLm1vZGVsVmVyc2lvbi5oaWdoKSkpcmV0dXJuXCJtb2RlbFZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO2lmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhbC5pc1N0cmluZyhlLmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUuZ3JhcGgmJmUuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSYmKG49Yy5vbm54LkdyYXBoUHJvdG8udmVyaWZ5KGUuZ3JhcGgpKSlyZXR1cm5cImdyYXBoLlwiK247aWYobnVsbCE9ZS5tZXRhZGF0YVByb3BzJiZlLmhhc093blByb3BlcnR5KFwibWV0YWRhdGFQcm9wc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5tZXRhZGF0YVByb3BzKSlyZXR1cm5cIm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUubWV0YWRhdGFQcm9wcy5sZW5ndGg7Kyt0KWlmKG49Yy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KGUubWV0YWRhdGFQcm9wc1t0XSkpcmV0dXJuXCJtZXRhZGF0YVByb3BzLlwiK259aWYobnVsbCE9ZS50cmFpbmluZ0luZm8mJmUuaGFzT3duUHJvcGVydHkoXCJ0cmFpbmluZ0luZm9cIikpe2lmKCFBcnJheS5pc0FycmF5KGUudHJhaW5pbmdJbmZvKSlyZXR1cm5cInRyYWluaW5nSW5mbzogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS50cmFpbmluZ0luZm8ubGVuZ3RoOysrdClpZihuPWMub25ueC5UcmFpbmluZ0luZm9Qcm90by52ZXJpZnkoZS50cmFpbmluZ0luZm9bdF0pKXJldHVyblwidHJhaW5pbmdJbmZvLlwiK259aWYobnVsbCE9ZS5mdW5jdGlvbnMmJmUuaGFzT3duUHJvcGVydHkoXCJmdW5jdGlvbnNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZnVuY3Rpb25zKSlyZXR1cm5cImZ1bmN0aW9uczogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5mdW5jdGlvbnMubGVuZ3RoOysrdCl7dmFyIG47aWYobj1jLm9ubnguRnVuY3Rpb25Qcm90by52ZXJpZnkoZS5mdW5jdGlvbnNbdF0pKXJldHVyblwiZnVuY3Rpb25zLlwiK259fXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5Nb2RlbFByb3RvKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguTW9kZWxQcm90bztpZihudWxsIT1lLmlyVmVyc2lvbiYmKGwuTG9uZz8odC5pclZlcnNpb249bC5Mb25nLmZyb21WYWx1ZShlLmlyVmVyc2lvbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmlyVmVyc2lvbj90LmlyVmVyc2lvbj1wYXJzZUludChlLmlyVmVyc2lvbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuaXJWZXJzaW9uP3QuaXJWZXJzaW9uPWUuaXJWZXJzaW9uOlwib2JqZWN0XCI9PXR5cGVvZiBlLmlyVmVyc2lvbiYmKHQuaXJWZXJzaW9uPW5ldyBsLkxvbmdCaXRzKGUuaXJWZXJzaW9uLmxvdz4+PjAsZS5pclZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCkpKSxlLm9wc2V0SW1wb3J0KXtpZighQXJyYXkuaXNBcnJheShlLm9wc2V0SW1wb3J0KSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiKTt0Lm9wc2V0SW1wb3J0PVtdO2Zvcih2YXIgbj0wO248ZS5vcHNldEltcG9ydC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5vcHNldEltcG9ydFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm9wc2V0SW1wb3J0OiBvYmplY3QgZXhwZWN0ZWRcIik7dC5vcHNldEltcG9ydFtuXT1jLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmZyb21PYmplY3QoZS5vcHNldEltcG9ydFtuXSl9fWlmKG51bGwhPWUucHJvZHVjZXJOYW1lJiYodC5wcm9kdWNlck5hbWU9U3RyaW5nKGUucHJvZHVjZXJOYW1lKSksbnVsbCE9ZS5wcm9kdWNlclZlcnNpb24mJih0LnByb2R1Y2VyVmVyc2lvbj1TdHJpbmcoZS5wcm9kdWNlclZlcnNpb24pKSxudWxsIT1lLmRvbWFpbiYmKHQuZG9tYWluPVN0cmluZyhlLmRvbWFpbikpLG51bGwhPWUubW9kZWxWZXJzaW9uJiYobC5Mb25nPyh0Lm1vZGVsVmVyc2lvbj1sLkxvbmcuZnJvbVZhbHVlKGUubW9kZWxWZXJzaW9uKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIGUubW9kZWxWZXJzaW9uP3QubW9kZWxWZXJzaW9uPXBhcnNlSW50KGUubW9kZWxWZXJzaW9uLDEwKTpcIm51bWJlclwiPT10eXBlb2YgZS5tb2RlbFZlcnNpb24/dC5tb2RlbFZlcnNpb249ZS5tb2RlbFZlcnNpb246XCJvYmplY3RcIj09dHlwZW9mIGUubW9kZWxWZXJzaW9uJiYodC5tb2RlbFZlcnNpb249bmV3IGwuTG9uZ0JpdHMoZS5tb2RlbFZlcnNpb24ubG93Pj4+MCxlLm1vZGVsVmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPWUuZG9jU3RyaW5nJiYodC5kb2NTdHJpbmc9U3RyaW5nKGUuZG9jU3RyaW5nKSksbnVsbCE9ZS5ncmFwaCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuZ3JhcGgpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5ncmFwaDogb2JqZWN0IGV4cGVjdGVkXCIpO3QuZ3JhcGg9Yy5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChlLmdyYXBoKX1pZihlLm1ldGFkYXRhUHJvcHMpe2lmKCFBcnJheS5pc0FycmF5KGUubWV0YWRhdGFQcm9wcykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5tZXRhZGF0YVByb3BzOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5tZXRhZGF0YVByb3BzPVtdLG49MDtuPGUubWV0YWRhdGFQcm9wcy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5tZXRhZGF0YVByb3BzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogb2JqZWN0IGV4cGVjdGVkXCIpO3QubWV0YWRhdGFQcm9wc1tuXT1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KGUubWV0YWRhdGFQcm9wc1tuXSl9fWlmKGUudHJhaW5pbmdJbmZvKXtpZighQXJyYXkuaXNBcnJheShlLnRyYWluaW5nSW5mbykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by50cmFpbmluZ0luZm86IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnRyYWluaW5nSW5mbz1bXSxuPTA7bjxlLnRyYWluaW5nSW5mby5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS50cmFpbmluZ0luZm9bbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by50cmFpbmluZ0luZm86IG9iamVjdCBleHBlY3RlZFwiKTt0LnRyYWluaW5nSW5mb1tuXT1jLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uZnJvbU9iamVjdChlLnRyYWluaW5nSW5mb1tuXSl9fWlmKGUuZnVuY3Rpb25zKXtpZighQXJyYXkuaXNBcnJheShlLmZ1bmN0aW9ucykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5mdW5jdGlvbnM6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmZ1bmN0aW9ucz1bXSxuPTA7bjxlLmZ1bmN0aW9ucy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5mdW5jdGlvbnNbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5mdW5jdGlvbnM6IG9iamVjdCBleHBlY3RlZFwiKTt0LmZ1bmN0aW9uc1tuXT1jLm9ubnguRnVuY3Rpb25Qcm90by5mcm9tT2JqZWN0KGUuZnVuY3Rpb25zW25dKX19cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYoKHQuYXJyYXlzfHx0LmRlZmF1bHRzKSYmKG4ub3BzZXRJbXBvcnQ9W10sbi5tZXRhZGF0YVByb3BzPVtdLG4udHJhaW5pbmdJbmZvPVtdLG4uZnVuY3Rpb25zPVtdKSx0LmRlZmF1bHRzKXtpZihsLkxvbmcpe3ZhciByPW5ldyBsLkxvbmcoMCwwLCExKTtuLmlyVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTp0LmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi5pclZlcnNpb249dC5sb25ncz09PVN0cmluZz9cIjBcIjowO24ucHJvZHVjZXJOYW1lPVwiXCIsbi5wcm9kdWNlclZlcnNpb249XCJcIixuLmRvbWFpbj1cIlwiLGwuTG9uZz8ocj1uZXcgbC5Mb25nKDAsMCwhMSksbi5tb2RlbFZlcnNpb249dC5sb25ncz09PVN0cmluZz9yLnRvU3RyaW5nKCk6dC5sb25ncz09PU51bWJlcj9yLnRvTnVtYmVyKCk6cik6bi5tb2RlbFZlcnNpb249dC5sb25ncz09PVN0cmluZz9cIjBcIjowLG4uZG9jU3RyaW5nPVwiXCIsbi5ncmFwaD1udWxsfWlmKG51bGwhPWUuaXJWZXJzaW9uJiZlLmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIGUuaXJWZXJzaW9uP24uaXJWZXJzaW9uPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuaXJWZXJzaW9uKTplLmlyVmVyc2lvbjpuLmlyVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmlyVmVyc2lvbik6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLmlyVmVyc2lvbi5sb3c+Pj4wLGUuaXJWZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuaXJWZXJzaW9uKSxudWxsIT1lLnByb2R1Y2VyTmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyTmFtZVwiKSYmKG4ucHJvZHVjZXJOYW1lPWUucHJvZHVjZXJOYW1lKSxudWxsIT1lLnByb2R1Y2VyVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInByb2R1Y2VyVmVyc2lvblwiKSYmKG4ucHJvZHVjZXJWZXJzaW9uPWUucHJvZHVjZXJWZXJzaW9uKSxudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmKG4uZG9tYWluPWUuZG9tYWluKSxudWxsIT1lLm1vZGVsVmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcIm1vZGVsVmVyc2lvblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBlLm1vZGVsVmVyc2lvbj9uLm1vZGVsVmVyc2lvbj10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLm1vZGVsVmVyc2lvbik6ZS5tb2RlbFZlcnNpb246bi5tb2RlbFZlcnNpb249dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS5tb2RlbFZlcnNpb24pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5tb2RlbFZlcnNpb24ubG93Pj4+MCxlLm1vZGVsVmVyc2lvbi5oaWdoPj4+MCkudG9OdW1iZXIoKTplLm1vZGVsVmVyc2lvbiksbnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz1lLmRvY1N0cmluZyksbnVsbCE9ZS5ncmFwaCYmZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpJiYobi5ncmFwaD1jLm9ubnguR3JhcGhQcm90by50b09iamVjdChlLmdyYXBoLHQpKSxlLm9wc2V0SW1wb3J0JiZlLm9wc2V0SW1wb3J0Lmxlbmd0aCl7bi5vcHNldEltcG9ydD1bXTtmb3IodmFyIG89MDtvPGUub3BzZXRJbXBvcnQubGVuZ3RoOysrbyluLm9wc2V0SW1wb3J0W29dPWMub25ueC5PcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QoZS5vcHNldEltcG9ydFtvXSx0KX1pZihlLm1ldGFkYXRhUHJvcHMmJmUubWV0YWRhdGFQcm9wcy5sZW5ndGgpZm9yKG4ubWV0YWRhdGFQcm9wcz1bXSxvPTA7bzxlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOysrbyluLm1ldGFkYXRhUHJvcHNbb109Yy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QoZS5tZXRhZGF0YVByb3BzW29dLHQpO2lmKGUudHJhaW5pbmdJbmZvJiZlLnRyYWluaW5nSW5mby5sZW5ndGgpZm9yKG4udHJhaW5pbmdJbmZvPVtdLG89MDtvPGUudHJhaW5pbmdJbmZvLmxlbmd0aDsrK28pbi50cmFpbmluZ0luZm9bb109Yy5vbm54LlRyYWluaW5nSW5mb1Byb3RvLnRvT2JqZWN0KGUudHJhaW5pbmdJbmZvW29dLHQpO2lmKGUuZnVuY3Rpb25zJiZlLmZ1bmN0aW9ucy5sZW5ndGgpZm9yKG4uZnVuY3Rpb25zPVtdLG89MDtvPGUuZnVuY3Rpb25zLmxlbmd0aDsrK28pbi5mdW5jdGlvbnNbb109Yy5vbm54LkZ1bmN0aW9uUHJvdG8udG9PYmplY3QoZS5mdW5jdGlvbnNbb10sdCk7cmV0dXJuIG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMscy51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguTW9kZWxQcm90b1wifSxlfSgpLGkuU3RyaW5nU3RyaW5nRW50cnlQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5rZXk9XCJcIixlLnByb3RvdHlwZS52YWx1ZT1cIlwiLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5rZXkmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJrZXlcIikmJnQudWludDMyKDEwKS5zdHJpbmcoZS5rZXkpLG51bGwhPWUudmFsdWUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJ2YWx1ZVwiKSYmdC51aW50MzIoMTgpLnN0cmluZyhlLnZhbHVlKSx0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBhfHwoZT1hLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTpyLmtleT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMjpyLnZhbHVlPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGF8fChlPW5ldyBhKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWU/XCJvYmplY3QgZXhwZWN0ZWRcIjpudWxsIT1lLmtleSYmZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmIWwuaXNTdHJpbmcoZS5rZXkpP1wia2V5OiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsIT1lLnZhbHVlJiZlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJiFsLmlzU3RyaW5nKGUudmFsdWUpP1widmFsdWU6IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvO3JldHVybiBudWxsIT1lLmtleSYmKHQua2V5PVN0cmluZyhlLmtleSkpLG51bGwhPWUudmFsdWUmJih0LnZhbHVlPVN0cmluZyhlLnZhbHVlKSksdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtyZXR1cm4gdC5kZWZhdWx0cyYmKG4ua2V5PVwiXCIsbi52YWx1ZT1cIlwiKSxudWxsIT1lLmtleSYmZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSYmKG4ua2V5PWUua2V5KSxudWxsIT1lLnZhbHVlJiZlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikmJihuLnZhbHVlPWUudmFsdWUpLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMscy51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1wifSxlfSgpLGkuVGVuc29yQW5ub3RhdGlvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUudGVuc29yTmFtZT1cIlwiLGUucHJvdG90eXBlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9bC5lbXB0eUFycmF5LGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLnRlbnNvck5hbWUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJ0ZW5zb3JOYW1lXCIpJiZ0LnVpbnQzMigxMCkuc3RyaW5nKGUudGVuc29yTmFtZSksbnVsbCE9ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzJiZlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK24pYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSx0LnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgYXx8KGU9YS5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlRlbnNvckFubm90YXRpb247ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci50ZW5zb3JOYW1lPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAyOnIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aHx8KHIucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXSksci5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLnB1c2goYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBhfHwoZT1uZXcgYShlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS50ZW5zb3JOYW1lJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmIWwuaXNTdHJpbmcoZS50ZW5zb3JOYW1lKSlyZXR1cm5cInRlbnNvck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmZS5oYXNPd25Qcm9wZXJ0eShcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcykpcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgdD0wO3Q8ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK3Qpe3ZhciBuPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbdF0pO2lmKG4pcmV0dXJuXCJxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlwiK259fXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UZW5zb3JBbm5vdGF0aW9uKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguVGVuc29yQW5ub3RhdGlvbjtpZihudWxsIT1lLnRlbnNvck5hbWUmJih0LnRlbnNvck5hbWU9U3RyaW5nKGUudGVuc29yTmFtZSkpLGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyl7aWYoIUFycmF5LmlzQXJyYXkoZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IGFycmF5IGV4cGVjdGVkXCIpO3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcz1bXTtmb3IodmFyIG49MDtuPGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvckFubm90YXRpb24ucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogb2JqZWN0IGV4cGVjdGVkXCIpO3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXT1jLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tuXSl9fXJldHVybiB0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O2lmKCh0LmFycmF5c3x8dC5kZWZhdWx0cykmJihuLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM9W10pLHQuZGVmYXVsdHMmJihuLnRlbnNvck5hbWU9XCJcIiksbnVsbCE9ZS50ZW5zb3JOYW1lJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yTmFtZVwiKSYmKG4udGVuc29yTmFtZT1lLnRlbnNvck5hbWUpLGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyYmZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aCl7bi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzPVtdO2Zvcih2YXIgcj0wO3I8ZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsrK3Ipbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW3JdPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KGUucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tyXSx0KX1yZXR1cm4gbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxzLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5UZW5zb3JBbm5vdGF0aW9uXCJ9LGV9KCksaS5HcmFwaFByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLm5vZGU9W10sdGhpcy5pbml0aWFsaXplcj1bXSx0aGlzLnNwYXJzZUluaXRpYWxpemVyPVtdLHRoaXMuaW5wdXQ9W10sdGhpcy5vdXRwdXQ9W10sdGhpcy52YWx1ZUluZm89W10sdGhpcy5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUubm9kZT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUubmFtZT1cIlwiLGUucHJvdG90eXBlLmluaXRpYWxpemVyPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5zcGFyc2VJbml0aWFsaXplcj1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsZS5wcm90b3R5cGUuaW5wdXQ9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLm91dHB1dD1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudmFsdWVJbmZvPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPWwuZW1wdHlBcnJheSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5ub2RlJiZlLm5vZGUubGVuZ3RoKWZvcih2YXIgbj0wO248ZS5ub2RlLmxlbmd0aDsrK24pYy5vbm54Lk5vZGVQcm90by5lbmNvZGUoZS5ub2RlW25dLHQudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPWUubmFtZSYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcIm5hbWVcIikmJnQudWludDMyKDE4KS5zdHJpbmcoZS5uYW1lKSxudWxsIT1lLmluaXRpYWxpemVyJiZlLmluaXRpYWxpemVyLmxlbmd0aClmb3Iobj0wO248ZS5pbml0aWFsaXplci5sZW5ndGg7KytuKWMub25ueC5UZW5zb3JQcm90by5lbmNvZGUoZS5pbml0aWFsaXplcltuXSx0LnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLmRvY1N0cmluZyYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvY1N0cmluZ1wiKSYmdC51aW50MzIoODIpLnN0cmluZyhlLmRvY1N0cmluZyksbnVsbCE9ZS5pbnB1dCYmZS5pbnB1dC5sZW5ndGgpZm9yKG49MDtuPGUuaW5wdXQubGVuZ3RoOysrbiljLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKGUuaW5wdXRbbl0sdC51aW50MzIoOTApLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS5vdXRwdXQmJmUub3V0cHV0Lmxlbmd0aClmb3Iobj0wO248ZS5vdXRwdXQubGVuZ3RoOysrbiljLm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKGUub3V0cHV0W25dLHQudWludDMyKDk4KS5mb3JrKCkpLmxkZWxpbSgpO2lmKG51bGwhPWUudmFsdWVJbmZvJiZlLnZhbHVlSW5mby5sZW5ndGgpZm9yKG49MDtuPGUudmFsdWVJbmZvLmxlbmd0aDsrK24pYy5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZShlLnZhbHVlSW5mb1tuXSx0LnVpbnQzMigxMDYpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuPTA7bjxlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrbiljLm9ubnguVGVuc29yQW5ub3RhdGlvbi5lbmNvZGUoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dLHQudWludDMyKDExNCkuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLnNwYXJzZUluaXRpYWxpemVyJiZlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aClmb3Iobj0wO248ZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7KytuKWMub25ueC5TcGFyc2VUZW5zb3JQcm90by5lbmNvZGUoZS5zcGFyc2VJbml0aWFsaXplcltuXSx0LnVpbnQzMigxMjIpLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIGF8fChlPWEuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5HcmFwaFByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIubm9kZSYmci5ub2RlLmxlbmd0aHx8KHIubm9kZT1bXSksci5ub2RlLnB1c2goYy5vbm54Lk5vZGVQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAyOnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNTpyLmluaXRpYWxpemVyJiZyLmluaXRpYWxpemVyLmxlbmd0aHx8KHIuaW5pdGlhbGl6ZXI9W10pLHIuaW5pdGlhbGl6ZXIucHVzaChjLm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTU6ci5zcGFyc2VJbml0aWFsaXplciYmci5zcGFyc2VJbml0aWFsaXplci5sZW5ndGh8fChyLnNwYXJzZUluaXRpYWxpemVyPVtdKSxyLnNwYXJzZUluaXRpYWxpemVyLnB1c2goYy5vbm54LlNwYXJzZVRlbnNvclByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDEwOnIuZG9jU3RyaW5nPWUuc3RyaW5nKCk7YnJlYWs7Y2FzZSAxMTpyLmlucHV0JiZyLmlucHV0Lmxlbmd0aHx8KHIuaW5wdXQ9W10pLHIuaW5wdXQucHVzaChjLm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgMTI6ci5vdXRwdXQmJnIub3V0cHV0Lmxlbmd0aHx8KHIub3V0cHV0PVtdKSxyLm91dHB1dC5wdXNoKGMub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxMzpyLnZhbHVlSW5mbyYmci52YWx1ZUluZm8ubGVuZ3RofHwoci52YWx1ZUluZm89W10pLHIudmFsdWVJbmZvLnB1c2goYy5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDE0OnIucXVhbnRpemF0aW9uQW5ub3RhdGlvbiYmci5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aHx8KHIucXVhbnRpemF0aW9uQW5ub3RhdGlvbj1bXSksci5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLnB1c2goYy5vbm54LlRlbnNvckFubm90YXRpb24uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBhfHwoZT1uZXcgYShlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5ub2RlJiZlLmhhc093blByb3BlcnR5KFwibm9kZVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5ub2RlKSlyZXR1cm5cIm5vZGU6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciB0PTA7dDxlLm5vZGUubGVuZ3RoOysrdClpZihuPWMub25ueC5Ob2RlUHJvdG8udmVyaWZ5KGUubm9kZVt0XSkpcmV0dXJuXCJub2RlLlwiK259aWYobnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmIWwuaXNTdHJpbmcoZS5uYW1lKSlyZXR1cm5cIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUuaW5pdGlhbGl6ZXImJmUuaGFzT3duUHJvcGVydHkoXCJpbml0aWFsaXplclwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbml0aWFsaXplcikpcmV0dXJuXCJpbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5pbml0aWFsaXplci5sZW5ndGg7Kyt0KWlmKG49Yy5vbm54LlRlbnNvclByb3RvLnZlcmlmeShlLmluaXRpYWxpemVyW3RdKSlyZXR1cm5cImluaXRpYWxpemVyLlwiK259aWYobnVsbCE9ZS5zcGFyc2VJbml0aWFsaXplciYmZS5oYXNPd25Qcm9wZXJ0eShcInNwYXJzZUluaXRpYWxpemVyXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnNwYXJzZUluaXRpYWxpemVyKSlyZXR1cm5cInNwYXJzZUluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aDsrK3QpaWYobj1jLm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KGUuc3BhcnNlSW5pdGlhbGl6ZXJbdF0pKXJldHVyblwic3BhcnNlSW5pdGlhbGl6ZXIuXCIrbn1pZihudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWwuaXNTdHJpbmcoZS5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmlucHV0JiZlLmhhc093blByb3BlcnR5KFwiaW5wdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5wdXQpKXJldHVyblwiaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUuaW5wdXQubGVuZ3RoOysrdClpZihuPWMub25ueC5WYWx1ZUluZm9Qcm90by52ZXJpZnkoZS5pbnB1dFt0XSkpcmV0dXJuXCJpbnB1dC5cIitufWlmKG51bGwhPWUub3V0cHV0JiZlLmhhc093blByb3BlcnR5KFwib3V0cHV0XCIpKXtpZighQXJyYXkuaXNBcnJheShlLm91dHB1dCkpcmV0dXJuXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUub3V0cHV0Lmxlbmd0aDsrK3QpaWYobj1jLm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KGUub3V0cHV0W3RdKSlyZXR1cm5cIm91dHB1dC5cIitufWlmKG51bGwhPWUudmFsdWVJbmZvJiZlLmhhc093blByb3BlcnR5KFwidmFsdWVJbmZvXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnZhbHVlSW5mbykpcmV0dXJuXCJ2YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUudmFsdWVJbmZvLmxlbmd0aDsrK3QpaWYobj1jLm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KGUudmFsdWVJbmZvW3RdKSlyZXR1cm5cInZhbHVlSW5mby5cIitufWlmKG51bGwhPWUucXVhbnRpemF0aW9uQW5ub3RhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInF1YW50aXphdGlvbkFubm90YXRpb25cIikpe2lmKCFBcnJheS5pc0FycmF5KGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpcmV0dXJuXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOysrdCl7dmFyIG47aWYobj1jLm9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnkoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3RdKSlyZXR1cm5cInF1YW50aXphdGlvbkFubm90YXRpb24uXCIrbn19cmV0dXJuIG51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LkdyYXBoUHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5HcmFwaFByb3RvO2lmKGUubm9kZSl7aWYoIUFycmF5LmlzQXJyYXkoZS5ub2RlKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm5vZGU6IGFycmF5IGV4cGVjdGVkXCIpO3Qubm9kZT1bXTtmb3IodmFyIG49MDtuPGUubm9kZS5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5ub2RlW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogb2JqZWN0IGV4cGVjdGVkXCIpO3Qubm9kZVtuXT1jLm9ubnguTm9kZVByb3RvLmZyb21PYmplY3QoZS5ub2RlW25dKX19aWYobnVsbCE9ZS5uYW1lJiYodC5uYW1lPVN0cmluZyhlLm5hbWUpKSxlLmluaXRpYWxpemVyKXtpZighQXJyYXkuaXNBcnJheShlLmluaXRpYWxpemVyKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLmluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5pbml0aWFsaXplcj1bXSxuPTA7bjxlLmluaXRpYWxpemVyLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmluaXRpYWxpemVyW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IG9iamVjdCBleHBlY3RlZFwiKTt0LmluaXRpYWxpemVyW25dPWMub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KGUuaW5pdGlhbGl6ZXJbbl0pfX1pZihlLnNwYXJzZUluaXRpYWxpemVyKXtpZighQXJyYXkuaXNBcnJheShlLnNwYXJzZUluaXRpYWxpemVyKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnNwYXJzZUluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5zcGFyc2VJbml0aWFsaXplcj1bXSxuPTA7bjxlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnNwYXJzZUluaXRpYWxpemVyW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uc3BhcnNlSW5pdGlhbGl6ZXI6IG9iamVjdCBleHBlY3RlZFwiKTt0LnNwYXJzZUluaXRpYWxpemVyW25dPWMub25ueC5TcGFyc2VUZW5zb3JQcm90by5mcm9tT2JqZWN0KGUuc3BhcnNlSW5pdGlhbGl6ZXJbbl0pfX1pZihudWxsIT1lLmRvY1N0cmluZyYmKHQuZG9jU3RyaW5nPVN0cmluZyhlLmRvY1N0cmluZykpLGUuaW5wdXQpe2lmKCFBcnJheS5pc0FycmF5KGUuaW5wdXQpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmlucHV0PVtdLG49MDtuPGUuaW5wdXQubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuaW5wdXRbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO3QuaW5wdXRbbl09Yy5vbm54LlZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QoZS5pbnB1dFtuXSl9fWlmKGUub3V0cHV0KXtpZighQXJyYXkuaXNBcnJheShlLm91dHB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0Lm91dHB1dD1bXSxuPTA7bjxlLm91dHB1dC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5vdXRwdXRbbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5vdXRwdXQ6IG9iamVjdCBleHBlY3RlZFwiKTt0Lm91dHB1dFtuXT1jLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChlLm91dHB1dFtuXSl9fWlmKGUudmFsdWVJbmZvKXtpZighQXJyYXkuaXNBcnJheShlLnZhbHVlSW5mbykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by52YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnZhbHVlSW5mbz1bXSxuPTA7bjxlLnZhbHVlSW5mby5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS52YWx1ZUluZm9bbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by52YWx1ZUluZm86IG9iamVjdCBleHBlY3RlZFwiKTt0LnZhbHVlSW5mb1tuXT1jLm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChlLnZhbHVlSW5mb1tuXSl9fWlmKGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbil7aWYoIUFycmF5LmlzQXJyYXkoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLnF1YW50aXphdGlvbkFubm90YXRpb246IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnF1YW50aXphdGlvbkFubm90YXRpb249W10sbj0wO248ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnF1YW50aXphdGlvbkFubm90YXRpb25bbl0pdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dPWMub25ueC5UZW5zb3JBbm5vdGF0aW9uLmZyb21PYmplY3QoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW25dKX19cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYoKHQuYXJyYXlzfHx0LmRlZmF1bHRzKSYmKG4ubm9kZT1bXSxuLmluaXRpYWxpemVyPVtdLG4uaW5wdXQ9W10sbi5vdXRwdXQ9W10sbi52YWx1ZUluZm89W10sbi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uPVtdLG4uc3BhcnNlSW5pdGlhbGl6ZXI9W10pLHQuZGVmYXVsdHMmJihuLm5hbWU9XCJcIixuLmRvY1N0cmluZz1cIlwiKSxlLm5vZGUmJmUubm9kZS5sZW5ndGgpe24ubm9kZT1bXTtmb3IodmFyIHI9MDtyPGUubm9kZS5sZW5ndGg7KytyKW4ubm9kZVtyXT1jLm9ubnguTm9kZVByb3RvLnRvT2JqZWN0KGUubm9kZVtyXSx0KX1pZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPWUubmFtZSksZS5pbml0aWFsaXplciYmZS5pbml0aWFsaXplci5sZW5ndGgpZm9yKG4uaW5pdGlhbGl6ZXI9W10scj0wO3I8ZS5pbml0aWFsaXplci5sZW5ndGg7KytyKW4uaW5pdGlhbGl6ZXJbcl09Yy5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUuaW5pdGlhbGl6ZXJbcl0sdCk7aWYobnVsbCE9ZS5kb2NTdHJpbmcmJmUuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikmJihuLmRvY1N0cmluZz1lLmRvY1N0cmluZyksZS5pbnB1dCYmZS5pbnB1dC5sZW5ndGgpZm9yKG4uaW5wdXQ9W10scj0wO3I8ZS5pbnB1dC5sZW5ndGg7KytyKW4uaW5wdXRbcl09Yy5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KGUuaW5wdXRbcl0sdCk7aWYoZS5vdXRwdXQmJmUub3V0cHV0Lmxlbmd0aClmb3Iobi5vdXRwdXQ9W10scj0wO3I8ZS5vdXRwdXQubGVuZ3RoOysrciluLm91dHB1dFtyXT1jLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QoZS5vdXRwdXRbcl0sdCk7aWYoZS52YWx1ZUluZm8mJmUudmFsdWVJbmZvLmxlbmd0aClmb3Iobi52YWx1ZUluZm89W10scj0wO3I8ZS52YWx1ZUluZm8ubGVuZ3RoOysrciluLnZhbHVlSW5mb1tyXT1jLm9ubnguVmFsdWVJbmZvUHJvdG8udG9PYmplY3QoZS52YWx1ZUluZm9bcl0sdCk7aWYoZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uJiZlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKWZvcihuLnF1YW50aXphdGlvbkFubm90YXRpb249W10scj0wO3I8ZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsrK3Ipbi5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW3JdPWMub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KGUucXVhbnRpemF0aW9uQW5ub3RhdGlvbltyXSx0KTtpZihlLnNwYXJzZUluaXRpYWxpemVyJiZlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aClmb3Iobi5zcGFyc2VJbml0aWFsaXplcj1bXSxyPTA7cjxlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aDsrK3Ipbi5zcGFyc2VJbml0aWFsaXplcltyXT1jLm9ubnguU3BhcnNlVGVuc29yUHJvdG8udG9PYmplY3QoZS5zcGFyc2VJbml0aWFsaXplcltyXSx0KTtyZXR1cm4gbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxzLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5HcmFwaFByb3RvXCJ9LGV9KCksaS5UZW5zb3JQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5kaW1zPVtdLHRoaXMuZmxvYXREYXRhPVtdLHRoaXMuaW50MzJEYXRhPVtdLHRoaXMuc3RyaW5nRGF0YT1bXSx0aGlzLmludDY0RGF0YT1bXSx0aGlzLmV4dGVybmFsRGF0YT1bXSx0aGlzLmRvdWJsZURhdGE9W10sdGhpcy51aW50NjREYXRhPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUuZGltcz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZGF0YVR5cGU9MCxlLnByb3RvdHlwZS5zZWdtZW50PW51bGwsZS5wcm90b3R5cGUuZmxvYXREYXRhPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5pbnQzMkRhdGE9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLnN0cmluZ0RhdGE9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmludDY0RGF0YT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUubmFtZT1cIlwiLGUucHJvdG90eXBlLmRvY1N0cmluZz1cIlwiLGUucHJvdG90eXBlLnJhd0RhdGE9bC5uZXdCdWZmZXIoW10pLGUucHJvdG90eXBlLmV4dGVybmFsRGF0YT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZGF0YUxvY2F0aW9uPTAsZS5wcm90b3R5cGUuZG91YmxlRGF0YT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUudWludDY0RGF0YT1sLmVtcHR5QXJyYXksZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe2lmKHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuZGltcyYmZS5kaW1zLmxlbmd0aCl7dC51aW50MzIoMTApLmZvcmsoKTtmb3IodmFyIG49MDtuPGUuZGltcy5sZW5ndGg7KytuKXQuaW50NjQoZS5kaW1zW25dKTt0LmxkZWxpbSgpfWlmKG51bGwhPWUuZGF0YVR5cGUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkYXRhVHlwZVwiKSYmdC51aW50MzIoMTYpLmludDMyKGUuZGF0YVR5cGUpLG51bGwhPWUuc2VnbWVudCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInNlZ21lbnRcIikmJmMub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmVuY29kZShlLnNlZ21lbnQsdC51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCksbnVsbCE9ZS5mbG9hdERhdGEmJmUuZmxvYXREYXRhLmxlbmd0aCl7Zm9yKHQudWludDMyKDM0KS5mb3JrKCksbj0wO248ZS5mbG9hdERhdGEubGVuZ3RoOysrbil0LmZsb2F0KGUuZmxvYXREYXRhW25dKTt0LmxkZWxpbSgpfWlmKG51bGwhPWUuaW50MzJEYXRhJiZlLmludDMyRGF0YS5sZW5ndGgpe2Zvcih0LnVpbnQzMig0MikuZm9yaygpLG49MDtuPGUuaW50MzJEYXRhLmxlbmd0aDsrK24pdC5pbnQzMihlLmludDMyRGF0YVtuXSk7dC5sZGVsaW0oKX1pZihudWxsIT1lLnN0cmluZ0RhdGEmJmUuc3RyaW5nRGF0YS5sZW5ndGgpZm9yKG49MDtuPGUuc3RyaW5nRGF0YS5sZW5ndGg7KytuKXQudWludDMyKDUwKS5ieXRlcyhlLnN0cmluZ0RhdGFbbl0pO2lmKG51bGwhPWUuaW50NjREYXRhJiZlLmludDY0RGF0YS5sZW5ndGgpe2Zvcih0LnVpbnQzMig1OCkuZm9yaygpLG49MDtuPGUuaW50NjREYXRhLmxlbmd0aDsrK24pdC5pbnQ2NChlLmludDY0RGF0YVtuXSk7dC5sZGVsaW0oKX1pZihudWxsIT1lLm5hbWUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJuYW1lXCIpJiZ0LnVpbnQzMig2Nikuc3RyaW5nKGUubmFtZSksbnVsbCE9ZS5yYXdEYXRhJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwicmF3RGF0YVwiKSYmdC51aW50MzIoNzQpLmJ5dGVzKGUucmF3RGF0YSksbnVsbCE9ZS5kb3VibGVEYXRhJiZlLmRvdWJsZURhdGEubGVuZ3RoKXtmb3IodC51aW50MzIoODIpLmZvcmsoKSxuPTA7bjxlLmRvdWJsZURhdGEubGVuZ3RoOysrbil0LmRvdWJsZShlLmRvdWJsZURhdGFbbl0pO3QubGRlbGltKCl9aWYobnVsbCE9ZS51aW50NjREYXRhJiZlLnVpbnQ2NERhdGEubGVuZ3RoKXtmb3IodC51aW50MzIoOTApLmZvcmsoKSxuPTA7bjxlLnVpbnQ2NERhdGEubGVuZ3RoOysrbil0LnVpbnQ2NChlLnVpbnQ2NERhdGFbbl0pO3QubGRlbGltKCl9aWYobnVsbCE9ZS5kb2NTdHJpbmcmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkb2NTdHJpbmdcIikmJnQudWludDMyKDk4KS5zdHJpbmcoZS5kb2NTdHJpbmcpLG51bGwhPWUuZXh0ZXJuYWxEYXRhJiZlLmV4dGVybmFsRGF0YS5sZW5ndGgpZm9yKG49MDtuPGUuZXh0ZXJuYWxEYXRhLmxlbmd0aDsrK24pYy5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKGUuZXh0ZXJuYWxEYXRhW25dLHQudWludDMyKDEwNikuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gbnVsbCE9ZS5kYXRhTG9jYXRpb24mJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkYXRhTG9jYXRpb25cIikmJnQudWludDMyKDExMikuaW50MzIoZS5kYXRhTG9jYXRpb24pLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIGF8fChlPWEuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UZW5zb3JQcm90bztlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtzd2l0Y2gobz4+PjMpe2Nhc2UgMTppZihyLmRpbXMmJnIuZGltcy5sZW5ndGh8fChyLmRpbXM9W10pLDI9PSg3Jm8pKWZvcih2YXIgaT1lLnVpbnQzMigpK2UucG9zO2UucG9zPGk7KXIuZGltcy5wdXNoKGUuaW50NjQoKSk7ZWxzZSByLmRpbXMucHVzaChlLmludDY0KCkpO2JyZWFrO2Nhc2UgMjpyLmRhdGFUeXBlPWUuaW50MzIoKTticmVhaztjYXNlIDM6ci5zZWdtZW50PWMub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgNDppZihyLmZsb2F0RGF0YSYmci5mbG9hdERhdGEubGVuZ3RofHwoci5mbG9hdERhdGE9W10pLDI9PSg3Jm8pKWZvcihpPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8aTspci5mbG9hdERhdGEucHVzaChlLmZsb2F0KCkpO2Vsc2Ugci5mbG9hdERhdGEucHVzaChlLmZsb2F0KCkpO2JyZWFrO2Nhc2UgNTppZihyLmludDMyRGF0YSYmci5pbnQzMkRhdGEubGVuZ3RofHwoci5pbnQzMkRhdGE9W10pLDI9PSg3Jm8pKWZvcihpPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8aTspci5pbnQzMkRhdGEucHVzaChlLmludDMyKCkpO2Vsc2Ugci5pbnQzMkRhdGEucHVzaChlLmludDMyKCkpO2JyZWFrO2Nhc2UgNjpyLnN0cmluZ0RhdGEmJnIuc3RyaW5nRGF0YS5sZW5ndGh8fChyLnN0cmluZ0RhdGE9W10pLHIuc3RyaW5nRGF0YS5wdXNoKGUuYnl0ZXMoKSk7YnJlYWs7Y2FzZSA3OmlmKHIuaW50NjREYXRhJiZyLmludDY0RGF0YS5sZW5ndGh8fChyLmludDY0RGF0YT1bXSksMj09KDcmbykpZm9yKGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLmludDY0RGF0YS5wdXNoKGUuaW50NjQoKSk7ZWxzZSByLmludDY0RGF0YS5wdXNoKGUuaW50NjQoKSk7YnJlYWs7Y2FzZSA4OnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgMTI6ci5kb2NTdHJpbmc9ZS5zdHJpbmcoKTticmVhaztjYXNlIDk6ci5yYXdEYXRhPWUuYnl0ZXMoKTticmVhaztjYXNlIDEzOnIuZXh0ZXJuYWxEYXRhJiZyLmV4dGVybmFsRGF0YS5sZW5ndGh8fChyLmV4dGVybmFsRGF0YT1bXSksci5leHRlcm5hbERhdGEucHVzaChjLm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKSk7YnJlYWs7Y2FzZSAxNDpyLmRhdGFMb2NhdGlvbj1lLmludDMyKCk7YnJlYWs7Y2FzZSAxMDppZihyLmRvdWJsZURhdGEmJnIuZG91YmxlRGF0YS5sZW5ndGh8fChyLmRvdWJsZURhdGE9W10pLDI9PSg3Jm8pKWZvcihpPWUudWludDMyKCkrZS5wb3M7ZS5wb3M8aTspci5kb3VibGVEYXRhLnB1c2goZS5kb3VibGUoKSk7ZWxzZSByLmRvdWJsZURhdGEucHVzaChlLmRvdWJsZSgpKTticmVhaztjYXNlIDExOmlmKHIudWludDY0RGF0YSYmci51aW50NjREYXRhLmxlbmd0aHx8KHIudWludDY0RGF0YT1bXSksMj09KDcmbykpZm9yKGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLnVpbnQ2NERhdGEucHVzaChlLnVpbnQ2NCgpKTtlbHNlIHIudWludDY0RGF0YS5wdXNoKGUudWludDY0KCkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBhfHwoZT1uZXcgYShlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5kaW1zJiZlLmhhc093blByb3BlcnR5KFwiZGltc1wiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5kaW1zKSlyZXR1cm5cImRpbXM6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciB0PTA7dDxlLmRpbXMubGVuZ3RoOysrdClpZighKGwuaXNJbnRlZ2VyKGUuZGltc1t0XSl8fGUuZGltc1t0XSYmbC5pc0ludGVnZXIoZS5kaW1zW3RdLmxvdykmJmwuaXNJbnRlZ2VyKGUuZGltc1t0XS5oaWdoKSkpcmV0dXJuXCJkaW1zOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPWUuZGF0YVR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJkYXRhVHlwZVwiKSYmIWwuaXNJbnRlZ2VyKGUuZGF0YVR5cGUpKXJldHVyblwiZGF0YVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnNlZ21lbnQmJmUuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpJiYobj1jLm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC52ZXJpZnkoZS5zZWdtZW50KSkpcmV0dXJuXCJzZWdtZW50LlwiK247aWYobnVsbCE9ZS5mbG9hdERhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJmbG9hdERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZmxvYXREYXRhKSlyZXR1cm5cImZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5mbG9hdERhdGEubGVuZ3RoOysrdClpZihcIm51bWJlclwiIT10eXBlb2YgZS5mbG9hdERhdGFbdF0pcmV0dXJuXCJmbG9hdERhdGE6IG51bWJlcltdIGV4cGVjdGVkXCJ9aWYobnVsbCE9ZS5pbnQzMkRhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJpbnQzMkRhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50MzJEYXRhKSlyZXR1cm5cImludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5pbnQzMkRhdGEubGVuZ3RoOysrdClpZighbC5pc0ludGVnZXIoZS5pbnQzMkRhdGFbdF0pKXJldHVyblwiaW50MzJEYXRhOiBpbnRlZ2VyW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLnN0cmluZ0RhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdEYXRhXCIpKXtpZighQXJyYXkuaXNBcnJheShlLnN0cmluZ0RhdGEpKXJldHVyblwic3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5zdHJpbmdEYXRhLmxlbmd0aDsrK3QpaWYoIShlLnN0cmluZ0RhdGFbdF0mJlwibnVtYmVyXCI9PXR5cGVvZiBlLnN0cmluZ0RhdGFbdF0ubGVuZ3RofHxsLmlzU3RyaW5nKGUuc3RyaW5nRGF0YVt0XSkpKXJldHVyblwic3RyaW5nRGF0YTogYnVmZmVyW10gZXhwZWN0ZWRcIn1pZihudWxsIT1lLmludDY0RGF0YSYmZS5oYXNPd25Qcm9wZXJ0eShcImludDY0RGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnQ2NERhdGEpKXJldHVyblwiaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmludDY0RGF0YS5sZW5ndGg7Kyt0KWlmKCEobC5pc0ludGVnZXIoZS5pbnQ2NERhdGFbdF0pfHxlLmludDY0RGF0YVt0XSYmbC5pc0ludGVnZXIoZS5pbnQ2NERhdGFbdF0ubG93KSYmbC5pc0ludGVnZXIoZS5pbnQ2NERhdGFbdF0uaGlnaCkpKXJldHVyblwiaW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifWlmKG51bGwhPWUubmFtZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikmJiFsLmlzU3RyaW5nKGUubmFtZSkpcmV0dXJuXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmIWwuaXNTdHJpbmcoZS5kb2NTdHJpbmcpKXJldHVyblwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnJhd0RhdGEmJmUuaGFzT3duUHJvcGVydHkoXCJyYXdEYXRhXCIpJiYhKGUucmF3RGF0YSYmXCJudW1iZXJcIj09dHlwZW9mIGUucmF3RGF0YS5sZW5ndGh8fGwuaXNTdHJpbmcoZS5yYXdEYXRhKSkpcmV0dXJuXCJyYXdEYXRhOiBidWZmZXIgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmV4dGVybmFsRGF0YSYmZS5oYXNPd25Qcm9wZXJ0eShcImV4dGVybmFsRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5leHRlcm5hbERhdGEpKXJldHVyblwiZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmV4dGVybmFsRGF0YS5sZW5ndGg7Kyt0KXt2YXIgbjtpZihuPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShlLmV4dGVybmFsRGF0YVt0XSkpcmV0dXJuXCJleHRlcm5hbERhdGEuXCIrbn19aWYobnVsbCE9ZS5kYXRhTG9jYXRpb24mJmUuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikpc3dpdGNoKGUuZGF0YUxvY2F0aW9uKXtkZWZhdWx0OnJldHVyblwiZGF0YUxvY2F0aW9uOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7Y2FzZSAwOmNhc2UgMTp9aWYobnVsbCE9ZS5kb3VibGVEYXRhJiZlLmhhc093blByb3BlcnR5KFwiZG91YmxlRGF0YVwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5kb3VibGVEYXRhKSlyZXR1cm5cImRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHQ9MDt0PGUuZG91YmxlRGF0YS5sZW5ndGg7Kyt0KWlmKFwibnVtYmVyXCIhPXR5cGVvZiBlLmRvdWJsZURhdGFbdF0pcmV0dXJuXCJkb3VibGVEYXRhOiBudW1iZXJbXSBleHBlY3RlZFwifWlmKG51bGwhPWUudWludDY0RGF0YSYmZS5oYXNPd25Qcm9wZXJ0eShcInVpbnQ2NERhdGFcIikpe2lmKCFBcnJheS5pc0FycmF5KGUudWludDY0RGF0YSkpcmV0dXJuXCJ1aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLnVpbnQ2NERhdGEubGVuZ3RoOysrdClpZighKGwuaXNJbnRlZ2VyKGUudWludDY0RGF0YVt0XSl8fGUudWludDY0RGF0YVt0XSYmbC5pc0ludGVnZXIoZS51aW50NjREYXRhW3RdLmxvdykmJmwuaXNJbnRlZ2VyKGUudWludDY0RGF0YVt0XS5oaWdoKSkpcmV0dXJuXCJ1aW50NjREYXRhOiBpbnRlZ2VyfExvbmdbXSBleHBlY3RlZFwifXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UZW5zb3JQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlRlbnNvclByb3RvO2lmKGUuZGltcyl7aWYoIUFycmF5LmlzQXJyYXkoZS5kaW1zKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5kaW1zOiBhcnJheSBleHBlY3RlZFwiKTt0LmRpbXM9W107Zm9yKHZhciBuPTA7bjxlLmRpbXMubGVuZ3RoOysrbilsLkxvbmc/KHQuZGltc1tuXT1sLkxvbmcuZnJvbVZhbHVlKGUuZGltc1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmRpbXNbbl0/dC5kaW1zW25dPXBhcnNlSW50KGUuZGltc1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuZGltc1tuXT90LmRpbXNbbl09ZS5kaW1zW25dOlwib2JqZWN0XCI9PXR5cGVvZiBlLmRpbXNbbl0mJih0LmRpbXNbbl09bmV3IGwuTG9uZ0JpdHMoZS5kaW1zW25dLmxvdz4+PjAsZS5kaW1zW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1pZihudWxsIT1lLmRhdGFUeXBlJiYodC5kYXRhVHlwZT0wfGUuZGF0YVR5cGUpLG51bGwhPWUuc2VnbWVudCl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuc2VnbWVudCl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5zZWdtZW50OiBvYmplY3QgZXhwZWN0ZWRcIik7dC5zZWdtZW50PWMub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmZyb21PYmplY3QoZS5zZWdtZW50KX1pZihlLmZsb2F0RGF0YSl7aWYoIUFycmF5LmlzQXJyYXkoZS5mbG9hdERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuZmxvYXREYXRhPVtdLG49MDtuPGUuZmxvYXREYXRhLmxlbmd0aDsrK24pdC5mbG9hdERhdGFbbl09TnVtYmVyKGUuZmxvYXREYXRhW25dKX1pZihlLmludDMyRGF0YSl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnQzMkRhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuaW50MzJEYXRhPVtdLG49MDtuPGUuaW50MzJEYXRhLmxlbmd0aDsrK24pdC5pbnQzMkRhdGFbbl09MHxlLmludDMyRGF0YVtuXX1pZihlLnN0cmluZ0RhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuc3RyaW5nRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuc3RyaW5nRGF0YT1bXSxuPTA7bjxlLnN0cmluZ0RhdGEubGVuZ3RoOysrbilcInN0cmluZ1wiPT10eXBlb2YgZS5zdHJpbmdEYXRhW25dP2wuYmFzZTY0LmRlY29kZShlLnN0cmluZ0RhdGFbbl0sdC5zdHJpbmdEYXRhW25dPWwubmV3QnVmZmVyKGwuYmFzZTY0Lmxlbmd0aChlLnN0cmluZ0RhdGFbbl0pKSwwKTplLnN0cmluZ0RhdGFbbl0ubGVuZ3RoPj0wJiYodC5zdHJpbmdEYXRhW25dPWUuc3RyaW5nRGF0YVtuXSl9aWYoZS5pbnQ2NERhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuaW50NjREYXRhKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5pbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmludDY0RGF0YT1bXSxuPTA7bjxlLmludDY0RGF0YS5sZW5ndGg7KytuKWwuTG9uZz8odC5pbnQ2NERhdGFbbl09bC5Mb25nLmZyb21WYWx1ZShlLmludDY0RGF0YVtuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmludDY0RGF0YVtuXT90LmludDY0RGF0YVtuXT1wYXJzZUludChlLmludDY0RGF0YVtuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuaW50NjREYXRhW25dP3QuaW50NjREYXRhW25dPWUuaW50NjREYXRhW25dOlwib2JqZWN0XCI9PXR5cGVvZiBlLmludDY0RGF0YVtuXSYmKHQuaW50NjREYXRhW25dPW5ldyBsLkxvbmdCaXRzKGUuaW50NjREYXRhW25dLmxvdz4+PjAsZS5pbnQ2NERhdGFbbl0uaGlnaD4+PjApLnRvTnVtYmVyKCkpfWlmKG51bGwhPWUubmFtZSYmKHQubmFtZT1TdHJpbmcoZS5uYW1lKSksbnVsbCE9ZS5kb2NTdHJpbmcmJih0LmRvY1N0cmluZz1TdHJpbmcoZS5kb2NTdHJpbmcpKSxudWxsIT1lLnJhd0RhdGEmJihcInN0cmluZ1wiPT10eXBlb2YgZS5yYXdEYXRhP2wuYmFzZTY0LmRlY29kZShlLnJhd0RhdGEsdC5yYXdEYXRhPWwubmV3QnVmZmVyKGwuYmFzZTY0Lmxlbmd0aChlLnJhd0RhdGEpKSwwKTplLnJhd0RhdGEubGVuZ3RoPj0wJiYodC5yYXdEYXRhPWUucmF3RGF0YSkpLGUuZXh0ZXJuYWxEYXRhKXtpZighQXJyYXkuaXNBcnJheShlLmV4dGVybmFsRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZXh0ZXJuYWxEYXRhOiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5leHRlcm5hbERhdGE9W10sbj0wO248ZS5leHRlcm5hbERhdGEubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuZXh0ZXJuYWxEYXRhW25dKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO3QuZXh0ZXJuYWxEYXRhW25dPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3QoZS5leHRlcm5hbERhdGFbbl0pfX1zd2l0Y2goZS5kYXRhTG9jYXRpb24pe2RlZmF1bHQ6aWYoXCJudW1iZXJcIj09dHlwZW9mIGUuZGF0YUxvY2F0aW9uKXt0LmRhdGFMb2NhdGlvbj1lLmRhdGFMb2NhdGlvbjticmVha31icmVhaztjYXNlXCJERUZBVUxUXCI6Y2FzZSAwOnQuZGF0YUxvY2F0aW9uPTA7YnJlYWs7Y2FzZVwiRVhURVJOQUxcIjpjYXNlIDE6dC5kYXRhTG9jYXRpb249MX1pZihlLmRvdWJsZURhdGEpe2lmKCFBcnJheS5pc0FycmF5KGUuZG91YmxlRGF0YSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZG91YmxlRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuZG91YmxlRGF0YT1bXSxuPTA7bjxlLmRvdWJsZURhdGEubGVuZ3RoOysrbil0LmRvdWJsZURhdGFbbl09TnVtYmVyKGUuZG91YmxlRGF0YVtuXSl9aWYoZS51aW50NjREYXRhKXtpZighQXJyYXkuaXNBcnJheShlLnVpbnQ2NERhdGEpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLnVpbnQ2NERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LnVpbnQ2NERhdGE9W10sbj0wO248ZS51aW50NjREYXRhLmxlbmd0aDsrK24pbC5Mb25nPyh0LnVpbnQ2NERhdGFbbl09bC5Mb25nLmZyb21WYWx1ZShlLnVpbnQ2NERhdGFbbl0pKS51bnNpZ25lZD0hMDpcInN0cmluZ1wiPT10eXBlb2YgZS51aW50NjREYXRhW25dP3QudWludDY0RGF0YVtuXT1wYXJzZUludChlLnVpbnQ2NERhdGFbbl0sMTApOlwibnVtYmVyXCI9PXR5cGVvZiBlLnVpbnQ2NERhdGFbbl0/dC51aW50NjREYXRhW25dPWUudWludDY0RGF0YVtuXTpcIm9iamVjdFwiPT10eXBlb2YgZS51aW50NjREYXRhW25dJiYodC51aW50NjREYXRhW25dPW5ldyBsLkxvbmdCaXRzKGUudWludDY0RGF0YVtuXS5sb3c+Pj4wLGUudWludDY0RGF0YVtuXS5oaWdoPj4+MCkudG9OdW1iZXIoITApKX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZigodC5hcnJheXN8fHQuZGVmYXVsdHMpJiYobi5kaW1zPVtdLG4uZmxvYXREYXRhPVtdLG4uaW50MzJEYXRhPVtdLG4uc3RyaW5nRGF0YT1bXSxuLmludDY0RGF0YT1bXSxuLmRvdWJsZURhdGE9W10sbi51aW50NjREYXRhPVtdLG4uZXh0ZXJuYWxEYXRhPVtdKSx0LmRlZmF1bHRzJiYobi5kYXRhVHlwZT0wLG4uc2VnbWVudD1udWxsLG4ubmFtZT1cIlwiLHQuYnl0ZXM9PT1TdHJpbmc/bi5yYXdEYXRhPVwiXCI6KG4ucmF3RGF0YT1bXSx0LmJ5dGVzIT09QXJyYXkmJihuLnJhd0RhdGE9bC5uZXdCdWZmZXIobi5yYXdEYXRhKSkpLG4uZG9jU3RyaW5nPVwiXCIsbi5kYXRhTG9jYXRpb249dC5lbnVtcz09PVN0cmluZz9cIkRFRkFVTFRcIjowKSxlLmRpbXMmJmUuZGltcy5sZW5ndGgpe24uZGltcz1bXTtmb3IodmFyIHI9MDtyPGUuZGltcy5sZW5ndGg7KytyKVwibnVtYmVyXCI9PXR5cGVvZiBlLmRpbXNbcl0/bi5kaW1zW3JdPXQubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKGUuZGltc1tyXSk6ZS5kaW1zW3JdOm4uZGltc1tyXT10LmxvbmdzPT09U3RyaW5nP2wuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlLmRpbXNbcl0pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5kaW1zW3JdLmxvdz4+PjAsZS5kaW1zW3JdLmhpZ2g+Pj4wKS50b051bWJlcigpOmUuZGltc1tyXX1pZihudWxsIT1lLmRhdGFUeXBlJiZlLmhhc093blByb3BlcnR5KFwiZGF0YVR5cGVcIikmJihuLmRhdGFUeXBlPWUuZGF0YVR5cGUpLG51bGwhPWUuc2VnbWVudCYmZS5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikmJihuLnNlZ21lbnQ9Yy5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQudG9PYmplY3QoZS5zZWdtZW50LHQpKSxlLmZsb2F0RGF0YSYmZS5mbG9hdERhdGEubGVuZ3RoKWZvcihuLmZsb2F0RGF0YT1bXSxyPTA7cjxlLmZsb2F0RGF0YS5sZW5ndGg7KytyKW4uZmxvYXREYXRhW3JdPXQuanNvbiYmIWlzRmluaXRlKGUuZmxvYXREYXRhW3JdKT9TdHJpbmcoZS5mbG9hdERhdGFbcl0pOmUuZmxvYXREYXRhW3JdO2lmKGUuaW50MzJEYXRhJiZlLmludDMyRGF0YS5sZW5ndGgpZm9yKG4uaW50MzJEYXRhPVtdLHI9MDtyPGUuaW50MzJEYXRhLmxlbmd0aDsrK3Ipbi5pbnQzMkRhdGFbcl09ZS5pbnQzMkRhdGFbcl07aWYoZS5zdHJpbmdEYXRhJiZlLnN0cmluZ0RhdGEubGVuZ3RoKWZvcihuLnN0cmluZ0RhdGE9W10scj0wO3I8ZS5zdHJpbmdEYXRhLmxlbmd0aDsrK3Ipbi5zdHJpbmdEYXRhW3JdPXQuYnl0ZXM9PT1TdHJpbmc/bC5iYXNlNjQuZW5jb2RlKGUuc3RyaW5nRGF0YVtyXSwwLGUuc3RyaW5nRGF0YVtyXS5sZW5ndGgpOnQuYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLnN0cmluZ0RhdGFbcl0pOmUuc3RyaW5nRGF0YVtyXTtpZihlLmludDY0RGF0YSYmZS5pbnQ2NERhdGEubGVuZ3RoKWZvcihuLmludDY0RGF0YT1bXSxyPTA7cjxlLmludDY0RGF0YS5sZW5ndGg7KytyKVwibnVtYmVyXCI9PXR5cGVvZiBlLmludDY0RGF0YVtyXT9uLmludDY0RGF0YVtyXT10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLmludDY0RGF0YVtyXSk6ZS5pbnQ2NERhdGFbcl06bi5pbnQ2NERhdGFbcl09dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS5pbnQ2NERhdGFbcl0pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5pbnQ2NERhdGFbcl0ubG93Pj4+MCxlLmludDY0RGF0YVtyXS5oaWdoPj4+MCkudG9OdW1iZXIoKTplLmludDY0RGF0YVtyXTtpZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYobi5uYW1lPWUubmFtZSksbnVsbCE9ZS5yYXdEYXRhJiZlLmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSYmKG4ucmF3RGF0YT10LmJ5dGVzPT09U3RyaW5nP2wuYmFzZTY0LmVuY29kZShlLnJhd0RhdGEsMCxlLnJhd0RhdGEubGVuZ3RoKTp0LmJ5dGVzPT09QXJyYXk/QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZS5yYXdEYXRhKTplLnJhd0RhdGEpLGUuZG91YmxlRGF0YSYmZS5kb3VibGVEYXRhLmxlbmd0aClmb3Iobi5kb3VibGVEYXRhPVtdLHI9MDtyPGUuZG91YmxlRGF0YS5sZW5ndGg7KytyKW4uZG91YmxlRGF0YVtyXT10Lmpzb24mJiFpc0Zpbml0ZShlLmRvdWJsZURhdGFbcl0pP1N0cmluZyhlLmRvdWJsZURhdGFbcl0pOmUuZG91YmxlRGF0YVtyXTtpZihlLnVpbnQ2NERhdGEmJmUudWludDY0RGF0YS5sZW5ndGgpZm9yKG4udWludDY0RGF0YT1bXSxyPTA7cjxlLnVpbnQ2NERhdGEubGVuZ3RoOysrcilcIm51bWJlclwiPT10eXBlb2YgZS51aW50NjREYXRhW3JdP24udWludDY0RGF0YVtyXT10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLnVpbnQ2NERhdGFbcl0pOmUudWludDY0RGF0YVtyXTpuLnVpbnQ2NERhdGFbcl09dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS51aW50NjREYXRhW3JdKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUudWludDY0RGF0YVtyXS5sb3c+Pj4wLGUudWludDY0RGF0YVtyXS5oaWdoPj4+MCkudG9OdW1iZXIoITApOmUudWludDY0RGF0YVtyXTtpZihudWxsIT1lLmRvY1N0cmluZyYmZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSYmKG4uZG9jU3RyaW5nPWUuZG9jU3RyaW5nKSxlLmV4dGVybmFsRGF0YSYmZS5leHRlcm5hbERhdGEubGVuZ3RoKWZvcihuLmV4dGVybmFsRGF0YT1bXSxyPTA7cjxlLmV4dGVybmFsRGF0YS5sZW5ndGg7KytyKW4uZXh0ZXJuYWxEYXRhW3JdPWMub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KGUuZXh0ZXJuYWxEYXRhW3JdLHQpO3JldHVybiBudWxsIT1lLmRhdGFMb2NhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSYmKG4uZGF0YUxvY2F0aW9uPXQuZW51bXM9PT1TdHJpbmc/dm9pZCAwPT09Yy5vbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbltlLmRhdGFMb2NhdGlvbl0/ZS5kYXRhTG9jYXRpb246Yy5vbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbltlLmRhdGFMb2NhdGlvbl06ZS5kYXRhTG9jYXRpb24pLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMscy51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguVGVuc29yUHJvdG9cIn0sZS5EYXRhVHlwZT1mdW5jdGlvbigpe3ZhciBlPXt9LHQ9T2JqZWN0LmNyZWF0ZShlKTtyZXR1cm4gdFtlWzBdPVwiVU5ERUZJTkVEXCJdPTAsdFtlWzFdPVwiRkxPQVRcIl09MSx0W2VbMl09XCJVSU5UOFwiXT0yLHRbZVszXT1cIklOVDhcIl09Myx0W2VbNF09XCJVSU5UMTZcIl09NCx0W2VbNV09XCJJTlQxNlwiXT01LHRbZVs2XT1cIklOVDMyXCJdPTYsdFtlWzddPVwiSU5UNjRcIl09Nyx0W2VbOF09XCJTVFJJTkdcIl09OCx0W2VbOV09XCJCT09MXCJdPTksdFtlWzEwXT1cIkZMT0FUMTZcIl09MTAsdFtlWzExXT1cIkRPVUJMRVwiXT0xMSx0W2VbMTJdPVwiVUlOVDMyXCJdPTEyLHRbZVsxM109XCJVSU5UNjRcIl09MTMsdFtlWzE0XT1cIkNPTVBMRVg2NFwiXT0xNCx0W2VbMTVdPVwiQ09NUExFWDEyOFwiXT0xNSx0W2VbMTZdPVwiQkZMT0FUMTZcIl09MTYsdFtlWzE3XT1cIkZMT0FUOEU0TTNGTlwiXT0xNyx0W2VbMThdPVwiRkxPQVQ4RTRNM0ZOVVpcIl09MTgsdFtlWzE5XT1cIkZMT0FUOEU1TTJcIl09MTksdFtlWzIwXT1cIkZMT0FUOEU1TTJGTlVaXCJdPTIwLHR9KCksZS5TZWdtZW50PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLmJlZ2luPWwuTG9uZz9sLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUucHJvdG90eXBlLmVuZD1sLkxvbmc/bC5Mb25nLmZyb21CaXRzKDAsMCwhMSk6MCxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuYmVnaW4mJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJiZWdpblwiKSYmdC51aW50MzIoOCkuaW50NjQoZS5iZWdpbiksbnVsbCE9ZS5lbmQmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJlbmRcIikmJnQudWludDMyKDE2KS5pbnQ2NChlLmVuZCksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgYXx8KGU9YS5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQ7ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5iZWdpbj1lLmludDY0KCk7YnJlYWs7Y2FzZSAyOnIuZW5kPWUuaW50NjQoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgYXx8KGU9bmV3IGEoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZT9cIm9iamVjdCBleHBlY3RlZFwiOm51bGwhPWUuYmVnaW4mJmUuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmIShsLmlzSW50ZWdlcihlLmJlZ2luKXx8ZS5iZWdpbiYmbC5pc0ludGVnZXIoZS5iZWdpbi5sb3cpJiZsLmlzSW50ZWdlcihlLmJlZ2luLmhpZ2gpKT9cImJlZ2luOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjpudWxsIT1lLmVuZCYmZS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmIShsLmlzSW50ZWdlcihlLmVuZCl8fGUuZW5kJiZsLmlzSW50ZWdlcihlLmVuZC5sb3cpJiZsLmlzSW50ZWdlcihlLmVuZC5oaWdoKSk/XCJlbmQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQpcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5UZW5zb3JQcm90by5TZWdtZW50O3JldHVybiBudWxsIT1lLmJlZ2luJiYobC5Mb25nPyh0LmJlZ2luPWwuTG9uZy5mcm9tVmFsdWUoZS5iZWdpbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmJlZ2luP3QuYmVnaW49cGFyc2VJbnQoZS5iZWdpbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuYmVnaW4/dC5iZWdpbj1lLmJlZ2luOlwib2JqZWN0XCI9PXR5cGVvZiBlLmJlZ2luJiYodC5iZWdpbj1uZXcgbC5Mb25nQml0cyhlLmJlZ2luLmxvdz4+PjAsZS5iZWdpbi5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPWUuZW5kJiYobC5Mb25nPyh0LmVuZD1sLkxvbmcuZnJvbVZhbHVlKGUuZW5kKSkudW5zaWduZWQ9ITE6XCJzdHJpbmdcIj09dHlwZW9mIGUuZW5kP3QuZW5kPXBhcnNlSW50KGUuZW5kLDEwKTpcIm51bWJlclwiPT10eXBlb2YgZS5lbmQ/dC5lbmQ9ZS5lbmQ6XCJvYmplY3RcIj09dHlwZW9mIGUuZW5kJiYodC5lbmQ9bmV3IGwuTG9uZ0JpdHMoZS5lbmQubG93Pj4+MCxlLmVuZC5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYodC5kZWZhdWx0cyl7aWYobC5Mb25nKXt2YXIgcj1uZXcgbC5Mb25nKDAsMCwhMSk7bi5iZWdpbj10LmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTp0LmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyfWVsc2Ugbi5iZWdpbj10LmxvbmdzPT09U3RyaW5nP1wiMFwiOjA7bC5Mb25nPyhyPW5ldyBsLkxvbmcoMCwwLCExKSxuLmVuZD10LmxvbmdzPT09U3RyaW5nP3IudG9TdHJpbmcoKTp0LmxvbmdzPT09TnVtYmVyP3IudG9OdW1iZXIoKTpyKTpuLmVuZD10LmxvbmdzPT09U3RyaW5nP1wiMFwiOjB9cmV0dXJuIG51bGwhPWUuYmVnaW4mJmUuaGFzT3duUHJvcGVydHkoXCJiZWdpblwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBlLmJlZ2luP24uYmVnaW49dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5iZWdpbik6ZS5iZWdpbjpuLmJlZ2luPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuYmVnaW4pOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5iZWdpbi5sb3c+Pj4wLGUuYmVnaW4uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5iZWdpbiksbnVsbCE9ZS5lbmQmJmUuaGFzT3duUHJvcGVydHkoXCJlbmRcIikmJihcIm51bWJlclwiPT10eXBlb2YgZS5lbmQ/bi5lbmQ9dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5lbmQpOmUuZW5kOm4uZW5kPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuZW5kKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUuZW5kLmxvdz4+PjAsZS5lbmQuaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5lbmQpLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMscy51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguVGVuc29yUHJvdG8uU2VnbWVudFwifSxlfSgpLGUuRGF0YUxvY2F0aW9uPWZ1bmN0aW9uKCl7dmFyIGU9e30sdD1PYmplY3QuY3JlYXRlKGUpO3JldHVybiB0W2VbMF09XCJERUZBVUxUXCJdPTAsdFtlWzFdPVwiRVhURVJOQUxcIl09MSx0fSgpLGV9KCksaS5TcGFyc2VUZW5zb3JQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYodGhpcy5kaW1zPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUudmFsdWVzPW51bGwsZS5wcm90b3R5cGUuaW5kaWNlcz1udWxsLGUucHJvdG90eXBlLmRpbXM9bC5lbXB0eUFycmF5LGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLnZhbHVlcyYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInZhbHVlc1wiKSYmYy5vbm54LlRlbnNvclByb3RvLmVuY29kZShlLnZhbHVlcyx0LnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT1lLmluZGljZXMmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJpbmRpY2VzXCIpJiZjLm9ubnguVGVuc29yUHJvdG8uZW5jb2RlKGUuaW5kaWNlcyx0LnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT1lLmRpbXMmJmUuZGltcy5sZW5ndGgpe3QudWludDMyKDI2KS5mb3JrKCk7Zm9yKHZhciBuPTA7bjxlLmRpbXMubGVuZ3RoOysrbil0LmludDY0KGUuZGltc1tuXSk7dC5sZGVsaW0oKX1yZXR1cm4gdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgYXx8KGU9YS5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlNwYXJzZVRlbnNvclByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIudmFsdWVzPWMub25ueC5UZW5zb3JQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDI6ci5pbmRpY2VzPWMub25ueC5UZW5zb3JQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDM6aWYoci5kaW1zJiZyLmRpbXMubGVuZ3RofHwoci5kaW1zPVtdKSwyPT0oNyZvKSlmb3IodmFyIGk9ZS51aW50MzIoKStlLnBvcztlLnBvczxpOylyLmRpbXMucHVzaChlLmludDY0KCkpO2Vsc2Ugci5kaW1zLnB1c2goZS5pbnQ2NCgpKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgYXx8KGU9bmV3IGEoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO3ZhciB0O2lmKG51bGwhPWUudmFsdWVzJiZlLmhhc093blByb3BlcnR5KFwidmFsdWVzXCIpJiYodD1jLm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KGUudmFsdWVzKSkpcmV0dXJuXCJ2YWx1ZXMuXCIrdDtpZihudWxsIT1lLmluZGljZXMmJmUuaGFzT3duUHJvcGVydHkoXCJpbmRpY2VzXCIpJiYodD1jLm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KGUuaW5kaWNlcykpKXJldHVyblwiaW5kaWNlcy5cIit0O2lmKG51bGwhPWUuZGltcyYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbXNcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuZGltcykpcmV0dXJuXCJkaW1zOiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgbj0wO248ZS5kaW1zLmxlbmd0aDsrK24paWYoIShsLmlzSW50ZWdlcihlLmRpbXNbbl0pfHxlLmRpbXNbbl0mJmwuaXNJbnRlZ2VyKGUuZGltc1tuXS5sb3cpJiZsLmlzSW50ZWdlcihlLmRpbXNbbl0uaGlnaCkpKXJldHVyblwiZGltczogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIn1yZXR1cm4gbnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguU3BhcnNlVGVuc29yUHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5TcGFyc2VUZW5zb3JQcm90bztpZihudWxsIT1lLnZhbHVlcyl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUudmFsdWVzKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlNwYXJzZVRlbnNvclByb3RvLnZhbHVlczogb2JqZWN0IGV4cGVjdGVkXCIpO3QudmFsdWVzPWMub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KGUudmFsdWVzKX1pZihudWxsIT1lLmluZGljZXMpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmluZGljZXMpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uaW5kaWNlczogb2JqZWN0IGV4cGVjdGVkXCIpO3QuaW5kaWNlcz1jLm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChlLmluZGljZXMpfWlmKGUuZGltcyl7aWYoIUFycmF5LmlzQXJyYXkoZS5kaW1zKSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5TcGFyc2VUZW5zb3JQcm90by5kaW1zOiBhcnJheSBleHBlY3RlZFwiKTt0LmRpbXM9W107Zm9yKHZhciBuPTA7bjxlLmRpbXMubGVuZ3RoOysrbilsLkxvbmc/KHQuZGltc1tuXT1sLkxvbmcuZnJvbVZhbHVlKGUuZGltc1tuXSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmRpbXNbbl0/dC5kaW1zW25dPXBhcnNlSW50KGUuZGltc1tuXSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuZGltc1tuXT90LmRpbXNbbl09ZS5kaW1zW25dOlwib2JqZWN0XCI9PXR5cGVvZiBlLmRpbXNbbl0mJih0LmRpbXNbbl09bmV3IGwuTG9uZ0JpdHMoZS5kaW1zW25dLmxvdz4+PjAsZS5kaW1zW25dLmhpZ2g+Pj4wKS50b051bWJlcigpKX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZigodC5hcnJheXN8fHQuZGVmYXVsdHMpJiYobi5kaW1zPVtdKSx0LmRlZmF1bHRzJiYobi52YWx1ZXM9bnVsbCxuLmluZGljZXM9bnVsbCksbnVsbCE9ZS52YWx1ZXMmJmUuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZXNcIikmJihuLnZhbHVlcz1jLm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QoZS52YWx1ZXMsdCkpLG51bGwhPWUuaW5kaWNlcyYmZS5oYXNPd25Qcm9wZXJ0eShcImluZGljZXNcIikmJihuLmluZGljZXM9Yy5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KGUuaW5kaWNlcyx0KSksZS5kaW1zJiZlLmRpbXMubGVuZ3RoKXtuLmRpbXM9W107Zm9yKHZhciByPTA7cjxlLmRpbXMubGVuZ3RoOysrcilcIm51bWJlclwiPT10eXBlb2YgZS5kaW1zW3JdP24uZGltc1tyXT10LmxvbmdzPT09U3RyaW5nP1N0cmluZyhlLmRpbXNbcl0pOmUuZGltc1tyXTpuLmRpbXNbcl09dC5sb25ncz09PVN0cmluZz9sLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS5kaW1zW3JdKTp0LmxvbmdzPT09TnVtYmVyP25ldyBsLkxvbmdCaXRzKGUuZGltc1tyXS5sb3c+Pj4wLGUuZGltc1tyXS5oaWdoPj4+MCkudG9OdW1iZXIoKTplLmRpbXNbcl19cmV0dXJuIG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMscy51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguU3BhcnNlVGVuc29yUHJvdG9cIn0sZX0oKSxpLlRlbnNvclNoYXBlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKHRoaXMuZGltPVtdLGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUuZGltPWwuZW1wdHlBcnJheSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7aWYodHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5kaW0mJmUuZGltLmxlbmd0aClmb3IodmFyIG49MDtuPGUuZGltLmxlbmd0aDsrK24pYy5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLmVuY29kZShlLmRpbVtuXSx0LnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtyZXR1cm4gdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgYXx8KGU9YS5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlRlbnNvclNoYXBlUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7bz4+PjM9PTE/KHIuZGltJiZyLmRpbS5sZW5ndGh8fChyLmRpbT1bXSksci5kaW0ucHVzaChjLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZGVjb2RlKGUsZS51aW50MzIoKSkpKTplLnNraXBUeXBlKDcmbyl9cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgYXx8KGU9bmV3IGEoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPWUuZGltJiZlLmhhc093blByb3BlcnR5KFwiZGltXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmRpbSkpcmV0dXJuXCJkaW06IGFycmF5IGV4cGVjdGVkXCI7Zm9yKHZhciB0PTA7dDxlLmRpbS5sZW5ndGg7Kyt0KXt2YXIgbj1jLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24udmVyaWZ5KGUuZGltW3RdKTtpZihuKXJldHVyblwiZGltLlwiK259fXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UZW5zb3JTaGFwZVByb3RvKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguVGVuc29yU2hhcGVQcm90bztpZihlLmRpbSl7aWYoIUFycmF5LmlzQXJyYXkoZS5kaW0pKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGltOiBhcnJheSBleHBlY3RlZFwiKTt0LmRpbT1bXTtmb3IodmFyIG49MDtuPGUuZGltLmxlbmd0aDsrK24pe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLmRpbVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JTaGFwZVByb3RvLmRpbTogb2JqZWN0IGV4cGVjdGVkXCIpO3QuZGltW25dPWMub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5mcm9tT2JqZWN0KGUuZGltW25dKX19cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYoKHQuYXJyYXlzfHx0LmRlZmF1bHRzKSYmKG4uZGltPVtdKSxlLmRpbSYmZS5kaW0ubGVuZ3RoKXtuLmRpbT1bXTtmb3IodmFyIHI9MDtyPGUuZGltLmxlbmd0aDsrK3Ipbi5kaW1bcl09Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnRvT2JqZWN0KGUuZGltW3JdLHQpfXJldHVybiBufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLHMudXRpbC50b0pTT05PcHRpb25zKX0sZS5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54LlRlbnNvclNoYXBlUHJvdG9cIn0sZS5EaW1lbnNpb249ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX12YXIgdDtyZXR1cm4gZS5wcm90b3R5cGUuZGltVmFsdWU9bnVsbCxlLnByb3RvdHlwZS5kaW1QYXJhbT1udWxsLGUucHJvdG90eXBlLmRlbm90YXRpb249XCJcIixPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJ2YWx1ZVwiLHtnZXQ6bC5vbmVPZkdldHRlcih0PVtcImRpbVZhbHVlXCIsXCJkaW1QYXJhbVwiXSksc2V0Omwub25lT2ZTZXR0ZXIodCl9KSxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuZGltVmFsdWUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkaW1WYWx1ZVwiKSYmdC51aW50MzIoOCkuaW50NjQoZS5kaW1WYWx1ZSksbnVsbCE9ZS5kaW1QYXJhbSYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRpbVBhcmFtXCIpJiZ0LnVpbnQzMigxOCkuc3RyaW5nKGUuZGltUGFyYW0pLG51bGwhPWUuZGVub3RhdGlvbiYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRlbm90YXRpb25cIikmJnQudWludDMyKDI2KS5zdHJpbmcoZS5kZW5vdGF0aW9uKSx0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBhfHwoZT1hLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb247ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5kaW1WYWx1ZT1lLmludDY0KCk7YnJlYWs7Y2FzZSAyOnIuZGltUGFyYW09ZS5zdHJpbmcoKTticmVhaztjYXNlIDM6ci5kZW5vdGF0aW9uPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGF8fChlPW5ldyBhKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjt2YXIgdD17fTtpZihudWxsIT1lLmRpbVZhbHVlJiZlLmhhc093blByb3BlcnR5KFwiZGltVmFsdWVcIikmJih0LnZhbHVlPTEsIShsLmlzSW50ZWdlcihlLmRpbVZhbHVlKXx8ZS5kaW1WYWx1ZSYmbC5pc0ludGVnZXIoZS5kaW1WYWx1ZS5sb3cpJiZsLmlzSW50ZWdlcihlLmRpbVZhbHVlLmhpZ2gpKSkpcmV0dXJuXCJkaW1WYWx1ZTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5kaW1QYXJhbSYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbVBhcmFtXCIpKXtpZigxPT09dC52YWx1ZSlyZXR1cm5cInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtpZih0LnZhbHVlPTEsIWwuaXNTdHJpbmcoZS5kaW1QYXJhbSkpcmV0dXJuXCJkaW1QYXJhbTogc3RyaW5nIGV4cGVjdGVkXCJ9cmV0dXJuIG51bGwhPWUuZGVub3RhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJiFsLmlzU3RyaW5nKGUuZGVub3RhdGlvbik/XCJkZW5vdGF0aW9uOiBzdHJpbmcgZXhwZWN0ZWRcIjpudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbilyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uO3JldHVybiBudWxsIT1lLmRpbVZhbHVlJiYobC5Mb25nPyh0LmRpbVZhbHVlPWwuTG9uZy5mcm9tVmFsdWUoZS5kaW1WYWx1ZSkpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLmRpbVZhbHVlP3QuZGltVmFsdWU9cGFyc2VJbnQoZS5kaW1WYWx1ZSwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUuZGltVmFsdWU/dC5kaW1WYWx1ZT1lLmRpbVZhbHVlOlwib2JqZWN0XCI9PXR5cGVvZiBlLmRpbVZhbHVlJiYodC5kaW1WYWx1ZT1uZXcgbC5Mb25nQml0cyhlLmRpbVZhbHVlLmxvdz4+PjAsZS5kaW1WYWx1ZS5oaWdoPj4+MCkudG9OdW1iZXIoKSkpLG51bGwhPWUuZGltUGFyYW0mJih0LmRpbVBhcmFtPVN0cmluZyhlLmRpbVBhcmFtKSksbnVsbCE9ZS5kZW5vdGF0aW9uJiYodC5kZW5vdGF0aW9uPVN0cmluZyhlLmRlbm90YXRpb24pKSx0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O3JldHVybiB0LmRlZmF1bHRzJiYobi5kZW5vdGF0aW9uPVwiXCIpLG51bGwhPWUuZGltVmFsdWUmJmUuaGFzT3duUHJvcGVydHkoXCJkaW1WYWx1ZVwiKSYmKFwibnVtYmVyXCI9PXR5cGVvZiBlLmRpbVZhbHVlP24uZGltVmFsdWU9dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS5kaW1WYWx1ZSk6ZS5kaW1WYWx1ZTpuLmRpbVZhbHVlPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUuZGltVmFsdWUpOnQubG9uZ3M9PT1OdW1iZXI/bmV3IGwuTG9uZ0JpdHMoZS5kaW1WYWx1ZS5sb3c+Pj4wLGUuZGltVmFsdWUuaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS5kaW1WYWx1ZSx0Lm9uZW9mcyYmKG4udmFsdWU9XCJkaW1WYWx1ZVwiKSksbnVsbCE9ZS5kaW1QYXJhbSYmZS5oYXNPd25Qcm9wZXJ0eShcImRpbVBhcmFtXCIpJiYobi5kaW1QYXJhbT1lLmRpbVBhcmFtLHQub25lb2ZzJiYobi52YWx1ZT1cImRpbVBhcmFtXCIpKSxudWxsIT1lLmRlbm90YXRpb24mJmUuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYobi5kZW5vdGF0aW9uPWUuZGVub3RhdGlvbiksbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxzLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblwifSxlfSgpLGV9KCksaS5UeXBlUHJvdG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX12YXIgdDtyZXR1cm4gZS5wcm90b3R5cGUudGVuc29yVHlwZT1udWxsLGUucHJvdG90eXBlLnNlcXVlbmNlVHlwZT1udWxsLGUucHJvdG90eXBlLm1hcFR5cGU9bnVsbCxlLnByb3RvdHlwZS5vcHRpb25hbFR5cGU9bnVsbCxlLnByb3RvdHlwZS5zcGFyc2VUZW5zb3JUeXBlPW51bGwsZS5wcm90b3R5cGUuZGVub3RhdGlvbj1cIlwiLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcInZhbHVlXCIse2dldDpsLm9uZU9mR2V0dGVyKHQ9W1widGVuc29yVHlwZVwiLFwic2VxdWVuY2VUeXBlXCIsXCJtYXBUeXBlXCIsXCJvcHRpb25hbFR5cGVcIixcInNwYXJzZVRlbnNvclR5cGVcIl0pLHNldDpsLm9uZU9mU2V0dGVyKHQpfSksZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLnRlbnNvclR5cGUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJ0ZW5zb3JUeXBlXCIpJiZjLm9ubnguVHlwZVByb3RvLlRlbnNvci5lbmNvZGUoZS50ZW5zb3JUeXBlLHQudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPWUuc2VxdWVuY2VUeXBlJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwic2VxdWVuY2VUeXBlXCIpJiZjLm9ubnguVHlwZVByb3RvLlNlcXVlbmNlLmVuY29kZShlLnNlcXVlbmNlVHlwZSx0LnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKSxudWxsIT1lLm1hcFR5cGUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJtYXBUeXBlXCIpJiZjLm9ubnguVHlwZVByb3RvLk1hcC5lbmNvZGUoZS5tYXBUeXBlLHQudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPWUuZGVub3RhdGlvbiYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRlbm90YXRpb25cIikmJnQudWludDMyKDUwKS5zdHJpbmcoZS5kZW5vdGF0aW9uKSxudWxsIT1lLnNwYXJzZVRlbnNvclR5cGUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJzcGFyc2VUZW5zb3JUeXBlXCIpJiZjLm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvci5lbmNvZGUoZS5zcGFyc2VUZW5zb3JUeXBlLHQudWludDMyKDY2KS5mb3JrKCkpLmxkZWxpbSgpLG51bGwhPWUub3B0aW9uYWxUeXBlJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwib3B0aW9uYWxUeXBlXCIpJiZjLm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmVuY29kZShlLm9wdGlvbmFsVHlwZSx0LnVpbnQzMig3NCkuZm9yaygpKS5sZGVsaW0oKSx0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBhfHwoZT1hLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguVHlwZVByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIudGVuc29yVHlwZT1jLm9ubnguVHlwZVByb3RvLlRlbnNvci5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDQ6ci5zZXF1ZW5jZVR5cGU9Yy5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5kZWNvZGUoZSxlLnVpbnQzMigpKTticmVhaztjYXNlIDU6ci5tYXBUeXBlPWMub25ueC5UeXBlUHJvdG8uTWFwLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgOTpyLm9wdGlvbmFsVHlwZT1jLm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2Nhc2UgODpyLnNwYXJzZVRlbnNvclR5cGU9Yy5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IuZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7Y2FzZSA2OnIuZGVub3RhdGlvbj1lLnN0cmluZygpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBhfHwoZT1uZXcgYShlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7dmFyIHQ9e307aWYobnVsbCE9ZS50ZW5zb3JUeXBlJiZlLmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSYmKHQudmFsdWU9MSxuPWMub25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeShlLnRlbnNvclR5cGUpKSlyZXR1cm5cInRlbnNvclR5cGUuXCIrbjtpZihudWxsIT1lLnNlcXVlbmNlVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInNlcXVlbmNlVHlwZVwiKSl7aWYoMT09PXQudmFsdWUpcmV0dXJuXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7aWYodC52YWx1ZT0xLG49Yy5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS52ZXJpZnkoZS5zZXF1ZW5jZVR5cGUpKXJldHVyblwic2VxdWVuY2VUeXBlLlwiK259aWYobnVsbCE9ZS5tYXBUeXBlJiZlLmhhc093blByb3BlcnR5KFwibWFwVHlwZVwiKSl7aWYoMT09PXQudmFsdWUpcmV0dXJuXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7aWYodC52YWx1ZT0xLG49Yy5vbm54LlR5cGVQcm90by5NYXAudmVyaWZ5KGUubWFwVHlwZSkpcmV0dXJuXCJtYXBUeXBlLlwiK259aWYobnVsbCE9ZS5vcHRpb25hbFR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJvcHRpb25hbFR5cGVcIikpe2lmKDE9PT10LnZhbHVlKXJldHVyblwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO2lmKHQudmFsdWU9MSxuPWMub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwudmVyaWZ5KGUub3B0aW9uYWxUeXBlKSlyZXR1cm5cIm9wdGlvbmFsVHlwZS5cIitufWlmKG51bGwhPWUuc3BhcnNlVGVuc29yVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInNwYXJzZVRlbnNvclR5cGVcIikpe2lmKDE9PT10LnZhbHVlKXJldHVyblwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO3ZhciBuO2lmKHQudmFsdWU9MSxuPWMub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnZlcmlmeShlLnNwYXJzZVRlbnNvclR5cGUpKXJldHVyblwic3BhcnNlVGVuc29yVHlwZS5cIitufXJldHVybiBudWxsIT1lLmRlbm90YXRpb24mJmUuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpJiYhbC5pc1N0cmluZyhlLmRlbm90YXRpb24pP1wiZGVub3RhdGlvbjogc3RyaW5nIGV4cGVjdGVkXCI6bnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguVHlwZVByb3RvKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguVHlwZVByb3RvO2lmKG51bGwhPWUudGVuc29yVHlwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUudGVuc29yVHlwZSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8udGVuc29yVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO3QudGVuc29yVHlwZT1jLm9ubnguVHlwZVByb3RvLlRlbnNvci5mcm9tT2JqZWN0KGUudGVuc29yVHlwZSl9aWYobnVsbCE9ZS5zZXF1ZW5jZVR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnNlcXVlbmNlVHlwZSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uc2VxdWVuY2VUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5zZXF1ZW5jZVR5cGU9Yy5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5mcm9tT2JqZWN0KGUuc2VxdWVuY2VUeXBlKX1pZihudWxsIT1lLm1hcFR5cGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLm1hcFR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLm1hcFR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTt0Lm1hcFR5cGU9Yy5vbm54LlR5cGVQcm90by5NYXAuZnJvbU9iamVjdChlLm1hcFR5cGUpfWlmKG51bGwhPWUub3B0aW9uYWxUeXBlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5vcHRpb25hbFR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLm9wdGlvbmFsVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO3Qub3B0aW9uYWxUeXBlPWMub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZnJvbU9iamVjdChlLm9wdGlvbmFsVHlwZSl9aWYobnVsbCE9ZS5zcGFyc2VUZW5zb3JUeXBlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5zcGFyc2VUZW5zb3JUeXBlKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5zcGFyc2VUZW5zb3JUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5zcGFyc2VUZW5zb3JUeXBlPWMub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLmZyb21PYmplY3QoZS5zcGFyc2VUZW5zb3JUeXBlKX1yZXR1cm4gbnVsbCE9ZS5kZW5vdGF0aW9uJiYodC5kZW5vdGF0aW9uPVN0cmluZyhlLmRlbm90YXRpb24pKSx0fSxlLnRvT2JqZWN0PWZ1bmN0aW9uKGUsdCl7dHx8KHQ9e30pO3ZhciBuPXt9O3JldHVybiB0LmRlZmF1bHRzJiYobi5kZW5vdGF0aW9uPVwiXCIpLG51bGwhPWUudGVuc29yVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInRlbnNvclR5cGVcIikmJihuLnRlbnNvclR5cGU9Yy5vbm54LlR5cGVQcm90by5UZW5zb3IudG9PYmplY3QoZS50ZW5zb3JUeXBlLHQpLHQub25lb2ZzJiYobi52YWx1ZT1cInRlbnNvclR5cGVcIikpLG51bGwhPWUuc2VxdWVuY2VUeXBlJiZlLmhhc093blByb3BlcnR5KFwic2VxdWVuY2VUeXBlXCIpJiYobi5zZXF1ZW5jZVR5cGU9Yy5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS50b09iamVjdChlLnNlcXVlbmNlVHlwZSx0KSx0Lm9uZW9mcyYmKG4udmFsdWU9XCJzZXF1ZW5jZVR5cGVcIikpLG51bGwhPWUubWFwVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm1hcFR5cGVcIikmJihuLm1hcFR5cGU9Yy5vbm54LlR5cGVQcm90by5NYXAudG9PYmplY3QoZS5tYXBUeXBlLHQpLHQub25lb2ZzJiYobi52YWx1ZT1cIm1hcFR5cGVcIikpLG51bGwhPWUuZGVub3RhdGlvbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikmJihuLmRlbm90YXRpb249ZS5kZW5vdGF0aW9uKSxudWxsIT1lLnNwYXJzZVRlbnNvclR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VUZW5zb3JUeXBlXCIpJiYobi5zcGFyc2VUZW5zb3JUeXBlPWMub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnRvT2JqZWN0KGUuc3BhcnNlVGVuc29yVHlwZSx0KSx0Lm9uZW9mcyYmKG4udmFsdWU9XCJzcGFyc2VUZW5zb3JUeXBlXCIpKSxudWxsIT1lLm9wdGlvbmFsVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcIm9wdGlvbmFsVHlwZVwiKSYmKG4ub3B0aW9uYWxUeXBlPWMub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwudG9PYmplY3QoZS5vcHRpb25hbFR5cGUsdCksdC5vbmVvZnMmJihuLnZhbHVlPVwib3B0aW9uYWxUeXBlXCIpKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLHMudXRpbC50b0pTT05PcHRpb25zKX0sZS5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54LlR5cGVQcm90b1wifSxlLlRlbnNvcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5lbGVtVHlwZT0wLGUucHJvdG90eXBlLnNoYXBlPW51bGwsZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmVsZW1UeXBlJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZWxlbVR5cGVcIikmJnQudWludDMyKDgpLmludDMyKGUuZWxlbVR5cGUpLG51bGwhPWUuc2hhcGUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJzaGFwZVwiKSYmYy5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKGUuc2hhcGUsdC51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgYXx8KGU9YS5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlR5cGVQcm90by5UZW5zb3I7ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5lbGVtVHlwZT1lLmludDMyKCk7YnJlYWs7Y2FzZSAyOnIuc2hhcGU9Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGF8fChlPW5ldyBhKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmVsZW1UeXBlJiZlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJiFsLmlzSW50ZWdlcihlLmVsZW1UeXBlKSlyZXR1cm5cImVsZW1UeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5zaGFwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKXt2YXIgdD1jLm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkoZS5zaGFwZSk7aWYodClyZXR1cm5cInNoYXBlLlwiK3R9cmV0dXJuIG51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlR5cGVQcm90by5UZW5zb3IpcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5UeXBlUHJvdG8uVGVuc29yO2lmKG51bGwhPWUuZWxlbVR5cGUmJih0LmVsZW1UeXBlPTB8ZS5lbGVtVHlwZSksbnVsbCE9ZS5zaGFwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuc2hhcGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLlRlbnNvci5zaGFwZTogb2JqZWN0IGV4cGVjdGVkXCIpO3Quc2hhcGU9Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdChlLnNoYXBlKX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtyZXR1cm4gdC5kZWZhdWx0cyYmKG4uZWxlbVR5cGU9MCxuLnNoYXBlPW51bGwpLG51bGwhPWUuZWxlbVR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmKG4uZWxlbVR5cGU9ZS5lbGVtVHlwZSksbnVsbCE9ZS5zaGFwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpJiYobi5zaGFwZT1jLm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdChlLnNoYXBlLHQpKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLHMudXRpbC50b0pTT05PcHRpb25zKX0sZS5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54LlR5cGVQcm90by5UZW5zb3JcIn0sZX0oKSxlLlNlcXVlbmNlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLmVsZW1UeXBlPW51bGwsZS5jcmVhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLmVuY29kZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLmVsZW1UeXBlJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiZWxlbVR5cGVcIikmJmMub25ueC5UeXBlUHJvdG8uZW5jb2RlKGUuZWxlbVR5cGUsdC51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCksdH0sZS5lbmNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5lbmNvZGUoZSx0KS5sZGVsaW0oKX0sZS5kZWNvZGU9ZnVuY3Rpb24oZSx0KXtlIGluc3RhbmNlb2YgYXx8KGU9YS5jcmVhdGUoZSkpO2Zvcih2YXIgbj12b2lkIDA9PT10P2UubGVuOmUucG9zK3Qscj1uZXcgYy5vbm54LlR5cGVQcm90by5TZXF1ZW5jZTtlLnBvczxuOyl7dmFyIG89ZS51aW50MzIoKTtvPj4+Mz09MT9yLmVsZW1UeXBlPWMub25ueC5UeXBlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk6ZS5za2lwVHlwZSg3Jm8pfXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGF8fChlPW5ldyBhKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmVsZW1UeXBlJiZlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikpe3ZhciB0PWMub25ueC5UeXBlUHJvdG8udmVyaWZ5KGUuZWxlbVR5cGUpO2lmKHQpcmV0dXJuXCJlbGVtVHlwZS5cIit0fXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UeXBlUHJvdG8uU2VxdWVuY2UpcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5UeXBlUHJvdG8uU2VxdWVuY2U7aWYobnVsbCE9ZS5lbGVtVHlwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUuZWxlbVR5cGUpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLlNlcXVlbmNlLmVsZW1UeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5lbGVtVHlwZT1jLm9ubnguVHlwZVByb3RvLmZyb21PYmplY3QoZS5lbGVtVHlwZSl9cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307cmV0dXJuIHQuZGVmYXVsdHMmJihuLmVsZW1UeXBlPW51bGwpLG51bGwhPWUuZWxlbVR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSYmKG4uZWxlbVR5cGU9Yy5vbm54LlR5cGVQcm90by50b09iamVjdChlLmVsZW1UeXBlLHQpKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLHMudXRpbC50b0pTT05PcHRpb25zKX0sZS5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54LlR5cGVQcm90by5TZXF1ZW5jZVwifSxlfSgpLGUuTWFwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZihlKWZvcih2YXIgdD1PYmplY3Qua2V5cyhlKSxuPTA7bjx0Lmxlbmd0aDsrK24pbnVsbCE9ZVt0W25dXSYmKHRoaXNbdFtuXV09ZVt0W25dXSl9cmV0dXJuIGUucHJvdG90eXBlLmtleVR5cGU9MCxlLnByb3RvdHlwZS52YWx1ZVR5cGU9bnVsbCxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUua2V5VHlwZSYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImtleVR5cGVcIikmJnQudWludDMyKDgpLmludDMyKGUua2V5VHlwZSksbnVsbCE9ZS52YWx1ZVR5cGUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJ2YWx1ZVR5cGVcIikmJmMub25ueC5UeXBlUHJvdG8uZW5jb2RlKGUudmFsdWVUeXBlLHQudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIGF8fChlPWEuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UeXBlUHJvdG8uTWFwO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIua2V5VHlwZT1lLmludDMyKCk7YnJlYWs7Y2FzZSAyOnIudmFsdWVUeXBlPWMub25ueC5UeXBlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGF8fChlPW5ldyBhKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLmtleVR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJrZXlUeXBlXCIpJiYhbC5pc0ludGVnZXIoZS5rZXlUeXBlKSlyZXR1cm5cImtleVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtpZihudWxsIT1lLnZhbHVlVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlVHlwZVwiKSl7dmFyIHQ9Yy5vbm54LlR5cGVQcm90by52ZXJpZnkoZS52YWx1ZVR5cGUpO2lmKHQpcmV0dXJuXCJ2YWx1ZVR5cGUuXCIrdH1yZXR1cm4gbnVsbH0sZS5mcm9tT2JqZWN0PWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBjLm9ubnguVHlwZVByb3RvLk1hcClyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlR5cGVQcm90by5NYXA7aWYobnVsbCE9ZS5rZXlUeXBlJiYodC5rZXlUeXBlPTB8ZS5rZXlUeXBlKSxudWxsIT1lLnZhbHVlVHlwZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUudmFsdWVUeXBlKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5NYXAudmFsdWVUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7dC52YWx1ZVR5cGU9Yy5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KGUudmFsdWVUeXBlKX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtyZXR1cm4gdC5kZWZhdWx0cyYmKG4ua2V5VHlwZT0wLG4udmFsdWVUeXBlPW51bGwpLG51bGwhPWUua2V5VHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcImtleVR5cGVcIikmJihuLmtleVR5cGU9ZS5rZXlUeXBlKSxudWxsIT1lLnZhbHVlVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlVHlwZVwiKSYmKG4udmFsdWVUeXBlPWMub25ueC5UeXBlUHJvdG8udG9PYmplY3QoZS52YWx1ZVR5cGUsdCkpLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMscy51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguVHlwZVByb3RvLk1hcFwifSxlfSgpLGUuT3B0aW9uYWw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUuZWxlbVR5cGU9bnVsbCxlLmNyZWF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGUodCl9LGUuZW5jb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fCh0PXUuY3JlYXRlKCkpLG51bGwhPWUuZWxlbVR5cGUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJlbGVtVHlwZVwiKSYmYy5vbm54LlR5cGVQcm90by5lbmNvZGUoZS5lbGVtVHlwZSx0LnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKSx0fSxlLmVuY29kZURlbGltaXRlZD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmVuY29kZShlLHQpLmxkZWxpbSgpfSxlLmRlY29kZT1mdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBhfHwoZT1hLmNyZWF0ZShlKSk7Zm9yKHZhciBuPXZvaWQgMD09PXQ/ZS5sZW46ZS5wb3MrdCxyPW5ldyBjLm9ubnguVHlwZVByb3RvLk9wdGlvbmFsO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO28+Pj4zPT0xP3IuZWxlbVR5cGU9Yy5vbm54LlR5cGVQcm90by5kZWNvZGUoZSxlLnVpbnQzMigpKTplLnNraXBUeXBlKDcmbyl9cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgYXx8KGU9bmV3IGEoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm5cIm9iamVjdCBleHBlY3RlZFwiO2lmKG51bGwhPWUuZWxlbVR5cGUmJmUuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSl7dmFyIHQ9Yy5vbm54LlR5cGVQcm90by52ZXJpZnkoZS5lbGVtVHlwZSk7aWYodClyZXR1cm5cImVsZW1UeXBlLlwiK3R9cmV0dXJuIG51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LlR5cGVQcm90by5PcHRpb25hbClyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54LlR5cGVQcm90by5PcHRpb25hbDtpZihudWxsIT1lLmVsZW1UeXBlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5lbGVtVHlwZSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZWxlbVR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTt0LmVsZW1UeXBlPWMub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChlLmVsZW1UeXBlKX1yZXR1cm4gdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtyZXR1cm4gdC5kZWZhdWx0cyYmKG4uZWxlbVR5cGU9bnVsbCksbnVsbCE9ZS5lbGVtVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpJiYobi5lbGVtVHlwZT1jLm9ubnguVHlwZVByb3RvLnRvT2JqZWN0KGUuZWxlbVR5cGUsdCkpLG59LGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMscy51dGlsLnRvSlNPTk9wdGlvbnMpfSxlLmdldFR5cGVVcmw9ZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwidHlwZS5nb29nbGVhcGlzLmNvbVwiKSxlK1wiL29ubnguVHlwZVByb3RvLk9wdGlvbmFsXCJ9LGV9KCksZS5TcGFyc2VUZW5zb3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe2lmKGUpZm9yKHZhciB0PU9iamVjdC5rZXlzKGUpLG49MDtuPHQubGVuZ3RoOysrbiludWxsIT1lW3Rbbl1dJiYodGhpc1t0W25dXT1lW3Rbbl1dKX1yZXR1cm4gZS5wcm90b3R5cGUuZWxlbVR5cGU9MCxlLnByb3RvdHlwZS5zaGFwZT1udWxsLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5lbGVtVHlwZSYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImVsZW1UeXBlXCIpJiZ0LnVpbnQzMig4KS5pbnQzMihlLmVsZW1UeXBlKSxudWxsIT1lLnNoYXBlJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChlLFwic2hhcGVcIikmJmMub25ueC5UZW5zb3JTaGFwZVByb3RvLmVuY29kZShlLnNoYXBlLHQudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIGF8fChlPWEuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIuZWxlbVR5cGU9ZS5pbnQzMigpO2JyZWFrO2Nhc2UgMjpyLnNoYXBlPWMub25ueC5UZW5zb3JTaGFwZVByb3RvLmRlY29kZShlLGUudWludDMyKCkpO2JyZWFrO2RlZmF1bHQ6ZS5za2lwVHlwZSg3Jm8pfX1yZXR1cm4gcn0sZS5kZWNvZGVEZWxpbWl0ZWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBhfHwoZT1uZXcgYShlKSksdGhpcy5kZWNvZGUoZSxlLnVpbnQzMigpKX0sZS52ZXJpZnk9ZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVyblwib2JqZWN0IGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5lbGVtVHlwZSYmZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpJiYhbC5pc0ludGVnZXIoZS5lbGVtVHlwZSkpcmV0dXJuXCJlbGVtVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO2lmKG51bGwhPWUuc2hhcGUmJmUuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSl7dmFyIHQ9Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5KGUuc2hhcGUpO2lmKHQpcmV0dXJuXCJzaGFwZS5cIit0fXJldHVybiBudWxsfSxlLmZyb21PYmplY3Q9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIGMub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yKXJldHVybiBlO3ZhciB0PW5ldyBjLm9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcjtpZihudWxsIT1lLmVsZW1UeXBlJiYodC5lbGVtVHlwZT0wfGUuZWxlbVR5cGUpLG51bGwhPWUuc2hhcGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlLnNoYXBlKXRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3Iuc2hhcGU6IG9iamVjdCBleHBlY3RlZFwiKTt0LnNoYXBlPWMub25ueC5UZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3QoZS5zaGFwZSl9cmV0dXJuIHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307cmV0dXJuIHQuZGVmYXVsdHMmJihuLmVsZW1UeXBlPTAsbi5zaGFwZT1udWxsKSxudWxsIT1lLmVsZW1UeXBlJiZlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikmJihuLmVsZW1UeXBlPWUuZWxlbVR5cGUpLG51bGwhPWUuc2hhcGUmJmUuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSYmKG4uc2hhcGU9Yy5vbm54LlRlbnNvclNoYXBlUHJvdG8udG9PYmplY3QoZS5zaGFwZSx0KSksbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxzLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXCJ9LGV9KCksZX0oKSxpLk9wZXJhdG9yU2V0SWRQcm90bz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5kb21haW49XCJcIixlLnByb3RvdHlwZS52ZXJzaW9uPWwuTG9uZz9sLkxvbmcuZnJvbUJpdHMoMCwwLCExKTowLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9dS5jcmVhdGUoKSksbnVsbCE9ZS5kb21haW4mJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkb21haW5cIikmJnQudWludDMyKDEwKS5zdHJpbmcoZS5kb21haW4pLG51bGwhPWUudmVyc2lvbiYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcInZlcnNpb25cIikmJnQudWludDMyKDE2KS5pbnQ2NChlLnZlcnNpb24pLHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIGF8fChlPWEuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5PcGVyYXRvclNldElkUHJvdG87ZS5wb3M8bjspe3ZhciBvPWUudWludDMyKCk7c3dpdGNoKG8+Pj4zKXtjYXNlIDE6ci5kb21haW49ZS5zdHJpbmcoKTticmVhaztjYXNlIDI6ci52ZXJzaW9uPWUuaW50NjQoKTticmVhaztkZWZhdWx0OmUuc2tpcFR5cGUoNyZvKX19cmV0dXJuIHJ9LGUuZGVjb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgYXx8KGU9bmV3IGEoZSkpLHRoaXMuZGVjb2RlKGUsZS51aW50MzIoKSl9LGUudmVyaWZ5PWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZT9cIm9iamVjdCBleHBlY3RlZFwiOm51bGwhPWUuZG9tYWluJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYhbC5pc1N0cmluZyhlLmRvbWFpbik/XCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiOm51bGwhPWUudmVyc2lvbiYmZS5oYXNPd25Qcm9wZXJ0eShcInZlcnNpb25cIikmJiEobC5pc0ludGVnZXIoZS52ZXJzaW9uKXx8ZS52ZXJzaW9uJiZsLmlzSW50ZWdlcihlLnZlcnNpb24ubG93KSYmbC5pc0ludGVnZXIoZS52ZXJzaW9uLmhpZ2gpKT9cInZlcnNpb246IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bylyZXR1cm4gZTt2YXIgdD1uZXcgYy5vbm54Lk9wZXJhdG9yU2V0SWRQcm90bztyZXR1cm4gbnVsbCE9ZS5kb21haW4mJih0LmRvbWFpbj1TdHJpbmcoZS5kb21haW4pKSxudWxsIT1lLnZlcnNpb24mJihsLkxvbmc/KHQudmVyc2lvbj1sLkxvbmcuZnJvbVZhbHVlKGUudmVyc2lvbikpLnVuc2lnbmVkPSExOlwic3RyaW5nXCI9PXR5cGVvZiBlLnZlcnNpb24/dC52ZXJzaW9uPXBhcnNlSW50KGUudmVyc2lvbiwxMCk6XCJudW1iZXJcIj09dHlwZW9mIGUudmVyc2lvbj90LnZlcnNpb249ZS52ZXJzaW9uOlwib2JqZWN0XCI9PXR5cGVvZiBlLnZlcnNpb24mJih0LnZlcnNpb249bmV3IGwuTG9uZ0JpdHMoZS52ZXJzaW9uLmxvdz4+PjAsZS52ZXJzaW9uLmhpZ2g+Pj4wKS50b051bWJlcigpKSksdH0sZS50b09iamVjdD1mdW5jdGlvbihlLHQpe3R8fCh0PXt9KTt2YXIgbj17fTtpZih0LmRlZmF1bHRzKWlmKG4uZG9tYWluPVwiXCIsbC5Mb25nKXt2YXIgcj1uZXcgbC5Mb25nKDAsMCwhMSk7bi52ZXJzaW9uPXQubG9uZ3M9PT1TdHJpbmc/ci50b1N0cmluZygpOnQubG9uZ3M9PT1OdW1iZXI/ci50b051bWJlcigpOnJ9ZWxzZSBuLnZlcnNpb249dC5sb25ncz09PVN0cmluZz9cIjBcIjowO3JldHVybiBudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmKG4uZG9tYWluPWUuZG9tYWluKSxudWxsIT1lLnZlcnNpb24mJmUuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpJiYoXCJudW1iZXJcIj09dHlwZW9mIGUudmVyc2lvbj9uLnZlcnNpb249dC5sb25ncz09PVN0cmluZz9TdHJpbmcoZS52ZXJzaW9uKTplLnZlcnNpb246bi52ZXJzaW9uPXQubG9uZ3M9PT1TdHJpbmc/bC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUudmVyc2lvbik6dC5sb25ncz09PU51bWJlcj9uZXcgbC5Mb25nQml0cyhlLnZlcnNpb24ubG93Pj4+MCxlLnZlcnNpb24uaGlnaD4+PjApLnRvTnVtYmVyKCk6ZS52ZXJzaW9uKSxufSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLHMudXRpbC50b0pTT05PcHRpb25zKX0sZS5nZXRUeXBlVXJsPWZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInR5cGUuZ29vZ2xlYXBpcy5jb21cIiksZStcIi9vbm54Lk9wZXJhdG9yU2V0SWRQcm90b1wifSxlfSgpLGkuT3BlcmF0b3JTdGF0dXM9ZnVuY3Rpb24oKXt2YXIgZT17fSx0PU9iamVjdC5jcmVhdGUoZSk7cmV0dXJuIHRbZVswXT1cIkVYUEVSSU1FTlRBTFwiXT0wLHRbZVsxXT1cIlNUQUJMRVwiXT0xLHR9KCksaS5GdW5jdGlvblByb3RvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXtpZih0aGlzLmlucHV0PVtdLHRoaXMub3V0cHV0PVtdLHRoaXMuYXR0cmlidXRlPVtdLHRoaXMuYXR0cmlidXRlUHJvdG89W10sdGhpcy5ub2RlPVtdLHRoaXMub3BzZXRJbXBvcnQ9W10sZSlmb3IodmFyIHQ9T2JqZWN0LmtleXMoZSksbj0wO248dC5sZW5ndGg7KytuKW51bGwhPWVbdFtuXV0mJih0aGlzW3Rbbl1dPWVbdFtuXV0pfXJldHVybiBlLnByb3RvdHlwZS5uYW1lPVwiXCIsZS5wcm90b3R5cGUuaW5wdXQ9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLm91dHB1dD1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuYXR0cmlidXRlPWwuZW1wdHlBcnJheSxlLnByb3RvdHlwZS5hdHRyaWJ1dGVQcm90bz1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUubm9kZT1sLmVtcHR5QXJyYXksZS5wcm90b3R5cGUuZG9jU3RyaW5nPVwiXCIsZS5wcm90b3R5cGUub3BzZXRJbXBvcnQ9bC5lbXB0eUFycmF5LGUucHJvdG90eXBlLmRvbWFpbj1cIlwiLGUuY3JlYXRlPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0sZS5lbmNvZGU9ZnVuY3Rpb24oZSx0KXtpZih0fHwodD11LmNyZWF0ZSgpKSxudWxsIT1lLm5hbWUmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJuYW1lXCIpJiZ0LnVpbnQzMigxMCkuc3RyaW5nKGUubmFtZSksbnVsbCE9ZS5pbnB1dCYmZS5pbnB1dC5sZW5ndGgpZm9yKHZhciBuPTA7bjxlLmlucHV0Lmxlbmd0aDsrK24pdC51aW50MzIoMzQpLnN0cmluZyhlLmlucHV0W25dKTtpZihudWxsIT1lLm91dHB1dCYmZS5vdXRwdXQubGVuZ3RoKWZvcihuPTA7bjxlLm91dHB1dC5sZW5ndGg7KytuKXQudWludDMyKDQyKS5zdHJpbmcoZS5vdXRwdXRbbl0pO2lmKG51bGwhPWUuYXR0cmlidXRlJiZlLmF0dHJpYnV0ZS5sZW5ndGgpZm9yKG49MDtuPGUuYXR0cmlidXRlLmxlbmd0aDsrK24pdC51aW50MzIoNTApLnN0cmluZyhlLmF0dHJpYnV0ZVtuXSk7aWYobnVsbCE9ZS5ub2RlJiZlLm5vZGUubGVuZ3RoKWZvcihuPTA7bjxlLm5vZGUubGVuZ3RoOysrbiljLm9ubnguTm9kZVByb3RvLmVuY29kZShlLm5vZGVbbl0sdC51aW50MzIoNTgpLmZvcmsoKSkubGRlbGltKCk7aWYobnVsbCE9ZS5kb2NTdHJpbmcmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkb2NTdHJpbmdcIikmJnQudWludDMyKDY2KS5zdHJpbmcoZS5kb2NTdHJpbmcpLG51bGwhPWUub3BzZXRJbXBvcnQmJmUub3BzZXRJbXBvcnQubGVuZ3RoKWZvcihuPTA7bjxlLm9wc2V0SW1wb3J0Lmxlbmd0aDsrK24pYy5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUoZS5vcHNldEltcG9ydFtuXSx0LnVpbnQzMig3NCkuZm9yaygpKS5sZGVsaW0oKTtpZihudWxsIT1lLmRvbWFpbiYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZSxcImRvbWFpblwiKSYmdC51aW50MzIoODIpLnN0cmluZyhlLmRvbWFpbiksbnVsbCE9ZS5hdHRyaWJ1dGVQcm90byYmZS5hdHRyaWJ1dGVQcm90by5sZW5ndGgpZm9yKG49MDtuPGUuYXR0cmlidXRlUHJvdG8ubGVuZ3RoOysrbiljLm9ubnguQXR0cmlidXRlUHJvdG8uZW5jb2RlKGUuYXR0cmlidXRlUHJvdG9bbl0sdC51aW50MzIoOTApLmZvcmsoKSkubGRlbGltKCk7cmV0dXJuIHR9LGUuZW5jb2RlRGVsaW1pdGVkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZW5jb2RlKGUsdCkubGRlbGltKCl9LGUuZGVjb2RlPWZ1bmN0aW9uKGUsdCl7ZSBpbnN0YW5jZW9mIGF8fChlPWEuY3JlYXRlKGUpKTtmb3IodmFyIG49dm9pZCAwPT09dD9lLmxlbjplLnBvcyt0LHI9bmV3IGMub25ueC5GdW5jdGlvblByb3RvO2UucG9zPG47KXt2YXIgbz1lLnVpbnQzMigpO3N3aXRjaChvPj4+Myl7Y2FzZSAxOnIubmFtZT1lLnN0cmluZygpO2JyZWFrO2Nhc2UgNDpyLmlucHV0JiZyLmlucHV0Lmxlbmd0aHx8KHIuaW5wdXQ9W10pLHIuaW5wdXQucHVzaChlLnN0cmluZygpKTticmVhaztjYXNlIDU6ci5vdXRwdXQmJnIub3V0cHV0Lmxlbmd0aHx8KHIub3V0cHV0PVtdKSxyLm91dHB1dC5wdXNoKGUuc3RyaW5nKCkpO2JyZWFrO2Nhc2UgNjpyLmF0dHJpYnV0ZSYmci5hdHRyaWJ1dGUubGVuZ3RofHwoci5hdHRyaWJ1dGU9W10pLHIuYXR0cmlidXRlLnB1c2goZS5zdHJpbmcoKSk7YnJlYWs7Y2FzZSAxMTpyLmF0dHJpYnV0ZVByb3RvJiZyLmF0dHJpYnV0ZVByb3RvLmxlbmd0aHx8KHIuYXR0cmlidXRlUHJvdG89W10pLHIuYXR0cmlidXRlUHJvdG8ucHVzaChjLm9ubnguQXR0cmlidXRlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgNzpyLm5vZGUmJnIubm9kZS5sZW5ndGh8fChyLm5vZGU9W10pLHIubm9kZS5wdXNoKGMub25ueC5Ob2RlUHJvdG8uZGVjb2RlKGUsZS51aW50MzIoKSkpO2JyZWFrO2Nhc2UgODpyLmRvY1N0cmluZz1lLnN0cmluZygpO2JyZWFrO2Nhc2UgOTpyLm9wc2V0SW1wb3J0JiZyLm9wc2V0SW1wb3J0Lmxlbmd0aHx8KHIub3BzZXRJbXBvcnQ9W10pLHIub3BzZXRJbXBvcnQucHVzaChjLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZShlLGUudWludDMyKCkpKTticmVhaztjYXNlIDEwOnIuZG9tYWluPWUuc3RyaW5nKCk7YnJlYWs7ZGVmYXVsdDplLnNraXBUeXBlKDcmbyl9fXJldHVybiByfSxlLmRlY29kZURlbGltaXRlZD1mdW5jdGlvbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGF8fChlPW5ldyBhKGUpKSx0aGlzLmRlY29kZShlLGUudWludDMyKCkpfSxlLnZlcmlmeT1mdW5jdGlvbihlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZXx8bnVsbD09PWUpcmV0dXJuXCJvYmplY3QgZXhwZWN0ZWRcIjtpZihudWxsIT1lLm5hbWUmJmUuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpJiYhbC5pc1N0cmluZyhlLm5hbWUpKXJldHVyblwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7aWYobnVsbCE9ZS5pbnB1dCYmZS5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKXtpZighQXJyYXkuaXNBcnJheShlLmlucHV0KSlyZXR1cm5cImlucHV0OiBhcnJheSBleHBlY3RlZFwiO2Zvcih2YXIgdD0wO3Q8ZS5pbnB1dC5sZW5ndGg7Kyt0KWlmKCFsLmlzU3RyaW5nKGUuaW5wdXRbdF0pKXJldHVyblwiaW5wdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9ZS5vdXRwdXQmJmUuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpe2lmKCFBcnJheS5pc0FycmF5KGUub3V0cHV0KSlyZXR1cm5cIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5vdXRwdXQubGVuZ3RoOysrdClpZighbC5pc1N0cmluZyhlLm91dHB1dFt0XSkpcmV0dXJuXCJvdXRwdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9ZS5hdHRyaWJ1dGUmJmUuaGFzT3duUHJvcGVydHkoXCJhdHRyaWJ1dGVcIikpe2lmKCFBcnJheS5pc0FycmF5KGUuYXR0cmlidXRlKSlyZXR1cm5cImF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5hdHRyaWJ1dGUubGVuZ3RoOysrdClpZighbC5pc1N0cmluZyhlLmF0dHJpYnV0ZVt0XSkpcmV0dXJuXCJhdHRyaWJ1dGU6IHN0cmluZ1tdIGV4cGVjdGVkXCJ9aWYobnVsbCE9ZS5hdHRyaWJ1dGVQcm90byYmZS5oYXNPd25Qcm9wZXJ0eShcImF0dHJpYnV0ZVByb3RvXCIpKXtpZighQXJyYXkuaXNBcnJheShlLmF0dHJpYnV0ZVByb3RvKSlyZXR1cm5cImF0dHJpYnV0ZVByb3RvOiBhcnJheSBleHBlY3RlZFwiO2Zvcih0PTA7dDxlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsrK3QpaWYobj1jLm9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5KGUuYXR0cmlidXRlUHJvdG9bdF0pKXJldHVyblwiYXR0cmlidXRlUHJvdG8uXCIrbn1pZihudWxsIT1lLm5vZGUmJmUuaGFzT3duUHJvcGVydHkoXCJub2RlXCIpKXtpZighQXJyYXkuaXNBcnJheShlLm5vZGUpKXJldHVyblwibm9kZTogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5ub2RlLmxlbmd0aDsrK3QpaWYobj1jLm9ubnguTm9kZVByb3RvLnZlcmlmeShlLm5vZGVbdF0pKXJldHVyblwibm9kZS5cIitufWlmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYhbC5pc1N0cmluZyhlLmRvY1N0cmluZykpcmV0dXJuXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO2lmKG51bGwhPWUub3BzZXRJbXBvcnQmJmUuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSl7aWYoIUFycmF5LmlzQXJyYXkoZS5vcHNldEltcG9ydCkpcmV0dXJuXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtmb3IodD0wO3Q8ZS5vcHNldEltcG9ydC5sZW5ndGg7Kyt0KXt2YXIgbjtpZihuPWMub25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5KGUub3BzZXRJbXBvcnRbdF0pKXJldHVyblwib3BzZXRJbXBvcnQuXCIrbn19cmV0dXJuIG51bGwhPWUuZG9tYWluJiZlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpJiYhbC5pc1N0cmluZyhlLmRvbWFpbik/XCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiOm51bGx9LGUuZnJvbU9iamVjdD1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgYy5vbm54LkZ1bmN0aW9uUHJvdG8pcmV0dXJuIGU7dmFyIHQ9bmV3IGMub25ueC5GdW5jdGlvblByb3RvO2lmKG51bGwhPWUubmFtZSYmKHQubmFtZT1TdHJpbmcoZS5uYW1lKSksZS5pbnB1dCl7aWYoIUFycmF5LmlzQXJyYXkoZS5pbnB1dCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7dC5pbnB1dD1bXTtmb3IodmFyIG49MDtuPGUuaW5wdXQubGVuZ3RoOysrbil0LmlucHV0W25dPVN0cmluZyhlLmlucHV0W25dKX1pZihlLm91dHB1dCl7aWYoIUFycmF5LmlzQXJyYXkoZS5vdXRwdXQpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkZ1bmN0aW9uUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtmb3IodC5vdXRwdXQ9W10sbj0wO248ZS5vdXRwdXQubGVuZ3RoOysrbil0Lm91dHB1dFtuXT1TdHJpbmcoZS5vdXRwdXRbbl0pfWlmKGUuYXR0cmlidXRlKXtpZighQXJyYXkuaXNBcnJheShlLmF0dHJpYnV0ZSkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCIpO2Zvcih0LmF0dHJpYnV0ZT1bXSxuPTA7bjxlLmF0dHJpYnV0ZS5sZW5ndGg7KytuKXQuYXR0cmlidXRlW25dPVN0cmluZyhlLmF0dHJpYnV0ZVtuXSl9aWYoZS5hdHRyaWJ1dGVQcm90byl7aWYoIUFycmF5LmlzQXJyYXkoZS5hdHRyaWJ1dGVQcm90bykpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5hdHRyaWJ1dGVQcm90bzogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQuYXR0cmlidXRlUHJvdG89W10sbj0wO248ZS5hdHRyaWJ1dGVQcm90by5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5hdHRyaWJ1dGVQcm90b1tuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLmF0dHJpYnV0ZVByb3RvOiBvYmplY3QgZXhwZWN0ZWRcIik7dC5hdHRyaWJ1dGVQcm90b1tuXT1jLm9ubnguQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdChlLmF0dHJpYnV0ZVByb3RvW25dKX19aWYoZS5ub2RlKXtpZighQXJyYXkuaXNBcnJheShlLm5vZGUpKXRocm93IFR5cGVFcnJvcihcIi5vbm54LkZ1bmN0aW9uUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQubm9kZT1bXSxuPTA7bjxlLm5vZGUubGVuZ3RoOysrbil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUubm9kZVtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm5vZGU6IG9iamVjdCBleHBlY3RlZFwiKTt0Lm5vZGVbbl09Yy5vbm54Lk5vZGVQcm90by5mcm9tT2JqZWN0KGUubm9kZVtuXSl9fWlmKG51bGwhPWUuZG9jU3RyaW5nJiYodC5kb2NTdHJpbmc9U3RyaW5nKGUuZG9jU3RyaW5nKSksZS5vcHNldEltcG9ydCl7aWYoIUFycmF5LmlzQXJyYXkoZS5vcHNldEltcG9ydCkpdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIik7Zm9yKHQub3BzZXRJbXBvcnQ9W10sbj0wO248ZS5vcHNldEltcG9ydC5sZW5ndGg7KytuKXtpZihcIm9iamVjdFwiIT10eXBlb2YgZS5vcHNldEltcG9ydFtuXSl0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm9wc2V0SW1wb3J0OiBvYmplY3QgZXhwZWN0ZWRcIik7dC5vcHNldEltcG9ydFtuXT1jLm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLmZyb21PYmplY3QoZS5vcHNldEltcG9ydFtuXSl9fXJldHVybiBudWxsIT1lLmRvbWFpbiYmKHQuZG9tYWluPVN0cmluZyhlLmRvbWFpbikpLHR9LGUudG9PYmplY3Q9ZnVuY3Rpb24oZSx0KXt0fHwodD17fSk7dmFyIG49e307aWYoKHQuYXJyYXlzfHx0LmRlZmF1bHRzKSYmKG4uaW5wdXQ9W10sbi5vdXRwdXQ9W10sbi5hdHRyaWJ1dGU9W10sbi5ub2RlPVtdLG4ub3BzZXRJbXBvcnQ9W10sbi5hdHRyaWJ1dGVQcm90bz1bXSksdC5kZWZhdWx0cyYmKG4ubmFtZT1cIlwiLG4uZG9jU3RyaW5nPVwiXCIsbi5kb21haW49XCJcIiksbnVsbCE9ZS5uYW1lJiZlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSYmKG4ubmFtZT1lLm5hbWUpLGUuaW5wdXQmJmUuaW5wdXQubGVuZ3RoKXtuLmlucHV0PVtdO2Zvcih2YXIgcj0wO3I8ZS5pbnB1dC5sZW5ndGg7KytyKW4uaW5wdXRbcl09ZS5pbnB1dFtyXX1pZihlLm91dHB1dCYmZS5vdXRwdXQubGVuZ3RoKWZvcihuLm91dHB1dD1bXSxyPTA7cjxlLm91dHB1dC5sZW5ndGg7KytyKW4ub3V0cHV0W3JdPWUub3V0cHV0W3JdO2lmKGUuYXR0cmlidXRlJiZlLmF0dHJpYnV0ZS5sZW5ndGgpZm9yKG4uYXR0cmlidXRlPVtdLHI9MDtyPGUuYXR0cmlidXRlLmxlbmd0aDsrK3Ipbi5hdHRyaWJ1dGVbcl09ZS5hdHRyaWJ1dGVbcl07aWYoZS5ub2RlJiZlLm5vZGUubGVuZ3RoKWZvcihuLm5vZGU9W10scj0wO3I8ZS5ub2RlLmxlbmd0aDsrK3Ipbi5ub2RlW3JdPWMub25ueC5Ob2RlUHJvdG8udG9PYmplY3QoZS5ub2RlW3JdLHQpO2lmKG51bGwhPWUuZG9jU3RyaW5nJiZlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpJiYobi5kb2NTdHJpbmc9ZS5kb2NTdHJpbmcpLGUub3BzZXRJbXBvcnQmJmUub3BzZXRJbXBvcnQubGVuZ3RoKWZvcihuLm9wc2V0SW1wb3J0PVtdLHI9MDtyPGUub3BzZXRJbXBvcnQubGVuZ3RoOysrciluLm9wc2V0SW1wb3J0W3JdPWMub25ueC5PcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QoZS5vcHNldEltcG9ydFtyXSx0KTtpZihudWxsIT1lLmRvbWFpbiYmZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSYmKG4uZG9tYWluPWUuZG9tYWluKSxlLmF0dHJpYnV0ZVByb3RvJiZlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aClmb3Iobi5hdHRyaWJ1dGVQcm90bz1bXSxyPTA7cjxlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsrK3Ipbi5hdHRyaWJ1dGVQcm90b1tyXT1jLm9ubnguQXR0cmlidXRlUHJvdG8udG9PYmplY3QoZS5hdHRyaWJ1dGVQcm90b1tyXSx0KTtyZXR1cm4gbn0sZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcyxzLnV0aWwudG9KU09OT3B0aW9ucyl9LGUuZ2V0VHlwZVVybD1mdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpLGUrXCIvb25ueC5GdW5jdGlvblByb3RvXCJ9LGV9KCksaSksZS5leHBvcnRzPWN9LDM0NzQ6KGUsdCxuKT0+e3ZhciBfc2NyaXB0RGlyLHI9KF9zY3JpcHREaXI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCxcInVuZGVmaW5lZFwiIT10eXBlb2YgX19maWxlbmFtZSYmKF9zY3JpcHREaXI9X3NjcmlwdERpcnx8X19maWxlbmFtZSksZnVuY3Rpb24oZT17fSl7ZnVuY3Rpb24gdCgpe3JldHVybiBELmJ1ZmZlciE9Ti5idWZmZXImJlUoKSxOfWZ1bmN0aW9uIHIoKXtyZXR1cm4gRC5idWZmZXIhPU4uYnVmZmVyJiZVKCksTH1mdW5jdGlvbiBvKCl7cmV0dXJuIEQuYnVmZmVyIT1OLmJ1ZmZlciYmVSgpLEN9ZnVuY3Rpb24gaSgpe3JldHVybiBELmJ1ZmZlciE9Ti5idWZmZXImJlUoKSxSfWZ1bmN0aW9uIHMoKXtyZXR1cm4gRC5idWZmZXIhPU4uYnVmZmVyJiZVKCksan12YXIgYSx1LGw9ZTtsLnJlYWR5PW5ldyBQcm9taXNlKCgoZSx0KT0+e2E9ZSx1PXR9KSk7dmFyIGMscCxkLGY9T2JqZWN0LmFzc2lnbih7fSxsKSxoPVwiLi90aGlzLnByb2dyYW1cIixnPShlLHQpPT57dGhyb3cgdH0sYj1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LG09XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyx5PVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxfPWwuRU5WSVJPTk1FTlRfSVNfUFRIUkVBRHx8ITEsdj1cIlwiO2Z1bmN0aW9uIFQoZSl7cmV0dXJuIGwubG9jYXRlRmlsZT9sLmxvY2F0ZUZpbGUoZSx2KTp2K2V9aWYoeSl7dmFyIHg9big2MjMxKSx3PW4oMTQyMyk7bGV0IHQ7dj1tP3cuZGlybmFtZSh2KStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsYz0oZSx0KT0+KGU9ZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGUpOncubm9ybWFsaXplKGUpLHgucmVhZEZpbGVTeW5jKGUsdD92b2lkIDA6XCJ1dGY4XCIpKSxkPWU9PigoZT1jKGUsITApKS5idWZmZXJ8fChlPW5ldyBVaW50OEFycmF5KGUpKSxlKSxwPShlLHQsbixyPSEwKT0+e2U9ZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGUpOncubm9ybWFsaXplKGUpLHgucmVhZEZpbGUoZSxyP3ZvaWQgMDpcInV0ZjhcIiwoKGUsbyk9PntlP24oZSk6dChyP28uYnVmZmVyOm8pfSkpfSwhbC50aGlzUHJvZ3JhbSYmMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYoaD1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLGc9KGUsdCk9Pnt0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWUsdH0sbC5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCI7dHJ5e3Q9big0NTY0KX1jYXRjaChlKXt0aHJvdyBjb25zb2xlLmVycm9yKCdUaGUgXCJ3b3JrZXJfdGhyZWFkc1wiIG1vZHVsZSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgbm9kZS5qcyBidWlsZCAtIHBlcmhhcHMgYSBuZXdlciB2ZXJzaW9uIGlzIG5lZWRlZD8nKSxlfWdsb2JhbC5Xb3JrZXI9dC5Xb3JrZXJ9ZWxzZShifHxtKSYmKG0/dj1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYodj1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKHY9X3NjcmlwdERpciksdj0wIT09di5pbmRleE9mKFwiYmxvYjpcIik/di5zdWJzdHIoMCx2LnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIseXx8KGM9ZT0+e3ZhciB0PW5ldyBYTUxIdHRwUmVxdWVzdDtyZXR1cm4gdC5vcGVuKFwiR0VUXCIsZSwhMSksdC5zZW5kKG51bGwpLHQucmVzcG9uc2VUZXh0fSxtJiYoZD1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oXCJHRVRcIixlLCExKSx0LnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsdC5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHQucmVzcG9uc2UpfSkscD0oZSx0LG4pPT57dmFyIHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3Iub3BlbihcIkdFVFwiLGUsITApLHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixyLm9ubG9hZD0oKT0+ezIwMD09ci5zdGF0dXN8fDA9PXIuc3RhdHVzJiZyLnJlc3BvbnNlP3Qoci5yZXNwb25zZSk6bigpfSxyLm9uZXJyb3I9bixyLnNlbmQobnVsbCl9KSk7eSYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIHBlcmZvcm1hbmNlJiYoZ2xvYmFsLnBlcmZvcm1hbmNlPW4oNDk4KS5wZXJmb3JtYW5jZSk7dmFyIE89Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxTPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTt5JiYoTz0oLi4uZSk9Pngud3JpdGVTeW5jKDEsZS5qb2luKFwiIFwiKStcIlxcblwiKSxTPSguLi5lKT0+eC53cml0ZVN5bmMoMixlLmpvaW4oXCIgXCIpK1wiXFxuXCIpKTt2YXIgQSxQPWwucHJpbnR8fE8sST1sLnByaW50RXJyfHxTO09iamVjdC5hc3NpZ24obCxmKSxmPW51bGwsbC50aGlzUHJvZ3JhbSYmKGg9bC50aGlzUHJvZ3JhbSksbC5xdWl0JiYoZz1sLnF1aXQpLGwud2FzbUJpbmFyeSYmKEE9bC53YXNtQmluYXJ5KTt2YXIgRT1sLm5vRXhpdFJ1bnRpbWV8fCEwO1wib2JqZWN0XCIhPXR5cGVvZiBXZWJBc3NlbWJseSYmdGUoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBELCQsayxGLE4sTCxDLFIsaixNPSExO2Z1bmN0aW9uIFUoKXt2YXIgZT1ELmJ1ZmZlcjtsLkhFQVA4PU49bmV3IEludDhBcnJheShlKSxsLkhFQVAxNj1uZXcgSW50MTZBcnJheShlKSxsLkhFQVAzMj1DPW5ldyBJbnQzMkFycmF5KGUpLGwuSEVBUFU4PUw9bmV3IFVpbnQ4QXJyYXkoZSksbC5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShlKSxsLkhFQVBVMzI9Uj1uZXcgVWludDMyQXJyYXkoZSksbC5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoZSksbC5IRUFQRjY0PWo9bmV3IEZsb2F0NjRBcnJheShlKX12YXIgQj1sLklOSVRJQUxfTUVNT1JZfHwxNjc3NzIxNjtpZig1MjQyODgwPD1CfHx0ZShcIklOSVRJQUxfTUVNT1JZIHNob3VsZCBiZSBsYXJnZXIgdGhhbiBTVEFDS19TSVpFLCB3YXMgXCIrQitcIiEgKFNUQUNLX1NJWkU9NTI0Mjg4MClcIiksXylEPWwud2FzbU1lbW9yeTtlbHNlIGlmKGwud2FzbU1lbW9yeSlEPWwud2FzbU1lbW9yeTtlbHNlIGlmKCEoKEQ9bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpCLzY1NTM2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKSl0aHJvdyBJKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLHkmJkkoXCIob24gbm9kZSB5b3UgbWF5IG5lZWQ6IC0tZXhwZXJpbWVudGFsLXdhc20tdGhyZWFkcyAtLWV4cGVyaW1lbnRhbC13YXNtLWJ1bGstbWVtb3J5IGFuZC9vciByZWNlbnQgdmVyc2lvbilcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpO1UoKSxCPUQuYnVmZmVyLmJ5dGVMZW5ndGg7dmFyIFYsej1bXSxHPVtdLEg9W10scT0wO2Z1bmN0aW9uIFcoKXtyZXR1cm4gRXx8MDxxfXZhciBYLFksSz0wLEo9bnVsbCxaPW51bGw7ZnVuY3Rpb24gUSgpe0srKyxsLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmwubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhLKX1mdW5jdGlvbiBlZSgpe2lmKEstLSxsLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJmwubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhLKSwwPT1LJiYobnVsbCE9PUomJihjbGVhckludGVydmFsKEopLEo9bnVsbCksWikpe3ZhciBlPVo7Wj1udWxsLGUoKX19ZnVuY3Rpb24gdGUoZSl7dGhyb3cgbC5vbkFib3J0JiZsLm9uQWJvcnQoZSksSShlPVwiQWJvcnRlZChcIitlK1wiKVwiKSxNPSEwLEY9MSxlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoZStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksdShlKSxlfWZ1bmN0aW9uIG5lKGUpe3JldHVybiBlLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpfWZ1bmN0aW9uIHJlKGUpe2lmKGU9PVgmJkEpcmV0dXJuIG5ldyBVaW50OEFycmF5KEEpO2lmKGQpcmV0dXJuIGQoZSk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gb2UoZSx0LG4pe3JldHVybiBmdW5jdGlvbihlKXtpZighQSYmKGJ8fG0pKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIWUuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKHQ9PntpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIrZStcIidcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKCgoKT0+cmUoZSkpKTtpZihwKXJldHVybiBuZXcgUHJvbWlzZSgoKHQsbik9PntwKGUsKGU9PnQobmV3IFVpbnQ4QXJyYXkoZSkpKSxuKX0pKX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKCk9PnJlKGUpKSl9KGUpLnRoZW4oKGU9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUsdCkpKS50aGVuKChlPT5lKSkudGhlbihuLChlPT57SShcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK2UpLHRlKGUpfSkpfWZ1bmN0aW9uIGllKGUpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtlfSlgLHRoaXMuc3RhdHVzPWV9ZnVuY3Rpb24gc2UoZSl7ZS50ZXJtaW5hdGUoKSxlLm9ubWVzc2FnZT0oKT0+e319ZnVuY3Rpb24gYWUoZSl7KGU9aGUuRmFbZV0pfHx0ZSgpLGhlLmZiKGUpfWZ1bmN0aW9uIHVlKGUpe3ZhciB0PWhlLlphKCk7aWYoIXQpcmV0dXJuIDY7aGUuSWEucHVzaCh0KSxoZS5GYVtlLkhhXT10LHQuSGE9ZS5IYTt2YXIgbj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTplLmdiLGFyZzplLllhLHB0aHJlYWRfcHRyOmUuSGF9O3JldHVybiB5JiZ0LnVucmVmKCksdC5wb3N0TWVzc2FnZShuLGUubWIpLDB9bmUoWD1cIm9ydC13YXNtLXRocmVhZGVkLndhc21cIil8fChYPVQoWCkpO3ZhciBsZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsY2U9KGUsdCxuKT0+e3ZhciByPSh0Pj4+PTApK247Zm9yKG49dDtlW25dJiYhKG4+PXIpOykrK247aWYoMTY8bi10JiZlLmJ1ZmZlciYmbGUpcmV0dXJuIGxlLmRlY29kZShlLmJ1ZmZlciBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyP2Uuc2xpY2UodCxuKTplLnN1YmFycmF5KHQsbikpO2ZvcihyPVwiXCI7dDxuOyl7dmFyIG89ZVt0KytdO2lmKDEyOCZvKXt2YXIgaT02MyZlW3QrK107aWYoMTkyPT0oMjI0Jm8pKXIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJm8pPDw2fGkpO2Vsc2V7dmFyIHM9NjMmZVt0KytdOzY1NTM2PihvPTIyND09KDI0MCZvKT8oMTUmbyk8PDEyfGk8PDZ8czooNyZvKTw8MTh8aTw8MTJ8czw8Nnw2MyZlW3QrK10pP3IrPVN0cmluZy5mcm9tQ2hhckNvZGUobyk6KG8tPTY1NTM2LHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8bz4+MTAsNTYzMjB8MTAyMyZvKSl9fWVsc2Ugcis9U3RyaW5nLmZyb21DaGFyQ29kZShvKX1yZXR1cm4gcn0scGU9KGUsdCk9PihlPj4+PTApP2NlKHIoKSxlLHQpOlwiXCI7ZnVuY3Rpb24gZGUoZSl7aWYoXylyZXR1cm4gV2UoMSwxLGUpO0Y9ZSxXKCl8fChoZS5oYigpLGwub25FeGl0JiZsLm9uRXhpdChlKSxNPSEwKSxnKGUsbmV3IGllKGUpKX12YXIgZmU9ZT0+e2lmKEY9ZSxfKXRocm93IGJlKGUpLFwidW53aW5kXCI7ZGUoZSl9LGhlPXtMYTpbXSxJYTpbXSxUYTpbXSxGYTp7fSxQYTpmdW5jdGlvbigpe18/aGUuYWIoKTpoZS4kYSgpfSwkYTpmdW5jdGlvbigpe3oudW5zaGlmdCgoKCk9PntRKCksaGUuYmIoKCgpPT5lZSgpKSl9KSl9LGFiOmZ1bmN0aW9uKCl7aGUucmVjZWl2ZU9iamVjdFRyYW5zZmVyPWhlLmViLGhlLnRocmVhZEluaXRUTFM9aGUuU2EsaGUuc2V0RXhpdFN0YXR1cz1oZS5SYSxFPSExfSxSYTpmdW5jdGlvbihlKXtGPWV9LHJiOltcIiR0ZXJtaW5hdGVXb3JrZXJcIl0saGI6ZnVuY3Rpb24oKXtmb3IodmFyIGUgb2YgaGUuSWEpc2UoZSk7Zm9yKGUgb2YgaGUuTGEpc2UoZSk7aGUuTGE9W10saGUuSWE9W10saGUuRmE9W119LGZiOmZ1bmN0aW9uKGUpe3ZhciB0PWUuSGE7ZGVsZXRlIGhlLkZhW3RdLGhlLkxhLnB1c2goZSksaGUuSWEuc3BsaWNlKGhlLklhLmluZGV4T2YoZSksMSksZS5IYT0wLG10KHQpfSxlYjpmdW5jdGlvbigpe30sU2E6ZnVuY3Rpb24oKXtoZS5UYS5mb3JFYWNoKChlPT5lKCkpKX0sY2I6ZT0+bmV3IFByb21pc2UoKHQ9PntlLm9ubWVzc2FnZT1uPT57dmFyIHI9KG49bi5kYXRhKS5jbWQ7aWYobi50YXJnZXRUaHJlYWQmJm4udGFyZ2V0VGhyZWFkIT1kdCgpKXt2YXIgbz1oZS5GYVtuLnFiXTtvP28ucG9zdE1lc3NhZ2UobixuLnRyYW5zZmVyTGlzdCk6SSgnSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIicrcisnXCIgdG8gdGFyZ2V0IHB0aHJlYWQgJytuLnRhcmdldFRocmVhZCtcIiwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhXCIpfWVsc2VcImNoZWNrTWFpbGJveFwiPT09cj9NZSgpOlwic3Bhd25UaHJlYWRcIj09PXI/dWUobik6XCJjbGVhbnVwVGhyZWFkXCI9PT1yP2FlKG4udGhyZWFkKTpcImtpbGxUaHJlYWRcIj09PXI/KG49bi50aHJlYWQscj1oZS5GYVtuXSxkZWxldGUgaGUuRmFbbl0sc2UociksbXQobiksaGUuSWEuc3BsaWNlKGhlLklhLmluZGV4T2YociksMSksci5IYT0wKTpcImNhbmNlbFRocmVhZFwiPT09cj9oZS5GYVtuLnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6XCJsb2FkZWRcIj09PXI/KGUubG9hZGVkPSEwLHQoZSkpOlwiYWxlcnRcIj09PXI/YWxlcnQoXCJUaHJlYWQgXCIrbi50aHJlYWRJZCtcIjogXCIrbi50ZXh0KTpcInNldGltbWVkaWF0ZVwiPT09bi50YXJnZXQ/ZS5wb3N0TWVzc2FnZShuKTpcImNhbGxIYW5kbGVyXCI9PT1yP2xbbi5oYW5kbGVyXSguLi5uLmFyZ3MpOnImJkkoXCJ3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgXCIrcil9LGUub25lcnJvcj1lPT57dGhyb3cgSShcIndvcmtlciBzZW50IGFuIGVycm9yISBcIitlLmZpbGVuYW1lK1wiOlwiK2UubGluZW5vK1wiOiBcIitlLm1lc3NhZ2UpLGV9LHkmJihlLm9uKFwibWVzc2FnZVwiLChmdW5jdGlvbih0KXtlLm9ubWVzc2FnZSh7ZGF0YTp0fSl9KSksZS5vbihcImVycm9yXCIsKGZ1bmN0aW9uKHQpe2Uub25lcnJvcih0KX0pKSk7dmFyIG4scj1bXTtmb3IobiBvZltcIm9uRXhpdFwiLFwib25BYm9ydFwiLFwicHJpbnRcIixcInByaW50RXJyXCJdKWwuaGFzT3duUHJvcGVydHkobikmJnIucHVzaChuKTtlLnBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkXCIsaGFuZGxlcnM6cix1cmxPckJsb2I6bC5tYWluU2NyaXB0VXJsT3JCbG9ifHxfc2NyaXB0RGlyLHdhc21NZW1vcnk6RCx3YXNtTW9kdWxlOmt9KX0pKSxiYjpmdW5jdGlvbihlKXtlKCl9LFhhOmZ1bmN0aW9uKCl7dmFyIGU9VChcIm9ydC13YXNtLXRocmVhZGVkLndvcmtlci5qc1wiKTtlPW5ldyBXb3JrZXIoZSksaGUuTGEucHVzaChlKX0sWmE6ZnVuY3Rpb24oKXtyZXR1cm4gMD09aGUuTGEubGVuZ3RoJiYoaGUuWGEoKSxoZS5jYihoZS5MYVswXSkpLGhlLkxhLnBvcCgpfX07bC5QVGhyZWFkPWhlO3ZhciBnZT1lPT57Zm9yKDswPGUubGVuZ3RoOyllLnNoaWZ0KCkobCl9O2Z1bmN0aW9uIGJlKGUpe2lmKF8pcmV0dXJuIFdlKDIsMCxlKTtmZShlKX1sLmVzdGFibGlzaFN0YWNrU3BhY2U9ZnVuY3Rpb24oKXt2YXIgZT1kdCgpLHQ9bygpW2UrNTI+PjI+Pj4wXTtlPW8oKVtlKzU2Pj4yPj4+MF0sVHQodCx0LWUpLHd0KHQpfTt2YXIgbWU9W107ZnVuY3Rpb24geWUoZSl7dGhpcy5PYT1lLTI0LHRoaXMuV2E9ZnVuY3Rpb24oZSl7aSgpW3RoaXMuT2ErND4+Mj4+PjBdPWV9LHRoaXMuVmE9ZnVuY3Rpb24oZSl7aSgpW3RoaXMuT2ErOD4+Mj4+PjBdPWV9LHRoaXMuUGE9ZnVuY3Rpb24oZSx0KXt0aGlzLlVhKCksdGhpcy5XYShlKSx0aGlzLlZhKHQpfSx0aGlzLlVhPWZ1bmN0aW9uKCl7aSgpW3RoaXMuT2ErMTY+PjI+Pj4wXT0wfX1mdW5jdGlvbiBfZShlLHQsbixyKXtyZXR1cm4gXz9XZSgzLDEsZSx0LG4scik6dmUoZSx0LG4scil9ZnVuY3Rpb24gdmUoZSx0LG4scil7aWYoZT4+Pj0wLHQ+Pj49MCxuPj4+PTAscj4+Pj0wLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcilyZXR1cm4gSShcIkN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBTaGFyZWRBcnJheUJ1ZmZlciwgcHRocmVhZHMgYXJlIG5vdCBhdmFpbGFibGUhXCIpLDY7dmFyIG89W107cmV0dXJuIF8mJjA9PT1vLmxlbmd0aD9fZShlLHQsbixyKTooZT17Z2I6bixIYTplLFlhOnIsbWI6b30sXz8oZS5vYj1cInNwYXduVGhyZWFkXCIscG9zdE1lc3NhZ2UoZSxvKSwwKTp1ZShlKSl9ZnVuY3Rpb24gVGUoZSx0LG4pe3JldHVybiBfP1dlKDQsMSxlLHQsbik6MH1mdW5jdGlvbiB4ZShlLHQpe2lmKF8pcmV0dXJuIFdlKDUsMSxlLHQpfWwuaW52b2tlRW50cnlQb2ludD1mdW5jdGlvbihlLHQpe3ZhciBuPW1lW2VdO258fChlPj1tZS5sZW5ndGgmJihtZS5sZW5ndGg9ZSsxKSxtZVtlXT1uPVYuZ2V0KGUpKSxlPW4odCksVygpP2hlLlJhKGUpOnl0KGUpfTt2YXIgd2U9ZT0+e2Zvcih2YXIgdD0wLG49MDtuPGUubGVuZ3RoOysrbil7dmFyIHI9ZS5jaGFyQ29kZUF0KG4pOzEyNz49cj90Kys6MjA0Nz49cj90Kz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8odCs9NCwrK24pOnQrPTN9cmV0dXJuIHR9LE9lPShlLHQsbixyKT0+e2lmKCEoMDxyKSlyZXR1cm4gMDt2YXIgbz1uPj4+PTA7cj1uK3ItMTtmb3IodmFyIGk9MDtpPGUubGVuZ3RoOysraSl7dmFyIHM9ZS5jaGFyQ29kZUF0KGkpO2lmKDU1Mjk2PD1zJiY1NzM0Mz49cyYmKHM9NjU1MzYrKCgxMDIzJnMpPDwxMCl8MTAyMyZlLmNoYXJDb2RlQXQoKytpKSksMTI3Pj1zKXtpZihuPj1yKWJyZWFrO3RbbisrPj4+MF09c31lbHNle2lmKDIwNDc+PXMpe2lmKG4rMT49cilicmVhazt0W24rKz4+PjBdPTE5MnxzPj42fWVsc2V7aWYoNjU1MzU+PXMpe2lmKG4rMj49cilicmVhazt0W24rKz4+PjBdPTIyNHxzPj4xMn1lbHNle2lmKG4rMz49cilicmVhazt0W24rKz4+PjBdPTI0MHxzPj4xOCx0W24rKz4+PjBdPTEyOHxzPj4xMiY2M310W24rKz4+PjBdPTEyOHxzPj42JjYzfXRbbisrPj4+MF09MTI4fDYzJnN9fXJldHVybiB0W24+Pj4wXT0wLG4tb30sU2U9KGUsdCxuKT0+T2UoZSxyKCksdCxuKTtmdW5jdGlvbiBBZShlLHQpe2lmKF8pcmV0dXJuIFdlKDYsMSxlLHQpfWZ1bmN0aW9uIFBlKGUsdCxuKXtpZihfKXJldHVybiBXZSg3LDEsZSx0LG4pfWZ1bmN0aW9uIEllKGUsdCxuKXtyZXR1cm4gXz9XZSg4LDEsZSx0LG4pOjB9ZnVuY3Rpb24gRWUoZSx0KXtpZihfKXJldHVybiBXZSg5LDEsZSx0KX1mdW5jdGlvbiBEZShlLHQsbil7aWYoXylyZXR1cm4gV2UoMTAsMSxlLHQsbil9ZnVuY3Rpb24gJGUoZSx0LG4scil7aWYoXylyZXR1cm4gV2UoMTEsMSxlLHQsbixyKX1mdW5jdGlvbiBrZShlLHQsbixyKXtpZihfKXJldHVybiBXZSgxMiwxLGUsdCxuLHIpfWZ1bmN0aW9uIEZlKGUsdCxuLHIpe2lmKF8pcmV0dXJuIFdlKDEzLDEsZSx0LG4scil9ZnVuY3Rpb24gTmUoZSl7aWYoXylyZXR1cm4gV2UoMTQsMSxlKX1mdW5jdGlvbiBMZShlLHQpe2lmKF8pcmV0dXJuIFdlKDE1LDEsZSx0KX1mdW5jdGlvbiBDZShlLHQsbil7aWYoXylyZXR1cm4gV2UoMTYsMSxlLHQsbil9dmFyIFJlPWU9PntpZighTSl0cnl7aWYoZSgpLCFXKCkpdHJ5e18/eXQoRik6ZmUoRil9Y2F0Y2goZSl7ZSBpbnN0YW5jZW9mIGllfHxcInVud2luZFwiPT1lfHxnKDEsZSl9fWNhdGNoKGUpe2UgaW5zdGFuY2VvZiBpZXx8XCJ1bndpbmRcIj09ZXx8ZygxLGUpfX07ZnVuY3Rpb24gamUoZSl7ZT4+Pj0wLFwiZnVuY3Rpb25cIj09dHlwZW9mIEF0b21pY3MubmImJihBdG9taWNzLm5iKG8oKSxlPj4yLGUpLnZhbHVlLnRoZW4oTWUpLGUrPTEyOCxBdG9taWNzLnN0b3JlKG8oKSxlPj4yLDEpKX1mdW5jdGlvbiBNZSgpe3ZhciBlPWR0KCk7ZSYmKGplKGUpLFJlKCgoKT0+X3QoKSkpKX1sLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdD1qZSxsLmNoZWNrTWFpbGJveD1NZTt2YXIgVWU9ZT0+MD09ZSU0JiYoMCE9ZSUxMDB8fDA9PWUlNDAwKSxCZT1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSxWZT1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtmdW5jdGlvbiB6ZShlLHQsbixyLG8saSxzLGEpe3JldHVybiBfP1dlKDE3LDEsZSx0LG4scixvLGkscyxhKTotNTJ9ZnVuY3Rpb24gR2UoZSx0LG4scixvLGkscyl7aWYoXylyZXR1cm4gV2UoMTgsMSxlLHQsbixyLG8saSxzKX12YXIgSGU9ZT0+e3ZhciB0PXdlKGUpKzEsbj1mdCh0KTtyZXR1cm4gbiYmU2UoZSxuLHQpLG59LHFlPWU9Pnt2YXIgdD14dCgpO3JldHVybiBlPWUoKSx3dCh0KSxlfTtmdW5jdGlvbiBXZShlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGgtMixyPWFyZ3VtZW50cztyZXR1cm4gcWUoKCgpPT57Zm9yKHZhciBvPU90KDgqbiksaT1vPj4zLGE9MDthPG47YSsrKXt2YXIgdT1yWzIrYV07cygpW2krYT4+PjBdPXV9cmV0dXJuIGJ0KGUsbixvLHQpfSkpfXZhciBYZSxZZT1bXSxLZT17fSxKZT0oKT0+e2lmKCFYZSl7dmFyIGUsdD17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpofHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2ZvcihlIGluIEtlKXZvaWQgMD09PUtlW2VdP2RlbGV0ZSB0W2VdOnRbZV09S2VbZV07dmFyIG49W107Zm9yKGUgaW4gdCluLnB1c2goYCR7ZX09JHt0W2VdfWApO1hlPW59cmV0dXJuIFhlfTtmdW5jdGlvbiBaZShlLG4pe2lmKF8pcmV0dXJuIFdlKDE5LDEsZSxuKTtlPj4+PTAsbj4+Pj0wO3ZhciByPTA7cmV0dXJuIEplKCkuZm9yRWFjaCgoZnVuY3Rpb24obyxzKXt2YXIgYT1uK3I7Zm9yKHM9aSgpW2UrNCpzPj4yPj4+MF09YSxhPTA7YTxvLmxlbmd0aDsrK2EpdCgpW3MrKz4+MD4+PjBdPW8uY2hhckNvZGVBdChhKTt0KClbcz4+MD4+PjBdPTAscis9by5sZW5ndGgrMX0pKSwwfWZ1bmN0aW9uIFFlKGUsdCl7aWYoXylyZXR1cm4gV2UoMjAsMSxlLHQpO2U+Pj49MCx0Pj4+PTA7dmFyIG49SmUoKTtpKClbZT4+Mj4+PjBdPW4ubGVuZ3RoO3ZhciByPTA7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24oZSl7cis9ZS5sZW5ndGgrMX0pKSxpKClbdD4+Mj4+PjBdPXIsMH1mdW5jdGlvbiBldChlKXtyZXR1cm4gXz9XZSgyMSwxLGUpOjUyfWZ1bmN0aW9uIHR0KGUsdCxuLHIpe3JldHVybiBfP1dlKDIyLDEsZSx0LG4scik6NTJ9ZnVuY3Rpb24gbnQoZSx0LG4scixvKXtyZXR1cm4gXz9XZSgyMywxLGUsdCxuLHIsbyk6NzB9dmFyIHJ0PVtudWxsLFtdLFtdXTtmdW5jdGlvbiBvdChlLHQsbixvKXtpZihfKXJldHVybiBXZSgyNCwxLGUsdCxuLG8pO3Q+Pj49MCxuPj4+PTAsbz4+Pj0wO2Zvcih2YXIgcz0wLGE9MDthPG47YSsrKXt2YXIgdT1pKClbdD4+Mj4+PjBdLGw9aSgpW3QrND4+Mj4+PjBdO3QrPTg7Zm9yKHZhciBjPTA7YzxsO2MrKyl7dmFyIHA9cigpW3UrYz4+PjBdLGQ9cnRbZV07MD09PXB8fDEwPT09cD8oKDE9PT1lP1A6SSkoY2UoZCwwKSksZC5sZW5ndGg9MCk6ZC5wdXNoKHApfXMrPWx9cmV0dXJuIGkoKVtvPj4yPj4+MF09cywwfXZhciBpdD1lPT4oaXQ9KCgpPT57aWYoXCJvYmplY3RcIj09dHlwZW9mIGNyeXB0byYmXCJmdW5jdGlvblwiPT10eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcylyZXR1cm4gZT0+KGUuc2V0KGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoZS5ieXRlTGVuZ3RoKSkpLGUpO2lmKHkpdHJ5e3ZhciBlPW4oNjExMyk7aWYoZS5yYW5kb21GaWxsU3luYylyZXR1cm4gdD0+ZS5yYW5kb21GaWxsU3luYyh0KTt2YXIgdD1lLnJhbmRvbUJ5dGVzO3JldHVybiBlPT4oZS5zZXQodChlLmJ5dGVMZW5ndGgpKSxlKX1jYXRjaChlKXt9dGUoXCJpbml0UmFuZG9tRGV2aWNlXCIpfSkoKSkoZSksc3Q9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxhdD1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLHV0PShlLG4pPT57dCgpLnNldChlLG4+Pj4wKX07ZnVuY3Rpb24gbHQoZSx0LG4scil7ZnVuY3Rpb24gaShlLHQsbil7Zm9yKGU9XCJudW1iZXJcIj09dHlwZW9mIGU/ZS50b1N0cmluZygpOmV8fFwiXCI7ZS5sZW5ndGg8dDspZT1uWzBdK2U7cmV0dXJuIGV9ZnVuY3Rpb24gcyhlLHQpe3JldHVybiBpKGUsdCxcIjBcIil9ZnVuY3Rpb24gYShlLHQpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIDA+ZT8tMTowPGU/MTowfXZhciByO3JldHVybiAwPT09KHI9bihlLmdldEZ1bGxZZWFyKCktdC5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKGUuZ2V0TW9udGgoKS10LmdldE1vbnRoKCkpKSYmKHI9bihlLmdldERhdGUoKS10LmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gdShlKXtzd2l0Y2goZS5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBlO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBsKGUpe3ZhciB0PWUuSmE7Zm9yKGU9bmV3IERhdGUobmV3IERhdGUoZS5LYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHQ7KXt2YXIgbj1lLmdldE1vbnRoKCkscj0oVWUoZS5nZXRGdWxsWWVhcigpKT9zdDphdClbbl07aWYoISh0PnItZS5nZXREYXRlKCkpKXtlLnNldERhdGUoZS5nZXREYXRlKCkrdCk7YnJlYWt9dC09ci1lLmdldERhdGUoKSsxLGUuc2V0RGF0ZSgxKSwxMT5uP2Uuc2V0TW9udGgobisxKTooZS5zZXRNb250aCgwKSxlLnNldEZ1bGxZZWFyKGUuZ2V0RnVsbFllYXIoKSsxKSl9cmV0dXJuIG49bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpKzEsMCw0KSx0PXUobmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsNCkpLG49dShuKSwwPj1hKHQsZSk/MD49YShuLGUpP2UuZ2V0RnVsbFllYXIoKSsxOmUuZ2V0RnVsbFllYXIoKTplLmdldEZ1bGxZZWFyKCktMX1lPj4+PTAsdD4+Pj0wLG4+Pj49MCxyPj4+PTA7dmFyIGM9bygpW3IrNDA+PjI+Pj4wXTtmb3IodmFyIHAgaW4gcj17a2I6bygpW3I+PjI+Pj4wXSxqYjpvKClbcis0Pj4yPj4+MF0sTWE6bygpW3IrOD4+Mj4+PjBdLFFhOm8oKVtyKzEyPj4yPj4+MF0sTmE6bygpW3IrMTY+PjI+Pj4wXSxLYTpvKClbcisyMD4+Mj4+PjBdLEdhOm8oKVtyKzI0Pj4yPj4+MF0sSmE6bygpW3IrMjg+PjI+Pj4wXSxzYjpvKClbciszMj4+Mj4+PjBdLGliOm8oKVtyKzM2Pj4yPj4+MF0sbGI6Yz9wZShjKTpcIlwifSxuPXBlKG4pLGM9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSluPW4ucmVwbGFjZShuZXcgUmVnRXhwKHAsXCJnXCIpLGNbcF0pO3ZhciBkPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksZj1cIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXJcIi5zcGxpdChcIiBcIik7Zm9yKHAgaW4gYz17XCIlYVwiOmU9PmRbZS5HYV0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOmU9PmRbZS5HYV0sXCIlYlwiOmU9PmZbZS5OYV0uc3Vic3RyaW5nKDAsMyksXCIlQlwiOmU9PmZbZS5OYV0sXCIlQ1wiOmU9PnMoKGUuS2ErMTkwMCkvMTAwfDAsMiksXCIlZFwiOmU9PnMoZS5RYSwyKSxcIiVlXCI6ZT0+aShlLlFhLDIsXCIgXCIpLFwiJWdcIjplPT5sKGUpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjplPT5sKGUpLFwiJUhcIjplPT5zKGUuTWEsMiksXCIlSVwiOmU9PigwPT0oZT1lLk1hKT9lPTEyOjEyPGUmJihlLT0xMikscyhlLDIpKSxcIiVqXCI6ZT0+e2Zvcih2YXIgdD0wLG49MDtuPD1lLk5hLTE7dCs9KFVlKGUuS2ErMTkwMCk/c3Q6YXQpW24rK10pO3JldHVybiBzKGUuUWErdCwzKX0sXCIlbVwiOmU9PnMoZS5OYSsxLDIpLFwiJU1cIjplPT5zKGUuamIsMiksXCIlblwiOigpPT5cIlxcblwiLFwiJXBcIjplPT4wPD1lLk1hJiYxMj5lLk1hP1wiQU1cIjpcIlBNXCIsXCIlU1wiOmU9PnMoZS5rYiwyKSxcIiV0XCI6KCk9PlwiXFx0XCIsXCIldVwiOmU9PmUuR2F8fDcsXCIlVVwiOmU9PnMoTWF0aC5mbG9vcigoZS5KYSs3LWUuR2EpLzcpLDIpLFwiJVZcIjplPT57dmFyIHQ9TWF0aC5mbG9vcigoZS5KYSs3LShlLkdhKzYpJTcpLzcpO2lmKDI+PShlLkdhKzM3MS1lLkphLTIpJTcmJnQrKyx0KTUzPT10JiYoND09KG49KGUuR2ErMzcxLWUuSmEpJTcpfHwzPT1uJiZVZShlLkthKXx8KHQ9MSkpO2Vsc2V7dD01Mjt2YXIgbj0oZS5HYSs3LWUuSmEtMSklNzsoND09bnx8NT09biYmVWUoZS5LYSU0MDAtMSkpJiZ0Kyt9cmV0dXJuIHModCwyKX0sXCIld1wiOmU9PmUuR2EsXCIlV1wiOmU9PnMoTWF0aC5mbG9vcigoZS5KYSs3LShlLkdhKzYpJTcpLzcpLDIpLFwiJXlcIjplPT4oZS5LYSsxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6ZT0+ZS5LYSsxOTAwLFwiJXpcIjplPT57dmFyIHQ9MDw9KGU9ZS5pYik7cmV0dXJuIGU9TWF0aC5hYnMoZSkvNjAsKHQ/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIisoZS82MCoxMDArZSU2MCkpLnNsaWNlKC00KX0sXCIlWlwiOmU9PmUubGIsXCIlJVwiOigpPT5cIiVcIn0sbj1uLnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIiksYyluLmluY2x1ZGVzKHApJiYobj1uLnJlcGxhY2UobmV3IFJlZ0V4cChwLFwiZ1wiKSxjW3BdKHIpKSk7cmV0dXJuIHA9ZnVuY3Rpb24oZSl7dmFyIHQ9QXJyYXkod2UoZSkrMSk7cmV0dXJuIE9lKGUsdCwwLHQubGVuZ3RoKSx0fShuPW4ucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxwLmxlbmd0aD50PzA6KHV0KHAsZSkscC5sZW5ndGgtMSl9aGUuUGEoKTt2YXIgY3Q9W251bGwsZGUsYmUsX2UsVGUseGUsQWUsUGUsSWUsRWUsRGUsJGUsa2UsRmUsTmUsTGUsQ2UsemUsR2UsWmUsUWUsZXQsdHQsbnQsb3RdLHB0PXtiOmZ1bmN0aW9uKGUsdCxuKXt0aHJvdyBuZXcgeWUoZT4+Pj0wKS5QYSh0Pj4+MCxuPj4+MCksZX0sTjpmdW5jdGlvbihlKXtodChlPj4+MCwhbSwxLCFiLDEzMTA3MiwhMSksaGUuU2EoKX0sazpmdW5jdGlvbihlKXtlPj4+PTAsXz9wb3N0TWVzc2FnZSh7Y21kOlwiY2xlYW51cFRocmVhZFwiLHRocmVhZDplfSk6YWUoZSl9LEk6dmUsaDpUZSxUOnhlLEU6QWUsRzpQZSxVOkllLFI6RWUsSjpEZSxROiRlLG86a2UsRjpGZSxDOk5lLFM6TGUsRDpDZSxxOigpPT4hMCxBOmZ1bmN0aW9uKGUsdCl7KGU+Pj49MCk9PXQ+Pj4wP3NldFRpbWVvdXQoKCgpPT5NZSgpKSk6Xz9wb3N0TWVzc2FnZSh7dGFyZ2V0VGhyZWFkOmUsY21kOlwiY2hlY2tNYWlsYm94XCJ9KTooZT1oZS5GYVtlXSkmJmUucG9zdE1lc3NhZ2Uoe2NtZDpcImNoZWNrTWFpbGJveFwifSl9LEw6ZnVuY3Rpb24oKXtyZXR1cm4tMX0sTTpqZSxwOmZ1bmN0aW9uKGUpe3kmJmhlLkZhW2U+Pj4wXS5yZWYoKX0sdDpmdW5jdGlvbihlLHQsbil7ZT10KzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFlPyhlPj4+MCkrNDI5NDk2NzI5Nip0Ok5hTixuPj4+PTAsZT1uZXcgRGF0ZSgxZTMqZSksbygpW24+PjI+Pj4wXT1lLmdldFVUQ1NlY29uZHMoKSxvKClbbis0Pj4yPj4+MF09ZS5nZXRVVENNaW51dGVzKCksbygpW24rOD4+Mj4+PjBdPWUuZ2V0VVRDSG91cnMoKSxvKClbbisxMj4+Mj4+PjBdPWUuZ2V0VVRDRGF0ZSgpLG8oKVtuKzE2Pj4yPj4+MF09ZS5nZXRVVENNb250aCgpLG8oKVtuKzIwPj4yPj4+MF09ZS5nZXRVVENGdWxsWWVhcigpLTE5MDAsbygpW24rMjQ+PjI+Pj4wXT1lLmdldFVUQ0RheSgpLGU9KGUuZ2V0VGltZSgpLURhdGUuVVRDKGUuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsbygpW24rMjg+PjI+Pj4wXT1lfSx1OmZ1bmN0aW9uKGUsdCxuKXtlPXQrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWU/KGU+Pj4wKSs0Mjk0OTY3Mjk2KnQ6TmFOLG4+Pj49MCxlPW5ldyBEYXRlKDFlMyplKSxvKClbbj4+Mj4+PjBdPWUuZ2V0U2Vjb25kcygpLG8oKVtuKzQ+PjI+Pj4wXT1lLmdldE1pbnV0ZXMoKSxvKClbbis4Pj4yPj4+MF09ZS5nZXRIb3VycygpLG8oKVtuKzEyPj4yPj4+MF09ZS5nZXREYXRlKCksbygpW24rMTY+PjI+Pj4wXT1lLmdldE1vbnRoKCksbygpW24rMjA+PjI+Pj4wXT1lLmdldEZ1bGxZZWFyKCktMTkwMCxvKClbbisyND4+Mj4+PjBdPWUuZ2V0RGF5KCksdD0oVWUoZS5nZXRGdWxsWWVhcigpKT9CZTpWZSlbZS5nZXRNb250aCgpXStlLmdldERhdGUoKS0xfDAsbygpW24rMjg+PjI+Pj4wXT10LG8oKVtuKzM2Pj4yPj4+MF09LTYwKmUuZ2V0VGltZXpvbmVPZmZzZXQoKSx0PW5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHI9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtlPTB8KHQhPXImJmUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4ocix0KSksbygpW24rMzI+PjI+Pj4wXT1lfSx2OmZ1bmN0aW9uKGUpe2U+Pj49MDt2YXIgdD1uZXcgRGF0ZShvKClbZSsyMD4+Mj4+PjBdKzE5MDAsbygpW2UrMTY+PjI+Pj4wXSxvKClbZSsxMj4+Mj4+PjBdLG8oKVtlKzg+PjI+Pj4wXSxvKClbZSs0Pj4yPj4+MF0sbygpW2U+PjI+Pj4wXSwwKSxuPW8oKVtlKzMyPj4yPj4+MF0scj10LmdldFRpbWV6b25lT2Zmc2V0KCksaT1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHM9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxhPU1hdGgubWluKHMsaSk7cmV0dXJuIDA+bj9vKClbZSszMj4+Mj4+PjBdPU51bWJlcihpIT1zJiZhPT1yKTowPG4hPShhPT1yKSYmKGk9TWF0aC5tYXgocyxpKSx0LnNldFRpbWUodC5nZXRUaW1lKCkrNmU0KigoMDxuP2E6aSktcikpKSxvKClbZSsyND4+Mj4+PjBdPXQuZ2V0RGF5KCksbj0oVWUodC5nZXRGdWxsWWVhcigpKT9CZTpWZSlbdC5nZXRNb250aCgpXSt0LmdldERhdGUoKS0xfDAsbygpW2UrMjg+PjI+Pj4wXT1uLG8oKVtlPj4yPj4+MF09dC5nZXRTZWNvbmRzKCksbygpW2UrND4+Mj4+PjBdPXQuZ2V0TWludXRlcygpLG8oKVtlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksbygpW2UrMTI+PjI+Pj4wXT10LmdldERhdGUoKSxvKClbZSsxNj4+Mj4+PjBdPXQuZ2V0TW9udGgoKSxvKClbZSsyMD4+Mj4+PjBdPXQuZ2V0WWVhcigpLGU9dC5nZXRUaW1lKCkvMWUzLHZ0KChZPWUsMTw9K01hdGguYWJzKFkpPzA8WT8rTWF0aC5mbG9vcihZLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKFktKyh+flk+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApKSxlPj4+MH0scjp6ZSxzOkdlLHo6ZnVuY3Rpb24oZSx0LG4pe2Z1bmN0aW9uIHIoZSl7cmV0dXJuKGU9ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pKT9lWzFdOlwiR01UXCJ9ZT4+Pj0wLHQ+Pj49MCxuPj4+PTA7dmFyIHM9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLGE9bmV3IERhdGUocywwLDEpLHU9bmV3IERhdGUocyw2LDEpO3M9YS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBsPXUuZ2V0VGltZXpvbmVPZmZzZXQoKSxjPU1hdGgubWF4KHMsbCk7aSgpW2U+PjI+Pj4wXT02MCpjLG8oKVt0Pj4yPj4+MF09TnVtYmVyKHMhPWwpLGU9cihhKSx0PXIodSksZT1IZShlKSx0PUhlKHQpLGw8cz8oaSgpW24+PjI+Pj4wXT1lLGkoKVtuKzQ+PjI+Pj4wXT10KTooaSgpW24+PjI+Pj4wXT10LGkoKVtuKzQ+PjI+Pj4wXT1lKX0sYzooKT0+e3RlKFwiXCIpfSxsOmZ1bmN0aW9uKCl7fSxpOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LFY6KCk9Pnt0aHJvdyBxKz0xLFwidW53aW5kXCJ9LEI6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sZTooKT0+cGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKSxmOmZ1bmN0aW9uKCl7cmV0dXJuIHk/big5NzE5KS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5fSxLOmZ1bmN0aW9uKGUsdCxuLHIpe2ZvcihoZS5wYj10Pj4+MCxZZS5sZW5ndGg9bix0PXI+Pj4wPj4zLHI9MDtyPG47cisrKVllW3JdPXMoKVt0K3I+Pj4wXTtyZXR1cm4gY3RbZV0uYXBwbHkobnVsbCxZZSl9LHk6ZnVuY3Rpb24oZSl7ZT4+Pj0wO3ZhciB0PXIoKS5sZW5ndGg7aWYoZTw9dHx8NDI5NDkwMTc2MDxlKXJldHVybiExO2Zvcih2YXIgbj0xOzQ+PW47bio9Mil7dmFyIG89dCooMSsuMi9uKTtvPU1hdGgubWluKG8sZSsxMDA2NjMyOTYpO3ZhciBpPU1hdGg7bz1NYXRoLm1heChlLG8pO2U6e2k9aS5taW4uY2FsbChpLDQyOTQ5MDE3NjAsbysoNjU1MzYtbyU2NTUzNiklNjU1MzYpLUQuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNjt0cnl7RC5ncm93KGkpLFUoKTt2YXIgcz0xO2JyZWFrIGV9Y2F0Y2goZSl7fXM9dm9pZCAwfWlmKHMpcmV0dXJuITB9cmV0dXJuITF9LE86WmUsUDpRZSxqOmZlLGc6ZXQsbjp0dCx3Om50LG06b3QseDpmdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdD4+Pj0wLGl0KHIoKS5zdWJhcnJheShlPj4+MCxlK3Q+Pj4wKSksMH0sYTpEfHxsLndhc21NZW1vcnksSDpsdCxkOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiBsdChlPj4+MCx0Pj4+MCxuPj4+MCxyPj4+MCl9fTshZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7cmV0dXJuIGU9ZS5leHBvcnRzLCQ9ZT1mdW5jdGlvbihlKXt2YXIgdD1lPT4oKT0+ZSgpPj4+MCxuPWU9PnQ9PmUodCk+Pj4wO3JldHVybihlPU9iamVjdC5hc3NpZ24oe30sZSkpLl9fZXJybm9fbG9jYXRpb249dChlLl9fZXJybm9fbG9jYXRpb24pLGUucHRocmVhZF9zZWxmPXQoZS5wdGhyZWFkX3NlbGYpLGUubWFsbG9jPW4oZS5tYWxsb2MpLGUuc3RhY2tTYXZlPXQoZS5zdGFja1NhdmUpLGUuc3RhY2tBbGxvYz1uKGUuc3RhY2tBbGxvYyksZX0oZSksaGUuVGEucHVzaCgkLnNhKSxWPSQudGEsRy51bnNoaWZ0KCQuVyksaz10LGVlKCksZX12YXIgdD17YTpwdH07aWYoUSgpLGwuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gbC5pbnN0YW50aWF0ZVdhc20odCxlKX1jYXRjaChlKXtJKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSksdShlKX0oZnVuY3Rpb24oZSx0KXt2YXIgbj1YO3JldHVybiBBfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8bmUobil8fG4uc3RhcnRzV2l0aChcImZpbGU6Ly9cIil8fHl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP29lKG4sZSx0KTpmZXRjaChuLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChyPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyLGUpLnRoZW4odCwoZnVuY3Rpb24ocil7cmV0dXJuIEkoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrciksSShcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLG9lKG4sZSx0KX0pKSkpfSkodCwoZnVuY3Rpb24odCl7ZSh0Lmluc3RhbmNlLHQubW9kdWxlKX0pKS5jYXRjaCh1KX0oKSxsLl9PcnRJbml0PShlLHQpPT4obC5fT3J0SW5pdD0kLlgpKGUsdCksbC5fT3J0R2V0TGFzdEVycm9yPShlLHQpPT4obC5fT3J0R2V0TGFzdEVycm9yPSQuWSkoZSx0KSxsLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0oZSx0LG4scixvLGkscyxhLHUsYyk9PihsLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0kLlopKGUsdCxuLHIsbyxpLHMsYSx1LGMpLGwuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShlLHQpPT4obC5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9JC5fKShlLHQpLGwuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0oZSx0LG4pPT4obC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PSQuJCkoZSx0LG4pLGwuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1lPT4obC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPSQuYWEpKGUpLGwuX09ydENyZWF0ZVNlc3Npb249KGUsdCxuKT0+KGwuX09ydENyZWF0ZVNlc3Npb249JC5iYSkoZSx0LG4pLGwuX09ydFJlbGVhc2VTZXNzaW9uPWU9PihsLl9PcnRSZWxlYXNlU2Vzc2lvbj0kLmNhKShlKSxsLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PShlLHQsbik9PihsLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PSQuZGEpKGUsdCxuKSxsLl9PcnRHZXRJbnB1dE5hbWU9KGUsdCk9PihsLl9PcnRHZXRJbnB1dE5hbWU9JC5lYSkoZSx0KSxsLl9PcnRHZXRPdXRwdXROYW1lPShlLHQpPT4obC5fT3J0R2V0T3V0cHV0TmFtZT0kLmZhKShlLHQpLGwuX09ydEZyZWU9ZT0+KGwuX09ydEZyZWU9JC5nYSkoZSksbC5fT3J0Q3JlYXRlVGVuc29yPShlLHQsbixyLG8pPT4obC5fT3J0Q3JlYXRlVGVuc29yPSQuaGEpKGUsdCxuLHIsbyksbC5fT3J0R2V0VGVuc29yRGF0YT0oZSx0LG4scixvKT0+KGwuX09ydEdldFRlbnNvckRhdGE9JC5pYSkoZSx0LG4scixvKSxsLl9PcnRSZWxlYXNlVGVuc29yPWU9PihsLl9PcnRSZWxlYXNlVGVuc29yPSQuamEpKGUpLGwuX09ydENyZWF0ZVJ1bk9wdGlvbnM9KGUsdCxuLHIpPT4obC5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0kLmthKShlLHQsbixyKSxsLl9PcnRBZGRSdW5Db25maWdFbnRyeT0oZSx0LG4pPT4obC5fT3J0QWRkUnVuQ29uZmlnRW50cnk9JC5sYSkoZSx0LG4pLGwuX09ydFJlbGVhc2VSdW5PcHRpb25zPWU9PihsLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz0kLm1hKShlKSxsLl9PcnRSdW49KGUsdCxuLHIsbyxpLHMsYSk9PihsLl9PcnRSdW49JC5uYSkoZSx0LG4scixvLGkscyxhKSxsLl9PcnRFbmRQcm9maWxpbmc9ZT0+KGwuX09ydEVuZFByb2ZpbGluZz0kLm9hKShlKTt2YXIgZHQ9bC5fcHRocmVhZF9zZWxmPSgpPT4oZHQ9bC5fcHRocmVhZF9zZWxmPSQucGEpKCksZnQ9bC5fbWFsbG9jPWU9PihmdD1sLl9tYWxsb2M9JC5xYSkoZSk7bC5fZnJlZT1lPT4obC5fZnJlZT0kLnJhKShlKSxsLl9fZW1zY3JpcHRlbl90bHNfaW5pdD0oKT0+KGwuX19lbXNjcmlwdGVuX3Rsc19pbml0PSQuc2EpKCk7dmFyIGh0PWwuX19lbXNjcmlwdGVuX3RocmVhZF9pbml0PShlLHQsbixyLG8saSk9PihodD1sLl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdD0kLnVhKShlLHQsbixyLG8saSk7bC5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQ9KCk9PihsLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZD0kLnZhKSgpO3ZhciBndCxidD0oZSx0LG4scik9PihidD0kLndhKShlLHQsbixyKSxtdD1lPT4obXQ9JC54YSkoZSkseXQ9bC5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQ9ZT0+KHl0PWwuX19lbXNjcmlwdGVuX3RocmVhZF9leGl0PSQueWEpKGUpLF90PWwuX19lbXNjcmlwdGVuX2NoZWNrX21haWxib3g9KCk9PihfdD1sLl9fZW1zY3JpcHRlbl9jaGVja19tYWlsYm94PSQuemEpKCksdnQ9ZT0+KHZ0PSQuQWEpKGUpLFR0PShlLHQpPT4oVHQ9JC5CYSkoZSx0KSx4dD0oKT0+KHh0PSQuQ2EpKCksd3Q9ZT0+KHd0PSQuRGEpKGUpLE90PWU9PihPdD0kLkVhKShlKTtmdW5jdGlvbiBTdCgpe2Z1bmN0aW9uIGUoKXtpZighZ3QmJihndD0hMCxsLmNhbGxlZFJ1bj0hMCwhTSkmJihffHxnZShHKSxhKGwpLGwub25SdW50aW1lSW5pdGlhbGl6ZWQmJmwub25SdW50aW1lSW5pdGlhbGl6ZWQoKSwhXykpe2lmKGwucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgbC5wb3N0UnVuJiYobC5wb3N0UnVuPVtsLnBvc3RSdW5dKTtsLnBvc3RSdW4ubGVuZ3RoOyl7dmFyIGU9bC5wb3N0UnVuLnNoaWZ0KCk7SC51bnNoaWZ0KGUpfWdlKEgpfX1pZighKDA8SykpaWYoXylhKGwpLF98fGdlKEcpLHN0YXJ0V29ya2VyKGwpO2Vsc2V7aWYobC5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGwucHJlUnVuJiYobC5wcmVSdW49W2wucHJlUnVuXSk7bC5wcmVSdW4ubGVuZ3RoOyl6LnVuc2hpZnQobC5wcmVSdW4uc2hpZnQoKSk7Z2UoeiksMDxLfHwobC5zZXRTdGF0dXM/KGwuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7bC5zZXRTdGF0dXMoXCJcIil9KSwxKSxlKCl9KSwxKSk6ZSgpKX19aWYobC5rZWVwUnVudGltZUFsaXZlPVcsbC53YXNtTWVtb3J5PUQsbC5zdGFja0FsbG9jPU90LGwuc3RhY2tTYXZlPXh0LGwuc3RhY2tSZXN0b3JlPXd0LGwuVVRGOFRvU3RyaW5nPXBlLGwuc3RyaW5nVG9VVEY4PVNlLGwubGVuZ3RoQnl0ZXNVVEY4PXdlLGwuRXhpdFN0YXR1cz1pZSxsLlBUaHJlYWQ9aGUsWj1mdW5jdGlvbiBlKCl7Z3R8fFN0KCksZ3R8fChaPWUpfSxsLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIGwucHJlSW5pdCYmKGwucHJlSW5pdD1bbC5wcmVJbml0XSk7MDxsLnByZUluaXQubGVuZ3RoOylsLnByZUluaXQucG9wKCkoKTtyZXR1cm4gU3QoKSxlLnJlYWR5fSk7ZS5leHBvcnRzPXJ9LDkzMjooZSx0LG4pPT57dmFyIF9zY3JpcHREaXIscj0oX3NjcmlwdERpcj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBfX2ZpbGVuYW1lJiYoX3NjcmlwdERpcj1fc2NyaXB0RGlyfHxfX2ZpbGVuYW1lKSxmdW5jdGlvbihlPXt9KXt2YXIgdCxyLG89ZTtvLnJlYWR5PW5ldyBQcm9taXNlKCgoZSxuKT0+e3Q9ZSxyPW59KSk7dmFyIGkscyxhLHU9T2JqZWN0LmFzc2lnbih7fSxvKSxsPVwiLi90aGlzLnByb2dyYW1cIixjPShlLHQpPT57dGhyb3cgdH0scD1cIm9iamVjdFwiPT10eXBlb2Ygd2luZG93LGQ9XCJmdW5jdGlvblwiPT10eXBlb2YgaW1wb3J0U2NyaXB0cyxmPVwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzJiZcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyYmXCJzdHJpbmdcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxoPVwiXCI7aWYoZil7dmFyIGc9big2MjMxKSxiPW4oMTQyMyk7aD1kP2IuZGlybmFtZShoKStcIi9cIjpfX2Rpcm5hbWUrXCIvXCIsaT0oZSx0KT0+KGU9ZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGUpOmIubm9ybWFsaXplKGUpLGcucmVhZEZpbGVTeW5jKGUsdD92b2lkIDA6XCJ1dGY4XCIpKSxhPWU9PigoZT1pKGUsITApKS5idWZmZXJ8fChlPW5ldyBVaW50OEFycmF5KGUpKSxlKSxzPShlLHQsbixyPSEwKT0+e2U9ZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKT9uZXcgVVJMKGUpOmIubm9ybWFsaXplKGUpLGcucmVhZEZpbGUoZSxyP3ZvaWQgMDpcInV0ZjhcIiwoKGUsbyk9PntlP24oZSk6dChyP28uYnVmZmVyOm8pfSkpfSwhby50aGlzUHJvZ3JhbSYmMTxwcm9jZXNzLmFyZ3YubGVuZ3RoJiYobD1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSkscHJvY2Vzcy5hcmd2LnNsaWNlKDIpLGM9KGUsdCk9Pnt0aHJvdyBwcm9jZXNzLmV4aXRDb2RlPWUsdH0sby5pbnNwZWN0PSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCJ9ZWxzZShwfHxkKSYmKGQ/aD1zZWxmLmxvY2F0aW9uLmhyZWY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoaD1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKGg9X3NjcmlwdERpciksaD0wIT09aC5pbmRleE9mKFwiYmxvYjpcIik/aC5zdWJzdHIoMCxoLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsaT1lPT57dmFyIHQ9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB0Lm9wZW4oXCJHRVRcIixlLCExKSx0LnNlbmQobnVsbCksdC5yZXNwb25zZVRleHR9LGQmJihhPWU9Pnt2YXIgdD1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHQub3BlbihcIkdFVFwiLGUsITEpLHQucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIix0LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodC5yZXNwb25zZSl9KSxzPShlLHQsbik9Pnt2YXIgcj1uZXcgWE1MSHR0cFJlcXVlc3Q7ci5vcGVuKFwiR0VUXCIsZSwhMCksci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLHIub25sb2FkPSgpPT57MjAwPT1yLnN0YXR1c3x8MD09ci5zdGF0dXMmJnIucmVzcG9uc2U/dChyLnJlc3BvbnNlKTpuKCl9LHIub25lcnJvcj1uLHIuc2VuZChudWxsKX0pO3ZhciBtLHk9by5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxfPW8ucHJpbnRFcnJ8fGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKG8sdSksdT1udWxsLG8udGhpc1Byb2dyYW0mJihsPW8udGhpc1Byb2dyYW0pLG8ucXVpdCYmKGM9by5xdWl0KSxvLndhc21CaW5hcnkmJihtPW8ud2FzbUJpbmFyeSk7dmFyIHY9by5ub0V4aXRSdW50aW1lfHwhMDtcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJmooXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBULHgsdyxPLFMsQSxQPSExO2Z1bmN0aW9uIEkoKXt2YXIgZT1ULmJ1ZmZlcjtvLkhFQVA4PXc9bmV3IEludDhBcnJheShlKSxvLkhFQVAxNj1uZXcgSW50MTZBcnJheShlKSxvLkhFQVAzMj1TPW5ldyBJbnQzMkFycmF5KGUpLG8uSEVBUFU4PU89bmV3IFVpbnQ4QXJyYXkoZSksby5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShlKSxvLkhFQVBVMzI9QT1uZXcgVWludDMyQXJyYXkoZSksby5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoZSksby5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoZSl9dmFyIEU9W10sRD1bXSwkPVtdO2Z1bmN0aW9uIGsoKXt2YXIgZT1vLnByZVJ1bi5zaGlmdCgpO0UudW5zaGlmdChlKX12YXIgRixOLEw9MCxDPW51bGwsUj1udWxsO2Z1bmN0aW9uIGooZSl7dGhyb3cgby5vbkFib3J0JiZvLm9uQWJvcnQoZSksXyhlPVwiQWJvcnRlZChcIitlK1wiKVwiKSxQPSEwLGU9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihlK1wiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiKSxyKGUpLGV9ZnVuY3Rpb24gTShlKXtyZXR1cm4gZS5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKX1pZighTShGPVwib3J0LXdhc20ud2FzbVwiKSl7dmFyIFU9RjtGPW8ubG9jYXRlRmlsZT9vLmxvY2F0ZUZpbGUoVSxoKTpoK1V9ZnVuY3Rpb24gQihlKXtpZihlPT1GJiZtKXJldHVybiBuZXcgVWludDhBcnJheShtKTtpZihhKXJldHVybiBhKGUpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIFYoZSx0LG4pe3JldHVybiBmdW5jdGlvbihlKXtpZighbSYmKHB8fGQpKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBmZXRjaCYmIWUuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpcmV0dXJuIGZldGNoKGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKHQ9PntpZighdC5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIrZStcIidcIjtyZXR1cm4gdC5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKCgoKT0+QihlKSkpO2lmKHMpcmV0dXJuIG5ldyBQcm9taXNlKCgodCxuKT0+e3MoZSwoZT0+dChuZXcgVWludDhBcnJheShlKSkpLG4pfSkpfXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgoKT0+QihlKSkpfShlKS50aGVuKChlPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShlLHQpKSkudGhlbigoZT0+ZSkpLnRoZW4obiwoZT0+e18oXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitlKSxqKGUpfSkpfWZ1bmN0aW9uIHooZSl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke2V9KWAsdGhpcy5zdGF0dXM9ZX12YXIgRz1lPT57Zm9yKDswPGUubGVuZ3RoOyllLnNoaWZ0KCkobyl9O2Z1bmN0aW9uIEgoZSl7dGhpcy5xYT1lLTI0LHRoaXMudmE9ZnVuY3Rpb24oZSl7QVt0aGlzLnFhKzQ+PjI+Pj4wXT1lfSx0aGlzLnVhPWZ1bmN0aW9uKGUpe0FbdGhpcy5xYSs4Pj4yPj4+MF09ZX0sdGhpcy5zYT1mdW5jdGlvbihlLHQpe3RoaXMudGEoKSx0aGlzLnZhKGUpLHRoaXMudWEodCl9LHRoaXMudGE9ZnVuY3Rpb24oKXtBW3RoaXMucWErMTY+PjI+Pj4wXT0wfX12YXIgcSxXPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMCxYPShlLHQsbik9Pnt2YXIgcj0odD4+Pj0wKStuO2ZvcihuPXQ7ZVtuXSYmIShuPj1yKTspKytuO2lmKDE2PG4tdCYmZS5idWZmZXImJlcpcmV0dXJuIFcuZGVjb2RlKGUuc3ViYXJyYXkodCxuKSk7Zm9yKHI9XCJcIjt0PG47KXt2YXIgbz1lW3QrK107aWYoMTI4Jm8pe3ZhciBpPTYzJmVbdCsrXTtpZigxOTI9PSgyMjQmbykpcis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmbyk8PDZ8aSk7ZWxzZXt2YXIgcz02MyZlW3QrK107NjU1MzY+KG89MjI0PT0oMjQwJm8pPygxNSZvKTw8MTJ8aTw8NnxzOig3Jm8pPDwxOHxpPDwxMnxzPDw2fDYzJmVbdCsrXSk/cis9U3RyaW5nLmZyb21DaGFyQ29kZShvKTooby09NjU1MzYscis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxvPj4xMCw1NjMyMHwxMDIzJm8pKX19ZWxzZSByKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pfXJldHVybiByfSxZPShlLHQpPT4oZT4+Pj0wKT9YKE8sZSx0KTpcIlwiLEs9ZT0+e2Zvcih2YXIgdD0wLG49MDtuPGUubGVuZ3RoOysrbil7dmFyIHI9ZS5jaGFyQ29kZUF0KG4pOzEyNz49cj90Kys6MjA0Nz49cj90Kz0yOjU1Mjk2PD1yJiY1NzM0Mz49cj8odCs9NCwrK24pOnQrPTN9cmV0dXJuIHR9LEo9KGUsdCxuLHIpPT57aWYoISgwPHIpKXJldHVybiAwO3ZhciBvPW4+Pj49MDtyPW4rci0xO2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7KytpKXt2YXIgcz1lLmNoYXJDb2RlQXQoaSk7aWYoNTUyOTY8PXMmJjU3MzQzPj1zJiYocz02NTUzNisoKDEwMjMmcyk8PDEwKXwxMDIzJmUuY2hhckNvZGVBdCgrK2kpKSwxMjc+PXMpe2lmKG4+PXIpYnJlYWs7dFtuKys+Pj4wXT1zfWVsc2V7aWYoMjA0Nz49cyl7aWYobisxPj1yKWJyZWFrO3RbbisrPj4+MF09MTkyfHM+PjZ9ZWxzZXtpZig2NTUzNT49cyl7aWYobisyPj1yKWJyZWFrO3RbbisrPj4+MF09MjI0fHM+PjEyfWVsc2V7aWYobiszPj1yKWJyZWFrO3RbbisrPj4+MF09MjQwfHM+PjE4LHRbbisrPj4+MF09MTI4fHM+PjEyJjYzfXRbbisrPj4+MF09MTI4fHM+PjYmNjN9dFtuKys+Pj4wXT0xMjh8NjMmc319cmV0dXJuIHRbbj4+PjBdPTAsbi1vfSxaPWU9PjA9PWUlNCYmKDAhPWUlMTAwfHwwPT1lJTQwMCksUT1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSxlZT1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XSx0ZT1lPT57dmFyIHQ9SyhlKSsxLG49Y2UodCk7cmV0dXJuIG4mJkooZSxPLG4sdCksbn0sbmU9e30scmU9KCk9PntpZighcSl7dmFyIGUsdD17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzooXCJvYmplY3RcIj09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpsfHxcIi4vdGhpcy5wcm9ncmFtXCJ9O2ZvcihlIGluIG5lKXZvaWQgMD09PW5lW2VdP2RlbGV0ZSB0W2VdOnRbZV09bmVbZV07dmFyIG49W107Zm9yKGUgaW4gdCluLnB1c2goYCR7ZX09JHt0W2VdfWApO3E9bn1yZXR1cm4gcX0sb2U9W251bGwsW10sW11dLGllPWU9PihpZT0oKCk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgY3J5cHRvJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXJldHVybiBlPT5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGUpO2lmKGYpdHJ5e3ZhciBlPW4oNjExMyk7aWYoZS5yYW5kb21GaWxsU3luYylyZXR1cm4gdD0+ZS5yYW5kb21GaWxsU3luYyh0KTt2YXIgdD1lLnJhbmRvbUJ5dGVzO3JldHVybiBlPT4oZS5zZXQodChlLmJ5dGVMZW5ndGgpKSxlKX1jYXRjaChlKXt9aihcImluaXRSYW5kb21EZXZpY2VcIil9KSgpKShlKSxzZT1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdLGFlPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gdWUoZSx0LG4scil7ZnVuY3Rpb24gbyhlLHQsbil7Zm9yKGU9XCJudW1iZXJcIj09dHlwZW9mIGU/ZS50b1N0cmluZygpOmV8fFwiXCI7ZS5sZW5ndGg8dDspZT1uWzBdK2U7cmV0dXJuIGV9ZnVuY3Rpb24gaShlLHQpe3JldHVybiBvKGUsdCxcIjBcIil9ZnVuY3Rpb24gcyhlLHQpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIDA+ZT8tMTowPGU/MTowfXZhciByO3JldHVybiAwPT09KHI9bihlLmdldEZ1bGxZZWFyKCktdC5nZXRGdWxsWWVhcigpKSkmJjA9PT0ocj1uKGUuZ2V0TW9udGgoKS10LmdldE1vbnRoKCkpKSYmKHI9bihlLmdldERhdGUoKS10LmdldERhdGUoKSkpLHJ9ZnVuY3Rpb24gYShlKXtzd2l0Y2goZS5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBlO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKGUuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiB1KGUpe3ZhciB0PWUubWE7Zm9yKGU9bmV3IERhdGUobmV3IERhdGUoZS5uYSsxOTAwLDAsMSkuZ2V0VGltZSgpKTswPHQ7KXt2YXIgbj1lLmdldE1vbnRoKCkscj0oWihlLmdldEZ1bGxZZWFyKCkpP3NlOmFlKVtuXTtpZighKHQ+ci1lLmdldERhdGUoKSkpe2Uuc2V0RGF0ZShlLmdldERhdGUoKSt0KTticmVha310LT1yLWUuZ2V0RGF0ZSgpKzEsZS5zZXREYXRlKDEpLDExPm4/ZS5zZXRNb250aChuKzEpOihlLnNldE1vbnRoKDApLGUuc2V0RnVsbFllYXIoZS5nZXRGdWxsWWVhcigpKzEpKX1yZXR1cm4gbj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCkrMSwwLDQpLHQ9YShuZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCw0KSksbj1hKG4pLDA+PXModCxlKT8wPj1zKG4sZSk/ZS5nZXRGdWxsWWVhcigpKzE6ZS5nZXRGdWxsWWVhcigpOmUuZ2V0RnVsbFllYXIoKS0xfWU+Pj49MCx0Pj4+PTAsbj4+Pj0wO3ZhciBsPVNbNDArKHI+Pj49MCk+PjI+Pj4wXTtmb3IodmFyIGMgaW4gcj17eWE6U1tyPj4yPj4+MF0seGE6U1tyKzQ+PjI+Pj4wXSxvYTpTW3IrOD4+Mj4+PjBdLHJhOlNbcisxMj4+Mj4+PjBdLHBhOlNbcisxNj4+Mj4+PjBdLG5hOlNbcisyMD4+Mj4+PjBdLGhhOlNbcisyND4+Mj4+PjBdLG1hOlNbcisyOD4+Mj4+PjBdLEFhOlNbciszMj4+Mj4+PjBdLHdhOlNbciszNj4+Mj4+PjBdLHphOmw/WShsKTpcIlwifSxuPVkobiksbD17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9KW49bi5yZXBsYWNlKG5ldyBSZWdFeHAoYyxcImdcIiksbFtjXSk7dmFyIHA9XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxkPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoYyBpbiBsPXtcIiVhXCI6ZT0+cFtlLmhhXS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6ZT0+cFtlLmhhXSxcIiViXCI6ZT0+ZFtlLnBhXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6ZT0+ZFtlLnBhXSxcIiVDXCI6ZT0+aSgoZS5uYSsxOTAwKS8xMDB8MCwyKSxcIiVkXCI6ZT0+aShlLnJhLDIpLFwiJWVcIjplPT5vKGUucmEsMixcIiBcIiksXCIlZ1wiOmU9PnUoZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOmU9PnUoZSksXCIlSFwiOmU9PmkoZS5vYSwyKSxcIiVJXCI6ZT0+KDA9PShlPWUub2EpP2U9MTI6MTI8ZSYmKGUtPTEyKSxpKGUsMikpLFwiJWpcIjplPT57Zm9yKHZhciB0PTAsbj0wO248PWUucGEtMTt0Kz0oWihlLm5hKzE5MDApP3NlOmFlKVtuKytdKTtyZXR1cm4gaShlLnJhK3QsMyl9LFwiJW1cIjplPT5pKGUucGErMSwyKSxcIiVNXCI6ZT0+aShlLnhhLDIpLFwiJW5cIjooKT0+XCJcXG5cIixcIiVwXCI6ZT0+MDw9ZS5vYSYmMTI+ZS5vYT9cIkFNXCI6XCJQTVwiLFwiJVNcIjplPT5pKGUueWEsMiksXCIldFwiOigpPT5cIlxcdFwiLFwiJXVcIjplPT5lLmhhfHw3LFwiJVVcIjplPT5pKE1hdGguZmxvb3IoKGUubWErNy1lLmhhKS83KSwyKSxcIiVWXCI6ZT0+e3ZhciB0PU1hdGguZmxvb3IoKGUubWErNy0oZS5oYSs2KSU3KS83KTtpZigyPj0oZS5oYSszNzEtZS5tYS0yKSU3JiZ0KyssdCk1Mz09dCYmKDQ9PShuPShlLmhhKzM3MS1lLm1hKSU3KXx8Mz09biYmWihlLm5hKXx8KHQ9MSkpO2Vsc2V7dD01Mjt2YXIgbj0oZS5oYSs3LWUubWEtMSklNzsoND09bnx8NT09biYmWihlLm5hJTQwMC0xKSkmJnQrK31yZXR1cm4gaSh0LDIpfSxcIiV3XCI6ZT0+ZS5oYSxcIiVXXCI6ZT0+aShNYXRoLmZsb29yKChlLm1hKzctKGUuaGErNiklNykvNyksMiksXCIleVwiOmU9PihlLm5hKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJVlcIjplPT5lLm5hKzE5MDAsXCIlelwiOmU9Pnt2YXIgdD0wPD0oZT1lLndhKTtyZXR1cm4gZT1NYXRoLmFicyhlKS82MCwodD9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiKyhlLzYwKjEwMCtlJTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ZT0+ZS56YSxcIiUlXCI6KCk9PlwiJVwifSxuPW4ucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxsKW4uaW5jbHVkZXMoYykmJihuPW4ucmVwbGFjZShuZXcgUmVnRXhwKGMsXCJnXCIpLGxbY10ocikpKTtyZXR1cm4gYz1mdW5jdGlvbihlKXt2YXIgdD1BcnJheShLKGUpKzEpO3JldHVybiBKKGUsdCwwLHQubGVuZ3RoKSx0fShuPW4ucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxjLmxlbmd0aD50PzA6KHcuc2V0KGMsZT4+PjApLGMubGVuZ3RoLTEpfXZhciBsZT17YTpmdW5jdGlvbihlLHQsbil7dGhyb3cgbmV3IEgoZT4+Pj0wKS5zYSh0Pj4+MCxuPj4+MCksZX0sZTpmdW5jdGlvbigpe3JldHVybiAwfSxJOmZ1bmN0aW9uKCl7fSx5OmZ1bmN0aW9uKCl7fSxBOmZ1bmN0aW9uKCl7fSxLOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LEc6ZnVuY3Rpb24oKXt9LEI6ZnVuY3Rpb24oKXt9LEY6ZnVuY3Rpb24oKXt9LGc6ZnVuY3Rpb24oKXt9LHo6ZnVuY3Rpb24oKXt9LHc6ZnVuY3Rpb24oKXt9LEg6ZnVuY3Rpb24oKXt9LHg6ZnVuY3Rpb24oKXt9LGs6KCk9PiEwLG46ZnVuY3Rpb24oZSx0LG4pe2U9dCsyMDk3MTUyPj4+MDw0MTk0MzA1LSEhZT8oZT4+PjApKzQyOTQ5NjcyOTYqdDpOYU4sbj4+Pj0wLGU9bmV3IERhdGUoMWUzKmUpLFNbbj4+Mj4+PjBdPWUuZ2V0VVRDU2Vjb25kcygpLFNbbis0Pj4yPj4+MF09ZS5nZXRVVENNaW51dGVzKCksU1tuKzg+PjI+Pj4wXT1lLmdldFVUQ0hvdXJzKCksU1tuKzEyPj4yPj4+MF09ZS5nZXRVVENEYXRlKCksU1tuKzE2Pj4yPj4+MF09ZS5nZXRVVENNb250aCgpLFNbbisyMD4+Mj4+PjBdPWUuZ2V0VVRDRnVsbFllYXIoKS0xOTAwLFNbbisyND4+Mj4+PjBdPWUuZ2V0VVRDRGF5KCksU1tuKzI4Pj4yPj4+MF09KGUuZ2V0VGltZSgpLURhdGUuVVRDKGUuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDB9LG86ZnVuY3Rpb24oZSx0LG4pe2U9dCsyMDk3MTUyPj4+MDw0MTk0MzA1LSEhZT8oZT4+PjApKzQyOTQ5NjcyOTYqdDpOYU4sbj4+Pj0wLGU9bmV3IERhdGUoMWUzKmUpLFNbbj4+Mj4+PjBdPWUuZ2V0U2Vjb25kcygpLFNbbis0Pj4yPj4+MF09ZS5nZXRNaW51dGVzKCksU1tuKzg+PjI+Pj4wXT1lLmdldEhvdXJzKCksU1tuKzEyPj4yPj4+MF09ZS5nZXREYXRlKCksU1tuKzE2Pj4yPj4+MF09ZS5nZXRNb250aCgpLFNbbisyMD4+Mj4+PjBdPWUuZ2V0RnVsbFllYXIoKS0xOTAwLFNbbisyND4+Mj4+PjBdPWUuZ2V0RGF5KCksU1tuKzI4Pj4yPj4+MF09KFooZS5nZXRGdWxsWWVhcigpKT9ROmVlKVtlLmdldE1vbnRoKCldK2UuZ2V0RGF0ZSgpLTF8MCxTW24rMzY+PjI+Pj4wXT0tNjAqZS5nZXRUaW1lem9uZU9mZnNldCgpLHQ9bmV3IERhdGUoZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgcj1uZXcgRGF0ZShlLmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO1NbbiszMj4+Mj4+PjBdPTB8KHQhPXImJmUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4ocix0KSl9LHA6ZnVuY3Rpb24oZSl7ZT4+Pj0wO3ZhciB0PW5ldyBEYXRlKFNbZSsyMD4+Mj4+PjBdKzE5MDAsU1tlKzE2Pj4yPj4+MF0sU1tlKzEyPj4yPj4+MF0sU1tlKzg+PjI+Pj4wXSxTW2UrND4+Mj4+PjBdLFNbZT4+Mj4+PjBdLDApLG49U1tlKzMyPj4yPj4+MF0scj10LmdldFRpbWV6b25lT2Zmc2V0KCksbz1uZXcgRGF0ZSh0LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLGk9bmV3IERhdGUodC5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxzPU1hdGgubWluKGksbyk7cmV0dXJuIDA+bj9TW2UrMzI+PjI+Pj4wXT1OdW1iZXIobyE9aSYmcz09cik6MDxuIT0ocz09cikmJihvPU1hdGgubWF4KGksbyksdC5zZXRUaW1lKHQuZ2V0VGltZSgpKzZlNCooKDA8bj9zOm8pLXIpKSksU1tlKzI0Pj4yPj4+MF09dC5nZXREYXkoKSxTW2UrMjg+PjI+Pj4wXT0oWih0LmdldEZ1bGxZZWFyKCkpP1E6ZWUpW3QuZ2V0TW9udGgoKV0rdC5nZXREYXRlKCktMXwwLFNbZT4+Mj4+PjBdPXQuZ2V0U2Vjb25kcygpLFNbZSs0Pj4yPj4+MF09dC5nZXRNaW51dGVzKCksU1tlKzg+PjI+Pj4wXT10LmdldEhvdXJzKCksU1tlKzEyPj4yPj4+MF09dC5nZXREYXRlKCksU1tlKzE2Pj4yPj4+MF09dC5nZXRNb250aCgpLFNbZSsyMD4+Mj4+PjBdPXQuZ2V0WWVhcigpLGU9dC5nZXRUaW1lKCkvMWUzLGRlKChOPWUsMTw9K01hdGguYWJzKE4pPzA8Tj8rTWF0aC5mbG9vcihOLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKE4tKyh+fk4+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApKSxlPj4+MH0sbDpmdW5jdGlvbigpe3JldHVybi01Mn0sbTpmdW5jdGlvbigpe30sdTpmdW5jdGlvbihlLHQsbil7ZnVuY3Rpb24gcihlKXtyZXR1cm4oZT1lLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLykpP2VbMV06XCJHTVRcIn1uPj4+PTA7dmFyIG89KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpLGk9bmV3IERhdGUobywwLDEpLHM9bmV3IERhdGUobyw2LDEpO289aS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBhPXMuZ2V0VGltZXpvbmVPZmZzZXQoKTtBW2U+Pj4wPj4yPj4+MF09NjAqTWF0aC5tYXgobyxhKSxTW3Q+Pj4wPj4yPj4+MF09TnVtYmVyKG8hPWEpLGU9cihpKSx0PXIocyksZT10ZShlKSx0PXRlKHQpLGE8bz8oQVtuPj4yPj4+MF09ZSxBW24rND4+Mj4+PjBdPXQpOihBW24+PjI+Pj4wXT10LEFbbis0Pj4yPj4+MF09ZSl9LGQ6KCk9PntqKFwiXCIpfSxoOmZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9LHY6ZnVuY3Rpb24oKXtyZXR1cm4gNDI5NDkwMTc2MH0sYjooKT0+cGVyZm9ybWFuY2Uubm93KCksSjpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHQ+Pj49MCxPLmNvcHlXaXRoaW4oZT4+PjA+Pj4wLHQ+Pj4wLHQrKG4+Pj4wKT4+PjApfSx0OmZ1bmN0aW9uKGUpe2U+Pj49MDt2YXIgdD1PLmxlbmd0aDtpZig0Mjk0OTAxNzYwPGUpcmV0dXJuITE7Zm9yKHZhciBuPTE7ND49bjtuKj0yKXt2YXIgcj10KigxKy4yL24pO3I9TWF0aC5taW4ocixlKzEwMDY2MzI5Nik7dmFyIG89TWF0aDtyPU1hdGgubWF4KGUscik7ZTp7bz1vLm1pbi5jYWxsKG8sNDI5NDkwMTc2MCxyKyg2NTUzNi1yJTY1NTM2KSU2NTUzNiktVC5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2O3RyeXtULmdyb3cobyksSSgpO3ZhciBpPTE7YnJlYWsgZX1jYXRjaChlKXt9aT12b2lkIDB9aWYoaSlyZXR1cm4hMH1yZXR1cm4hMX0sRDpmdW5jdGlvbihlLHQpe2U+Pj49MCx0Pj4+PTA7dmFyIG49MDtyZXR1cm4gcmUoKS5mb3JFYWNoKChmdW5jdGlvbihyLG8pe3ZhciBpPXQrbjtmb3Iobz1BW2UrNCpvPj4yPj4+MF09aSxpPTA7aTxyLmxlbmd0aDsrK2kpd1tvKys+PjA+Pj4wXT1yLmNoYXJDb2RlQXQoaSk7d1tvPj4wPj4+MF09MCxuKz1yLmxlbmd0aCsxfSkpLDB9LEU6ZnVuY3Rpb24oZSx0KXtlPj4+PTAsdD4+Pj0wO3ZhciBuPXJlKCk7QVtlPj4yPj4+MF09bi5sZW5ndGg7dmFyIHI9MDtyZXR1cm4gbi5mb3JFYWNoKChmdW5jdGlvbihlKXtyKz1lLmxlbmd0aCsxfSkpLEFbdD4+Mj4+PjBdPXIsMH0sczplPT57dnx8KG8ub25FeGl0JiZvLm9uRXhpdChlKSxQPSEwKSxjKGUsbmV3IHooZSkpfSxmOigpPT41MixqOmZ1bmN0aW9uKCl7cmV0dXJuIDUyfSxxOmZ1bmN0aW9uKCl7cmV0dXJuIDcwfSxpOmZ1bmN0aW9uKGUsdCxuLHIpe3Q+Pj49MCxuPj4+PTAscj4+Pj0wO2Zvcih2YXIgbz0wLGk9MDtpPG47aSsrKXt2YXIgcz1BW3Q+PjI+Pj4wXSxhPUFbdCs0Pj4yPj4+MF07dCs9ODtmb3IodmFyIHU9MDt1PGE7dSsrKXt2YXIgbD1PW3MrdT4+PjBdLGM9b2VbZV07MD09PWx8fDEwPT09bD8oKDE9PT1lP3k6XykoWChjLDApKSxjLmxlbmd0aD0wKTpjLnB1c2gobCl9bys9YX1yZXR1cm4gQVtyPj4yPj4+MF09bywwfSxyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCxpZShPLnN1YmFycmF5KGU+Pj4wLGUrKHQ+Pj4wKT4+PjApKSwwfSxDOnVlLGM6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHVlKGU+Pj4wLHQ+Pj4wLG4+Pj4wLHI+Pj4wKX19OyFmdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSl7aWYoZT1lLmV4cG9ydHMseD1lPWZ1bmN0aW9uKGUpe3ZhciB0PWU9PigpPT5lKCk+Pj4wLG49ZT0+dD0+ZSh0KT4+PjA7cmV0dXJuKGU9T2JqZWN0LmFzc2lnbih7fSxlKSkuX19lcnJub19sb2NhdGlvbj10KGUuX19lcnJub19sb2NhdGlvbiksZS5tYWxsb2M9bihlLm1hbGxvYyksZS5zdGFja1NhdmU9dChlLnN0YWNrU2F2ZSksZS5zdGFja0FsbG9jPW4oZS5zdGFja0FsbG9jKSxlfShlKSxUPXguTCxJKCksRC51bnNoaWZ0KHguTSksTC0tLG8ubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmby5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEwpLDA9PUwmJihudWxsIT09QyYmKGNsZWFySW50ZXJ2YWwoQyksQz1udWxsKSxSKSl7dmFyIHQ9UjtSPW51bGwsdCgpfXJldHVybiBlfXZhciB0PXthOmxlfTtpZihMKyssby5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZvLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoTCksby5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBvLmluc3RhbnRpYXRlV2FzbSh0LGUpfWNhdGNoKGUpe18oXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitlKSxyKGUpfShmdW5jdGlvbihlLHQpe3ZhciBuPUY7cmV0dXJuIG18fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxNKG4pfHxuLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfHxmfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9WKG4sZSx0KTpmZXRjaChuLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChyPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyLGUpLnRoZW4odCwoZnVuY3Rpb24ocil7cmV0dXJuIF8oXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrciksXyhcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLFYobixlLHQpfSkpKSl9KSh0LChmdW5jdGlvbih0KXtlKHQuaW5zdGFuY2UpfSkpLmNhdGNoKHIpfSgpLG8uX09ydEluaXQ9KGUsdCk9PihvLl9PcnRJbml0PXguTikoZSx0KSxvLl9PcnRHZXRMYXN0RXJyb3I9KGUsdCk9PihvLl9PcnRHZXRMYXN0RXJyb3I9eC5PKShlLHQpLG8uX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShlLHQsbixyLGkscyxhLHUsbCxjKT0+KG8uX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPXguUCkoZSx0LG4scixpLHMsYSx1LGwsYyksby5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9KGUsdCk9PihvLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj14LlEpKGUsdCksby5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShlLHQsbik9PihvLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9eC5SKShlLHQsbiksby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPWU9PihvLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9eC5TKShlKSxvLl9PcnRDcmVhdGVTZXNzaW9uPShlLHQsbik9PihvLl9PcnRDcmVhdGVTZXNzaW9uPXguVCkoZSx0LG4pLG8uX09ydFJlbGVhc2VTZXNzaW9uPWU9PihvLl9PcnRSZWxlYXNlU2Vzc2lvbj14LlUpKGUpLG8uX09ydEdldElucHV0T3V0cHV0Q291bnQ9KGUsdCxuKT0+KG8uX09ydEdldElucHV0T3V0cHV0Q291bnQ9eC5WKShlLHQsbiksby5fT3J0R2V0SW5wdXROYW1lPShlLHQpPT4oby5fT3J0R2V0SW5wdXROYW1lPXguVykoZSx0KSxvLl9PcnRHZXRPdXRwdXROYW1lPShlLHQpPT4oby5fT3J0R2V0T3V0cHV0TmFtZT14LlgpKGUsdCksby5fT3J0RnJlZT1lPT4oby5fT3J0RnJlZT14LlkpKGUpLG8uX09ydENyZWF0ZVRlbnNvcj0oZSx0LG4scixpKT0+KG8uX09ydENyZWF0ZVRlbnNvcj14LlopKGUsdCxuLHIsaSksby5fT3J0R2V0VGVuc29yRGF0YT0oZSx0LG4scixpKT0+KG8uX09ydEdldFRlbnNvckRhdGE9eC5fKShlLHQsbixyLGkpLG8uX09ydFJlbGVhc2VUZW5zb3I9ZT0+KG8uX09ydFJlbGVhc2VUZW5zb3I9eC4kKShlKSxvLl9PcnRDcmVhdGVSdW5PcHRpb25zPShlLHQsbixyKT0+KG8uX09ydENyZWF0ZVJ1bk9wdGlvbnM9eC5hYSkoZSx0LG4sciksby5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KGUsdCxuKT0+KG8uX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PXguYmEpKGUsdCxuKSxvLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1lPT4oby5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9eC5jYSkoZSksby5fT3J0UnVuPShlLHQsbixyLGkscyxhLHUpPT4oby5fT3J0UnVuPXguZGEpKGUsdCxuLHIsaSxzLGEsdSksby5fT3J0RW5kUHJvZmlsaW5nPWU9PihvLl9PcnRFbmRQcm9maWxpbmc9eC5lYSkoZSk7dmFyIGNlPW8uX21hbGxvYz1lPT4oY2U9by5fbWFsbG9jPXguZmEpKGUpO28uX2ZyZWU9ZT0+KG8uX2ZyZWU9eC5nYSkoZSk7dmFyIHBlLGRlPWU9PihkZT14LmlhKShlKSxmZT0oKT0+KGZlPXguamEpKCksaGU9ZT0+KGhlPXgua2EpKGUpLGdlPWU9PihnZT14LmxhKShlKTtmdW5jdGlvbiBiZSgpe2Z1bmN0aW9uIGUoKXtpZighcGUmJihwZT0hMCxvLmNhbGxlZFJ1bj0hMCwhUCkpe2lmKEcoRCksdChvKSxvLm9uUnVudGltZUluaXRpYWxpemVkJiZvLm9uUnVudGltZUluaXRpYWxpemVkKCksby5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBvLnBvc3RSdW4mJihvLnBvc3RSdW49W28ucG9zdFJ1bl0pO28ucG9zdFJ1bi5sZW5ndGg7KXt2YXIgZT1vLnBvc3RSdW4uc2hpZnQoKTskLnVuc2hpZnQoZSl9RygkKX19aWYoISgwPEwpKXtpZihvLnByZVJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygby5wcmVSdW4mJihvLnByZVJ1bj1bby5wcmVSdW5dKTtvLnByZVJ1bi5sZW5ndGg7KWsoKTtHKEUpLDA8THx8KG8uc2V0U3RhdHVzPyhvLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe28uc2V0U3RhdHVzKFwiXCIpfSksMSksZSgpfSksMSkpOmUoKSl9fWlmKG8uc3RhY2tBbGxvYz1nZSxvLnN0YWNrU2F2ZT1mZSxvLnN0YWNrUmVzdG9yZT1oZSxvLlVURjhUb1N0cmluZz1ZLG8uc3RyaW5nVG9VVEY4PShlLHQsbik9PkooZSxPLHQsbiksby5sZW5ndGhCeXRlc1VURjg9SyxSPWZ1bmN0aW9uIGUoKXtwZXx8YmUoKSxwZXx8KFI9ZSl9LG8ucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2Ygby5wcmVJbml0JiYoby5wcmVJbml0PVtvLnByZUluaXRdKTswPG8ucHJlSW5pdC5sZW5ndGg7KW8ucHJlSW5pdC5wb3AoKSgpO3JldHVybiBiZSgpLGUucmVhZHl9KTtlLmV4cG9ydHM9cn0sNDUzNzplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpLHI9MCxvPTIsaT0hMDtvPGFyZ3VtZW50cy5sZW5ndGg7KW5bcisrXT1hcmd1bWVudHNbbysrXTtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG8scyl7bltyXT1mdW5jdGlvbihlKXtpZihpKWlmKGk9ITEsZSlzKGUpO2Vsc2V7Zm9yKHZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpLG49MDtuPHQubGVuZ3RoOyl0W24rK109YXJndW1lbnRzW25dO28uYXBwbHkobnVsbCx0KX19O3RyeXtlLmFwcGx5KHR8fG51bGwsbil9Y2F0Y2goZSl7aSYmKGk9ITEscyhlKSl9fSkpfX0sNzQxOTooZSx0KT0+e1widXNlIHN0cmljdFwiO3ZhciBuPXQ7bi5sZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGg7aWYoIXQpcmV0dXJuIDA7Zm9yKHZhciBuPTA7LS10JTQ+MSYmXCI9XCI9PT1lLmNoYXJBdCh0KTspKytuO3JldHVybiBNYXRoLmNlaWwoMyplLmxlbmd0aCkvNC1ufTtmb3IodmFyIHI9bmV3IEFycmF5KDY0KSxvPW5ldyBBcnJheSgxMjMpLGk9MDtpPDY0OylvW3JbaV09aTwyNj9pKzY1Omk8NTI/aSs3MTppPDYyP2ktNDppLTU5fDQzXT1pKys7bi5lbmNvZGU9ZnVuY3Rpb24oZSx0LG4pe2Zvcih2YXIgbyxpPW51bGwscz1bXSxhPTAsdT0wO3Q8bjspe3ZhciBsPWVbdCsrXTtzd2l0Y2godSl7Y2FzZSAwOnNbYSsrXT1yW2w+PjJdLG89KDMmbCk8PDQsdT0xO2JyZWFrO2Nhc2UgMTpzW2ErK109cltvfGw+PjRdLG89KDE1JmwpPDwyLHU9MjticmVhaztjYXNlIDI6c1thKytdPXJbb3xsPj42XSxzW2ErK109cls2MyZsXSx1PTB9YT44MTkxJiYoKGl8fChpPVtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxzKSksYT0wKX1yZXR1cm4gdSYmKHNbYSsrXT1yW29dLHNbYSsrXT02MSwxPT09dSYmKHNbYSsrXT02MSkpLGk/KGEmJmkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxzLnNsaWNlKDAsYSkpKSxpLmpvaW4oXCJcIikpOlN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLHMuc2xpY2UoMCxhKSl9O3ZhciBzPVwiaW52YWxpZCBlbmNvZGluZ1wiO24uZGVjb2RlPWZ1bmN0aW9uKGUsdCxuKXtmb3IodmFyIHIsaT1uLGE9MCx1PTA7dTxlLmxlbmd0aDspe3ZhciBsPWUuY2hhckNvZGVBdCh1KyspO2lmKDYxPT09bCYmYT4xKWJyZWFrO2lmKHZvaWQgMD09PShsPW9bbF0pKXRocm93IEVycm9yKHMpO3N3aXRjaChhKXtjYXNlIDA6cj1sLGE9MTticmVhaztjYXNlIDE6dFtuKytdPXI8PDJ8KDQ4JmwpPj40LHI9bCxhPTI7YnJlYWs7Y2FzZSAyOnRbbisrXT0oMTUmcik8PDR8KDYwJmwpPj4yLHI9bCxhPTM7YnJlYWs7Y2FzZSAzOnRbbisrXT0oMyZyKTw8NnxsLGE9MH19aWYoMT09PWEpdGhyb3cgRXJyb3Iocyk7cmV0dXJuIG4taX0sbi50ZXN0PWZ1bmN0aW9uKGUpe3JldHVybi9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KGUpfX0sOTIxMTplPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCgpe3RoaXMuX2xpc3RlbmVycz17fX1lLmV4cG9ydHM9dCx0LnByb3RvdHlwZS5vbj1mdW5jdGlvbihlLHQsbil7cmV0dXJuKHRoaXMuX2xpc3RlbmVyc1tlXXx8KHRoaXMuX2xpc3RlbmVyc1tlXT1bXSkpLnB1c2goe2ZuOnQsY3R4Om58fHRoaXN9KSx0aGlzfSx0LnByb3RvdHlwZS5vZmY9ZnVuY3Rpb24oZSx0KXtpZih2b2lkIDA9PT1lKXRoaXMuX2xpc3RlbmVycz17fTtlbHNlIGlmKHZvaWQgMD09PXQpdGhpcy5fbGlzdGVuZXJzW2VdPVtdO2Vsc2UgZm9yKHZhciBuPXRoaXMuX2xpc3RlbmVyc1tlXSxyPTA7cjxuLmxlbmd0aDspbltyXS5mbj09PXQ/bi5zcGxpY2UociwxKTorK3I7cmV0dXJuIHRoaXN9LHQucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fbGlzdGVuZXJzW2VdO2lmKHQpe2Zvcih2YXIgbj1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoOyluLnB1c2goYXJndW1lbnRzW3IrK10pO2ZvcihyPTA7cjx0Lmxlbmd0aDspdFtyXS5mbi5hcHBseSh0W3IrK10uY3R4LG4pfXJldHVybiB0aGlzfX0sOTQ1OmU9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KGUpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBGbG9hdDMyQXJyYXk/ZnVuY3Rpb24oKXt2YXIgdD1uZXcgRmxvYXQzMkFycmF5KFstMF0pLG49bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpLHI9MTI4PT09blszXTtmdW5jdGlvbiBvKGUscixvKXt0WzBdPWUscltvXT1uWzBdLHJbbysxXT1uWzFdLHJbbysyXT1uWzJdLHJbbyszXT1uWzNdfWZ1bmN0aW9uIGkoZSxyLG8pe3RbMF09ZSxyW29dPW5bM10scltvKzFdPW5bMl0scltvKzJdPW5bMV0scltvKzNdPW5bMF19ZnVuY3Rpb24gcyhlLHIpe3JldHVybiBuWzBdPWVbcl0sblsxXT1lW3IrMV0sblsyXT1lW3IrMl0sblszXT1lW3IrM10sdFswXX1mdW5jdGlvbiBhKGUscil7cmV0dXJuIG5bM109ZVtyXSxuWzJdPWVbcisxXSxuWzFdPWVbcisyXSxuWzBdPWVbciszXSx0WzBdfWUud3JpdGVGbG9hdExFPXI/bzppLGUud3JpdGVGbG9hdEJFPXI/aTpvLGUucmVhZEZsb2F0TEU9cj9zOmEsZS5yZWFkRmxvYXRCRT1yP2E6c30oKTpmdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSx0LG4scil7dmFyIG89dDwwPzE6MDtpZihvJiYodD0tdCksMD09PXQpZSgxL3Q+MD8wOjIxNDc0ODM2NDgsbixyKTtlbHNlIGlmKGlzTmFOKHQpKWUoMjE0MzI4OTM0NCxuLHIpO2Vsc2UgaWYodD4zNDAyODIzNDY2Mzg1Mjg4NmUyMillKChvPDwzMXwyMTM5MDk1MDQwKT4+PjAsbixyKTtlbHNlIGlmKHQ8MTE3NTQ5NDM1MDgyMjI4NzVlLTU0KWUoKG88PDMxfE1hdGgucm91bmQodC8xNDAxMjk4NDY0MzI0ODE3ZS02MCkpPj4+MCxuLHIpO2Vsc2V7dmFyIGk9TWF0aC5mbG9vcihNYXRoLmxvZyh0KS9NYXRoLkxOMik7ZSgobzw8MzF8aSsxMjc8PDIzfDgzODg2MDcmTWF0aC5yb3VuZCh0Kk1hdGgucG93KDIsLWkpKjgzODg2MDgpKT4+PjAsbixyKX19ZnVuY3Rpb24gcyhlLHQsbil7dmFyIHI9ZSh0LG4pLG89Mioocj4+MzEpKzEsaT1yPj4+MjMmMjU1LHM9ODM4ODYwNyZyO3JldHVybiAyNTU9PT1pP3M/TmFOOm8qKDEvMCk6MD09PWk/MTQwMTI5ODQ2NDMyNDgxN2UtNjAqbypzOm8qTWF0aC5wb3coMixpLTE1MCkqKHMrODM4ODYwOCl9ZS53cml0ZUZsb2F0TEU9dC5iaW5kKG51bGwsbiksZS53cml0ZUZsb2F0QkU9dC5iaW5kKG51bGwsciksZS5yZWFkRmxvYXRMRT1zLmJpbmQobnVsbCxvKSxlLnJlYWRGbG9hdEJFPXMuYmluZChudWxsLGkpfSgpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBGbG9hdDY0QXJyYXk/ZnVuY3Rpb24oKXt2YXIgdD1uZXcgRmxvYXQ2NEFycmF5KFstMF0pLG49bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpLHI9MTI4PT09bls3XTtmdW5jdGlvbiBvKGUscixvKXt0WzBdPWUscltvXT1uWzBdLHJbbysxXT1uWzFdLHJbbysyXT1uWzJdLHJbbyszXT1uWzNdLHJbbys0XT1uWzRdLHJbbys1XT1uWzVdLHJbbys2XT1uWzZdLHJbbys3XT1uWzddfWZ1bmN0aW9uIGkoZSxyLG8pe3RbMF09ZSxyW29dPW5bN10scltvKzFdPW5bNl0scltvKzJdPW5bNV0scltvKzNdPW5bNF0scltvKzRdPW5bM10scltvKzVdPW5bMl0scltvKzZdPW5bMV0scltvKzddPW5bMF19ZnVuY3Rpb24gcyhlLHIpe3JldHVybiBuWzBdPWVbcl0sblsxXT1lW3IrMV0sblsyXT1lW3IrMl0sblszXT1lW3IrM10sbls0XT1lW3IrNF0sbls1XT1lW3IrNV0sbls2XT1lW3IrNl0sbls3XT1lW3IrN10sdFswXX1mdW5jdGlvbiBhKGUscil7cmV0dXJuIG5bN109ZVtyXSxuWzZdPWVbcisxXSxuWzVdPWVbcisyXSxuWzRdPWVbciszXSxuWzNdPWVbcis0XSxuWzJdPWVbcis1XSxuWzFdPWVbcis2XSxuWzBdPWVbcis3XSx0WzBdfWUud3JpdGVEb3VibGVMRT1yP286aSxlLndyaXRlRG91YmxlQkU9cj9pOm8sZS5yZWFkRG91YmxlTEU9cj9zOmEsZS5yZWFkRG91YmxlQkU9cj9hOnN9KCk6ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUsdCxuLHIsbyxpKXt2YXIgcz1yPDA/MTowO2lmKHMmJihyPS1yKSwwPT09cillKDAsbyxpK3QpLGUoMS9yPjA/MDoyMTQ3NDgzNjQ4LG8saStuKTtlbHNlIGlmKGlzTmFOKHIpKWUoMCxvLGkrdCksZSgyMTQ2OTU5MzYwLG8saStuKTtlbHNlIGlmKHI+MTc5NzY5MzEzNDg2MjMxNTdlMjkyKWUoMCxvLGkrdCksZSgoczw8MzF8MjE0NjQzNTA3Mik+Pj4wLG8saStuKTtlbHNle3ZhciBhO2lmKHI8MjIyNTA3Mzg1ODUwNzIwMTRlLTMyNCllKChhPXIvNWUtMzI0KT4+PjAsbyxpK3QpLGUoKHM8PDMxfGEvNDI5NDk2NzI5Nik+Pj4wLG8saStuKTtlbHNle3ZhciB1PU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpOzEwMjQ9PT11JiYodT0xMDIzKSxlKDQ1MDM1OTk2MjczNzA0OTYqKGE9cipNYXRoLnBvdygyLC11KSk+Pj4wLG8saSt0KSxlKChzPDwzMXx1KzEwMjM8PDIwfDEwNDg1NzYqYSYxMDQ4NTc1KT4+PjAsbyxpK24pfX19ZnVuY3Rpb24gcyhlLHQsbixyLG8pe3ZhciBpPWUocixvK3QpLHM9ZShyLG8rbiksYT0yKihzPj4zMSkrMSx1PXM+Pj4yMCYyMDQ3LGw9NDI5NDk2NzI5NiooMTA0ODU3NSZzKStpO3JldHVybiAyMDQ3PT09dT9sP05hTjphKigxLzApOjA9PT11PzVlLTMyNCphKmw6YSpNYXRoLnBvdygyLHUtMTA3NSkqKGwrNDUwMzU5OTYyNzM3MDQ5Nil9ZS53cml0ZURvdWJsZUxFPXQuYmluZChudWxsLG4sMCw0KSxlLndyaXRlRG91YmxlQkU9dC5iaW5kKG51bGwsciw0LDApLGUucmVhZERvdWJsZUxFPXMuYmluZChudWxsLG8sMCw0KSxlLnJlYWREb3VibGVCRT1zLmJpbmQobnVsbCxpLDQsMCl9KCksZX1mdW5jdGlvbiBuKGUsdCxuKXt0W25dPTI1NSZlLHRbbisxXT1lPj4+OCYyNTUsdFtuKzJdPWU+Pj4xNiYyNTUsdFtuKzNdPWU+Pj4yNH1mdW5jdGlvbiByKGUsdCxuKXt0W25dPWU+Pj4yNCx0W24rMV09ZT4+PjE2JjI1NSx0W24rMl09ZT4+PjgmMjU1LHRbbiszXT0yNTUmZX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuKGVbdF18ZVt0KzFdPDw4fGVbdCsyXTw8MTZ8ZVt0KzNdPDwyNCk+Pj4wfWZ1bmN0aW9uIGkoZSx0KXtyZXR1cm4oZVt0XTw8MjR8ZVt0KzFdPDwxNnxlW3QrMl08PDh8ZVt0KzNdKT4+PjB9ZS5leHBvcnRzPXQodCl9LDcxOTk6bW9kdWxlPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKXt0cnl7dmFyIG1vZD1ldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTtpZihtb2QmJihtb2QubGVuZ3RofHxPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpcmV0dXJuIG1vZH1jYXRjaChlKXt9cmV0dXJuIG51bGx9bW9kdWxlLmV4cG9ydHM9aW5xdWlyZX0sNjY2MjplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1ufHw4MTkyLG89cj4+PjEsaT1udWxsLHM9cjtyZXR1cm4gZnVuY3Rpb24obil7aWYobjwxfHxuPm8pcmV0dXJuIGUobik7cytuPnImJihpPWUocikscz0wKTt2YXIgYT10LmNhbGwoaSxzLHMrPW4pO3JldHVybiA3JnMmJihzPTErKDd8cykpLGF9fX0sNDk5NzooZSx0KT0+e1widXNlIHN0cmljdFwiO3ZhciBuPXQ7bi5sZW5ndGg9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTAsbj0wLHI9MDtyPGUubGVuZ3RoOysrcikobj1lLmNoYXJDb2RlQXQocikpPDEyOD90Kz0xOm48MjA0OD90Kz0yOjU1Mjk2PT0oNjQ1MTImbikmJjU2MzIwPT0oNjQ1MTImZS5jaGFyQ29kZUF0KHIrMSkpPygrK3IsdCs9NCk6dCs9MztyZXR1cm4gdH0sbi5yZWFkPWZ1bmN0aW9uKGUsdCxuKXtpZihuLXQ8MSlyZXR1cm5cIlwiO2Zvcih2YXIgcixvPW51bGwsaT1bXSxzPTA7dDxuOykocj1lW3QrK10pPDEyOD9pW3MrK109cjpyPjE5MSYmcjwyMjQ/aVtzKytdPSgzMSZyKTw8Nnw2MyZlW3QrK106cj4yMzkmJnI8MzY1PyhyPSgoNyZyKTw8MTh8KDYzJmVbdCsrXSk8PDEyfCg2MyZlW3QrK10pPDw2fDYzJmVbdCsrXSktNjU1MzYsaVtzKytdPTU1Mjk2KyhyPj4xMCksaVtzKytdPTU2MzIwKygxMDIzJnIpKTppW3MrK109KDE1JnIpPDwxMnwoNjMmZVt0KytdKTw8Nnw2MyZlW3QrK10scz44MTkxJiYoKG98fChvPVtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxpKSkscz0wKTtyZXR1cm4gbz8ocyYmby5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGkuc2xpY2UoMCxzKSkpLG8uam9pbihcIlwiKSk6U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsaS5zbGljZSgwLHMpKX0sbi53cml0ZT1mdW5jdGlvbihlLHQsbil7Zm9yKHZhciByLG8saT1uLHM9MDtzPGUubGVuZ3RoOysrcykocj1lLmNoYXJDb2RlQXQocykpPDEyOD90W24rK109cjpyPDIwNDg/KHRbbisrXT1yPj42fDE5Mix0W24rK109NjMmcnwxMjgpOjU1Mjk2PT0oNjQ1MTImcikmJjU2MzIwPT0oNjQ1MTImKG89ZS5jaGFyQ29kZUF0KHMrMSkpKT8ocj02NTUzNisoKDEwMjMmcik8PDEwKSsoMTAyMyZvKSwrK3MsdFtuKytdPXI+PjE4fDI0MCx0W24rK109cj4+MTImNjN8MTI4LHRbbisrXT1yPj42JjYzfDEyOCx0W24rK109NjMmcnwxMjgpOih0W24rK109cj4+MTJ8MjI0LHRbbisrXT1yPj42JjYzfDEyOCx0W24rK109NjMmcnwxMjgpO3JldHVybiBuLWl9fSwzNDQyOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwO3ZhciBuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtpZighdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudDsgYHZhbHVlYCBoYXMgbm8gdmFsdWUuXCIpO3RoaXMudmFsdWU9ZS5FTVBUWSx0JiZlLmlzR3VpZCh0KSYmKHRoaXMudmFsdWU9dCl9cmV0dXJuIGUuaXNHdWlkPWZ1bmN0aW9uKHQpe3ZhciBuPXQudG9TdHJpbmcoKTtyZXR1cm4gdCYmKHQgaW5zdGFuY2VvZiBlfHxlLnZhbGlkYXRvci50ZXN0KG4pKX0sZS5jcmVhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUoW2UuZ2VuKDIpLGUuZ2VuKDEpLGUuZ2VuKDEpLGUuZ2VuKDEpLGUuZ2VuKDMpXS5qb2luKFwiLVwiKSl9LGUuY3JlYXRlRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUoXCJlbXB0eWd1aWRcIil9LGUucGFyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBlKHQpfSxlLnJhdz1mdW5jdGlvbigpe3JldHVybltlLmdlbigyKSxlLmdlbigxKSxlLmdlbigxKSxlLmdlbigxKSxlLmdlbigzKV0uam9pbihcIi1cIil9LGUuZ2VuPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1cIlwiLG49MDtuPGU7bisrKXQrPSg2NTUzNiooMStNYXRoLnJhbmRvbSgpKXwwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO3JldHVybiB0fSxlLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIGUuaXNHdWlkKHQpJiZ0aGlzLnZhbHVlPT09dC50b1N0cmluZygpfSxlLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWU9PT1lLkVNUFRZfSxlLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxlLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dmFsdWU6dGhpcy52YWx1ZX19LGUudmFsaWRhdG9yPW5ldyBSZWdFeHAoXCJeW2EtejAtOV17OH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17NH0tW2EtejAtOV17MTJ9JFwiLFwiaVwiKSxlLkVNUFRZPVwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCIsZX0oKTt0Lkd1aWQ9bn0sMjEwMDooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPW4oOTQ4Mil9LDk0ODI6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO3ZhciByPXQ7ZnVuY3Rpb24gbygpe3IudXRpbC5fY29uZmlndXJlKCksci5Xcml0ZXIuX2NvbmZpZ3VyZShyLkJ1ZmZlcldyaXRlciksci5SZWFkZXIuX2NvbmZpZ3VyZShyLkJ1ZmZlclJlYWRlcil9ci5idWlsZD1cIm1pbmltYWxcIixyLldyaXRlcj1uKDExNzMpLHIuQnVmZmVyV3JpdGVyPW4oMzE1NSksci5SZWFkZXI9bigxNDA4KSxyLkJ1ZmZlclJlYWRlcj1uKDU5Myksci51dGlsPW4oOTY5Myksci5ycGM9big1OTk0KSxyLnJvb3RzPW4oNTA1NCksci5jb25maWd1cmU9byxvKCl9LDE0MDg6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz11O3ZhciByLG89big5NjkzKSxpPW8uTG9uZ0JpdHMscz1vLnV0Zjg7ZnVuY3Rpb24gYShlLHQpe3JldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIitlLnBvcytcIiArIFwiKyh0fHwxKStcIiA+IFwiK2UubGVuKX1mdW5jdGlvbiB1KGUpe3RoaXMuYnVmPWUsdGhpcy5wb3M9MCx0aGlzLmxlbj1lLmxlbmd0aH12YXIgbCxjPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5P2Z1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHxBcnJheS5pc0FycmF5KGUpKXJldHVybiBuZXcgdShlKTt0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpfTpmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBuZXcgdShlKTt0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpfSxwPWZ1bmN0aW9uKCl7cmV0dXJuIG8uQnVmZmVyP2Z1bmN0aW9uKGUpe3JldHVybih1LmNyZWF0ZT1mdW5jdGlvbihlKXtyZXR1cm4gby5CdWZmZXIuaXNCdWZmZXIoZSk/bmV3IHIoZSk6YyhlKX0pKGUpfTpjfTtmdW5jdGlvbiBkKCl7dmFyIGU9bmV3IGkoMCwwKSx0PTA7aWYoISh0aGlzLmxlbi10aGlzLnBvcz40KSl7Zm9yKDt0PDM7Kyt0KXtpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgYSh0aGlzKTtpZihlLmxvPShlLmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyp0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlfXJldHVybiBlLmxvPShlLmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3MrK10pPDw3KnQpPj4+MCxlfWZvcig7dDw0OysrdClpZihlLmxvPShlLmxvfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyp0KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlO2lmKGUubG89KGUubG98KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwyOCk+Pj4wLGUuaGk9KGUuaGl8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPj40KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlO2lmKHQ9MCx0aGlzLmxlbi10aGlzLnBvcz40KXtmb3IoO3Q8NTsrK3QpaWYoZS5oaT0oZS5oaXwoMTI3JnRoaXMuYnVmW3RoaXMucG9zXSk8PDcqdCszKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBlfWVsc2UgZm9yKDt0PDU7Kyt0KXtpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgYSh0aGlzKTtpZihlLmhpPShlLmhpfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8Nyp0KzMpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGV9dGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKX1mdW5jdGlvbiBmKGUsdCl7cmV0dXJuKGVbdC00XXxlW3QtM108PDh8ZVt0LTJdPDwxNnxlW3QtMV08PDI0KT4+PjB9ZnVuY3Rpb24gaCgpe2lmKHRoaXMucG9zKzg+dGhpcy5sZW4pdGhyb3cgYSh0aGlzLDgpO3JldHVybiBuZXcgaShmKHRoaXMuYnVmLHRoaXMucG9zKz00KSxmKHRoaXMuYnVmLHRoaXMucG9zKz00KSl9dS5jcmVhdGU9cCgpLHUucHJvdG90eXBlLl9zbGljZT1vLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheXx8by5BcnJheS5wcm90b3R5cGUuc2xpY2UsdS5wcm90b3R5cGUudWludDMyPShsPTQyOTQ5NjcyOTUsZnVuY3Rpb24oKXtpZihsPSgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBsO2lmKGw9KGx8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDw3KT4+PjAsdGhpcy5idWZbdGhpcy5wb3MrK108MTI4KXJldHVybiBsO2lmKGw9KGx8KDEyNyZ0aGlzLmJ1Zlt0aGlzLnBvc10pPDwxNCk+Pj4wLHRoaXMuYnVmW3RoaXMucG9zKytdPDEyOClyZXR1cm4gbDtpZihsPShsfCgxMjcmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjEpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGw7aWYobD0obHwoMTUmdGhpcy5idWZbdGhpcy5wb3NdKTw8MjgpPj4+MCx0aGlzLmJ1Zlt0aGlzLnBvcysrXTwxMjgpcmV0dXJuIGw7aWYoKHRoaXMucG9zKz01KT50aGlzLmxlbil0aHJvdyB0aGlzLnBvcz10aGlzLmxlbixhKHRoaXMsMTApO3JldHVybiBsfSksdS5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24oKXtyZXR1cm4gMHx0aGlzLnVpbnQzMigpfSx1LnByb3RvdHlwZS5zaW50MzI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnVpbnQzMigpO3JldHVybiBlPj4+MV4tKDEmZSl8MH0sdS5wcm90b3R5cGUuYm9vbD1mdW5jdGlvbigpe3JldHVybiAwIT09dGhpcy51aW50MzIoKX0sdS5wcm90b3R5cGUuZml4ZWQzMj1mdW5jdGlvbigpe2lmKHRoaXMucG9zKzQ+dGhpcy5sZW4pdGhyb3cgYSh0aGlzLDQpO3JldHVybiBmKHRoaXMuYnVmLHRoaXMucG9zKz00KX0sdS5wcm90b3R5cGUuc2ZpeGVkMzI9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IGEodGhpcyw0KTtyZXR1cm4gMHxmKHRoaXMuYnVmLHRoaXMucG9zKz00KX0sdS5wcm90b3R5cGUuZmxvYXQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvcys0PnRoaXMubGVuKXRocm93IGEodGhpcyw0KTt2YXIgZT1vLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTQsZX0sdS5wcm90b3R5cGUuZG91YmxlPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3MrOD50aGlzLmxlbil0aHJvdyBhKHRoaXMsNCk7dmFyIGU9by5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsdGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSx1LnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbigpe3ZhciBlPXRoaXMudWludDMyKCksdD10aGlzLnBvcyxuPXRoaXMucG9zK2U7aWYobj50aGlzLmxlbil0aHJvdyBhKHRoaXMsZSk7cmV0dXJuIHRoaXMucG9zKz1lLEFycmF5LmlzQXJyYXkodGhpcy5idWYpP3RoaXMuYnVmLnNsaWNlKHQsbik6dD09PW4/bmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApOnRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsdCxuKX0sdS5wcm90b3R5cGUuc3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5ieXRlcygpO3JldHVybiBzLnJlYWQoZSwwLGUubGVuZ3RoKX0sdS5wcm90b3R5cGUuc2tpcD1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYodGhpcy5wb3MrZT50aGlzLmxlbil0aHJvdyBhKHRoaXMsZSk7dGhpcy5wb3MrPWV9ZWxzZSBkb3tpZih0aGlzLnBvcz49dGhpcy5sZW4pdGhyb3cgYSh0aGlzKX13aGlsZSgxMjgmdGhpcy5idWZbdGhpcy5wb3MrK10pO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS5za2lwVHlwZT1mdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZSAwOnRoaXMuc2tpcCgpO2JyZWFrO2Nhc2UgMTp0aGlzLnNraXAoOCk7YnJlYWs7Y2FzZSAyOnRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTticmVhaztjYXNlIDM6Zm9yKDs0IT0oZT03JnRoaXMudWludDMyKCkpOyl0aGlzLnNraXBUeXBlKGUpO2JyZWFrO2Nhc2UgNTp0aGlzLnNraXAoNCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiK2UrXCIgYXQgb2Zmc2V0IFwiK3RoaXMucG9zKX1yZXR1cm4gdGhpc30sdS5fY29uZmlndXJlPWZ1bmN0aW9uKGUpe3I9ZSx1LmNyZWF0ZT1wKCksci5fY29uZmlndXJlKCk7dmFyIHQ9by5Mb25nP1widG9Mb25nXCI6XCJ0b051bWJlclwiO28ubWVyZ2UodS5wcm90b3R5cGUse2ludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGQuY2FsbCh0aGlzKVt0XSghMSl9LHVpbnQ2NDpmdW5jdGlvbigpe3JldHVybiBkLmNhbGwodGhpcylbdF0oITApfSxzaW50NjQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbdF0oITEpfSxmaXhlZDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGguY2FsbCh0aGlzKVt0XSghMCl9LHNmaXhlZDY0OmZ1bmN0aW9uKCl7cmV0dXJuIGguY2FsbCh0aGlzKVt0XSghMSl9fSl9fSw1OTM6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1pO3ZhciByPW4oMTQwOCk7KGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1pO3ZhciBvPW4oOTY5Myk7ZnVuY3Rpb24gaShlKXtyLmNhbGwodGhpcyxlKX1pLl9jb25maWd1cmU9ZnVuY3Rpb24oKXtvLkJ1ZmZlciYmKGkucHJvdG90eXBlLl9zbGljZT1vLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UpfSxpLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnVpbnQzMigpO3JldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2U/dGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLHRoaXMucG9zPU1hdGgubWluKHRoaXMucG9zK2UsdGhpcy5sZW4pKTp0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsdGhpcy5wb3MsdGhpcy5wb3M9TWF0aC5taW4odGhpcy5wb3MrZSx0aGlzLmxlbikpfSxpLl9jb25maWd1cmUoKX0sNTA1NDplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXt9fSw1OTk0OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjt0LlNlcnZpY2U9big3OTQ4KX0sNzk0ODooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPW87dmFyIHI9big5NjkzKTtmdW5jdGlvbiBvKGUsdCxuKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO3IuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyksdGhpcy5ycGNJbXBsPWUsdGhpcy5yZXF1ZXN0RGVsaW1pdGVkPUJvb2xlYW4odCksdGhpcy5yZXNwb25zZURlbGltaXRlZD1Cb29sZWFuKG4pfShvLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPW8sby5wcm90b3R5cGUucnBjQ2FsbD1mdW5jdGlvbiBlKHQsbixvLGkscyl7aWYoIWkpdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTt2YXIgYT10aGlzO2lmKCFzKXJldHVybiByLmFzUHJvbWlzZShlLGEsdCxuLG8saSk7aWYoYS5ycGNJbXBsKXRyeXtyZXR1cm4gYS5ycGNJbXBsKHQsblthLnJlcXVlc3REZWxpbWl0ZWQ/XCJlbmNvZGVEZWxpbWl0ZWRcIjpcImVuY29kZVwiXShpKS5maW5pc2goKSwoZnVuY3Rpb24oZSxuKXtpZihlKXJldHVybiBhLmVtaXQoXCJlcnJvclwiLGUsdCkscyhlKTtpZihudWxsIT09bil7aWYoIShuIGluc3RhbmNlb2YgbykpdHJ5e249b1thLnJlc3BvbnNlRGVsaW1pdGVkP1wiZGVjb2RlRGVsaW1pdGVkXCI6XCJkZWNvZGVcIl0obil9Y2F0Y2goZSl7cmV0dXJuIGEuZW1pdChcImVycm9yXCIsZSx0KSxzKGUpfXJldHVybiBhLmVtaXQoXCJkYXRhXCIsbix0KSxzKG51bGwsbil9YS5lbmQoITApfSkpfWNhdGNoKGUpe3JldHVybiBhLmVtaXQoXCJlcnJvclwiLGUsdCksdm9pZCBzZXRUaW1lb3V0KChmdW5jdGlvbigpe3MoZSl9KSwwKX1lbHNlIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7cyhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpfSksMCl9LG8ucHJvdG90eXBlLmVuZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5ycGNJbXBsJiYoZXx8dGhpcy5ycGNJbXBsKG51bGwsbnVsbCxudWxsKSx0aGlzLnJwY0ltcGw9bnVsbCx0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCkpLHRoaXN9fSwxOTQ1OihlLHQsbik9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9bzt2YXIgcj1uKDk2OTMpO2Z1bmN0aW9uIG8oZSx0KXt0aGlzLmxvPWU+Pj4wLHRoaXMuaGk9dD4+PjB9dmFyIGk9by56ZXJvPW5ldyBvKDAsMCk7aS50b051bWJlcj1mdW5jdGlvbigpe3JldHVybiAwfSxpLnp6RW5jb2RlPWkuenpEZWNvZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30saS5sZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gMX07dmFyIHM9by56ZXJvSGFzaD1cIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO28uZnJvbU51bWJlcj1mdW5jdGlvbihlKXtpZigwPT09ZSlyZXR1cm4gaTt2YXIgdD1lPDA7dCYmKGU9LWUpO3ZhciBuPWU+Pj4wLHI9KGUtbikvNDI5NDk2NzI5Nj4+PjA7cmV0dXJuIHQmJihyPX5yPj4+MCxuPX5uPj4+MCwrK24+NDI5NDk2NzI5NSYmKG49MCwrK3I+NDI5NDk2NzI5NSYmKHI9MCkpKSxuZXcgbyhuLHIpfSxvLmZyb209ZnVuY3Rpb24oZSl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGUpcmV0dXJuIG8uZnJvbU51bWJlcihlKTtpZihyLmlzU3RyaW5nKGUpKXtpZighci5Mb25nKXJldHVybiBvLmZyb21OdW1iZXIocGFyc2VJbnQoZSwxMCkpO2U9ci5Mb25nLmZyb21TdHJpbmcoZSl9cmV0dXJuIGUubG93fHxlLmhpZ2g/bmV3IG8oZS5sb3c+Pj4wLGUuaGlnaD4+PjApOml9LG8ucHJvdG90eXBlLnRvTnVtYmVyPWZ1bmN0aW9uKGUpe2lmKCFlJiZ0aGlzLmhpPj4+MzEpe3ZhciB0PTErfnRoaXMubG8+Pj4wLG49fnRoaXMuaGk+Pj4wO3JldHVybiB0fHwobj1uKzE+Pj4wKSwtKHQrNDI5NDk2NzI5NipuKX1yZXR1cm4gdGhpcy5sbys0Mjk0OTY3Mjk2KnRoaXMuaGl9LG8ucHJvdG90eXBlLnRvTG9uZz1mdW5jdGlvbihlKXtyZXR1cm4gci5Mb25nP25ldyByLkxvbmcoMHx0aGlzLmxvLDB8dGhpcy5oaSxCb29sZWFuKGUpKTp7bG93OjB8dGhpcy5sbyxoaWdoOjB8dGhpcy5oaSx1bnNpZ25lZDpCb29sZWFuKGUpfX07dmFyIGE9U3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O28uZnJvbUhhc2g9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1zP2k6bmV3IG8oKGEuY2FsbChlLDApfGEuY2FsbChlLDEpPDw4fGEuY2FsbChlLDIpPDwxNnxhLmNhbGwoZSwzKTw8MjQpPj4+MCwoYS5jYWxsKGUsNCl8YS5jYWxsKGUsNSk8PDh8YS5jYWxsKGUsNik8PDE2fGEuY2FsbChlLDcpPDwyNCk+Pj4wKX0sby5wcm90b3R5cGUudG9IYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1JnRoaXMubG8sdGhpcy5sbz4+PjgmMjU1LHRoaXMubG8+Pj4xNiYyNTUsdGhpcy5sbz4+PjI0LDI1NSZ0aGlzLmhpLHRoaXMuaGk+Pj44JjI1NSx0aGlzLmhpPj4+MTYmMjU1LHRoaXMuaGk+Pj4yNCl9LG8ucHJvdG90eXBlLnp6RW5jb2RlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5oaT4+MzE7cmV0dXJuIHRoaXMuaGk9KCh0aGlzLmhpPDwxfHRoaXMubG8+Pj4zMSleZSk+Pj4wLHRoaXMubG89KHRoaXMubG88PDFeZSk+Pj4wLHRoaXN9LG8ucHJvdG90eXBlLnp6RGVjb2RlPWZ1bmN0aW9uKCl7dmFyIGU9LSgxJnRoaXMubG8pO3JldHVybiB0aGlzLmxvPSgodGhpcy5sbz4+PjF8dGhpcy5oaTw8MzEpXmUpPj4+MCx0aGlzLmhpPSh0aGlzLmhpPj4+MV5lKT4+PjAsdGhpc30sby5wcm90b3R5cGUubGVuZ3RoPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sbyx0PSh0aGlzLmxvPj4+Mjh8dGhpcy5oaTw8NCk+Pj4wLG49dGhpcy5oaT4+PjI0O3JldHVybiAwPT09bj8wPT09dD9lPDE2Mzg0P2U8MTI4PzE6MjplPDIwOTcxNTI/Mzo0OnQ8MTYzODQ/dDwxMjg/NTo2OnQ8MjA5NzE1Mj83Ojg6bjwxMjg/OToxMH19LDk2OTM6ZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3ZhciByPXQ7ZnVuY3Rpb24gbyhlLHQsbil7Zm9yKHZhciByPU9iamVjdC5rZXlzKHQpLG89MDtvPHIubGVuZ3RoOysrbyl2b2lkIDAhPT1lW3Jbb11dJiZufHwoZVtyW29dXT10W3Jbb11dKTtyZXR1cm4gZX1mdW5jdGlvbiBpKGUpe2Z1bmN0aW9uIHQoZSxuKXtpZighKHRoaXMgaW5zdGFuY2VvZiB0KSlyZXR1cm4gbmV3IHQoZSxuKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcIm1lc3NhZ2VcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9fSksRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U/RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyx0KTpPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInN0YWNrXCIse3ZhbHVlOihuZXcgRXJyb3IpLnN0YWNrfHxcIlwifSksbiYmbyh0aGlzLG4pfXJldHVybiB0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITB9LG5hbWU6e2dldDpmdW5jdGlvbigpe3JldHVybiBlfSxzZXQ6dm9pZCAwLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfSx0b1N0cmluZzp7dmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lK1wiOiBcIit0aGlzLm1lc3NhZ2V9LHdyaXRhYmxlOiEwLGVudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiEwfX0pLHR9ci5hc1Byb21pc2U9big0NTM3KSxyLmJhc2U2ND1uKDc0MTkpLHIuRXZlbnRFbWl0dGVyPW4oOTIxMSksci5mbG9hdD1uKDk0NSksci5pbnF1aXJlPW4oNzE5OSksci51dGY4PW4oNDk5Nyksci5wb29sPW4oNjY2Miksci5Mb25nQml0cz1uKDE5NDUpLHIuaXNOb2RlPUJvb2xlYW4oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCYmZ2xvYmFsJiZnbG9iYWwucHJvY2VzcyYmZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMmJmdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpLHIuZ2xvYmFsPXIuaXNOb2RlJiZnbG9iYWx8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvd3x8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGZ8fHRoaXMsci5lbXB0eUFycmF5PU9iamVjdC5mcmVlemU/T2JqZWN0LmZyZWV6ZShbXSk6W10sci5lbXB0eU9iamVjdD1PYmplY3QuZnJlZXplP09iamVjdC5mcmVlemUoe30pOnt9LHIuaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlJiZpc0Zpbml0ZShlKSYmTWF0aC5mbG9vcihlKT09PWV9LHIuaXNTdHJpbmc9ZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV8fGUgaW5zdGFuY2VvZiBTdHJpbmd9LHIuaXNPYmplY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlfSxyLmlzc2V0PXIuaXNTZXQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lW3RdO3JldHVybiEobnVsbD09bnx8IWUuaGFzT3duUHJvcGVydHkodCkpJiYoXCJvYmplY3RcIiE9dHlwZW9mIG58fChBcnJheS5pc0FycmF5KG4pP24ubGVuZ3RoOk9iamVjdC5rZXlzKG4pLmxlbmd0aCk+MCl9LHIuQnVmZmVyPWZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXIuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7cmV0dXJuIGUucHJvdG90eXBlLnV0ZjhXcml0ZT9lOm51bGx9Y2F0Y2goZSl7cmV0dXJuIG51bGx9fSgpLHIuX0J1ZmZlcl9mcm9tPW51bGwsci5fQnVmZmVyX2FsbG9jVW5zYWZlPW51bGwsci5uZXdCdWZmZXI9ZnVuY3Rpb24oZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGU/ci5CdWZmZXI/ci5fQnVmZmVyX2FsbG9jVW5zYWZlKGUpOm5ldyByLkFycmF5KGUpOnIuQnVmZmVyP3IuX0J1ZmZlcl9mcm9tKGUpOlwidW5kZWZpbmVkXCI9PXR5cGVvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSl9LHIuQXJyYXk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXk/VWludDhBcnJheTpBcnJheSxyLkxvbmc9ci5nbG9iYWwuZGNvZGVJTyYmci5nbG9iYWwuZGNvZGVJTy5Mb25nfHxyLmdsb2JhbC5Mb25nfHxyLmlucXVpcmUoXCJsb25nXCIpLHIua2V5MlJlPS9edHJ1ZXxmYWxzZXwwfDEkLyxyLmtleTMyUmU9L14tPyg/OjB8WzEtOV1bMC05XSopJC8sci5rZXk2NFJlPS9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLyxyLmxvbmdUb0hhc2g9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/ci5Mb25nQml0cy5mcm9tKGUpLnRvSGFzaCgpOnIuTG9uZ0JpdHMuemVyb0hhc2h9LHIubG9uZ0Zyb21IYXNoPWZ1bmN0aW9uKGUsdCl7dmFyIG49ci5Mb25nQml0cy5mcm9tSGFzaChlKTtyZXR1cm4gci5Mb25nP3IuTG9uZy5mcm9tQml0cyhuLmxvLG4uaGksdCk6bi50b051bWJlcihCb29sZWFuKHQpKX0sci5tZXJnZT1vLHIubGNGaXJzdD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKStlLnN1YnN0cmluZygxKX0sci5uZXdFcnJvcj1pLHIuUHJvdG9jb2xFcnJvcj1pKFwiUHJvdG9jb2xFcnJvclwiKSxyLm9uZU9mR2V0dGVyPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD17fSxuPTA7bjxlLmxlbmd0aDsrK24pdFtlW25dXT0xO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgZT1PYmplY3Qua2V5cyh0aGlzKSxuPWUubGVuZ3RoLTE7bj4tMTstLW4paWYoMT09PXRbZVtuXV0mJnZvaWQgMCE9PXRoaXNbZVtuXV0mJm51bGwhPT10aGlzW2Vbbl1dKXJldHVybiBlW25dfX0sci5vbmVPZlNldHRlcj1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDsrK24pZVtuXSE9PXQmJmRlbGV0ZSB0aGlzW2Vbbl1dfX0sci50b0pTT05PcHRpb25zPXtsb25nczpTdHJpbmcsZW51bXM6U3RyaW5nLGJ5dGVzOlN0cmluZyxqc29uOiEwfSxyLl9jb25maWd1cmU9ZnVuY3Rpb24oKXt2YXIgZT1yLkJ1ZmZlcjtlPyhyLl9CdWZmZXJfZnJvbT1lLmZyb20hPT1VaW50OEFycmF5LmZyb20mJmUuZnJvbXx8ZnVuY3Rpb24odCxuKXtyZXR1cm4gbmV3IGUodCxuKX0sci5fQnVmZmVyX2FsbG9jVW5zYWZlPWUuYWxsb2NVbnNhZmV8fGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZSh0KX0pOnIuX0J1ZmZlcl9mcm9tPXIuX0J1ZmZlcl9hbGxvY1Vuc2FmZT1udWxsfX0sMTE3MzooZSx0LG4pPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXA7dmFyIHIsbz1uKDk2OTMpLGk9by5Mb25nQml0cyxzPW8uYmFzZTY0LGE9by51dGY4O2Z1bmN0aW9uIHUoZSx0LG4pe3RoaXMuZm49ZSx0aGlzLmxlbj10LHRoaXMubmV4dD12b2lkIDAsdGhpcy52YWw9bn1mdW5jdGlvbiBsKCl7fWZ1bmN0aW9uIGMoZSl7dGhpcy5oZWFkPWUuaGVhZCx0aGlzLnRhaWw9ZS50YWlsLHRoaXMubGVuPWUubGVuLHRoaXMubmV4dD1lLnN0YXRlc31mdW5jdGlvbiBwKCl7dGhpcy5sZW49MCx0aGlzLmhlYWQ9bmV3IHUobCwwLDApLHRoaXMudGFpbD10aGlzLmhlYWQsdGhpcy5zdGF0ZXM9bnVsbH12YXIgZD1mdW5jdGlvbigpe3JldHVybiBvLkJ1ZmZlcj9mdW5jdGlvbigpe3JldHVybihwLmNyZWF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgcn0pKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBwfX07ZnVuY3Rpb24gZihlLHQsbil7dFtuXT0yNTUmZX1mdW5jdGlvbiBoKGUsdCl7dGhpcy5sZW49ZSx0aGlzLm5leHQ9dm9pZCAwLHRoaXMudmFsPXR9ZnVuY3Rpb24gZyhlLHQsbil7Zm9yKDtlLmhpOyl0W24rK109MTI3JmUubG98MTI4LGUubG89KGUubG8+Pj43fGUuaGk8PDI1KT4+PjAsZS5oaT4+Pj03O2Zvcig7ZS5sbz4xMjc7KXRbbisrXT0xMjcmZS5sb3wxMjgsZS5sbz1lLmxvPj4+Nzt0W24rK109ZS5sb31mdW5jdGlvbiBiKGUsdCxuKXt0W25dPTI1NSZlLHRbbisxXT1lPj4+OCYyNTUsdFtuKzJdPWU+Pj4xNiYyNTUsdFtuKzNdPWU+Pj4yNH1wLmNyZWF0ZT1kKCkscC5hbGxvYz1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IG8uQXJyYXkoZSl9LG8uQXJyYXkhPT1BcnJheSYmKHAuYWxsb2M9by5wb29sKHAuYWxsb2Msby5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpKSxwLnByb3RvdHlwZS5fcHVzaD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgdShlLHQsbiksdGhpcy5sZW4rPXQsdGhpc30saC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh1LnByb3RvdHlwZSksaC5wcm90b3R5cGUuZm49ZnVuY3Rpb24oZSx0LG4pe2Zvcig7ZT4xMjc7KXRbbisrXT0xMjcmZXwxMjgsZT4+Pj03O3Rbbl09ZX0scC5wcm90b3R5cGUudWludDMyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxlbis9KHRoaXMudGFpbD10aGlzLnRhaWwubmV4dD1uZXcgaCgoZT4+Pj0wKTwxMjg/MTplPDE2Mzg0PzI6ZTwyMDk3MTUyPzM6ZTwyNjg0MzU0NTY/NDo1LGUpKS5sZW4sdGhpc30scC5wcm90b3R5cGUuaW50MzI9ZnVuY3Rpb24oZSl7cmV0dXJuIGU8MD90aGlzLl9wdXNoKGcsMTAsaS5mcm9tTnVtYmVyKGUpKTp0aGlzLnVpbnQzMihlKX0scC5wcm90b3R5cGUuc2ludDMyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnVpbnQzMigoZTw8MV5lPj4zMSk+Pj4wKX0scC5wcm90b3R5cGUudWludDY0PWZ1bmN0aW9uKGUpe3ZhciB0PWkuZnJvbShlKTtyZXR1cm4gdGhpcy5fcHVzaChnLHQubGVuZ3RoKCksdCl9LHAucHJvdG90eXBlLmludDY0PXAucHJvdG90eXBlLnVpbnQ2NCxwLnByb3RvdHlwZS5zaW50NjQ9ZnVuY3Rpb24oZSl7dmFyIHQ9aS5mcm9tKGUpLnp6RW5jb2RlKCk7cmV0dXJuIHRoaXMuX3B1c2goZyx0Lmxlbmd0aCgpLHQpfSxwLnByb3RvdHlwZS5ib29sPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9wdXNoKGYsMSxlPzE6MCl9LHAucHJvdG90eXBlLmZpeGVkMzI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3B1c2goYiw0LGU+Pj4wKX0scC5wcm90b3R5cGUuc2ZpeGVkMzI9cC5wcm90b3R5cGUuZml4ZWQzMixwLnByb3RvdHlwZS5maXhlZDY0PWZ1bmN0aW9uKGUpe3ZhciB0PWkuZnJvbShlKTtyZXR1cm4gdGhpcy5fcHVzaChiLDQsdC5sbykuX3B1c2goYiw0LHQuaGkpfSxwLnByb3RvdHlwZS5zZml4ZWQ2ND1wLnByb3RvdHlwZS5maXhlZDY0LHAucHJvdG90eXBlLmZsb2F0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9wdXNoKG8uZmxvYXQud3JpdGVGbG9hdExFLDQsZSl9LHAucHJvdG90eXBlLmRvdWJsZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fcHVzaChvLmZsb2F0LndyaXRlRG91YmxlTEUsOCxlKX07dmFyIG09by5BcnJheS5wcm90b3R5cGUuc2V0P2Z1bmN0aW9uKGUsdCxuKXt0LnNldChlLG4pfTpmdW5jdGlvbihlLHQsbil7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDsrK3IpdFtuK3JdPWVbcl19O3AucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKGUpe3ZhciB0PWUubGVuZ3RoPj4+MDtpZighdClyZXR1cm4gdGhpcy5fcHVzaChmLDEsMCk7aWYoby5pc1N0cmluZyhlKSl7dmFyIG49cC5hbGxvYyh0PXMubGVuZ3RoKGUpKTtzLmRlY29kZShlLG4sMCksZT1ufXJldHVybiB0aGlzLnVpbnQzMih0KS5fcHVzaChtLHQsZSl9LHAucHJvdG90eXBlLnN0cmluZz1mdW5jdGlvbihlKXt2YXIgdD1hLmxlbmd0aChlKTtyZXR1cm4gdD90aGlzLnVpbnQzMih0KS5fcHVzaChhLndyaXRlLHQsZSk6dGhpcy5fcHVzaChmLDEsMCl9LHAucHJvdG90eXBlLmZvcms9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZXM9bmV3IGModGhpcyksdGhpcy5oZWFkPXRoaXMudGFpbD1uZXcgdShsLDAsMCksdGhpcy5sZW49MCx0aGlzfSxwLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlcz8odGhpcy5oZWFkPXRoaXMuc3RhdGVzLmhlYWQsdGhpcy50YWlsPXRoaXMuc3RhdGVzLnRhaWwsdGhpcy5sZW49dGhpcy5zdGF0ZXMubGVuLHRoaXMuc3RhdGVzPXRoaXMuc3RhdGVzLm5leHQpOih0aGlzLmhlYWQ9dGhpcy50YWlsPW5ldyB1KGwsMCwwKSx0aGlzLmxlbj0wKSx0aGlzfSxwLnByb3RvdHlwZS5sZGVsaW09ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmhlYWQsdD10aGlzLnRhaWwsbj10aGlzLmxlbjtyZXR1cm4gdGhpcy5yZXNldCgpLnVpbnQzMihuKSxuJiYodGhpcy50YWlsLm5leHQ9ZS5uZXh0LHRoaXMudGFpbD10LHRoaXMubGVuKz1uKSx0aGlzfSxwLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5oZWFkLm5leHQsdD10aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxuPTA7ZTspZS5mbihlLnZhbCx0LG4pLG4rPWUubGVuLGU9ZS5uZXh0O3JldHVybiB0fSxwLl9jb25maWd1cmU9ZnVuY3Rpb24oZSl7cj1lLHAuY3JlYXRlPWQoKSxyLl9jb25maWd1cmUoKX19LDMxNTU6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1pO3ZhciByPW4oMTE3Myk7KGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1pO3ZhciBvPW4oOTY5Myk7ZnVuY3Rpb24gaSgpe3IuY2FsbCh0aGlzKX1mdW5jdGlvbiBzKGUsdCxuKXtlLmxlbmd0aDw0MD9vLnV0Zjgud3JpdGUoZSx0LG4pOnQudXRmOFdyaXRlP3QudXRmOFdyaXRlKGUsbik6dC53cml0ZShlLG4pfWkuX2NvbmZpZ3VyZT1mdW5jdGlvbigpe2kuYWxsb2M9by5fQnVmZmVyX2FsbG9jVW5zYWZlLGkud3JpdGVCeXRlc0J1ZmZlcj1vLkJ1ZmZlciYmby5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJzZXRcIj09PW8uQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZT9mdW5jdGlvbihlLHQsbil7dC5zZXQoZSxuKX06ZnVuY3Rpb24oZSx0LG4pe2lmKGUuY29weSllLmNvcHkodCxuLDAsZS5sZW5ndGgpO2Vsc2UgZm9yKHZhciByPTA7cjxlLmxlbmd0aDspdFtuKytdPWVbcisrXX19LGkucHJvdG90eXBlLmJ5dGVzPWZ1bmN0aW9uKGUpe28uaXNTdHJpbmcoZSkmJihlPW8uX0J1ZmZlcl9mcm9tKGUsXCJiYXNlNjRcIikpO3ZhciB0PWUubGVuZ3RoPj4+MDtyZXR1cm4gdGhpcy51aW50MzIodCksdCYmdGhpcy5fcHVzaChpLndyaXRlQnl0ZXNCdWZmZXIsdCxlKSx0aGlzfSxpLnByb3RvdHlwZS5zdHJpbmc9ZnVuY3Rpb24oZSl7dmFyIHQ9by5CdWZmZXIuYnl0ZUxlbmd0aChlKTtyZXR1cm4gdGhpcy51aW50MzIodCksdCYmdGhpcy5fcHVzaChzLHQsZSksdGhpc30saS5fY29uZmlndXJlKCl9LDQxNTQ6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz0nXCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e30sYT1cIm9iamVjdFwiPT10eXBlb2YgcHJvY2VzcyYmXCJvYmplY3RcIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMmJlwic3RyaW5nXCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7aWYoYSl7dmFyIHI9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLHQ9ci5wYXJlbnRQb3J0O3Qub24oXCJtZXNzYWdlXCIsKGU9Pm9ubWVzc2FnZSh7ZGF0YTplfSkpKTt2YXIgcz1yZXF1aXJlKFwiZnNcIik7T2JqZWN0LmFzc2lnbihnbG9iYWwse3NlbGY6Z2xvYmFsLHJlcXVpcmU6cmVxdWlyZSxNb2R1bGU6ZSxsb2NhdGlvbjp7aHJlZjpfX2ZpbGVuYW1lfSxXb3JrZXI6ci5Xb3JrZXIsaW1wb3J0U2NyaXB0czplPT4oMCxldmFsKShzLnJlYWRGaWxlU3luYyhlLFwidXRmOFwiKStcIi8vIyBzb3VyY2VVUkw9XCIrZSkscG9zdE1lc3NhZ2U6ZT0+dC5wb3N0TWVzc2FnZShlKSxwZXJmb3JtYW5jZTpnbG9iYWwucGVyZm9ybWFuY2V8fHtub3c6RGF0ZS5ub3d9fSl9dmFyIG89ITEsZD1mdW5jdGlvbigpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbihcIiBcIik7YT9zLndyaXRlU3luYygyLGUrXCJcXFxcblwiKTpjb25zb2xlLmVycm9yKGUpfTtzZWxmLmFsZXJ0PWZ1bmN0aW9uKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFwiIFwiKTtwb3N0TWVzc2FnZSh7Y21kOlwiYWxlcnRcIix0ZXh0OmEsdGhyZWFkSWQ6ZS5fcHRocmVhZF9zZWxmKCl9KX0sZS5pbnN0YW50aWF0ZVdhc209KGEscik9Pnt2YXIgdD1lLndhc21Nb2R1bGU7cmV0dXJuIGUud2FzbU1vZHVsZT1udWxsLHIobmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKHQsYSkpfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWU9Pnt0aHJvdyBlLnJlYXNvbj8/ZX0sc2VsZi5vbm1lc3NhZ2U9ZnVuY3Rpb24gYShyKXt0cnl7aWYoXCJsb2FkXCI9PT1yLmRhdGEuY21kKXtsZXQgcz1bXTtzZWxmLm9ubWVzc2FnZT1lPT5zLnB1c2goZSksc2VsZi5zdGFydFdvcmtlcj1yPT57ZT1yLHBvc3RNZXNzYWdlKHtjbWQ6XCJsb2FkZWRcIn0pO2ZvcihsZXQgZSBvZiBzKWEoZSk7c2VsZi5vbm1lc3NhZ2U9YX0sZS53YXNtTW9kdWxlPXIuZGF0YS53YXNtTW9kdWxlO2Zvcihjb25zdCBhIG9mIHIuZGF0YS5oYW5kbGVycyllW2FdPSguLi5lKT0+e3Bvc3RNZXNzYWdlKHtjbWQ6XCJjYWxsSGFuZGxlclwiLGhhbmRsZXI6YSxhcmdzOmV9KX07aWYoZS53YXNtTWVtb3J5PXIuZGF0YS53YXNtTWVtb3J5LGUuYnVmZmVyPWUud2FzbU1lbW9yeS5idWZmZXIsZS5FTlZJUk9OTUVOVF9JU19QVEhSRUFEPSEwLFwic3RyaW5nXCI9PXR5cGVvZiByLmRhdGEudXJsT3JCbG9iKWltcG9ydFNjcmlwdHMoci5kYXRhLnVybE9yQmxvYik7ZWxzZXt2YXIgdD1VUkwuY3JlYXRlT2JqZWN0VVJMKHIuZGF0YS51cmxPckJsb2IpO2ltcG9ydFNjcmlwdHModCksVVJMLnJldm9rZU9iamVjdFVSTCh0KX1vcnRXYXNtVGhyZWFkZWQoZSl9ZWxzZSBpZihcInJ1blwiPT09ci5kYXRhLmNtZCl7ZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2luaXQoci5kYXRhLnB0aHJlYWRfcHRyLDAsMCwxKSxlLl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdChyLmRhdGEucHRocmVhZF9wdHIpLGUuZXN0YWJsaXNoU3RhY2tTcGFjZSgpLGUuUFRocmVhZC5yZWNlaXZlT2JqZWN0VHJhbnNmZXIoci5kYXRhKSxlLlBUaHJlYWQudGhyZWFkSW5pdFRMUygpLG98fChvPSEwKTt0cnl7ZS5pbnZva2VFbnRyeVBvaW50KHIuZGF0YS5zdGFydF9yb3V0aW5lLHIuZGF0YS5hcmcpfWNhdGNoKGUpe2lmKFwidW53aW5kXCIhPWUpdGhyb3cgZX19ZWxzZVwiY2FuY2VsXCI9PT1yLmRhdGEuY21kP2UuX3B0aHJlYWRfc2VsZigpJiZlLl9fZW1zY3JpcHRlbl90aHJlYWRfZXhpdCgtMSk6XCJzZXRpbW1lZGlhdGVcIj09PXIuZGF0YS50YXJnZXR8fChcImNoZWNrTWFpbGJveFwiPT09ci5kYXRhLmNtZD9vJiZlLmNoZWNrTWFpbGJveCgpOnIuZGF0YS5jbWQmJihkKFwid29ya2VyLmpzIHJlY2VpdmVkIHVua25vd24gY29tbWFuZCBcIityLmRhdGEuY21kKSxkKHIuZGF0YSkpKX1jYXRjaChhKXt0aHJvdyBlLl9fZW1zY3JpcHRlbl90aHJlYWRfY3Jhc2hlZCYmZS5fX2Vtc2NyaXB0ZW5fdGhyZWFkX2NyYXNoZWQoKSxhfX07XFxuJ30sNjIzMTplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJmc1wiKX0sOTcxOTplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJvc1wiKX0sMTQyMzplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJwYXRoXCIpfSw0OTg6ZT0+e1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1yZXF1aXJlKFwicGVyZl9ob29rc1wiKX0sNjQ2NDplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJ1dGlsXCIpfSw0NTY0OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpfSw2MjA3OmU9PntcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9cmVxdWlyZShcIm9ubnhydW50aW1lLWNvbW1vblwiKX0sNjExMzplPT57XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXJlcXVpcmUoXCJjcnlwdG9cIil9LDE1ODM6KGUsdCk9Pnt2YXIgbixyPWZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGVmYXVsdD12b2lkIDA7dmFyIHQ9bnVsbDt0cnl7dD1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSwxMywyLDk2LDAsMSwxMjcsOTYsNCwxMjcsMTI3LDEyNywxMjcsMSwxMjcsMyw3LDYsMCwxLDEsMSwxLDEsNiw2LDEsMTI3LDEsNjUsMCwxMSw3LDUwLDYsMywxMDksMTE3LDEwOCwwLDEsNSwxMDAsMTA1LDExOCw5NSwxMTUsMCwyLDUsMTAwLDEwNSwxMTgsOTUsMTE3LDAsMyw1LDExNCwxMDEsMTA5LDk1LDExNSwwLDQsNSwxMTQsMTAxLDEwOSw5NSwxMTcsMCw1LDgsMTAzLDEwMSwxMTYsOTUsMTA0LDEwNSwxMDMsMTA0LDAsMCwxMCwxOTEsMSw2LDQsMCwzNSwwLDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyNiwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMjcsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTEsMzYsMSwxLDEyNiwzMiwwLDE3MywzMiwxLDE3Myw2NiwzMiwxMzQsMTMyLDMyLDIsMTczLDMyLDMsMTczLDY2LDMyLDEzNCwxMzIsMTI4LDM0LDQsNjYsMzIsMTM1LDE2NywzNiwwLDMyLDQsMTY3LDExLDM2LDEsMSwxMjYsMzIsMCwxNzMsMzIsMSwxNzMsNjYsMzIsMTM0LDEzMiwzMiwyLDE3MywzMiwzLDE3Myw2NiwzMiwxMzQsMTMyLDEyOSwzNCw0LDY2LDMyLDEzNSwxNjcsMzYsMCwzMiw0LDE2NywxMSwzNiwxLDEsMTI2LDMyLDAsMTczLDMyLDEsMTczLDY2LDMyLDEzNCwxMzIsMzIsMiwxNzMsMzIsMywxNzMsNjYsMzIsMTM0LDEzMiwxMzAsMzQsNCw2NiwzMiwxMzUsMTY3LDM2LDAsMzIsNCwxNjcsMTFdKSkse30pLmV4cG9ydHN9Y2F0Y2goZSl7fWZ1bmN0aW9uIG4oZSx0LG4pe3RoaXMubG93PTB8ZSx0aGlzLmhpZ2g9MHx0LHRoaXMudW5zaWduZWQ9ISFufWZ1bmN0aW9uIHIoZSl7cmV0dXJuITA9PT0oZSYmZS5fX2lzTG9uZ19fKX1mdW5jdGlvbiBvKGUpe3ZhciB0PU1hdGguY2x6MzIoZSYtZSk7cmV0dXJuIGU/MzEtdDp0fW4ucHJvdG90eXBlLl9faXNMb25nX18sT2JqZWN0LmRlZmluZVByb3BlcnR5KG4ucHJvdG90eXBlLFwiX19pc0xvbmdfX1wiLHt2YWx1ZTohMH0pLG4uaXNMb25nPXI7dmFyIGk9e30scz17fTtmdW5jdGlvbiBhKGUsdCl7dmFyIG4scixvO3JldHVybiB0PyhvPTA8PShlPj4+PTApJiZlPDI1NikmJihyPXNbZV0pP3I6KG49bChlLDAsITApLG8mJihzW2VdPW4pLG4pOihvPS0xMjg8PShlfD0wKSYmZTwxMjgpJiYocj1pW2VdKT9yOihuPWwoZSxlPDA/LTE6MCwhMSksbyYmKGlbZV09biksbil9ZnVuY3Rpb24gdShlLHQpe2lmKGlzTmFOKGUpKXJldHVybiB0P3k6bTtpZih0KXtpZihlPDApcmV0dXJuIHk7aWYoZT49aClyZXR1cm4gd31lbHNle2lmKGU8PS1nKXJldHVybiBPO2lmKGUrMT49ZylyZXR1cm4geH1yZXR1cm4gZTwwP3UoLWUsdCkubmVnKCk6bChlJWZ8MCxlL2Z8MCx0KX1mdW5jdGlvbiBsKGUsdCxyKXtyZXR1cm4gbmV3IG4oZSx0LHIpfW4uZnJvbUludD1hLG4uZnJvbU51bWJlcj11LG4uZnJvbUJpdHM9bDt2YXIgYz1NYXRoLnBvdztmdW5jdGlvbiBwKGUsdCxuKXtpZigwPT09ZS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQ/KG49dCx0PSExKTp0PSEhdCxcIk5hTlwiPT09ZXx8XCJJbmZpbml0eVwiPT09ZXx8XCIrSW5maW5pdHlcIj09PWV8fFwiLUluZmluaXR5XCI9PT1lKXJldHVybiB0P3k6bTtpZigobj1ufHwxMCk8Mnx8MzY8bil0aHJvdyBSYW5nZUVycm9yKFwicmFkaXhcIik7dmFyIHI7aWYoKHI9ZS5pbmRleE9mKFwiLVwiKSk+MCl0aHJvdyBFcnJvcihcImludGVyaW9yIGh5cGhlblwiKTtpZigwPT09cilyZXR1cm4gcChlLnN1YnN0cmluZygxKSx0LG4pLm5lZygpO2Zvcih2YXIgbz11KGMobiw4KSksaT1tLHM9MDtzPGUubGVuZ3RoO3MrPTgpe3ZhciBhPU1hdGgubWluKDgsZS5sZW5ndGgtcyksbD1wYXJzZUludChlLnN1YnN0cmluZyhzLHMrYSksbik7aWYoYTw4KXt2YXIgZD11KGMobixhKSk7aT1pLm11bChkKS5hZGQodShsKSl9ZWxzZSBpPShpPWkubXVsKG8pKS5hZGQodShsKSl9cmV0dXJuIGkudW5zaWduZWQ9dCxpfWZ1bmN0aW9uIGQoZSx0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgZT91KGUsdCk6XCJzdHJpbmdcIj09dHlwZW9mIGU/cChlLHQpOmwoZS5sb3csZS5oaWdoLFwiYm9vbGVhblwiPT10eXBlb2YgdD90OmUudW5zaWduZWQpfW4uZnJvbVN0cmluZz1wLG4uZnJvbVZhbHVlPWQ7dmFyIGY9NDI5NDk2NzI5NixoPWYqZixnPWgvMixiPWEoMTw8MjQpLG09YSgwKTtuLlpFUk89bTt2YXIgeT1hKDAsITApO24uVVpFUk89eTt2YXIgXz1hKDEpO24uT05FPV87dmFyIHY9YSgxLCEwKTtuLlVPTkU9djt2YXIgVD1hKC0xKTtuLk5FR19PTkU9VDt2YXIgeD1sKC0xLDIxNDc0ODM2NDcsITEpO24uTUFYX1ZBTFVFPXg7dmFyIHc9bCgtMSwtMSwhMCk7bi5NQVhfVU5TSUdORURfVkFMVUU9dzt2YXIgTz1sKDAsLTIxNDc0ODM2NDgsITEpO24uTUlOX1ZBTFVFPU87dmFyIFM9bi5wcm90b3R5cGU7Uy50b0ludD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkP3RoaXMubG93Pj4+MDp0aGlzLmxvd30sUy50b051bWJlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVuc2lnbmVkPyh0aGlzLmhpZ2g+Pj4wKSpmKyh0aGlzLmxvdz4+PjApOnRoaXMuaGlnaCpmKyh0aGlzLmxvdz4+PjApfSxTLnRvU3RyaW5nPWZ1bmN0aW9uKGUpe2lmKChlPWV8fDEwKTwyfHwzNjxlKXRocm93IFJhbmdlRXJyb3IoXCJyYWRpeFwiKTtpZih0aGlzLmlzWmVybygpKXJldHVyblwiMFwiO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXtpZih0aGlzLmVxKE8pKXt2YXIgdD11KGUpLG49dGhpcy5kaXYodCkscj1uLm11bCh0KS5zdWIodGhpcyk7cmV0dXJuIG4udG9TdHJpbmcoZSkrci50b0ludCgpLnRvU3RyaW5nKGUpfXJldHVyblwiLVwiK3RoaXMubmVnKCkudG9TdHJpbmcoZSl9Zm9yKHZhciBvPXUoYyhlLDYpLHRoaXMudW5zaWduZWQpLGk9dGhpcyxzPVwiXCI7Oyl7dmFyIGE9aS5kaXYobyksbD0oaS5zdWIoYS5tdWwobykpLnRvSW50KCk+Pj4wKS50b1N0cmluZyhlKTtpZigoaT1hKS5pc1plcm8oKSlyZXR1cm4gbCtzO2Zvcig7bC5sZW5ndGg8NjspbD1cIjBcIitsO3M9XCJcIitsK3N9fSxTLmdldEhpZ2hCaXRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGlnaH0sUy5nZXRIaWdoQml0c1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGlnaD4+PjB9LFMuZ2V0TG93Qml0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvd30sUy5nZXRMb3dCaXRzVW5zaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb3c+Pj4wfSxTLmdldE51bUJpdHNBYnM9ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5lcShPKT82NDp0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtmb3IodmFyIGU9MCE9dGhpcy5oaWdoP3RoaXMuaGlnaDp0aGlzLmxvdyx0PTMxO3Q+MCYmMD09KGUmMTw8dCk7dC0tKTtyZXR1cm4gMCE9dGhpcy5oaWdoP3QrMzM6dCsxfSxTLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5oaWdoJiYwPT09dGhpcy5sb3d9LFMuZXF6PVMuaXNaZXJvLFMuaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLnVuc2lnbmVkJiZ0aGlzLmhpZ2g8MH0sUy5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWR8fHRoaXMuaGlnaD49MH0sUy5pc09kZD1mdW5jdGlvbigpe3JldHVybiAxPT0oMSZ0aGlzLmxvdyl9LFMuaXNFdmVuPWZ1bmN0aW9uKCl7cmV0dXJuIDA9PSgxJnRoaXMubG93KX0sUy5lcXVhbHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl8fChlPWQoZSkpLCh0aGlzLnVuc2lnbmVkPT09ZS51bnNpZ25lZHx8dGhpcy5oaWdoPj4+MzEhPTF8fGUuaGlnaD4+PjMxIT0xKSYmdGhpcy5oaWdoPT09ZS5oaWdoJiZ0aGlzLmxvdz09PWUubG93fSxTLmVxPVMuZXF1YWxzLFMubm90RXF1YWxzPWZ1bmN0aW9uKGUpe3JldHVybiF0aGlzLmVxKGUpfSxTLm5lcT1TLm5vdEVxdWFscyxTLm5lPVMubm90RXF1YWxzLFMubGVzc1RoYW49ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY29tcChlKTwwfSxTLmx0PVMubGVzc1RoYW4sUy5sZXNzVGhhbk9yRXF1YWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY29tcChlKTw9MH0sUy5sdGU9Uy5sZXNzVGhhbk9yRXF1YWwsUy5sZT1TLmxlc3NUaGFuT3JFcXVhbCxTLmdyZWF0ZXJUaGFuPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvbXAoZSk+MH0sUy5ndD1TLmdyZWF0ZXJUaGFuLFMuZ3JlYXRlclRoYW5PckVxdWFsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNvbXAoZSk+PTB9LFMuZ3RlPVMuZ3JlYXRlclRoYW5PckVxdWFsLFMuZ2U9Uy5ncmVhdGVyVGhhbk9yRXF1YWwsUy5jb21wYXJlPWZ1bmN0aW9uKGUpe2lmKHIoZSl8fChlPWQoZSkpLHRoaXMuZXEoZSkpcmV0dXJuIDA7dmFyIHQ9dGhpcy5pc05lZ2F0aXZlKCksbj1lLmlzTmVnYXRpdmUoKTtyZXR1cm4gdCYmIW4/LTE6IXQmJm4/MTp0aGlzLnVuc2lnbmVkP2UuaGlnaD4+PjA+dGhpcy5oaWdoPj4+MHx8ZS5oaWdoPT09dGhpcy5oaWdoJiZlLmxvdz4+PjA+dGhpcy5sb3c+Pj4wPy0xOjE6dGhpcy5zdWIoZSkuaXNOZWdhdGl2ZSgpPy0xOjF9LFMuY29tcD1TLmNvbXBhcmUsUy5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy51bnNpZ25lZCYmdGhpcy5lcShPKT9POnRoaXMubm90KCkuYWRkKF8pfSxTLm5lZz1TLm5lZ2F0ZSxTLmFkZD1mdW5jdGlvbihlKXtyKGUpfHwoZT1kKGUpKTt2YXIgdD10aGlzLmhpZ2g+Pj4xNixuPTY1NTM1JnRoaXMuaGlnaCxvPXRoaXMubG93Pj4+MTYsaT02NTUzNSZ0aGlzLmxvdyxzPWUuaGlnaD4+PjE2LGE9NjU1MzUmZS5oaWdoLHU9ZS5sb3c+Pj4xNixjPTAscD0wLGY9MCxoPTA7cmV0dXJuIGYrPShoKz1pKyg2NTUzNSZlLmxvdykpPj4+MTYscCs9KGYrPW8rdSk+Pj4xNixjKz0ocCs9bithKT4+PjE2LGMrPXQrcyxsKChmJj02NTUzNSk8PDE2fChoJj02NTUzNSksKGMmPTY1NTM1KTw8MTZ8KHAmPTY1NTM1KSx0aGlzLnVuc2lnbmVkKX0sUy5zdWJ0cmFjdD1mdW5jdGlvbihlKXtyZXR1cm4gcihlKXx8KGU9ZChlKSksdGhpcy5hZGQoZS5uZWcoKSl9LFMuc3ViPVMuc3VidHJhY3QsUy5tdWx0aXBseT1mdW5jdGlvbihlKXtpZih0aGlzLmlzWmVybygpKXJldHVybiB0aGlzO2lmKHIoZSl8fChlPWQoZSkpLHQpcmV0dXJuIGwodC5tdWwodGhpcy5sb3csdGhpcy5oaWdoLGUubG93LGUuaGlnaCksdC5nZXRfaGlnaCgpLHRoaXMudW5zaWduZWQpO2lmKGUuaXNaZXJvKCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/eTptO2lmKHRoaXMuZXEoTykpcmV0dXJuIGUuaXNPZGQoKT9POm07aWYoZS5lcShPKSlyZXR1cm4gdGhpcy5pc09kZCgpP086bTtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gZS5pc05lZ2F0aXZlKCk/dGhpcy5uZWcoKS5tdWwoZS5uZWcoKSk6dGhpcy5uZWcoKS5tdWwoZSkubmVnKCk7aWYoZS5pc05lZ2F0aXZlKCkpcmV0dXJuIHRoaXMubXVsKGUubmVnKCkpLm5lZygpO2lmKHRoaXMubHQoYikmJmUubHQoYikpcmV0dXJuIHUodGhpcy50b051bWJlcigpKmUudG9OdW1iZXIoKSx0aGlzLnVuc2lnbmVkKTt2YXIgbj10aGlzLmhpZ2g+Pj4xNixvPTY1NTM1JnRoaXMuaGlnaCxpPXRoaXMubG93Pj4+MTYscz02NTUzNSZ0aGlzLmxvdyxhPWUuaGlnaD4+PjE2LGM9NjU1MzUmZS5oaWdoLHA9ZS5sb3c+Pj4xNixmPTY1NTM1JmUubG93LGg9MCxnPTAsXz0wLHY9MDtyZXR1cm4gXys9KHYrPXMqZik+Pj4xNixnKz0oXys9aSpmKT4+PjE2LF8mPTY1NTM1LGcrPShfKz1zKnApPj4+MTYsaCs9KGcrPW8qZik+Pj4xNixnJj02NTUzNSxoKz0oZys9aSpwKT4+PjE2LGcmPTY1NTM1LGgrPShnKz1zKmMpPj4+MTYsaCs9bipmK28qcCtpKmMrcyphLGwoKF8mPTY1NTM1KTw8MTZ8KHYmPTY1NTM1KSwoaCY9NjU1MzUpPDwxNnwoZyY9NjU1MzUpLHRoaXMudW5zaWduZWQpfSxTLm11bD1TLm11bHRpcGx5LFMuZGl2aWRlPWZ1bmN0aW9uKGUpe2lmKHIoZSl8fChlPWQoZSkpLGUuaXNaZXJvKCkpdGhyb3cgRXJyb3IoXCJkaXZpc2lvbiBieSB6ZXJvXCIpO3ZhciBuLG8saTtpZih0KXJldHVybiB0aGlzLnVuc2lnbmVkfHwtMjE0NzQ4MzY0OCE9PXRoaXMuaGlnaHx8LTEhPT1lLmxvd3x8LTEhPT1lLmhpZ2g/bCgodGhpcy51bnNpZ25lZD90LmRpdl91OnQuZGl2X3MpKHRoaXMubG93LHRoaXMuaGlnaCxlLmxvdyxlLmhpZ2gpLHQuZ2V0X2hpZ2goKSx0aGlzLnVuc2lnbmVkKTp0aGlzO2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIHRoaXMudW5zaWduZWQ/eTptO2lmKHRoaXMudW5zaWduZWQpe2lmKGUudW5zaWduZWR8fChlPWUudG9VbnNpZ25lZCgpKSxlLmd0KHRoaXMpKXJldHVybiB5O2lmKGUuZ3QodGhpcy5zaHJ1KDEpKSlyZXR1cm4gdjtpPXl9ZWxzZXtpZih0aGlzLmVxKE8pKXJldHVybiBlLmVxKF8pfHxlLmVxKFQpP086ZS5lcShPKT9fOihuPXRoaXMuc2hyKDEpLmRpdihlKS5zaGwoMSkpLmVxKG0pP2UuaXNOZWdhdGl2ZSgpP186VDoobz10aGlzLnN1YihlLm11bChuKSksaT1uLmFkZChvLmRpdihlKSkpO2lmKGUuZXEoTykpcmV0dXJuIHRoaXMudW5zaWduZWQ/eTptO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBlLmlzTmVnYXRpdmUoKT90aGlzLm5lZygpLmRpdihlLm5lZygpKTp0aGlzLm5lZygpLmRpdihlKS5uZWcoKTtpZihlLmlzTmVnYXRpdmUoKSlyZXR1cm4gdGhpcy5kaXYoZS5uZWcoKSkubmVnKCk7aT1tfWZvcihvPXRoaXM7by5ndGUoZSk7KXtuPU1hdGgubWF4KDEsTWF0aC5mbG9vcihvLnRvTnVtYmVyKCkvZS50b051bWJlcigpKSk7Zm9yKHZhciBzPU1hdGguY2VpbChNYXRoLmxvZyhuKS9NYXRoLkxOMiksYT1zPD00OD8xOmMoMixzLTQ4KSxwPXUobiksZj1wLm11bChlKTtmLmlzTmVnYXRpdmUoKXx8Zi5ndChvKTspZj0ocD11KG4tPWEsdGhpcy51bnNpZ25lZCkpLm11bChlKTtwLmlzWmVybygpJiYocD1fKSxpPWkuYWRkKHApLG89by5zdWIoZil9cmV0dXJuIGl9LFMuZGl2PVMuZGl2aWRlLFMubW9kdWxvPWZ1bmN0aW9uKGUpe3JldHVybiByKGUpfHwoZT1kKGUpKSx0P2woKHRoaXMudW5zaWduZWQ/dC5yZW1fdTp0LnJlbV9zKSh0aGlzLmxvdyx0aGlzLmhpZ2gsZS5sb3csZS5oaWdoKSx0LmdldF9oaWdoKCksdGhpcy51bnNpZ25lZCk6dGhpcy5zdWIodGhpcy5kaXYoZSkubXVsKGUpKX0sUy5tb2Q9Uy5tb2R1bG8sUy5yZW09Uy5tb2R1bG8sUy5ub3Q9ZnVuY3Rpb24oKXtyZXR1cm4gbCh+dGhpcy5sb3csfnRoaXMuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5jb3VudExlYWRpbmdaZXJvcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmhpZ2g/TWF0aC5jbHozMih0aGlzLmhpZ2gpOk1hdGguY2x6MzIodGhpcy5sb3cpKzMyfSxTLmNsej1TLmNvdW50TGVhZGluZ1plcm9zLFMuY291bnRUcmFpbGluZ1plcm9zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG93P28odGhpcy5sb3cpOm8odGhpcy5oaWdoKSszMn0sUy5jdHo9Uy5jb3VudFRyYWlsaW5nWmVyb3MsUy5hbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSl8fChlPWQoZSkpLGwodGhpcy5sb3cmZS5sb3csdGhpcy5oaWdoJmUuaGlnaCx0aGlzLnVuc2lnbmVkKX0sUy5vcj1mdW5jdGlvbihlKXtyZXR1cm4gcihlKXx8KGU9ZChlKSksbCh0aGlzLmxvd3xlLmxvdyx0aGlzLmhpZ2h8ZS5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnhvcj1mdW5jdGlvbihlKXtyZXR1cm4gcihlKXx8KGU9ZChlKSksbCh0aGlzLmxvd15lLmxvdyx0aGlzLmhpZ2heZS5oaWdoLHRoaXMudW5zaWduZWQpfSxTLnNoaWZ0TGVmdD1mdW5jdGlvbihlKXtyZXR1cm4gcihlKSYmKGU9ZS50b0ludCgpKSwwPT0oZSY9NjMpP3RoaXM6ZTwzMj9sKHRoaXMubG93PDxlLHRoaXMuaGlnaDw8ZXx0aGlzLmxvdz4+PjMyLWUsdGhpcy51bnNpZ25lZCk6bCgwLHRoaXMubG93PDxlLTMyLHRoaXMudW5zaWduZWQpfSxTLnNobD1TLnNoaWZ0TGVmdCxTLnNoaWZ0UmlnaHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHIoZSkmJihlPWUudG9JbnQoKSksMD09KGUmPTYzKT90aGlzOmU8MzI/bCh0aGlzLmxvdz4+PmV8dGhpcy5oaWdoPDwzMi1lLHRoaXMuaGlnaD4+ZSx0aGlzLnVuc2lnbmVkKTpsKHRoaXMuaGlnaD4+ZS0zMix0aGlzLmhpZ2g+PTA/MDotMSx0aGlzLnVuc2lnbmVkKX0sUy5zaHI9Uy5zaGlmdFJpZ2h0LFMuc2hpZnRSaWdodFVuc2lnbmVkPWZ1bmN0aW9uKGUpe3JldHVybiByKGUpJiYoZT1lLnRvSW50KCkpLDA9PShlJj02Myk/dGhpczplPDMyP2wodGhpcy5sb3c+Pj5lfHRoaXMuaGlnaDw8MzItZSx0aGlzLmhpZ2g+Pj5lLHRoaXMudW5zaWduZWQpOmwoMzI9PT1lP3RoaXMuaGlnaDp0aGlzLmhpZ2g+Pj5lLTMyLDAsdGhpcy51bnNpZ25lZCl9LFMuc2hydT1TLnNoaWZ0UmlnaHRVbnNpZ25lZCxTLnNocl91PVMuc2hpZnRSaWdodFVuc2lnbmVkLFMucm90YXRlTGVmdD1mdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gcihlKSYmKGU9ZS50b0ludCgpKSwwPT0oZSY9NjMpP3RoaXM6MzI9PT1lP2wodGhpcy5oaWdoLHRoaXMubG93LHRoaXMudW5zaWduZWQpOmU8MzI/KHQ9MzItZSxsKHRoaXMubG93PDxlfHRoaXMuaGlnaD4+PnQsdGhpcy5oaWdoPDxlfHRoaXMubG93Pj4+dCx0aGlzLnVuc2lnbmVkKSk6KHQ9MzItKGUtPTMyKSxsKHRoaXMuaGlnaDw8ZXx0aGlzLmxvdz4+PnQsdGhpcy5sb3c8PGV8dGhpcy5oaWdoPj4+dCx0aGlzLnVuc2lnbmVkKSl9LFMucm90bD1TLnJvdGF0ZUxlZnQsUy5yb3RhdGVSaWdodD1mdW5jdGlvbihlKXt2YXIgdDtyZXR1cm4gcihlKSYmKGU9ZS50b0ludCgpKSwwPT0oZSY9NjMpP3RoaXM6MzI9PT1lP2wodGhpcy5oaWdoLHRoaXMubG93LHRoaXMudW5zaWduZWQpOmU8MzI/KHQ9MzItZSxsKHRoaXMuaGlnaDw8dHx0aGlzLmxvdz4+PmUsdGhpcy5sb3c8PHR8dGhpcy5oaWdoPj4+ZSx0aGlzLnVuc2lnbmVkKSk6KHQ9MzItKGUtPTMyKSxsKHRoaXMubG93PDx0fHRoaXMuaGlnaD4+PmUsdGhpcy5oaWdoPDx0fHRoaXMubG93Pj4+ZSx0aGlzLnVuc2lnbmVkKSl9LFMucm90cj1TLnJvdGF0ZVJpZ2h0LFMudG9TaWduZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bnNpZ25lZD9sKHRoaXMubG93LHRoaXMuaGlnaCwhMSk6dGhpc30sUy50b1Vuc2lnbmVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5zaWduZWQ/dGhpczpsKHRoaXMubG93LHRoaXMuaGlnaCwhMCl9LFMudG9CeXRlcz1mdW5jdGlvbihlKXtyZXR1cm4gZT90aGlzLnRvQnl0ZXNMRSgpOnRoaXMudG9CeXRlc0JFKCl9LFMudG9CeXRlc0xFPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5oaWdoLHQ9dGhpcy5sb3c7cmV0dXJuWzI1NSZ0LHQ+Pj44JjI1NSx0Pj4+MTYmMjU1LHQ+Pj4yNCwyNTUmZSxlPj4+OCYyNTUsZT4+PjE2JjI1NSxlPj4+MjRdfSxTLnRvQnl0ZXNCRT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuaGlnaCx0PXRoaXMubG93O3JldHVybltlPj4+MjQsZT4+PjE2JjI1NSxlPj4+OCYyNTUsMjU1JmUsdD4+PjI0LHQ+Pj4xNiYyNTUsdD4+PjgmMjU1LDI1NSZ0XX0sbi5mcm9tQnl0ZXM9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiByP24uZnJvbUJ5dGVzTEUoZSx0KTpuLmZyb21CeXRlc0JFKGUsdCl9LG4uZnJvbUJ5dGVzTEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IG4oZVswXXxlWzFdPDw4fGVbMl08PDE2fGVbM108PDI0LGVbNF18ZVs1XTw8OHxlWzZdPDwxNnxlWzddPDwyNCx0KX0sbi5mcm9tQnl0ZXNCRT1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgbihlWzRdPDwyNHxlWzVdPDwxNnxlWzZdPDw4fGVbN10sZVswXTw8MjR8ZVsxXTw8MTZ8ZVsyXTw8OHxlWzNdLHQpfTt2YXIgQT1uO3JldHVybiBlLmRlZmF1bHQ9QSxcImRlZmF1bHRcImluIGU/ZS5kZWZhdWx0OmV9KHt9KTt2b2lkIDA9PT0obj1mdW5jdGlvbigpe3JldHVybiByfS5hcHBseSh0LFtdKSl8fChlLmV4cG9ydHM9bil9LDU2ODY6KGUsdCxuKT0+e1widXNlIHN0cmljdFwiO24ucih0KSxuLmQodCx7ZmxhdGJ1ZmZlcnM6KCk9PnJ9KTt2YXIgcj17fTtyLk9mZnNldCxyLlRhYmxlLHIuU0laRU9GX1NIT1JUPTIsci5TSVpFT0ZfSU5UPTQsci5GSUxFX0lERU5USUZJRVJfTEVOR1RIPTQsci5TSVpFX1BSRUZJWF9MRU5HVEg9NCxyLkVuY29kaW5nPXtVVEY4X0JZVEVTOjEsVVRGMTZfU1RSSU5HOjJ9LHIuaW50MzI9bmV3IEludDMyQXJyYXkoMiksci5mbG9hdDMyPW5ldyBGbG9hdDMyQXJyYXkoci5pbnQzMi5idWZmZXIpLHIuZmxvYXQ2ND1uZXcgRmxvYXQ2NEFycmF5KHIuaW50MzIuYnVmZmVyKSxyLmlzTGl0dGxlRW5kaWFuPTE9PT1uZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkoWzEsMF0pLmJ1ZmZlcilbMF0sci5Mb25nPWZ1bmN0aW9uKGUsdCl7dGhpcy5sb3c9MHxlLHRoaXMuaGlnaD0wfHR9LHIuTG9uZy5jcmVhdGU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gMD09ZSYmMD09dD9yLkxvbmcuWkVSTzpuZXcgci5Mb25nKGUsdCl9LHIuTG9uZy5wcm90b3R5cGUudG9GbG9hdDY0PWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubG93Pj4+MCkrNDI5NDk2NzI5Nip0aGlzLmhpZ2h9LHIuTG9uZy5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxvdz09ZS5sb3cmJnRoaXMuaGlnaD09ZS5oaWdofSxyLkxvbmcuWkVSTz1uZXcgci5Mb25nKDAsMCksci5CdWlsZGVyPWZ1bmN0aW9uKGUpe2lmKGUpdD1lO2Vsc2UgdmFyIHQ9MTAyNDt0aGlzLmJiPXIuQnl0ZUJ1ZmZlci5hbGxvY2F0ZSh0KSx0aGlzLnNwYWNlPXQsdGhpcy5taW5hbGlnbj0xLHRoaXMudnRhYmxlPW51bGwsdGhpcy52dGFibGVfaW5fdXNlPTAsdGhpcy5pc05lc3RlZD0hMSx0aGlzLm9iamVjdF9zdGFydD0wLHRoaXMudnRhYmxlcz1bXSx0aGlzLnZlY3Rvcl9udW1fZWxlbXM9MCx0aGlzLmZvcmNlX2RlZmF1bHRzPSExfSxyLkJ1aWxkZXIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5iYi5jbGVhcigpLHRoaXMuc3BhY2U9dGhpcy5iYi5jYXBhY2l0eSgpLHRoaXMubWluYWxpZ249MSx0aGlzLnZ0YWJsZT1udWxsLHRoaXMudnRhYmxlX2luX3VzZT0wLHRoaXMuaXNOZXN0ZWQ9ITEsdGhpcy5vYmplY3Rfc3RhcnQ9MCx0aGlzLnZ0YWJsZXM9W10sdGhpcy52ZWN0b3JfbnVtX2VsZW1zPTAsdGhpcy5mb3JjZV9kZWZhdWx0cz0hMX0sci5CdWlsZGVyLnByb3RvdHlwZS5mb3JjZURlZmF1bHRzPWZ1bmN0aW9uKGUpe3RoaXMuZm9yY2VfZGVmYXVsdHM9ZX0sci5CdWlsZGVyLnByb3RvdHlwZS5kYXRhQnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmJ9LHIuQnVpbGRlci5wcm90b3R5cGUuYXNVaW50OEFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmIuYnl0ZXMoKS5zdWJhcnJheSh0aGlzLmJiLnBvc2l0aW9uKCksdGhpcy5iYi5wb3NpdGlvbigpK3RoaXMub2Zmc2V0KCkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLnByZXA9ZnVuY3Rpb24oZSx0KXtlPnRoaXMubWluYWxpZ24mJih0aGlzLm1pbmFsaWduPWUpO2Zvcih2YXIgbj0xK34odGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMuc3BhY2UrdCkmZS0xO3RoaXMuc3BhY2U8bitlK3Q7KXt2YXIgbz10aGlzLmJiLmNhcGFjaXR5KCk7dGhpcy5iYj1yLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXIodGhpcy5iYiksdGhpcy5zcGFjZSs9dGhpcy5iYi5jYXBhY2l0eSgpLW99dGhpcy5wYWQobil9LHIuQnVpbGRlci5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wO3Q8ZTt0KyspdGhpcy5iYi53cml0ZUludDgoLS10aGlzLnNwYWNlLDApfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihlKXt0aGlzLmJiLndyaXRlSW50OCh0aGlzLnNwYWNlLT0xLGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50MTY9ZnVuY3Rpb24oZSl7dGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UtPTIsZSl9LHIuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQzMj1mdW5jdGlvbihlKXt0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZS09NCxlKX0sci5CdWlsZGVyLnByb3RvdHlwZS53cml0ZUludDY0PWZ1bmN0aW9uKGUpe3RoaXMuYmIud3JpdGVJbnQ2NCh0aGlzLnNwYWNlLT04LGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbihlKXt0aGlzLmJiLndyaXRlRmxvYXQzMih0aGlzLnNwYWNlLT00LGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2ND1mdW5jdGlvbihlKXt0aGlzLmJiLndyaXRlRmxvYXQ2NCh0aGlzLnNwYWNlLT04LGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDg9ZnVuY3Rpb24oZSl7dGhpcy5wcmVwKDEsMCksdGhpcy53cml0ZUludDgoZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50MTY9ZnVuY3Rpb24oZSl7dGhpcy5wcmVwKDIsMCksdGhpcy53cml0ZUludDE2KGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDMyPWZ1bmN0aW9uKGUpe3RoaXMucHJlcCg0LDApLHRoaXMud3JpdGVJbnQzMihlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ2ND1mdW5jdGlvbihlKXt0aGlzLnByZXAoOCwwKSx0aGlzLndyaXRlSW50NjQoZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmxvYXQzMj1mdW5jdGlvbihlKXt0aGlzLnByZXAoNCwwKSx0aGlzLndyaXRlRmxvYXQzMihlKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDY0PWZ1bmN0aW9uKGUpe3RoaXMucHJlcCg4LDApLHRoaXMud3JpdGVGbG9hdDY0KGUpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50OD1mdW5jdGlvbihlLHQsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fHQhPW4pJiYodGhpcy5hZGRJbnQ4KHQpLHRoaXMuc2xvdChlKSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQxNj1mdW5jdGlvbihlLHQsbil7KHRoaXMuZm9yY2VfZGVmYXVsdHN8fHQhPW4pJiYodGhpcy5hZGRJbnQxNih0KSx0aGlzLnNsb3QoZSkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50MzI9ZnVuY3Rpb24oZSx0LG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHx0IT1uKSYmKHRoaXMuYWRkSW50MzIodCksdGhpcy5zbG90KGUpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEludDY0PWZ1bmN0aW9uKGUsdCxuKXshdGhpcy5mb3JjZV9kZWZhdWx0cyYmdC5lcXVhbHMobil8fCh0aGlzLmFkZEludDY0KHQpLHRoaXMuc2xvdChlKSl9LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDMyPWZ1bmN0aW9uKGUsdCxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8dCE9bikmJih0aGlzLmFkZEZsb2F0MzIodCksdGhpcy5zbG90KGUpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZEZsb2F0NjQ9ZnVuY3Rpb24oZSx0LG4peyh0aGlzLmZvcmNlX2RlZmF1bHRzfHx0IT1uKSYmKHRoaXMuYWRkRmxvYXQ2NCh0KSx0aGlzLnNsb3QoZSkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkT2Zmc2V0PWZ1bmN0aW9uKGUsdCxuKXsodGhpcy5mb3JjZV9kZWZhdWx0c3x8dCE9bikmJih0aGlzLmFkZE9mZnNldCh0KSx0aGlzLnNsb3QoZSkpfSxyLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkU3RydWN0PWZ1bmN0aW9uKGUsdCxuKXt0IT1uJiYodGhpcy5uZXN0ZWQodCksdGhpcy5zbG90KGUpKX0sci5CdWlsZGVyLnByb3RvdHlwZS5uZXN0ZWQ9ZnVuY3Rpb24oZSl7aWYoZSE9dGhpcy5vZmZzZXQoKSl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogc3RydWN0IG11c3QgYmUgc2VyaWFsaXplZCBpbmxpbmUuXCIpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm5vdE5lc3RlZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNOZXN0ZWQpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IG9iamVjdCBzZXJpYWxpemF0aW9uIG11c3Qgbm90IGJlIG5lc3RlZC5cIil9LHIuQnVpbGRlci5wcm90b3R5cGUuc2xvdD1mdW5jdGlvbihlKXt0aGlzLnZ0YWJsZVtlXT10aGlzLm9mZnNldCgpfSxyLkJ1aWxkZXIucHJvdG90eXBlLm9mZnNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJiLmNhcGFjaXR5KCktdGhpcy5zcGFjZX0sci5CdWlsZGVyLmdyb3dCeXRlQnVmZmVyPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY2FwYWNpdHkoKTtpZigzMjIxMjI1NDcyJnQpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGNhbm5vdCBncm93IGJ1ZmZlciBiZXlvbmQgMiBnaWdhYnl0ZXMuXCIpO3ZhciBuPXQ8PDEsbz1yLkJ5dGVCdWZmZXIuYWxsb2NhdGUobik7cmV0dXJuIG8uc2V0UG9zaXRpb24obi10KSxvLmJ5dGVzKCkuc2V0KGUuYnl0ZXMoKSxuLXQpLG99LHIuQnVpbGRlci5wcm90b3R5cGUuYWRkT2Zmc2V0PWZ1bmN0aW9uKGUpe3RoaXMucHJlcChyLlNJWkVPRl9JTlQsMCksdGhpcy53cml0ZUludDMyKHRoaXMub2Zmc2V0KCktZStyLlNJWkVPRl9JTlQpfSxyLkJ1aWxkZXIucHJvdG90eXBlLnN0YXJ0T2JqZWN0PWZ1bmN0aW9uKGUpe3RoaXMubm90TmVzdGVkKCksbnVsbD09dGhpcy52dGFibGUmJih0aGlzLnZ0YWJsZT1bXSksdGhpcy52dGFibGVfaW5fdXNlPWU7Zm9yKHZhciB0PTA7dDxlO3QrKyl0aGlzLnZ0YWJsZVt0XT0wO3RoaXMuaXNOZXN0ZWQ9ITAsdGhpcy5vYmplY3Rfc3RhcnQ9dGhpcy5vZmZzZXQoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5lbmRPYmplY3Q9ZnVuY3Rpb24oKXtpZihudWxsPT10aGlzLnZ0YWJsZXx8IXRoaXMuaXNOZXN0ZWQpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGVuZE9iamVjdCBjYWxsZWQgd2l0aG91dCBzdGFydE9iamVjdFwiKTt0aGlzLmFkZEludDMyKDApO2Zvcih2YXIgZT10aGlzLm9mZnNldCgpLHQ9dGhpcy52dGFibGVfaW5fdXNlLTE7dD49MCYmMD09dGhpcy52dGFibGVbdF07dC0tKTtmb3IodmFyIG49dCsxO3Q+PTA7dC0tKXRoaXMuYWRkSW50MTYoMCE9dGhpcy52dGFibGVbdF0/ZS10aGlzLnZ0YWJsZVt0XTowKTt0aGlzLmFkZEludDE2KGUtdGhpcy5vYmplY3Rfc3RhcnQpO3ZhciBvPShuKzIpKnIuU0laRU9GX1NIT1JUO3RoaXMuYWRkSW50MTYobyk7dmFyIGk9MCxzPXRoaXMuc3BhY2U7ZTpmb3IodD0wO3Q8dGhpcy52dGFibGVzLmxlbmd0aDt0Kyspe3ZhciBhPXRoaXMuYmIuY2FwYWNpdHkoKS10aGlzLnZ0YWJsZXNbdF07aWYobz09dGhpcy5iYi5yZWFkSW50MTYoYSkpe2Zvcih2YXIgdT1yLlNJWkVPRl9TSE9SVDt1PG87dSs9ci5TSVpFT0ZfU0hPUlQpaWYodGhpcy5iYi5yZWFkSW50MTYocyt1KSE9dGhpcy5iYi5yZWFkSW50MTYoYSt1KSljb250aW51ZSBlO2k9dGhpcy52dGFibGVzW3RdO2JyZWFrfX1yZXR1cm4gaT8odGhpcy5zcGFjZT10aGlzLmJiLmNhcGFjaXR5KCktZSx0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZSxpLWUpKToodGhpcy52dGFibGVzLnB1c2godGhpcy5vZmZzZXQoKSksdGhpcy5iYi53cml0ZUludDMyKHRoaXMuYmIuY2FwYWNpdHkoKS1lLHRoaXMub2Zmc2V0KCktZSkpLHRoaXMuaXNOZXN0ZWQ9ITEsZX0sci5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2g9ZnVuY3Rpb24oZSx0LG4pe3ZhciBvPW4/ci5TSVpFX1BSRUZJWF9MRU5HVEg6MDtpZih0KXt2YXIgaT10O2lmKHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLHIuU0laRU9GX0lOVCtyLkZJTEVfSURFTlRJRklFUl9MRU5HVEgrbyksaS5sZW5ndGghPXIuRklMRV9JREVOVElGSUVSX0xFTkdUSCl0aHJvdyBuZXcgRXJyb3IoXCJGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoIFwiK3IuRklMRV9JREVOVElGSUVSX0xFTkdUSCk7Zm9yKHZhciBzPXIuRklMRV9JREVOVElGSUVSX0xFTkdUSC0xO3M+PTA7cy0tKXRoaXMud3JpdGVJbnQ4KGkuY2hhckNvZGVBdChzKSl9dGhpcy5wcmVwKHRoaXMubWluYWxpZ24sci5TSVpFT0ZfSU5UK28pLHRoaXMuYWRkT2Zmc2V0KGUpLG8mJnRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpLXRoaXMuc3BhY2UpLHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZSl9LHIuQnVpbGRlci5wcm90b3R5cGUuZmluaXNoU2l6ZVByZWZpeGVkPWZ1bmN0aW9uKGUsdCl7dGhpcy5maW5pc2goZSx0LCEwKX0sci5CdWlsZGVyLnByb3RvdHlwZS5yZXF1aXJlZEZpZWxkPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5iYi5jYXBhY2l0eSgpLWUscj1uLXRoaXMuYmIucmVhZEludDMyKG4pO2lmKDA9PXRoaXMuYmIucmVhZEludDE2KHIrdCkpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IGZpZWxkIFwiK3QrXCIgbXVzdCBiZSBzZXRcIil9LHIuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRWZWN0b3I9ZnVuY3Rpb24oZSx0LG4pe3RoaXMubm90TmVzdGVkKCksdGhpcy52ZWN0b3JfbnVtX2VsZW1zPXQsdGhpcy5wcmVwKHIuU0laRU9GX0lOVCxlKnQpLHRoaXMucHJlcChuLGUqdCl9LHIuQnVpbGRlci5wcm90b3R5cGUuZW5kVmVjdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud3JpdGVJbnQzMih0aGlzLnZlY3Rvcl9udW1fZWxlbXMpLHRoaXMub2Zmc2V0KCl9LHIuQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlU3RyaW5nPWZ1bmN0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KXZhciB0PWU7ZWxzZXt0PVtdO2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7KXt2YXIgcixvPWUuY2hhckNvZGVBdChuKyspOyhyPW88NTUyOTZ8fG8+PTU2MzIwP286KG88PDEwKStlLmNoYXJDb2RlQXQobisrKSstNTY2MTM4ODgpPDEyOD90LnB1c2gocik6KHI8MjA0OD90LnB1c2gocj4+NiYzMXwxOTIpOihyPDY1NTM2P3QucHVzaChyPj4xMiYxNXwyMjQpOnQucHVzaChyPj4xOCY3fDI0MCxyPj4xMiY2M3wxMjgpLHQucHVzaChyPj42JjYzfDEyOCkpLHQucHVzaCg2MyZyfDEyOCkpfX10aGlzLmFkZEludDgoMCksdGhpcy5zdGFydFZlY3RvcigxLHQubGVuZ3RoLDEpLHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZS09dC5sZW5ndGgpLG49MDtmb3IodmFyIGk9dGhpcy5zcGFjZSxzPXRoaXMuYmIuYnl0ZXMoKTtuPHQubGVuZ3RoO24rKylzW2krK109dFtuXTtyZXR1cm4gdGhpcy5lbmRWZWN0b3IoKX0sci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMb25nPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHIuTG9uZy5jcmVhdGUoZSx0KX0sci5CeXRlQnVmZmVyPWZ1bmN0aW9uKGUpe3RoaXMuYnl0ZXNfPWUsdGhpcy5wb3NpdGlvbl89MH0sci5CeXRlQnVmZmVyLmFsbG9jYXRlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgci5CeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KGUpKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMucG9zaXRpb25fPTB9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuYnl0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ieXRlc199LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl99LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuc2V0UG9zaXRpb249ZnVuY3Rpb24oZSl7dGhpcy5wb3NpdGlvbl89ZX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5jYXBhY2l0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ5dGVzXy5sZW5ndGh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVhZFVpbnQ4KGUpPDwyND4+MjR9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmJ5dGVzX1tlXX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTY9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVhZFVpbnQxNihlKTw8MTY+PjE2fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTY9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYnl0ZXNfW2VdfHRoaXMuYnl0ZXNfW2UrMV08PDh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmJ5dGVzX1tlXXx0aGlzLmJ5dGVzX1tlKzFdPDw4fHRoaXMuYnl0ZXNfW2UrMl08PDE2fHRoaXMuYnl0ZXNfW2UrM108PDI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVhZEludDMyKGUpPj4+MH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50NjQ9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyByLkxvbmcodGhpcy5yZWFkSW50MzIoZSksdGhpcy5yZWFkSW50MzIoZSs0KSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ2ND1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHIuTG9uZyh0aGlzLnJlYWRVaW50MzIoZSksdGhpcy5yZWFkVWludDMyKGUrNCkpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdDMyPWZ1bmN0aW9uKGUpe3JldHVybiByLmludDMyWzBdPXRoaXMucmVhZEludDMyKGUpLHIuZmxvYXQzMlswXX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXQ2ND1mdW5jdGlvbihlKXtyZXR1cm4gci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzA6MV09dGhpcy5yZWFkSW50MzIoZSksci5pbnQzMltyLmlzTGl0dGxlRW5kaWFuPzE6MF09dGhpcy5yZWFkSW50MzIoZSs0KSxyLmZsb2F0NjRbMF19LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4PWZ1bmN0aW9uKGUsdCl7dGhpcy5ieXRlc19bZV09dH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4PWZ1bmN0aW9uKGUsdCl7dGhpcy5ieXRlc19bZV09dH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2PWZ1bmN0aW9uKGUsdCl7dGhpcy5ieXRlc19bZV09dCx0aGlzLmJ5dGVzX1tlKzFdPXQ+Pjh9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTY9ZnVuY3Rpb24oZSx0KXt0aGlzLmJ5dGVzX1tlXT10LHRoaXMuYnl0ZXNfW2UrMV09dD4+OH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKGUsdCl7dGhpcy5ieXRlc19bZV09dCx0aGlzLmJ5dGVzX1tlKzFdPXQ+PjgsdGhpcy5ieXRlc19bZSsyXT10Pj4xNix0aGlzLmJ5dGVzX1tlKzNdPXQ+PjI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyPWZ1bmN0aW9uKGUsdCl7dGhpcy5ieXRlc19bZV09dCx0aGlzLmJ5dGVzX1tlKzFdPXQ+PjgsdGhpcy5ieXRlc19bZSsyXT10Pj4xNix0aGlzLmJ5dGVzX1tlKzNdPXQ+PjI0fSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlSW50NjQ9ZnVuY3Rpb24oZSx0KXt0aGlzLndyaXRlSW50MzIoZSx0LmxvdyksdGhpcy53cml0ZUludDMyKGUrNCx0LmhpZ2gpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlVWludDY0PWZ1bmN0aW9uKGUsdCl7dGhpcy53cml0ZVVpbnQzMihlLHQubG93KSx0aGlzLndyaXRlVWludDMyKGUrNCx0LmhpZ2gpfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMj1mdW5jdGlvbihlLHQpe3IuZmxvYXQzMlswXT10LHRoaXMud3JpdGVJbnQzMihlLHIuaW50MzJbMF0pfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQ2ND1mdW5jdGlvbihlLHQpe3IuZmxvYXQ2NFswXT10LHRoaXMud3JpdGVJbnQzMihlLHIuaW50MzJbci5pc0xpdHRsZUVuZGlhbj8wOjFdKSx0aGlzLndyaXRlSW50MzIoZSs0LHIuaW50MzJbci5pc0xpdHRsZUVuZGlhbj8xOjBdKX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5nZXRCdWZmZXJJZGVudGlmaWVyPWZ1bmN0aW9uKCl7aWYodGhpcy5ieXRlc18ubGVuZ3RoPHRoaXMucG9zaXRpb25fK3IuU0laRU9GX0lOVCtyLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpdGhyb3cgbmV3IEVycm9yKFwiRmxhdEJ1ZmZlcnM6IEJ5dGVCdWZmZXIgaXMgdG9vIHNob3J0IHRvIGNvbnRhaW4gYW4gaWRlbnRpZmllci5cIik7Zm9yKHZhciBlPVwiXCIsdD0wO3Q8ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIO3QrKyllKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8rci5TSVpFT0ZfSU5UK3QpKTtyZXR1cm4gZX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX29mZnNldD1mdW5jdGlvbihlLHQpe3ZhciBuPWUtdGhpcy5yZWFkSW50MzIoZSk7cmV0dXJuIHQ8dGhpcy5yZWFkSW50MTYobik/dGhpcy5yZWFkSW50MTYobit0KTowfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdW5pb249ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5iYl9wb3M9dCt0aGlzLnJlYWRJbnQzMih0KSxlLmJiPXRoaXMsZX0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3N0cmluZz1mdW5jdGlvbihlLHQpe2UrPXRoaXMucmVhZEludDMyKGUpO3ZhciBuPXRoaXMucmVhZEludDMyKGUpLG89XCJcIixpPTA7aWYoZSs9ci5TSVpFT0ZfSU5ULHQ9PT1yLkVuY29kaW5nLlVURjhfQllURVMpcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KGUsZStuKTtmb3IoO2k8bjspe3ZhciBzLGE9dGhpcy5yZWFkVWludDgoZStpKyspO2lmKGE8MTkyKXM9YTtlbHNle3ZhciB1PXRoaXMucmVhZFVpbnQ4KGUraSsrKTtpZihhPDIyNClzPSgzMSZhKTw8Nnw2MyZ1O2Vsc2V7dmFyIGw9dGhpcy5yZWFkVWludDgoZStpKyspO3M9YTwyNDA/KDE1JmEpPDwxMnwoNjMmdSk8PDZ8NjMmbDooNyZhKTw8MTh8KDYzJnUpPDwxMnwoNjMmbCk8PDZ8NjMmdGhpcy5yZWFkVWludDgoZStpKyspfX1zPDY1NTM2P28rPVN0cmluZy5mcm9tQ2hhckNvZGUocyk6KHMtPTY1NTM2LG8rPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKHM+PjEwKSw1NjMyMCsoMTAyMyZzKSkpfXJldHVybiBvfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faW5kaXJlY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUrdGhpcy5yZWFkSW50MzIoZSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3I9ZnVuY3Rpb24oZSl7cmV0dXJuIGUrdGhpcy5yZWFkSW50MzIoZSkrci5TSVpFT0ZfSU5UfSxyLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9fdmVjdG9yX2xlbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWFkSW50MzIoZSt0aGlzLnJlYWRJbnQzMihlKSl9LHIuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19oYXNfaWRlbnRpZmllcj1mdW5jdGlvbihlKXtpZihlLmxlbmd0aCE9ci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKXRocm93IG5ldyBFcnJvcihcIkZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggXCIrci5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtmb3IodmFyIHQ9MDt0PHIuRklMRV9JREVOVElGSUVSX0xFTkdUSDt0KyspaWYoZS5jaGFyQ29kZUF0KHQpIT10aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb25fK3IuU0laRU9GX0lOVCt0KSlyZXR1cm4hMTtyZXR1cm4hMH0sci5CeXRlQnVmZmVyLnByb3RvdHlwZS5jcmVhdGVMb25nPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHIuTG9uZy5jcmVhdGUoZSx0KX19fSxfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX189e307ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhlKXt2YXIgdD1fX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bZV07aWYodm9pZCAwIT09dClyZXR1cm4gdC5leHBvcnRzO3ZhciBuPV9fd2VicGFja19tb2R1bGVfY2FjaGVfX1tlXT17ZXhwb3J0czp7fX07cmV0dXJuIF9fd2VicGFja19tb2R1bGVzX19bZV0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyksbi5leHBvcnRzfV9fd2VicGFja19yZXF1aXJlX18ubj1lPT57dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlPygpPT5lLmRlZmF1bHQ6KCk9PmU7cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZCh0LHthOnR9KSx0fSxfX3dlYnBhY2tfcmVxdWlyZV9fLmQ9KGUsdCk9Pntmb3IodmFyIG4gaW4gdClfX3dlYnBhY2tfcmVxdWlyZV9fLm8odCxuKSYmIV9fd2VicGFja19yZXF1aXJlX18ubyhlLG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtlbnVtZXJhYmxlOiEwLGdldDp0W25dfSl9LF9fd2VicGFja19yZXF1aXJlX18ubz0oZSx0KT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCksX193ZWJwYWNrX3JlcXVpcmVfXy5yPWU9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTt2YXIgX193ZWJwYWNrX2V4cG9ydHNfXz1fX3dlYnBhY2tfcmVxdWlyZV9fKDEwNTcpLF9fd2VicGFja19leHBvcnRfdGFyZ2V0X189ZXhwb3J0cztmb3IodmFyIGkgaW4gX193ZWJwYWNrX2V4cG9ydHNfXylfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fW2ldPV9fd2VicGFja19leHBvcnRzX19baV07X193ZWJwYWNrX2V4cG9ydHNfXy5fX2VzTW9kdWxlJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfXyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQtd2ViLm5vZGUuanMubWFwIl0sIm5hbWVzIjpbIl9fd2VicGFja19tb2R1bGVzX18iLCJlIiwidCIsIm4iLCJSIiwiciIsIm8iLCJpbml0IiwiY3JlYXRlU2Vzc2lvbkhhbmRsZXIiLCJTZXNzaW9uIiwibG9hZE1vZGVsIiwiT25ueGpzU2Vzc2lvbkhhbmRsZXIiLCJjOCIsInJYIiwiaSIsInMiLCJlbnYiLCJ3YXNtIiwiaW5pdFRpbWVvdXQiLCJzaW1kIiwicHJveHkiLCJudW1UaHJlYWRzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwibmF2aWdhdG9yIiwiY3B1cyIsImxlbmd0aCIsImhhcmR3YXJlQ29uY3VycmVuY3kiLCJNYXRoIiwibWluIiwiY2VpbCIsImluaXRpYWxpemVXZWJBc3NlbWJseUluc3RhbmNlIiwiT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2V4cG9ydFN0YXIiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsInJlZ2lzdGVyQmFja2VuZCIsInZlcnNpb25zIiwid2ViIiwidmVyc2lvbiIsImNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSIsImNvbnN0cnVjdG9yIiwiYXNzaWduIiwiY2FjaGVLZXkiLCJfY2FjaGVLZXkiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic29ydCIsIm1hcCIsImpvaW4iLCJBdHRyaWJ1dGUiLCJhIiwib25ueHJ1bnRpbWUiLCJleHBlcmltZW50YWwiLCJmYnMiLCJ1IiwiX2F0dHJpYnV0ZXMiLCJNYXAiLCJvbm54IiwiQXR0cmlidXRlUHJvdG8iLCJzZXQiLCJuYW1lIiwiZ2V0VmFsdWUiLCJnZXRUeXBlIiwic2l6ZSIsIkVycm9yIiwiZGVsZXRlIiwiZ2V0RmxvYXQiLCJnZXRJbnQiLCJnZXRTdHJpbmciLCJnZXRUZW5zb3IiLCJnZXRGbG9hdHMiLCJnZXRJbnRzIiwiZ2V0U3RyaW5ncyIsImdldFRlbnNvcnMiLCJ0eXBlIiwiQXR0cmlidXRlVHlwZSIsIkZMT0FUIiwiSU5UIiwiU1RSSU5HIiwiVEVOU09SIiwiRkxPQVRTIiwiSU5UUyIsIlNUUklOR1MiLCJURU5TT1JTIiwiR1JBUEgiLCJHUkFQSFMiLCJnZXRWYWx1ZU5vQ2hlY2siLCJMb25nVXRpbCIsImlzTG9uZyIsImxvbmdUb051bWJlciIsIkFycmF5IiwiVGVuc29yIiwiZnJvbVByb3RvIiwiZnJvbU9ydFRlbnNvciIsImRlY29kZVV0ZjhTdHJpbmciLCJnZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdCIsImdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQiLCJmIiwiZyIsImZsb2F0cyIsImludHMiLCJzdHJpbmdzIiwidGVuc29ycyIsImdyYXBocyIsImZsb2F0c0FycmF5IiwiaW50c0xlbmd0aCIsInB1c2giLCJzdHJpbmdzTGVuZ3RoIiwidGVuc29yc0xlbmd0aCIsInJlc29sdmVCYWNrZW5kIiwiYmFja2VuZCIsImluaXRpYWxpemUiLCJkaXNwb3NlIiwid2ViZ2wiLCJXZWJHTEJhY2tlbmQiLCJjb250ZXh0SWQiLCJtYXRtdWxNYXhCYXRjaFNpemUiLCJ0ZXh0dXJlQ2FjaGVNb2RlIiwicGFjayIsImFzeW5jIiwiZ2xDb250ZXh0IiwiY3JlYXRlV2ViR0xDb250ZXh0IiwiTG9nZ2VyIiwic2V0V2l0aEVudiIsInZlcmJvc2UiLCJ3YXJuaW5nIiwiV2ViR0xTZXNzaW9uSGFuZGxlciIsIkNvb3Jkc0dsc2xMaWIiLCJHbHNsTGliIiwiZ2V0RnVuY3Rpb25zIiwib2Zmc2V0VG9Db29yZHMiLCJjb29yZHNUb09mZnNldCIsInRvVmVjIiwidmFsdWVGcm9tIiwiZ2V0Q29tbW9uVXRpbEZ1bmNzIiwiZ2V0SW5wdXRzU2FtcGxpbmdTbmlwcGV0cyIsImdldE91dHB1dFNhbXBsaW5nU25pcHBldCIsImdldEN1c3RvbVR5cGVzIiwiR2xzbExpYlJvdXRpbmUiLCJjb250ZXh0Iiwib3V0cHV0VGV4dHVyZUxheW91dCIsImlzUGFja2VkIiwiZ2V0UGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0IiwiZ2V0VW5wYWNrZWRPdXRwdXRTYW1wbGluZ1NuaXBwZXQiLCJ1bnBhY2tlZFNoYXBlIiwid2lkdGgiLCJoZWlnaHQiLCJnZXRPdXRwdXRTY2FsYXJDb29yZHMiLCJnZXRPdXRwdXRQYWNrZWQxRENvb3JkcyIsImdldE91dHB1dFBhY2tlZDJEQ29vcmRzIiwiZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMiLCJnZXRPdXRwdXRQYWNrZWRORENvb3JkcyIsImdldEdsc2wiLCJvdXRwdXQiLCJmbG9hdFRleHR1cmVTZXRSR0JBIiwiZ2V0T3V0cHV0VW5wYWNrZWQxRENvb3JkcyIsImdldE91dHB1dFVucGFja2VkMkRDb29yZHMiLCJnZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzIiwiZ2V0T3V0cHV0VW5wYWNrZWQ0RENvb3JkcyIsImdldE91dHB1dFVucGFja2VkNURDb29yZHMiLCJnZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzIiwiZmxvYXRUZXh0dXJlU2V0UiIsIkFycmF5VXRpbCIsImFycmF5c0VxdWFsIiwibCIsInRleHR1cmUyRCIsInByb2dyYW1JbmZvIiwiaW5wdXROYW1lcyIsImZvckVhY2giLCJpbnB1dFRleHR1cmVMYXlvdXRzIiwiZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lIiwiZ2V0UGFja2VkU2FtcGxlckZyb21JbnB1dCIsImdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dCIsImdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZUF0T3V0Q29vcmRzIiwiZ2V0UGFja2VkU2FtcGxlckF0T3V0cHV0Q29vcmRzIiwiZ2V0VW5wYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMiLCJjIiwicCIsImQiLCJCcm9hZGNhc3RVdGlsIiwiZ2V0QnJvYWRjYXN0RGltcyIsImgiLCJnZXRDb29yZHNEYXRhVHlwZSIsImIiLCJtIiwiZ2V0R2xDaGFubmVscyIsInkiLCJfIiwidiIsIlNoYXBlVXRpbCIsIlQiLCJpbmRleE9mIiwieCIsImdldFBhY2tlZFNhbXBsZXJTY2FsYXIiLCJnZXRQYWNrZWRTYW1wbGVyMUQiLCJnZXRQYWNrZWRTYW1wbGVyMkQiLCJnZXRQYWNrZWRTYW1wbGVyM0QiLCJnZXRQYWNrZWRTYW1wbGVyTkQiLCJnZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIiLCJnZXRVbnBhY2tlZFNhbXBsZXIxRCIsImdldFVucGFja2VkU2FtcGxlcjJEIiwiZ2V0VW5wYWNrZWRTYW1wbGVyM0QiLCJnZXRVbnBhY2tlZFNhbXBsZXI0RCIsImdldFVucGFja2VkU2FtcGxlcjVEIiwiZ2V0VW5wYWNrZWRTYW1wbGVyNkQiLCJzbGljZSIsInNxdWVlemVJbnB1dFNoYXBlIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5Iiwicm91dGluZUJvZHkiLCJnZXRTcXVlZXplZFBhcmFtcyIsImRlcGVuZGVuY2llcyIsIm5ld1NoYXBlIiwia2VwdERpbXMiLCJzcXVlZXplU2hhcGUiLCJyZXZlcnNlIiwic2hhcGUiLCJzdHJpZGVzIiwiZ2V0VmFsdWVGcm9tU2luZ2xlIiwiZ2V0UGFja2VkVmFsdWVGcm9tIiwiVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzIiwiR2xzbExpYlJvdXRpbmVOb2RlIiwiR2xzbENvbnRleHQiLCJGdW5jdGlvblR5cGUiLCJWYWx1ZUJhc2VkIiwiUG9zaXRpb25hbCIsImFkZERlcGVuZGVuY3kiLCJyZXR1cm5PcmRlcmVkTm9kZXMiLCJTZXQiLCJjcmVhdGVPcmRlcmVkTm9kZXMiLCJkZnNUcmF2ZXJzZSIsImhhcyIsImFkZCIsIkVuY29kaW5nR2xzbExpYiIsImVuY29kZUZsb2F0MzIiLCJkZWNvZGVGbG9hdDMyIiwiZW5jb2RlIiwiZGVjb2RlIiwiZW5jb2RlVWludDgiLCJpc0xpdHRsZUVuZGlhbiIsImRlY29kZVVpbnQ4IiwiQXJyYXlCdWZmZXIiLCJVaW50MzJBcnJheSIsIlVpbnQ4QXJyYXkiLCJGcmFnQ29sb3JHbHNsTGliIiwic2V0RnJhZ0NvbG9yIiwiZ2V0Q29sb3JBc0Zsb2F0IiwicmVwbGFjZUlubGluZXMiLCJleGVjIiwic3BsaXQiLCJ0cmltIiwiZmlsdGVyIiwicGFyYW1zIiwiYm9keSIsInJlcGxhY2UiLCJSZWdFeHAiLCJHbHNsUHJlcHJvY2Vzc29yIiwibGlicyIsImdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoIiwia2V5cyIsImdsc2xSZWdpc3RyeSIsInByZXByb2Nlc3MiLCJzaGFkZXJTb3VyY2UiLCJoYXNNYWluIiwiZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluIiwiZ2V0RnJhZ1NoYWRlclByZWFtYmxlIiwiZ2V0VW5pZm9ybXMiLCJ2YXJpYWJsZXMiLCJnZXRJbXBvcnRzIiwic2VsZWN0R2xzbExpYlJvdXRpbmVzVG9CZUluY2x1ZGVkIiwiYXJyYXlMZW5ndGgiLCJlbmNvZGluZyIsImZyYWdjb2xvciIsInZlYyIsIlZlY0dsc2xMaWIiLCJzaGFwZVV0aWxzIiwiU2hhcGVVdGlsc0dsc2xMaWIiLCJjb29yZGluYXRlcyIsImJjYXN0SW5kZXgiLCJiY2FzdE1hdG11bEluZGV4Iiwib2Zmc2V0VG9JbmRpY2VzIiwiaW5kaWNlc1RvT2Zmc2V0IiwiaW5jcmVtZW50SW5kaWNlcyIsImluZGV4VG9PZmZzZXRTaW5nbGUiLCJvZmZzZXRUb0luZGljZXNTaW5nbGUiLCJnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UiLCJhdHRyaWJ1dGUiLCJ2YXJ5aW5nVmVydGV4IiwidmFyeWluZ0ZyYWciLCJvdXRwdXREZWNsYXJhdGlvbiIsImJpbmFyeVZlY0Z1bmN0aW9ucyIsImNvcHlWZWMiLCJzZXRWZWNJdGVtIiwiZ2V0VmVjSXRlbSIsInN1YiIsIm11bCIsImRpdiIsIldlYkdMSW5mZXJlbmNlSGFuZGxlciIsInNlc3Npb24iLCJwYWNrZWRUZXh0dXJlRGF0YUNhY2hlIiwidW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlIiwiY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0IiwibGF5b3V0U3RyYXRlZ3kiLCJleGVjdXRlUHJvZ3JhbSIsImlucHV0VHlwZXMiLCJnZXRPckNyZWF0ZVRleHR1cmVEYXRhIiwiY2FjaGVIaW50IiwicHJvZ3JhbU1hbmFnZXIiLCJnZXRBcnRpZmFjdCIsImNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tVGV4dHVyZVR5cGUiLCJkaW1zIiwidGV4dHVyZVR5cGUiLCJjcmVhdGVUZXh0dXJlRGF0YSIsImJ1aWxkIiwic2V0QXJ0aWZhY3QiLCJydW5Qcm9ncmFtIiwicnVuIiwidGVuc29yIiwiVGV4dHVyZVR5cGUiLCJwYWNrZWQiLCJnZXRUZXh0dXJlRGF0YSIsImRhdGFJZCIsInVucGFjayIsInBhY2tlZExhc3REaW1lbnNpb24iLCJudW1iZXJEYXRhIiwiRmxvYXQzMkFycmF5Iiwic3ViYXJyYXkiLCJjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlIiwicmV2ZXJzZVdIIiwiY3JlYXRlVGV4dHVyZURhdGFGcm9tTGF5b3V0QmluZFRlbnNvciIsInRleHR1cmVNYW5hZ2VyIiwiY3JlYXRlVGV4dHVyZUZyb21MYXlvdXQiLCJjcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlIiwicmVzaGFwZVVucGFja2VkIiwidW5wYWNrZWQiLCJjaGFubmVscyIsImNvbXB1dGVTdHJpZGVzIiwidGV4dHVyZSIsInJlc2hhcGVQYWNrZWQiLCJpc1Jlc2hhcGVDaGVhcCIsInByb2Nlc3NEaW1zM0QiLCJjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlciIsImNhc3QiLCJyZWFkVGV4dHVyZSIsInJlYWRUZXh0dXJlQXN5bmMiLCJzZXRUZXh0dXJlRGF0YSIsImlzSW5pdGlhbGl6ZXIiLCJpc1RleHR1cmVMYXlvdXRDYWNoZWQiLCJjbGVhckFjdGl2ZVRleHR1cmVzIiwicmVsZWFzZVRleHR1cmUiLCJpc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZCIsInJlYWRVaW50OFRleHR1cmVBc0Zsb2F0IiwiZW5jb2RlQXNVaW50OCIsImNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlciIsImNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyIiwiX19zZXRNb2R1bGVEZWZhdWx0IiwiZGVmYXVsdCIsIl9faW1wb3J0U3RhciIsIldFQkdMX09QX1JFU09MVkVfUlVMRVMiLCJ3IiwiTyIsIlMiLCJBIiwiUCIsIkkiLCJFIiwiRCIsIiQiLCJrIiwiRiIsIk4iLCJMIiwiYWJzIiwiYWNvcyIsImFuZCIsImFzaW4iLCJhdGFuIiwiYXZlcmFnZVBvb2wiLCJwYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlcyIsImJhdGNoTm9ybWFsaXphdGlvbiIsInBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlcyIsInBhcnNlQ2FzdEF0dHJpYnV0ZXMiLCJjbGlwIiwicGFyc2VDbGlwQXR0cmlidXRlcyIsImNsaXBWMTEiLCJjb25jYXQiLCJwYXJzZUNvbmNhdEF0dHJpYnV0ZXMiLCJjb252IiwicGFyc2VDb252QXR0cmlidXRlcyIsImNvbnZUcmFuc3Bvc2UiLCJwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIiwiY29zIiwiaWRlbnRpdHkiLCJkZXB0aFRvU3BhY2UiLCJwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXMiLCJlcXVhbCIsImVsdSIsInBhcnNlRWx1QXR0cmlidXRlcyIsImV4cCIsImZsYXR0ZW4iLCJwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzIiwiZmxvb3IiLCJnYXRoZXIiLCJwYXJzZUdhdGhlckF0dHJpYnV0ZXMiLCJnZW1tIiwicGFyc2VHZW1tQXR0cmlidXRlc1Y3IiwicGFyc2VHZW1tQXR0cmlidXRlc1YxMSIsImdsb2JhbEF2ZXJhZ2VQb29sIiwicGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXMiLCJnbG9iYWxNYXhQb29sIiwiZ3JlYXRlciIsImltYWdlU2NhbGVyIiwicGFyc2VJbWFnZVNjYWxlckF0dHJpYnV0ZXMiLCJpbnN0YW5jZU5vcm1hbGl6YXRpb24iLCJwYXJzZUluc3RhbmNlTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXMiLCJsZWFreVJlbHUiLCJwYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXMiLCJsZXNzIiwibHJuIiwicGFyc2VMcm5BdHRyaWJ1dGVzIiwibG9nIiwibWF0TXVsIiwicGFyc2VNYXRNdWxBdHRyaWJ1dGVzIiwibWF4UG9vbCIsInBhcnNlTWF4UG9vbEF0dHJpYnV0ZXMiLCJuZWciLCJub3QiLCJvciIsInBhZFYyIiwicGFyc2VQYWRBdHRyaWJ1dGVzVjIiLCJwYWRWMTEiLCJwYXJzZVBhZEF0dHJpYnV0ZXNWMTEiLCJwb3ciLCJwUmVsdSIsInJlZHVjZUxvZ1N1bSIsInBhcnNlUmVkdWNlQXR0cmlidXRlcyIsInJlZHVjZU1heCIsInJlZHVjZU1lYW4iLCJyZWR1Y2VNaW4iLCJyZWR1Y2VQcm9kIiwicmVkdWNlU3VtIiwicmVkdWNlTG9nU3VtU3F1YXJlIiwicmVsdSIsInJlc2hhcGUiLCJyZXNpemUiLCJwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTAiLCJwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTEiLCJzaWdtb2lkIiwic2luIiwic2xpY2VWMTAiLCJwYXJzZVNsaWNlQXR0cmlidXRlcyIsInNvZnRtYXgiLCJwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzIiwic29mdG1heFYxMyIsInBhcnNlU29mdG1heEF0dHJpYnV0ZXNWMTMiLCJwYXJzZVNwbGl0QXR0cmlidXRlcyIsInNxcnQiLCJzcXVlZXplIiwicGFyc2VTcXVlZXplQXR0cmlidXRlcyIsInNxdWVlemVWMTMiLCJzdW0iLCJ0YW4iLCJ0YW5oIiwidGlsZSIsInRyYW5zcG9zZSIsInBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcyIsInVwc2FtcGxlIiwicGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWNyIsInBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzVjkiLCJ1bnNxdWVlemUiLCJwYXJzZVVuc3F1ZWV6ZUF0dHJpYnV0ZXMiLCJ1bnNxdWVlemVWMTMiLCJ4b3IiLCJhdHRyaWJ1dGVzIiwiZXBzaWxvbiIsIm1vbWVudHVtIiwic3BhdGlhbCIsImdsc2xQUmVsdSIsImdsc2xQb3ciLCJnbHNsWG9yIiwiZ2xzbE9yIiwiZ2xzbEFuZCIsImdsc2xMZXNzIiwiZ2xzbEdyZWF0ZXIiLCJnbHNsRXF1YWwiLCJnbHNsU3ViIiwiZ2xzbE11bCIsImdsc2xEaXYiLCJnbHNsQWRkIiwiYXJlRXF1YWwiLCJjYWxjU2hhcGUiLCJQcm90b1V0aWwiLCJ0ZW5zb3JEYXRhVHlwZUZyb21Qcm90byIsImNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyIiwiZnJvbSIsImZpbGwiLCJnZXRDaGFubmVscyIsInVucGFja0Zyb21DaGFubmVsIiwiYXhpcyIsImNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlciIsImdyb3VwIiwiYXV0b1BhZCIsImRpbGF0aW9ucyIsImtlcm5lbFNoYXBlIiwicGFkcyIsImNhbGN1bGF0ZU91dHB1dFNoYXBlIiwiYWN0aXZhdGlvbkZ1bmN0aW9uIiwiYXBwbHlBY3RpdmF0aW9uIiwiZ2V0QWN0aXZhdGlvblNuaXBwZXQiLCJjb252MkRQYWNrZWQiLCJjb252MkRQYWNrZWRQb2ludHdpc2UiLCJjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlciIsImNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyIiwib3V0cHV0U2hhcGUiLCJvdXRwdXRQYWRkaW5nIiwicGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzIiwiY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIiLCJjcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciIsImNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlciIsIlBvb2xDb252VXRpbCIsImFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCIsImJsb2Nrc2l6ZSIsIm1vZGUiLCJwZXJtIiwiVHlwZUVycm9yIiwiYWN0aXZhdGlvbkNhY2hlS2V5IiwiY2FsY3VsYXRlSW0yQ29sRGltcyIsImZsYXR0ZW5TaGFwZSIsImFjdGl2YXRpb24iLCJnbHNsUmVsdSIsImdsc2xTaWdtb2lkIiwiZ2xzbENsaXAiLCJjbGlwTWluIiwiY2xpcE1heCIsIk1JTl9DTElQIiwiTUFYX0NMSVAiLCJub3JtYWxpemVBeGlzIiwiTlVNQkVSX1RZUEVTIiwidHJhbnNBIiwidHJhbnNCIiwiYWxwaGEiLCJiZXRhIiwiaXNPcHRpb25hbEMiLCJrZXkiLCJHZW1tVXRpbCIsImdldFNoYXBlT2ZHZW1tUmVzdWx0IiwiZGF0YSIsInNjYWxlIiwiYmlhcyIsImNyZWF0ZUxyblByb2dyYW1JbmZvTG9hZGVyIiwiZ2V0Qmlhc0Zvck1hdG11bCIsInVucGFja2VkUmV2ZXJzZWQiLCJnZXRWZWNDaGFubmVscyIsImludGVnZXJEYXRhIiwiZmxvYXREYXRhIiwicGFkU2hhcGUiLCJjZWlsTW9kZSIsImNvdW50SW5jbHVkZVBhZCIsInN0b3JhZ2VPcmRlciIsImFkanVzdFBvb2xBdHRyaWJ1dGVzIiwiY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSIsInJlZHVjZSIsImF4ZXMiLCJrZWVwRGltcyIsIm5vcm1hbGl6ZUF4ZXMiLCJjYWxjdWxhdGVSZXNoYXBlZERpbXMiLCJ2YWxpZGF0ZUlucHV0cyIsInBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzIiwiZXZlcnkiLCJjb29yZGluYXRlVHJhbnNmb3JtTW9kZSIsInNjYWxlcyIsInNjYWxlc0lucHV0SWR4Iiwic2l6ZXNJbnB1dElkeCIsImlzUmVzaXplIiwic2NhbGVzVmFsaWRhdGlvbiIsIkludDMyQXJyYXkiLCJzdGFydHMiLCJlbmRzIiwic29tZSIsInNpemVUb0RpbWVuc2lvbiIsInNpemVGcm9tRGltZW5zaW9uIiwib3V0cHV0cyIsIm51bU91dHB1dHMiLCJTcGxpdFV0aWwiLCJzcGxpdFNoYXBlIiwic29ydEJhc2VkT25QZXJtIiwiZG93bmxvYWRVaW50OEFzRmxvYXQiLCJnbHNsVGFuaCIsImdsc2xUYW4iLCJnbHNsU3FydCIsImdsc2xTaW4iLCJnbHNsTm90IiwiZ2xzbE5lZyIsImdsc2xMb2ciLCJnbHNsTGVha3lSZWx1IiwiZ2xzbElkZW50aXR5IiwiZ2xzbEZsb29yIiwiZ2xzbEV4cCIsImdsc2xFbHUiLCJnbHNsQ29zIiwiZ2xzbENlaWwiLCJnbHNsQXRhbiIsImdsc2xBc2luIiwiZ2xzbEFjb3MiLCJnbHNsQWJzIiwibWF4IiwiY3JlYXRlVW5wYWNrUHJvZ3JhbUluZm8iLCJ1bnNxdWVlemVTaGFwZSIsImlucHV0cyIsIm9wc2V0IiwiZXh0cmFwb2xhdGlvblZhbHVlIiwidXNlRXh0cmFwb2xhdGlvbiIsIm5lZWRSb2lJbnB1dCIsIm5lYXJlc3RNb2RlIiwiY3ViaWNDb2VmZmljaWVudEEiLCJleGNsdWRlT3V0c2lkZSIsInVzZU5lYXJlc3QyeE9wdGltaXphdGlvbiIsInJvaUlucHV0SWR4IiwiUHJvZ3JhbU1hbmFnZXIiLCJwcm9maWxlciIsInRleHR1cmVMYXlvdXRTdHJhdGVneSIsInJlcG8iLCJhdHRyaWJ1dGVzQm91bmQiLCJldmVudCIsImdsIiwicHJvZ3JhbSIsInVzZVByb2dyYW0iLCJiaW5kT3V0cHV0IiwiYmluZEF0dHJpYnV0ZXMiLCJhdHRyaWJMb2NhdGlvbnMiLCJiaW5kVW5pZm9ybXMiLCJ1bmlmb3JtTG9jYXRpb25zIiwiZXJyb3IiLCJkcmF3IiwidmVydGV4U2hhZGVyIiwiZGVsZXRlU2hhZGVyIiwiZGVsZXRlUHJvZ3JhbSIsImNvbXBpbGUiLCJnZXRVbmlmb3JtTG9jYXRpb25zIiwiZ2V0QXR0cmliTG9jYXRpb25zIiwiY29tcGlsZVNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJkZWJ1ZyIsIkZSQUdNRU5UX1NIQURFUiIsImNyZWF0ZVByb2dyYW0iLCJhdHRhY2hGcmFtZWJ1ZmZlciIsInBvc2l0aW9uIiwidGV4dHVyZUNvb3JkIiwic2V0VmVydGV4QXR0cmlidXRlcyIsImxvY2F0aW9uIiwiZmluZCIsImJpbmRUZXh0dXJlIiwidW5pZm9ybTFmdiIsInVuaWZvcm0xZiIsInVuaWZvcm0xaXYiLCJ1bmlmb3JtMWkiLCJiaW5kVGV4dHVyZVRvVW5pZm9ybSIsImdldEF0dHJpYkxvY2F0aW9uIiwiZ2V0VW5pZm9ybUxvY2F0aW9uIiwiUHJlZmVyTG9naWNhbFN0cmF0ZWd5IiwibWF4VGV4dHVyZVNpemUiLCJUZXh0dXJlTWFuYWdlciIsInJldXNlVGV4dHVyZXMiLCJwYWNrMnVucGFja01hcCIsInVucGFjazJwYWNrTWFwIiwiY3JlYXRlSW5mZXJlbmNlSGFuZGxlciIsIm9uR3JhcGhJbml0aWFsaXplZCIsImdldFZhbHVlcyIsImluaXRpYWxpemVycyIsImFkZEluaXRpYWxpemVyIiwicmVzb2x2ZU9wZXJhdG9yIiwiaW1wbCIsIm9wSW1wbCIsIm9wSW5pdCIsIlVpbnQ4RGF0YUVuY29kZXIiLCJSR0JBRmxvYXREYXRhRW5jb2RlciIsIlJlZEZsb2F0MzJEYXRhRW5jb2RlciIsImludGVybmFsRm9ybWF0IiwiUjMyRiIsImZvcm1hdCIsIlJFRCIsImNoYW5uZWxTaXplIiwiUkdCQTMyRiIsIlJHQkEiLCJhbGxvY2F0ZSIsIkFMUEhBIiwiVU5TSUdORURfQllURSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiZ2V0QmF0Y2hEaW0iLCJzaXplVG9TcXVhcmlzaFNoYXBlIiwiZ2V0Um93c0NvbHMiLCJzaXplRnJvbVNoYXBlIiwiaXNJbnQiLCJwYXJzZUF4aXNQYXJhbSIsIkFsd2F5c0tlZXBPcmlnaW5hbFNpemVTdHJhdGVneSIsImlzQXJyYXkiLCJhc3NlcnQiLCJjb21wdXRlVGV4dHVyZVdIIiwiYnJlYWtBeGlzIiwiY29tcHV0ZVRleHR1cmUiLCJyZXZlcnNlZFdIIiwiY29uZmlnIiwicGVuZGluZ1JlYWQiLCJpblVzZVRleHR1cmVzIiwiaWRsZVRleHR1cmVzIiwidGV4dHVyZUxvb2t1cCIsInRvRW5jb2RlclR5cGUiLCJnZXRFbmNvZGVyIiwicG9wIiwidXBkYXRlVGV4dHVyZSIsInRvVGV4dHVyZURhdGEiLCJhbGxvY2F0ZVRleHR1cmUiLCJ0b1RlbnNvckRhdGEiLCJjcmVhdGVBbmRXYWl0Rm9yRmVuY2UiLCJzcGxpY2UiLCJkZWxldGVUZXh0dXJlIiwiSW50MTZBcnJheSIsIkludDhBcnJheSIsIlVpbnQxNkFycmF5IiwiRmxvYXQ2NEFycmF5IiwicmVwZWF0ZWRUcnkiLCJnZXRQYWNrZWRTaGFwZSIsInNldFRpbWVvdXQiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImNyZWF0ZU5ld1dlYkdMQ29udGV4dCIsImRlcHRoIiwiYW50aWFsaWFzIiwic3RlbmNpbCIsInByZXNlcnZlRHJhd2luZ0J1ZmZlciIsInByZW11bHRpcGxpZWRBbHBoYSIsImZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQiLCJnZXRDb250ZXh0IiwiV2ViR0xDb250ZXh0Iiwid2ViZ2wyIiwiT2Zmc2NyZWVuQ2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNDb250ZXh0TG9zdCIsImRpc2FibGUiLCJERVBUSF9URVNUIiwiU1RFTkNJTF9URVNUIiwiQkxFTkQiLCJESVRIRVIiLCJQT0xZR09OX09GRlNFVF9GSUxMIiwiU0FNUExFX0NPVkVSQUdFIiwiZW5hYmxlIiwiU0NJU1NPUl9URVNUIiwiQ1VMTF9GQUNFIiwiY3VsbEZhY2UiLCJCQUNLIiwibGluZWFyU2VhcmNoTGFzdFRydWUiLCJmcmFtZUJ1ZmZlckJvdW5kIiwiaXRlbXNUb1BvbGwiLCJnZXRFeHRlbnNpb25zIiwidmVydGV4YnVmZmVyIiwiY3JlYXRlVmVydGV4YnVmZmVyIiwiZnJhbWVidWZmZXIiLCJjcmVhdGVGcmFtZWJ1ZmZlciIsInF1ZXJ5Vml0YWxQYXJhbWV0ZXJzIiwiY3JlYXRlVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiTkVBUkVTVCIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwidGV4SW1hZ2UyRCIsImNoZWNrRXJyb3IiLCJ0ZXhTdWJJbWFnZTJEIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwidmlld3BvcnQiLCJzY2lzc29yIiwicmVhZFBpeGVscyIsImlzRnJhbWVidWZmZXJSZWFkeSIsImdldEFjdGl2ZVRleHR1cmUiLCJnZXRQYXJhbWV0ZXIiLCJBQ1RJVkVfVEVYVFVSRSIsIlRFWFRVUkUwIiwiZ2V0VGV4dHVyZUJpbmRpbmciLCJURVhUVVJFX0JJTkRJTkdfMkQiLCJnZXRGcmFtZWJ1ZmZlckJpbmRpbmciLCJGUkFNRUJVRkZFUl9CSU5ESU5HIiwidmVydGV4QXR0cmliUG9pbnRlciIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJjcmVhdGVTaGFkZXIiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImdldFNoYWRlckluZm9Mb2ciLCJhY3RpdmVUZXh0dXJlIiwiZHJhd0FycmF5cyIsIlRSSUFOR0xFX1NUUklQIiwiZ2V0RXJyb3IiLCJOT19FUlJPUiIsIklOVkFMSURfRU5VTSIsIklOVkFMSURfVkFMVUUiLCJJTlZBTElEX09QRVJBVElPTiIsIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OIiwiT1VUX09GX01FTU9SWSIsIkNPTlRFWFRfTE9TVF9XRUJHTCIsInRvU3RyaW5nIiwiaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkIiwidGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiIsIkhBTEZfRkxPQVRfT0VTIiwibWF4VGV4dHVyZUltYWdlVW5pdHMiLCJkaXNwb3NlZCIsImRlbGV0ZUZyYW1lYnVmZmVyIiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImRlbGV0ZUJ1ZmZlciIsIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwiZmluaXNoIiwiY3JlYXRlRGVmYXVsdEdlb21ldHJ5IiwiY3JlYXRlQnVmZmVyIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwiaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlciIsImNoZWNrRmxvYXRUZXh0dXJlQXR0YWNoYWJsZVRvRnJhbWVCdWZmZXIiLCJjaGVja1JlbmRlckZsb2F0MzIiLCJjaGVja0Zsb2F0MzJEb3dubG9hZCIsImlzQmxlbmRTdXBwb3J0ZWQiLCJjaGVja0Zsb2F0MzJCbGVuZCIsIk1BWF9URVhUVVJFX1NJWkUiLCJNQVhfVEVYVFVSRV9JTUFHRV9VTklUUyIsImNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24iLCJnZXRFeHRlbnNpb24iLCJkaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24iLCJ0ZXh0dXJlRmxvYXRFeHRlbnNpb24iLCJjaGVja0ZyYW1lYnVmZmVyU3RhdHVzIiwiRlJBTUVCVUZGRVJfQ09NUExFVEUiLCJQT0lOVFMiLCJiZWdpblRpbWVyIiwiY3JlYXRlUXVlcnkiLCJiZWdpblF1ZXJ5IiwiVElNRV9FTEFQU0VEX0VYVCIsImVuZFRpbWVyIiwiZW5kUXVlcnkiLCJpc1RpbWVyUmVzdWx0QXZhaWxhYmxlIiwiZ2V0UXVlcnlQYXJhbWV0ZXIiLCJRVUVSWV9SRVNVTFRfQVZBSUxBQkxFIiwiR1BVX0RJU0pPSU5UX0VYVCIsImdldFRpbWVyUmVzdWx0IiwiUVVFUllfUkVTVUxUIiwiZGVsZXRlUXVlcnkiLCJ3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lIiwiY3JlYXRlRmVuY2UiLCJwb2xsRmVuY2UiLCJmZW5jZVN5bmMiLCJTWU5DX0dQVV9DT01NQU5EU19DT01QTEVURSIsImZsdXNoIiwiY2xpZW50V2FpdFN5bmMiLCJBTFJFQURZX1NJR05BTEVEIiwiQ09ORElUSU9OX1NBVElTRklFRCIsInF1ZXJ5IiwiaXNGZW5jZVBhc3NlZCIsImFkZEl0ZW1Ub1BvbGwiLCJwb2xsSXRlbXMiLCJpc0RvbmVGbiIsInJlc29sdmVGbiIsIkV4ZWN1dGlvblBsYW4iLCJvcCIsIm5vZGUiLCJncmFwaCIsImdldE5vZGVzIiwiX29wcyIsInJlc2V0IiwiX3N0YXJ0ZXIiLCJfdmFsdWVzIiwiZ2V0SW5wdXRJbmRpY2VzIiwiZXhlY3V0ZSIsInRvIiwiZ2V0T3V0cHV0SW5kaWNlcyIsImdldERhdGEiLCJHcmFwaCIsIl9mcm9tIiwiX3RvIiwidGVuc29yVmFsdWVUeXBlRnJvbVByb3RvIiwidGVuc29yVHlwZSIsIk5vZGVQcm90byIsIm9wVHlwZSIsIk5vZGUiLCJ0ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdCIsImV4ZWN1dGVOb2RlIiwiYnVpbGRHcmFwaCIsInRyYW5zZm9ybUdyYXBoIiwiY2hlY2tJc0FjeWNsaWMiLCJfYWxsSW5wdXRJbmRpY2VzIiwiZ2V0SW5wdXROYW1lcyIsIl9hbGxJbnB1dE5hbWVzIiwiX2FsbE91dHB1dEluZGljZXMiLCJnZXRPdXRwdXROYW1lcyIsIl9hbGxPdXRwdXROYW1lcyIsIl9hbGxEYXRhIiwiX25vZGVzIiwiR3JhcGhQcm90byIsImJ1aWxkR3JhcGhGcm9tT25ueEZvcm1hdCIsImJ1aWxkR3JhcGhGcm9tT3J0Rm9ybWF0IiwiaW5wdXQiLCJpbml0aWFsaXplciIsInRlbnNvckRpbXNGcm9tUHJvdG8iLCJkYXRhVHlwZSIsImlucHV0c0xlbmd0aCIsIm5vZGVBcmdzTGVuZ3RoIiwibm9kZUFyZ3MiLCJ2YWx1ZVR5cGUiLCJUeXBlSW5mb1ZhbHVlIiwidGVuc29yX3R5cGUiLCJUZW5zb3JUeXBlQW5kU2hhcGUiLCJlbGVtVHlwZSIsImRpbUxlbmd0aCIsImRpbSIsImRpbVZhbHVlIiwiaW5pdGlhbGl6ZXJzTGVuZ3RoIiwidGVuc29yRGltc0Zyb21PUlRGb3JtYXQiLCJvdXRwdXRzTGVuZ3RoIiwibm9kZXMiLCJub2Rlc0xlbmd0aCIsImF0dHJpYnV0ZXNMZW5ndGgiLCJyZW1vdmVBbGxJZGVudGl0eU5vZGVzIiwicmVtb3ZlQWxsRHJvcG91dE5vZGVzIiwiZnVzZUNvbnZBY3RpdmF0aW9uTm9kZXMiLCJmaW5hbGl6ZUdyYXBoIiwiZGVsZXRlTm9kZSIsImlzQWN0aXZhdGlvbiIsIm5vdyIsIlByb2ZpbGVyIiwiaW5mbyIsImZhdGFsIiwibm9uZSIsImNvbnNvbGUiLCJjb2xvciIsInByb3ZpZGVyIiwibWluaW1hbFNldmVyaXR5IiwibG9nRGF0ZVRpbWUiLCJsb2dTb3VyY2VMb2NhdGlvbiIsImJpbmQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJsb2dMZXZlbCIsImNhdGVnb3J5Iiwic3RhcnRUaW1lIiwiZW5kQ2FsbGJhY2siLCJ0aW1lciIsImN0eCIsImVuZCIsImNoZWNrVGltZXIiLCJlbmRUaW1lIiwibWF4TnVtYmVyRXZlbnRzIiwiZmx1c2hCYXRjaFNpemUiLCJmbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMiLCJfc3RhcnRlZCIsIl9mbHVzaFBvaW50ZXIiLCJfbWF4TnVtYmVyRXZlbnRzIiwiX2ZsdXNoQmF0Y2hTaXplIiwiX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyIsInN0YXJ0IiwiX3RpbWluZ0V2ZW50cyIsIl9mbHVzaFRpbWUiLCJzdG9wIiwibG9nT25lRXZlbnQiLCJiZWdpbiIsInRoZW4iLCJlbmRTeW5jIiwidG9GaXhlZCIsInN0YXJ0ZWQiLCJwZXJmb3JtYW5jZSIsIk1vZGVsIiwibG9hZCIsImxvYWRGcm9tT25ueEZvcm1hdCIsImxvYWRGcm9tT3J0Rm9ybWF0IiwiTW9kZWxQcm90byIsImlyVmVyc2lvbiIsIl9vcHNldHMiLCJvcHNldEltcG9ydCIsImRvbWFpbiIsIl9ncmFwaCIsImZsYXRidWZmZXJzIiwiQnl0ZUJ1ZmZlciIsIkluZmVyZW5jZVNlc3Npb24iLCJnZXRSb290QXNJbmZlcmVuY2VTZXNzaW9uIiwibW9kZWwiLCJvcHNldEltcG9ydExlbmd0aCIsIm9wc2V0cyIsIkZMT0FUX1RZUEVTIiwiSU5UX1RZUEVTIiwiZW5kc1dpdGgiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImlzTmFOIiwiVU5ERUZJTkVEIiwiU1BBUlNFX1RFTlNPUiIsIlNQQVJTRV9URU5TT1JTIiwiVU5LTk9XTiIsIlZBTFVFIiwiUEFSQU0iLCJEaW1lbnNpb25WYWx1ZVR5cGUiLCJVSU5UOCIsIklOVDgiLCJVSU5UMTYiLCJJTlQxNiIsIklOVDMyIiwiSU5UNjQiLCJCT09MIiwiRkxPQVQxNiIsIkRPVUJMRSIsIlVJTlQzMiIsIlVJTlQ2NCIsIkNPTVBMRVg2NCIsIkNPTVBMRVgxMjgiLCJCRkxPQVQxNiIsIkZMT0FUOEU0TTNGTiIsIkZMT0FUOEU0TTNGTlVaIiwiRkxPQVQ4RTVNMiIsIkZMT0FUOEU1TTJGTlVaIiwiVGVuc29yRGF0YVR5cGUiLCJQcmltaXRpdmUiLCJGdXNlZCIsIk5vZGVUeXBlIiwiTk9ORSIsInNlcXVlbmNlX3R5cGUiLCJtYXBfdHlwZSIsImJiIiwiYmJfcG9zIiwiX19pbml0IiwiZ2V0Um9vdEFzU2hhcGUiLCJyZWFkSW50MzIiLCJnZXRTaXplUHJlZml4ZWRSb290QXNTaGFwZSIsInNldFBvc2l0aW9uIiwiU0laRV9QUkVGSVhfTEVOR1RIIiwiX19vZmZzZXQiLCJEaW1lbnNpb24iLCJfX2luZGlyZWN0IiwiX192ZWN0b3IiLCJfX3ZlY3Rvcl9sZW4iLCJzdGFydFNoYXBlIiwic3RhcnRPYmplY3QiLCJhZGREaW0iLCJhZGRGaWVsZE9mZnNldCIsImNyZWF0ZURpbVZlY3RvciIsInN0YXJ0VmVjdG9yIiwiYWRkT2Zmc2V0IiwiZW5kVmVjdG9yIiwic3RhcnREaW1WZWN0b3IiLCJlbmRTaGFwZSIsImVuZE9iamVjdCIsImNyZWF0ZVNoYXBlIiwiU2hhcGUiLCJnZXRSb290QXNEaW1lbnNpb24iLCJnZXRTaXplUHJlZml4ZWRSb290QXNEaW1lbnNpb24iLCJEaW1lbnNpb25WYWx1ZSIsImRlbm90YXRpb24iLCJfX3N0cmluZyIsInN0YXJ0RGltZW5zaW9uIiwiYWRkVmFsdWUiLCJhZGREZW5vdGF0aW9uIiwiZW5kRGltZW5zaW9uIiwiY3JlYXRlRGltZW5zaW9uIiwiZ2V0Um9vdEFzRGltZW5zaW9uVmFsdWUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNEaW1lbnNpb25WYWx1ZSIsImRpbVR5cGUiLCJyZWFkSW50OCIsInJlYWRJbnQ2NCIsImNyZWF0ZUxvbmciLCJkaW1QYXJhbSIsInN0YXJ0RGltZW5zaW9uVmFsdWUiLCJhZGREaW1UeXBlIiwiYWRkRmllbGRJbnQ4IiwiYWRkRGltVmFsdWUiLCJhZGRGaWVsZEludDY0IiwiYWRkRGltUGFyYW0iLCJlbmREaW1lbnNpb25WYWx1ZSIsImNyZWF0ZURpbWVuc2lvblZhbHVlIiwiZ2V0Um9vdEFzVGVuc29yVHlwZUFuZFNoYXBlIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yVHlwZUFuZFNoYXBlIiwic3RhcnRUZW5zb3JUeXBlQW5kU2hhcGUiLCJhZGRFbGVtVHlwZSIsImFkZEZpZWxkSW50MzIiLCJhZGRTaGFwZSIsImVuZFRlbnNvclR5cGVBbmRTaGFwZSIsImNyZWF0ZVRlbnNvclR5cGVBbmRTaGFwZSIsImdldFJvb3RBc01hcFR5cGUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNNYXBUeXBlIiwia2V5VHlwZSIsIlR5cGVJbmZvIiwic3RhcnRNYXBUeXBlIiwiYWRkS2V5VHlwZSIsImFkZFZhbHVlVHlwZSIsImVuZE1hcFR5cGUiLCJjcmVhdGVNYXBUeXBlIiwiTWFwVHlwZSIsImdldFJvb3RBc1NlcXVlbmNlVHlwZSIsImdldFNpemVQcmVmaXhlZFJvb3RBc1NlcXVlbmNlVHlwZSIsInN0YXJ0U2VxdWVuY2VUeXBlIiwiZW5kU2VxdWVuY2VUeXBlIiwiY3JlYXRlU2VxdWVuY2VUeXBlIiwiU2VxdWVuY2VUeXBlIiwiRWRnZUVuZCIsIm5vZGVJbmRleCIsInJlYWRVaW50MzIiLCJzcmNBcmdJbmRleCIsImRzdEFyZ0luZGV4IiwiY3JlYXRlRWRnZUVuZCIsInByZXAiLCJ3cml0ZUludDMyIiwib2Zmc2V0IiwiZ2V0Um9vdEFzTm9kZUVkZ2UiLCJnZXRTaXplUHJlZml4ZWRSb290QXNOb2RlRWRnZSIsImlucHV0RWRnZXMiLCJpbnB1dEVkZ2VzTGVuZ3RoIiwib3V0cHV0RWRnZXMiLCJvdXRwdXRFZGdlc0xlbmd0aCIsInN0YXJ0Tm9kZUVkZ2UiLCJhZGROb2RlSW5kZXgiLCJhZGRJbnB1dEVkZ2VzIiwic3RhcnRJbnB1dEVkZ2VzVmVjdG9yIiwiYWRkT3V0cHV0RWRnZXMiLCJzdGFydE91dHB1dEVkZ2VzVmVjdG9yIiwiZW5kTm9kZUVkZ2UiLCJjcmVhdGVOb2RlRWRnZSIsIk5vZGVFZGdlIiwiZ2V0Um9vdEFzTm9kZSIsImdldFNpemVQcmVmaXhlZFJvb3RBc05vZGUiLCJkb2NTdHJpbmciLCJzaW5jZVZlcnNpb24iLCJpbmRleCIsImV4ZWN1dGlvblByb3ZpZGVyVHlwZSIsImlucHV0QXJnQ291bnRzIiwiaW5wdXRBcmdDb3VudHNMZW5ndGgiLCJpbnB1dEFyZ0NvdW50c0FycmF5IiwiYnl0ZXMiLCJpbXBsaWNpdElucHV0cyIsImltcGxpY2l0SW5wdXRzTGVuZ3RoIiwic3RhcnROb2RlIiwiYWRkTmFtZSIsImFkZERvY1N0cmluZyIsImFkZERvbWFpbiIsImFkZFNpbmNlVmVyc2lvbiIsImFkZEluZGV4IiwiYWRkT3BUeXBlIiwiYWRkVHlwZSIsImFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZSIsImFkZElucHV0cyIsImNyZWF0ZUlucHV0c1ZlY3RvciIsInN0YXJ0SW5wdXRzVmVjdG9yIiwiYWRkT3V0cHV0cyIsImNyZWF0ZU91dHB1dHNWZWN0b3IiLCJzdGFydE91dHB1dHNWZWN0b3IiLCJhZGRBdHRyaWJ1dGVzIiwiY3JlYXRlQXR0cmlidXRlc1ZlY3RvciIsInN0YXJ0QXR0cmlidXRlc1ZlY3RvciIsImFkZElucHV0QXJnQ291bnRzIiwiY3JlYXRlSW5wdXRBcmdDb3VudHNWZWN0b3IiLCJhZGRJbnQzMiIsInN0YXJ0SW5wdXRBcmdDb3VudHNWZWN0b3IiLCJhZGRJbXBsaWNpdElucHV0cyIsImNyZWF0ZUltcGxpY2l0SW5wdXRzVmVjdG9yIiwic3RhcnRJbXBsaWNpdElucHV0c1ZlY3RvciIsImVuZE5vZGUiLCJjcmVhdGVOb2RlIiwiZ2V0Um9vdEFzVmFsdWVJbmZvIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVmFsdWVJbmZvIiwic3RhcnRWYWx1ZUluZm8iLCJlbmRWYWx1ZUluZm8iLCJjcmVhdGVWYWx1ZUluZm8iLCJWYWx1ZUluZm8iLCJnZXRSb290QXNUeXBlSW5mbyIsImdldFNpemVQcmVmaXhlZFJvb3RBc1R5cGVJbmZvIiwicmVhZFVpbnQ4IiwiX191bmlvbiIsInN0YXJ0VHlwZUluZm8iLCJlbmRUeXBlSW5mbyIsImNyZWF0ZVR5cGVJbmZvIiwiZ2V0Um9vdEFzT3BlcmF0b3JTZXRJZCIsImdldFNpemVQcmVmaXhlZFJvb3RBc09wZXJhdG9yU2V0SWQiLCJzdGFydE9wZXJhdG9yU2V0SWQiLCJhZGRWZXJzaW9uIiwiZW5kT3BlcmF0b3JTZXRJZCIsImNyZWF0ZU9wZXJhdG9yU2V0SWQiLCJPcGVyYXRvclNldElkIiwiZ2V0Um9vdEFzVGVuc29yIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzVGVuc29yIiwiZGltc0xlbmd0aCIsInJhd0RhdGEiLCJyYXdEYXRhTGVuZ3RoIiwicmF3RGF0YUFycmF5Iiwic3RyaW5nRGF0YSIsInN0cmluZ0RhdGFMZW5ndGgiLCJzdGFydFRlbnNvciIsImFkZERpbXMiLCJjcmVhdGVEaW1zVmVjdG9yIiwiYWRkSW50NjQiLCJzdGFydERpbXNWZWN0b3IiLCJhZGREYXRhVHlwZSIsImFkZFJhd0RhdGEiLCJjcmVhdGVSYXdEYXRhVmVjdG9yIiwiYWRkSW50OCIsInN0YXJ0UmF3RGF0YVZlY3RvciIsImFkZFN0cmluZ0RhdGEiLCJjcmVhdGVTdHJpbmdEYXRhVmVjdG9yIiwic3RhcnRTdHJpbmdEYXRhVmVjdG9yIiwiZW5kVGVuc29yIiwiY3JlYXRlVGVuc29yIiwiZ2V0Um9vdEFzU3BhcnNlVGVuc29yIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU3BhcnNlVGVuc29yIiwidmFsdWVzIiwiaW5kaWNlcyIsInN0YXJ0U3BhcnNlVGVuc29yIiwiYWRkVmFsdWVzIiwiYWRkSW5kaWNlcyIsImVuZFNwYXJzZVRlbnNvciIsImNyZWF0ZVNwYXJzZVRlbnNvciIsIlNwYXJzZVRlbnNvciIsImdldFJvb3RBc0F0dHJpYnV0ZSIsImdldFNpemVQcmVmaXhlZFJvb3RBc0F0dHJpYnV0ZSIsInJlYWRGbG9hdDMyIiwiZmxvYXRzTGVuZ3RoIiwiZ3JhcGhzTGVuZ3RoIiwic3RhcnRBdHRyaWJ1dGUiLCJhZGRGIiwiYWRkRmllbGRGbG9hdDMyIiwiYWRkSSIsImFkZFMiLCJhZGRUIiwiYWRkRyIsImFkZEZsb2F0cyIsImNyZWF0ZUZsb2F0c1ZlY3RvciIsImFkZEZsb2F0MzIiLCJzdGFydEZsb2F0c1ZlY3RvciIsImFkZEludHMiLCJjcmVhdGVJbnRzVmVjdG9yIiwic3RhcnRJbnRzVmVjdG9yIiwiYWRkU3RyaW5ncyIsImNyZWF0ZVN0cmluZ3NWZWN0b3IiLCJzdGFydFN0cmluZ3NWZWN0b3IiLCJhZGRUZW5zb3JzIiwiY3JlYXRlVGVuc29yc1ZlY3RvciIsInN0YXJ0VGVuc29yc1ZlY3RvciIsImFkZEdyYXBocyIsImNyZWF0ZUdyYXBoc1ZlY3RvciIsInN0YXJ0R3JhcGhzVmVjdG9yIiwiZW5kQXR0cmlidXRlIiwiY3JlYXRlQXR0cmlidXRlIiwiZ2V0Um9vdEFzR3JhcGgiLCJnZXRTaXplUHJlZml4ZWRSb290QXNHcmFwaCIsIm1heE5vZGVJbmRleCIsIm5vZGVFZGdlcyIsIm5vZGVFZGdlc0xlbmd0aCIsInNwYXJzZUluaXRpYWxpemVycyIsInNwYXJzZUluaXRpYWxpemVyc0xlbmd0aCIsInN0YXJ0R3JhcGgiLCJhZGRJbml0aWFsaXplcnMiLCJjcmVhdGVJbml0aWFsaXplcnNWZWN0b3IiLCJzdGFydEluaXRpYWxpemVyc1ZlY3RvciIsImFkZE5vZGVBcmdzIiwiY3JlYXRlTm9kZUFyZ3NWZWN0b3IiLCJzdGFydE5vZGVBcmdzVmVjdG9yIiwiYWRkTm9kZXMiLCJjcmVhdGVOb2Rlc1ZlY3RvciIsInN0YXJ0Tm9kZXNWZWN0b3IiLCJhZGRNYXhOb2RlSW5kZXgiLCJhZGROb2RlRWRnZXMiLCJjcmVhdGVOb2RlRWRnZXNWZWN0b3IiLCJzdGFydE5vZGVFZGdlc1ZlY3RvciIsImFkZFNwYXJzZUluaXRpYWxpemVycyIsImNyZWF0ZVNwYXJzZUluaXRpYWxpemVyc1ZlY3RvciIsInN0YXJ0U3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yIiwiZW5kR3JhcGgiLCJjcmVhdGVHcmFwaCIsImdldFJvb3RBc01vZGVsIiwiZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTW9kZWwiLCJwcm9kdWNlck5hbWUiLCJwcm9kdWNlclZlcnNpb24iLCJtb2RlbFZlcnNpb24iLCJncmFwaERvY1N0cmluZyIsInN0YXJ0TW9kZWwiLCJhZGRJclZlcnNpb24iLCJhZGRPcHNldEltcG9ydCIsImNyZWF0ZU9wc2V0SW1wb3J0VmVjdG9yIiwic3RhcnRPcHNldEltcG9ydFZlY3RvciIsImFkZFByb2R1Y2VyTmFtZSIsImFkZFByb2R1Y2VyVmVyc2lvbiIsImFkZE1vZGVsVmVyc2lvbiIsImFkZEdyYXBoIiwiYWRkR3JhcGhEb2NTdHJpbmciLCJlbmRNb2RlbCIsImNyZWF0ZU1vZGVsIiwiZ2V0Um9vdEFzS2VybmVsQ3JlYXRlSW5mb3MiLCJnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyIsIm5vZGVJbmRpY2VzIiwibm9kZUluZGljZXNMZW5ndGgiLCJub2RlSW5kaWNlc0FycmF5Iiwia2VybmVsRGVmSGFzaGVzIiwicmVhZFVpbnQ2NCIsImtlcm5lbERlZkhhc2hlc0xlbmd0aCIsInN0YXJ0S2VybmVsQ3JlYXRlSW5mb3MiLCJhZGROb2RlSW5kaWNlcyIsImNyZWF0ZU5vZGVJbmRpY2VzVmVjdG9yIiwic3RhcnROb2RlSW5kaWNlc1ZlY3RvciIsImFkZEtlcm5lbERlZkhhc2hlcyIsImNyZWF0ZUtlcm5lbERlZkhhc2hlc1ZlY3RvciIsInN0YXJ0S2VybmVsRGVmSGFzaGVzVmVjdG9yIiwiZW5kS2VybmVsQ3JlYXRlSW5mb3MiLCJjcmVhdGVLZXJuZWxDcmVhdGVJbmZvcyIsIktlcm5lbENyZWF0ZUluZm9zIiwiZ2V0Um9vdEFzU3ViR3JhcGhTZXNzaW9uU3RhdGUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNTdWJHcmFwaFNlc3Npb25TdGF0ZSIsImdyYXBoSWQiLCJzZXNzaW9uU3RhdGUiLCJTZXNzaW9uU3RhdGUiLCJzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlIiwiYWRkR3JhcGhJZCIsImFkZFNlc3Npb25TdGF0ZSIsImVuZFN1YkdyYXBoU2Vzc2lvblN0YXRlIiwicmVxdWlyZWRGaWVsZCIsImNyZWF0ZVN1YkdyYXBoU2Vzc2lvblN0YXRlIiwiU3ViR3JhcGhTZXNzaW9uU3RhdGUiLCJnZXRSb290QXNTZXNzaW9uU3RhdGUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNTZXNzaW9uU3RhdGUiLCJrZXJuZWxzIiwic3ViR3JhcGhTZXNzaW9uU3RhdGVzIiwic3ViR3JhcGhTZXNzaW9uU3RhdGVzTGVuZ3RoIiwic3RhcnRTZXNzaW9uU3RhdGUiLCJhZGRLZXJuZWxzIiwiYWRkU3ViR3JhcGhTZXNzaW9uU3RhdGVzIiwiY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yIiwic3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZXNWZWN0b3IiLCJlbmRTZXNzaW9uU3RhdGUiLCJjcmVhdGVTZXNzaW9uU3RhdGUiLCJnZXRTaXplUHJlZml4ZWRSb290QXNJbmZlcmVuY2VTZXNzaW9uIiwiYnVmZmVySGFzSWRlbnRpZmllciIsIl9faGFzX2lkZW50aWZpZXIiLCJvcnRWZXJzaW9uIiwic3RhcnRJbmZlcmVuY2VTZXNzaW9uIiwiYWRkT3J0VmVyc2lvbiIsImFkZE1vZGVsIiwiZW5kSW5mZXJlbmNlU2Vzc2lvbiIsImZpbmlzaEluZmVyZW5jZVNlc3Npb25CdWZmZXIiLCJmaW5pc2hTaXplUHJlZml4ZWRJbmZlcmVuY2VTZXNzaW9uQnVmZmVyIiwiY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbiIsIm91dHB1dE5hbWVzIiwic3RhcnRQcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJfaW5pdGlhbGl6ZWQiLCJiYWNrZW5kSGludCIsImdyYXBoSW5wdXRUeXBlcyIsImdyYXBoSW5wdXREaW1zIiwiX21vZGVsIiwic2Vzc2lvbkhhbmRsZXIiLCJwcm9jZXNzIiwicHJvbWlzaWZ5IiwicmVhZEZpbGUiLCJmZXRjaCIsImFycmF5QnVmZmVyIiwiaXNWaWV3IiwiaW5pdGlhbGl6ZU9wcyIsIl9leGVjdXRpb25QbGFuIiwibm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHMiLCJjcmVhdGVPdXRwdXQiLCJ2YWxpZGF0ZUlucHV0VGVuc29yRGltcyIsInZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyIsImNvbXBhcmVUZW5zb3JEaW1zIiwiX19pbXBvcnREZWZhdWx0IiwiY2FjaGUiLCJkYXRhUHJvdmlkZXIiLCJhc3luY0RhdGFQcm92aWRlciIsIl9zdHJpZGVzIiwiR3VpZCIsInZhbGlkYXRlRGltc0FuZENhbGNTaXplIiwiUmFuZ2VFcnJvciIsIkRhdGFWaWV3IiwiVGVuc29yUHJvdG8iLCJEYXRhVHlwZSIsImludDMyRGF0YSIsImludDY0RGF0YSIsImRvdWJsZURhdGEiLCJ1aW50NjREYXRhIiwiZnJvbURhdGEiLCJCaWdJbnQ2NEFycmF5IiwiZ3JlYXRlclRoYW5PckVxdWFsIiwibGVzc1RoYW4iLCJ0b051bWJlciIsImdldFVpbnQ4IiwiZ2V0SW50OCIsImdldFVpbnQxNiIsImdldEludDE2IiwiZ2V0RmxvYXQzMiIsImdldEludDMyIiwiZ2V0VWludDMyIiwiZnJvbUJpdHMiLCJnZXRGbG9hdDY0IiwiUmVkdWNlVXRpbCIsIk1hdGhVdGlsIiwiYXJyYXlDb3B5SGVscGVyIiwiTWF0TXVsVXRpbCIsImNoZWNrSW5wdXRzU2hhcGUiLCJwcmVwcm9jZXNzSW5wdXRTaGFwZXMiLCJwb3N0cHJvY2Vzc091dHB1dFNoYXBlIiwiY2FsY01hdE11bFNoYXBlIiwiZmlsbEluZGV4IiwiY2FsYyIsImlzVmFsaWRCcm9hZGNhc3QiLCJ1bnNoaWZ0IiwidGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0iLCJMb25nIiwiZnJvbVZhbHVlIiwibG93IiwiaGlnaCIsInVuc2lnbmVkIiwiZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSIsImluY3JlbWVudEluZGV4Iiwic3FyIiwiYXhweSIsInBvd3giLCJkZXRlcm1pbmVTcGxpdCIsImNhbGNSZWR1Y2UiLCJjYWxjUmVkdWNlU2hhcGUiLCJjYWxjUmVkdWNlQnlBeGlzIiwiYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUiLCJjb21wdXRlU2hhcGVIZWxwZXIiLCJjb21wdXRlQ29udk91dHB1dFNoYXBlIiwiVGV4dERlY29kZXIiLCJyZWxlYXNlU2Vzc2lvbiIsImNyZWF0ZVNlc3Npb24iLCJjcmVhdGVTZXNzaW9uRmluYWxpemUiLCJjcmVhdGVTZXNzaW9uQWxsb2NhdGUiLCJpbml0aWFsaXplUnVudGltZSIsImVyciIsInNoaWZ0Iiwib3V0IiwiY3VycmVudFNjcmlwdCIsInNyYyIsIndhc21QYXRocyIsInN1YnN0ciIsImxhc3RJbmRleE9mIiwidGVybWluYXRlIiwiWiIsIm9ubWVzc2FnZSIsImluIiwicG9zdE1lc3NhZ2UiLCJpbml0aWFsaXplV2ViQXNzZW1ibHkiLCJpbml0UnVudGltZSIsIm1vZGVsZGF0YSIsIm9wdGlvbnMiLCJzZXNzaW9uSWQiLCJpbnB1dEluZGljZXMiLCJvdXRwdXRJbmRpY2VzIiwiZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMiLCJzZXRSdW5PcHRpb25zIiwiZ2V0SW5zdGFuY2UiLCJsb2dTZXZlcml0eUxldmVsIiwibG9nVmVyYm9zaXR5TGV2ZWwiLCJ0YWciLCJhbGxvY1dhc21TdHJpbmciLCJfT3J0Q3JlYXRlUnVuT3B0aW9ucyIsImNoZWNrTGFzdEVycm9yIiwiZXh0cmEiLCJpdGVyYXRlRXh0cmFPcHRpb25zIiwiV2Vha1NldCIsIl9PcnRBZGRSdW5Db25maWdFbnRyeSIsIl9PcnRSZWxlYXNlUnVuT3B0aW9ucyIsIl9mcmVlIiwic3RhdHVzIiwiZW50cmllcyIsInNldFNlc3Npb25PcHRpb25zIiwidXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSIsImV4ZWN1dGlvblByb3ZpZGVycyIsImVuYWJsZU1lbVBhdHRlcm4iLCJncmFwaE9wdGltaXphdGlvbkxldmVsIiwiZXhlY3V0aW9uTW9kZSIsImxvZ0lkIiwib3B0aW1pemVkTW9kZWxGaWxlUGF0aCIsIl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyIsImVuYWJsZUNwdU1lbUFyZW5hIiwiZW5hYmxlUHJvZmlsaW5nIiwiZGV2aWNlVHlwZSIsIl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkiLCJwb3dlclByZWZlcmVuY2UiLCJfT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIiLCJfT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zIiwibG9nTGV2ZWxTdHJpbmdUb0VudW0iLCJ0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IiLCJnZXRUZW5zb3JFbGVtZW50U2l6ZSIsInRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nIiwiQmlnVWludDY0QXJyYXkiLCJfT3J0SW5pdCIsIl9tYWxsb2MiLCJIRUFQVTgiLCJfT3J0Q3JlYXRlU2Vzc2lvbiIsInN0YWNrU2F2ZSIsInN0YWNrQWxsb2MiLCJfT3J0R2V0SW5wdXRPdXRwdXRDb3VudCIsIkhFQVAzMiIsInN0YWNrUmVzdG9yZSIsIl9PcnRHZXRJbnB1dE5hbWUiLCJVVEY4VG9TdHJpbmciLCJfT3J0R2V0T3V0cHV0TmFtZSIsIl9PcnRGcmVlIiwiX09ydFJlbGVhc2VTZXNzaW9uIiwiSEVBUFUzMiIsIl9PcnRDcmVhdGVUZW5zb3IiLCJfT3J0UnVuIiwianNlcFJ1blByb21pc2UiLCJfT3J0R2V0VGVuc29yRGF0YSIsIl9PcnRSZWxlYXNlVGVuc29yIiwiX09ydEVuZFByb2ZpbGluZyIsIlNoYXJlZEFycmF5QnVmZmVyIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsIldlYkFzc2VtYmx5IiwidmFsaWRhdGUiLCJsb2NhdGVGaWxlIiwiQmxvYiIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsIm1haW5TY3JpcHRVcmxPckJsb2IiLCJfX2Rpcm5hbWUiLCJyYWNlIiwiUFRocmVhZCIsInRlcm1pbmF0ZUFsbFRocmVhZHMiLCJsZW5ndGhCeXRlc1VURjgiLCJzdHJpbmdUb1VURjgiLCJfT3J0R2V0TGFzdEVycm9yIiwiZXhwb3J0cyIsInNlbGYiLCJ3aW5kb3ciLCJCbG9iQnVpbGRlciIsIldlYktpdEJsb2JCdWlsZGVyIiwiTW96QmxvYkJ1aWxkZXIiLCJNU0Jsb2JCdWlsZGVyIiwiYXBwZW5kIiwiZ2V0QmxvYiIsIndlYmtpdFVSTCIsInJldm9rZU9iamVjdFVSTCIsImVuY29kZVVSSUNvbXBvbmVudCIsIlJlYWRlciIsIldyaXRlciIsInV0aWwiLCJyb290cyIsIlZlcnNpb24iLCJzcGFyc2VUZW5zb3JzIiwidHlwZVByb3RvcyIsInJlZkF0dHJOYW1lIiwibmV3QnVmZmVyIiwic3BhcnNlVGVuc29yIiwidHAiLCJlbXB0eUFycmF5IiwidWludDMyIiwic3RyaW5nIiwiZmxvYXQiLCJpbnQ2NCIsImZvcmsiLCJsZGVsaW0iLCJUeXBlUHJvdG8iLCJpbnQzMiIsIlNwYXJzZVRlbnNvclByb3RvIiwiZW5jb2RlRGVsaW1pdGVkIiwibGVuIiwicG9zIiwic2tpcFR5cGUiLCJkZWNvZGVEZWxpbWl0ZWQiLCJ2ZXJpZnkiLCJpc1N0cmluZyIsImZyb21PYmplY3QiLCJTdHJpbmciLCJMb25nQml0cyIsImJhc2U2NCIsInRvT2JqZWN0IiwiYXJyYXlzIiwiZGVmYXVsdHMiLCJsb25ncyIsImVudW1zIiwianNvbiIsImlzRmluaXRlIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImdldFR5cGVVcmwiLCJWYWx1ZUluZm9Qcm90byIsIlRyYWluaW5nSW5mb1Byb3RvIiwiaW5pdGlhbGl6YXRpb25CaW5kaW5nIiwidXBkYXRlQmluZGluZyIsImluaXRpYWxpemF0aW9uIiwiYWxnb3JpdGhtIiwiU3RyaW5nU3RyaW5nRW50cnlQcm90byIsIm1ldGFkYXRhUHJvcHMiLCJ0cmFpbmluZ0luZm8iLCJmdW5jdGlvbnMiLCJPcGVyYXRvclNldElkUHJvdG8iLCJGdW5jdGlvblByb3RvIiwiVGVuc29yQW5ub3RhdGlvbiIsInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMiLCJ0ZW5zb3JOYW1lIiwic3BhcnNlSW5pdGlhbGl6ZXIiLCJ2YWx1ZUluZm8iLCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uIiwiZXh0ZXJuYWxEYXRhIiwic2VnbWVudCIsImRhdGFMb2NhdGlvbiIsIlNlZ21lbnQiLCJkb3VibGUiLCJ1aW50NjQiLCJEYXRhTG9jYXRpb24iLCJUZW5zb3JTaGFwZVByb3RvIiwib25lT2ZHZXR0ZXIiLCJvbmVPZlNldHRlciIsIm9uZW9mcyIsInNlcXVlbmNlVHlwZSIsIm1hcFR5cGUiLCJvcHRpb25hbFR5cGUiLCJzcGFyc2VUZW5zb3JUeXBlIiwiU2VxdWVuY2UiLCJPcHRpb25hbCIsIk9wZXJhdG9yU3RhdHVzIiwiYXR0cmlidXRlUHJvdG8iLCJfc2NyaXB0RGlyIiwiX19maWxlbmFtZSIsIlUiLCJDIiwiaiIsInJlYWR5IiwiaW1wb3J0U2NyaXB0cyIsIkVOVklST05NRU5UX0lTX1BUSFJFQUQiLCJkaXJuYW1lIiwic3RhcnRzV2l0aCIsIm5vcm1hbGl6ZSIsInJlYWRGaWxlU3luYyIsInRoaXNQcm9ncmFtIiwiYXJndiIsImV4aXRDb2RlIiwiaW5zcGVjdCIsImdsb2JhbCIsIldvcmtlciIsImhyZWYiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZW5kIiwicmVzcG9uc2VUZXh0IiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2UiLCJvbmxvYWQiLCJvbmVycm9yIiwid3JpdGVTeW5jIiwicHJpbnQiLCJwcmludEVyciIsInF1aXQiLCJ3YXNtQmluYXJ5Iiwibm9FeGl0UnVudGltZSIsInRlIiwiTSIsIkhFQVA4IiwiSEVBUDE2IiwiSEVBUFUxNiIsIkhFQVBGMzIiLCJIRUFQRjY0IiwiQiIsIklOSVRJQUxfTUVNT1JZIiwid2FzbU1lbW9yeSIsIk1lbW9yeSIsImluaXRpYWwiLCJtYXhpbXVtIiwic2hhcmVkIiwiViIsInoiLCJHIiwiSCIsInEiLCJXIiwiWCIsIlkiLCJLIiwiSiIsIlEiLCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIiwiZWUiLCJjbGVhckludGVydmFsIiwib25BYm9ydCIsIlJ1bnRpbWVFcnJvciIsIm5lIiwicmUiLCJvZSIsImNyZWRlbnRpYWxzIiwib2siLCJjYXRjaCIsImluc3RhbnRpYXRlIiwiaWUiLCJtZXNzYWdlIiwic2UiLCJhZSIsImhlIiwiRmEiLCJmYiIsInVlIiwiWmEiLCJJYSIsIkhhIiwiY21kIiwic3RhcnRfcm91dGluZSIsImdiIiwiYXJnIiwiWWEiLCJwdGhyZWFkX3B0ciIsInVucmVmIiwibWIiLCJsZSIsImNlIiwiZnJvbUNoYXJDb2RlIiwicGUiLCJkZSIsIldlIiwiaGIiLCJvbkV4aXQiLCJmZSIsImJlIiwiTGEiLCJUYSIsIlBhIiwiYWIiLCIkYSIsInJlY2VpdmVPYmplY3RUcmFuc2ZlciIsImViIiwidGhyZWFkSW5pdFRMUyIsIlNhIiwic2V0RXhpdFN0YXR1cyIsIlJhIiwicmIiLCJtdCIsImNiIiwidGFyZ2V0VGhyZWFkIiwiZHQiLCJxYiIsInRyYW5zZmVyTGlzdCIsIk1lIiwidGhyZWFkIiwibG9hZGVkIiwiYWxlcnQiLCJ0aHJlYWRJZCIsInRleHQiLCJ0YXJnZXQiLCJoYW5kbGVyIiwiYXJncyIsImZpbGVuYW1lIiwibGluZW5vIiwib24iLCJoYW5kbGVycyIsInVybE9yQmxvYiIsIndhc21Nb2R1bGUiLCJYYSIsImdlIiwiZXN0YWJsaXNoU3RhY2tTcGFjZSIsIlR0Iiwid3QiLCJtZSIsInllIiwiT2EiLCJXYSIsIlZhIiwiVWEiLCJfZSIsInZlIiwib2IiLCJUZSIsInhlIiwiaW52b2tlRW50cnlQb2ludCIsInl0Iiwid2UiLCJjaGFyQ29kZUF0IiwiT2UiLCJTZSIsIkFlIiwiUGUiLCJJZSIsIkVlIiwiRGUiLCIkZSIsImtlIiwiRmUiLCJOZSIsIkxlIiwiQ2UiLCJSZSIsImplIiwiQXRvbWljcyIsIm5iIiwic3RvcmUiLCJfdCIsIl9fZW1zY3JpcHRlbl90aHJlYWRfbWFpbGJveF9hd2FpdCIsImNoZWNrTWFpbGJveCIsIlVlIiwiQmUiLCJWZSIsInplIiwiR2UiLCJIZSIsImZ0IiwicWUiLCJ4dCIsImFyZ3VtZW50cyIsIk90IiwiYnQiLCJYZSIsIlllIiwiS2UiLCJKZSIsIlVTRVIiLCJMT0dOQU1FIiwiUEFUSCIsIlBXRCIsIkhPTUUiLCJMQU5HIiwibGFuZ3VhZ2VzIiwiWmUiLCJRZSIsImV0IiwidHQiLCJudCIsInJ0Iiwib3QiLCJpdCIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInJhbmRvbUZpbGxTeW5jIiwicmFuZG9tQnl0ZXMiLCJzdCIsImF0IiwidXQiLCJsdCIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0RGF5IiwiSmEiLCJLYSIsImdldFRpbWUiLCJzZXREYXRlIiwic2V0TW9udGgiLCJzZXRGdWxsWWVhciIsImtiIiwiamIiLCJNYSIsIlFhIiwiTmEiLCJHYSIsInNiIiwiaWIiLCJsYiIsImluY2x1ZGVzIiwiY3QiLCJwdCIsImh0IiwicmVmIiwiTmFOIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENIb3VycyIsImdldFVUQ0RhdGUiLCJnZXRVVENNb250aCIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDRGF5IiwiVVRDIiwiZ2V0U2Vjb25kcyIsImdldE1pbnV0ZXMiLCJnZXRIb3VycyIsImdldFRpbWV6b25lT2Zmc2V0Iiwic2V0VGltZSIsImdldFllYXIiLCJ2dCIsInRvVGltZVN0cmluZyIsIm1hdGNoIiwidGltZU9yaWdpbiIsInBiIiwiYXBwbHkiLCJncm93IiwiX19lcnJub19sb2NhdGlvbiIsInB0aHJlYWRfc2VsZiIsIm1hbGxvYyIsInNhIiwidGEiLCJpbnN0YW50aWF0ZVdhc20iLCJpbnN0YW50aWF0ZVN0cmVhbWluZyIsImluc3RhbmNlIiwibW9kdWxlIiwiYWEiLCJiYSIsImNhIiwiZGEiLCJlYSIsImZhIiwiZ2EiLCJoYSIsImlhIiwiamEiLCJrYSIsImxhIiwibWEiLCJuYSIsIm9hIiwiX3B0aHJlYWRfc2VsZiIsInBhIiwicWEiLCJyYSIsIl9fZW1zY3JpcHRlbl90bHNfaW5pdCIsIl9fZW1zY3JpcHRlbl90aHJlYWRfaW5pdCIsInVhIiwiX19lbXNjcmlwdGVuX3RocmVhZF9jcmFzaGVkIiwidmEiLCJndCIsIndhIiwieGEiLCJfX2Vtc2NyaXB0ZW5fdGhyZWFkX2V4aXQiLCJ5YSIsIl9fZW1zY3JpcHRlbl9jaGVja19tYWlsYm94IiwiemEiLCJBYSIsIkJhIiwiQ2EiLCJEYSIsIkVhIiwiU3QiLCJjYWxsZWRSdW4iLCJvblJ1bnRpbWVJbml0aWFsaXplZCIsInBvc3RSdW4iLCJzdGFydFdvcmtlciIsInByZVJ1biIsInNldFN0YXR1cyIsImtlZXBSdW50aW1lQWxpdmUiLCJFeGl0U3RhdHVzIiwicHJlSW5pdCIsImNvcHlXaXRoaW4iLCJ0ZXN0IiwiX2xpc3RlbmVycyIsImZuIiwib2ZmIiwiZW1pdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsInJlYWRGbG9hdExFIiwicmVhZEZsb2F0QkUiLCJyb3VuZCIsIkxOMiIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiaW5xdWlyZSIsIm1vZHVsZU5hbWUiLCJtb2QiLCJldmFsIiwicmVhZCIsIndyaXRlIiwiRU1QVFkiLCJpc0d1aWQiLCJ2YWxpZGF0b3IiLCJnZW4iLCJjcmVhdGVFbXB0eSIsInJhdyIsInJhbmRvbSIsImVxdWFscyIsImlzRW1wdHkiLCJfY29uZmlndXJlIiwiQnVmZmVyV3JpdGVyIiwiQnVmZmVyUmVhZGVyIiwicnBjIiwiY29uZmlndXJlIiwidXRmOCIsImJ1ZiIsIkJ1ZmZlciIsImlzQnVmZmVyIiwibG8iLCJoaSIsIl9zbGljZSIsInNpbnQzMiIsImJvb2wiLCJmaXhlZDMyIiwic2ZpeGVkMzIiLCJza2lwIiwibWVyZ2UiLCJzaW50NjQiLCJ6ekRlY29kZSIsImZpeGVkNjQiLCJzZml4ZWQ2NCIsInV0ZjhTbGljZSIsIlNlcnZpY2UiLCJFdmVudEVtaXR0ZXIiLCJycGNJbXBsIiwicmVxdWVzdERlbGltaXRlZCIsIkJvb2xlYW4iLCJyZXNwb25zZURlbGltaXRlZCIsInJwY0NhbGwiLCJhc1Byb21pc2UiLCJ6ZXJvIiwienpFbmNvZGUiLCJ6ZXJvSGFzaCIsImZyb21OdW1iZXIiLCJmcm9tU3RyaW5nIiwidG9Mb25nIiwiZnJvbUhhc2giLCJ0b0hhc2giLCJjYXB0dXJlU3RhY2tUcmFjZSIsInN0YWNrIiwicG9vbCIsImlzTm9kZSIsImZyZWV6ZSIsImVtcHR5T2JqZWN0IiwiaXNPYmplY3QiLCJpc3NldCIsImlzU2V0IiwidXRmOFdyaXRlIiwiX0J1ZmZlcl9mcm9tIiwiX0J1ZmZlcl9hbGxvY1Vuc2FmZSIsImRjb2RlSU8iLCJrZXkyUmUiLCJrZXkzMlJlIiwia2V5NjRSZSIsImxvbmdUb0hhc2giLCJsb25nRnJvbUhhc2giLCJsY0ZpcnN0IiwidG9Mb3dlckNhc2UiLCJuZXdFcnJvciIsIlByb3RvY29sRXJyb3IiLCJhbGxvY1Vuc2FmZSIsIm5leHQiLCJ2YWwiLCJoZWFkIiwidGFpbCIsInN0YXRlcyIsImFsbG9jIiwiX3B1c2giLCJ3cml0ZUJ5dGVzQnVmZmVyIiwiY29weSIsInJlcXVpcmUiLCJJbnN0YW5jZSIsIk1vZHVsZSIsIl9faXNMb25nX18iLCJjbHozMiIsImZyb21JbnQiLCJaRVJPIiwiVVpFUk8iLCJPTkUiLCJVT05FIiwiTkVHX09ORSIsIk1BWF9WQUxVRSIsIk1BWF9VTlNJR05FRF9WQUxVRSIsIk1JTl9WQUxVRSIsInRvSW50IiwiaXNaZXJvIiwiaXNOZWdhdGl2ZSIsImVxIiwiZ2V0SGlnaEJpdHMiLCJnZXRIaWdoQml0c1Vuc2lnbmVkIiwiZ2V0TG93Qml0cyIsImdldExvd0JpdHNVbnNpZ25lZCIsImdldE51bUJpdHNBYnMiLCJlcXoiLCJpc1Bvc2l0aXZlIiwiaXNPZGQiLCJpc0V2ZW4iLCJub3RFcXVhbHMiLCJuZXEiLCJjb21wIiwibGVzc1RoYW5PckVxdWFsIiwibHRlIiwiZ3JlYXRlclRoYW4iLCJndGUiLCJjb21wYXJlIiwibmVnYXRlIiwic3VidHJhY3QiLCJtdWx0aXBseSIsImdldF9oaWdoIiwiZGl2aWRlIiwiZGl2X3UiLCJkaXZfcyIsInRvVW5zaWduZWQiLCJzaHJ1Iiwic2hyIiwic2hsIiwibW9kdWxvIiwicmVtX3UiLCJyZW1fcyIsInJlbSIsImNvdW50TGVhZGluZ1plcm9zIiwiY2x6IiwiY291bnRUcmFpbGluZ1plcm9zIiwiY3R6Iiwic2hpZnRMZWZ0Iiwic2hpZnRSaWdodCIsInNoaWZ0UmlnaHRVbnNpZ25lZCIsInNocl91Iiwicm90YXRlTGVmdCIsInJvdGwiLCJyb3RhdGVSaWdodCIsInJvdHIiLCJ0b1NpZ25lZCIsInRvQnl0ZXMiLCJ0b0J5dGVzTEUiLCJ0b0J5dGVzQkUiLCJmcm9tQnl0ZXMiLCJmcm9tQnl0ZXNMRSIsImZyb21CeXRlc0JFIiwiT2Zmc2V0IiwiVGFibGUiLCJTSVpFT0ZfU0hPUlQiLCJTSVpFT0ZfSU5UIiwiRklMRV9JREVOVElGSUVSX0xFTkdUSCIsIkVuY29kaW5nIiwiVVRGOF9CWVRFUyIsIlVURjE2X1NUUklORyIsImZsb2F0MzIiLCJmbG9hdDY0IiwidG9GbG9hdDY0IiwiQnVpbGRlciIsInNwYWNlIiwibWluYWxpZ24iLCJ2dGFibGUiLCJ2dGFibGVfaW5fdXNlIiwiaXNOZXN0ZWQiLCJvYmplY3Rfc3RhcnQiLCJ2dGFibGVzIiwidmVjdG9yX251bV9lbGVtcyIsImZvcmNlX2RlZmF1bHRzIiwiY2xlYXIiLCJjYXBhY2l0eSIsImZvcmNlRGVmYXVsdHMiLCJkYXRhQnVmZmVyIiwiYXNVaW50OEFycmF5IiwiZ3Jvd0J5dGVCdWZmZXIiLCJwYWQiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2Iiwid3JpdGVJbnQ2NCIsIndyaXRlRmxvYXQzMiIsIndyaXRlRmxvYXQ2NCIsImFkZEludDE2IiwiYWRkRmxvYXQ2NCIsInNsb3QiLCJhZGRGaWVsZEludDE2IiwiYWRkRmllbGRGbG9hdDY0IiwiYWRkRmllbGRTdHJ1Y3QiLCJuZXN0ZWQiLCJub3ROZXN0ZWQiLCJyZWFkSW50MTYiLCJmaW5pc2hTaXplUHJlZml4ZWQiLCJjcmVhdGVTdHJpbmciLCJieXRlc18iLCJwb3NpdGlvbl8iLCJyZWFkVWludDE2IiwicmVhZEZsb2F0NjQiLCJ3cml0ZVVpbnQ4Iiwid3JpdGVVaW50MTYiLCJ3cml0ZVVpbnQzMiIsIndyaXRlVWludDY0IiwiZ2V0QnVmZmVySWRlbnRpZmllciIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIl9fd2VicGFja19leHBvcnRzX18iLCJfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/dist/ort-web.node.js\n");

/***/ })

};
;