"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/onnxruntime-common";
exports.ids = ["vendor-chunks/onnxruntime-common"];
exports.modules = {

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/backend-impl.js":
/*!******************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/backend-impl.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.resolveBackend = exports.registerBackend = void 0;\nconst backends = {};\nconst backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */ const registerBackend = (name, backend, priority)=>{\n    if (backend && typeof backend.init === \"function\" && typeof backend.createSessionHandler === \"function\") {\n        const currentBackend = backends[name];\n        if (currentBackend === undefined) {\n            backends[name] = {\n                backend,\n                priority\n            };\n        } else if (currentBackend.priority > priority) {\n            // same name is already registered with a higher priority. skip registeration.\n            return;\n        } else if (currentBackend.priority === priority) {\n            if (currentBackend.backend !== backend) {\n                throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n            }\n        }\n        if (priority >= 0) {\n            const i = backendsSortedByPriority.indexOf(name);\n            if (i !== -1) {\n                backendsSortedByPriority.splice(i, 1);\n            }\n            for(let i = 0; i < backendsSortedByPriority.length; i++){\n                if (backends[backendsSortedByPriority[i]].priority <= priority) {\n                    backendsSortedByPriority.splice(i, 0, name);\n                    return;\n                }\n            }\n            backendsSortedByPriority.push(name);\n        }\n        return;\n    }\n    throw new TypeError(\"not a valid backend\");\n};\nexports.registerBackend = registerBackend;\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */ const resolveBackend = async (backendHints)=>{\n    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n    const errors = [];\n    for (const backendName of backendNames){\n        const backendInfo = backends[backendName];\n        if (backendInfo) {\n            if (backendInfo.initialized) {\n                return backendInfo.backend;\n            } else if (backendInfo.aborted) {\n                continue; // current backend is unavailable; try next\n            }\n            const isInitializing = !!backendInfo.initPromise;\n            try {\n                if (!isInitializing) {\n                    backendInfo.initPromise = backendInfo.backend.init();\n                }\n                await backendInfo.initPromise;\n                backendInfo.initialized = true;\n                return backendInfo.backend;\n            } catch (e) {\n                if (!isInitializing) {\n                    errors.push({\n                        name: backendName,\n                        err: e\n                    });\n                }\n                backendInfo.aborted = true;\n            } finally{\n                delete backendInfo.initPromise;\n            }\n        }\n    }\n    throw new Error(`no available backend found. ERR: ${errors.map((e)=>`[${e.name}] ${e.err}`).join(\", \")}`);\n};\nexports.resolveBackend = resolveBackend; //# sourceMappingURL=backend-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2JhY2tlbmQtaW1wbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDREQUE0RDtBQUM1RCxrQ0FBa0M7QUFDbENBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUN4RCxNQUFNSSxXQUFXLENBQUM7QUFDbEIsTUFBTUMsMkJBQTJCLEVBQUU7QUFDbkM7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUYsa0JBQWtCLENBQUNHLE1BQU1DLFNBQVNDO0lBQ3BDLElBQUlELFdBQVcsT0FBT0EsUUFBUUUsSUFBSSxLQUFLLGNBQWMsT0FBT0YsUUFBUUcsb0JBQW9CLEtBQUssWUFBWTtRQUNyRyxNQUFNQyxpQkFBaUJQLFFBQVEsQ0FBQ0UsS0FBSztRQUNyQyxJQUFJSyxtQkFBbUJDLFdBQVc7WUFDOUJSLFFBQVEsQ0FBQ0UsS0FBSyxHQUFHO2dCQUFFQztnQkFBU0M7WUFBUztRQUN6QyxPQUNLLElBQUlHLGVBQWVILFFBQVEsR0FBR0EsVUFBVTtZQUN6Qyw4RUFBOEU7WUFDOUU7UUFDSixPQUNLLElBQUlHLGVBQWVILFFBQVEsS0FBS0EsVUFBVTtZQUMzQyxJQUFJRyxlQUFlSixPQUFPLEtBQUtBLFNBQVM7Z0JBQ3BDLE1BQU0sSUFBSU0sTUFBTSxDQUFDLHlCQUF5QixFQUFFUCxLQUFLLGlCQUFpQixFQUFFRSxTQUFTLENBQUM7WUFDbEY7UUFDSjtRQUNBLElBQUlBLFlBQVksR0FBRztZQUNmLE1BQU1NLElBQUlULHlCQUF5QlUsT0FBTyxDQUFDVDtZQUMzQyxJQUFJUSxNQUFNLENBQUMsR0FBRztnQkFDVlQseUJBQXlCVyxNQUFNLENBQUNGLEdBQUc7WUFDdkM7WUFDQSxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSVQseUJBQXlCWSxNQUFNLEVBQUVILElBQUs7Z0JBQ3RELElBQUlWLFFBQVEsQ0FBQ0Msd0JBQXdCLENBQUNTLEVBQUUsQ0FBQyxDQUFDTixRQUFRLElBQUlBLFVBQVU7b0JBQzVESCx5QkFBeUJXLE1BQU0sQ0FBQ0YsR0FBRyxHQUFHUjtvQkFDdEM7Z0JBQ0o7WUFDSjtZQUNBRCx5QkFBeUJhLElBQUksQ0FBQ1o7UUFDbEM7UUFDQTtJQUNKO0lBQ0EsTUFBTSxJQUFJYSxVQUFVO0FBQ3hCO0FBQ0FuQix1QkFBdUIsR0FBR0c7QUFDMUI7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1ELGlCQUFpQixPQUFPa0I7SUFDMUIsTUFBTUMsZUFBZUQsYUFBYUgsTUFBTSxLQUFLLElBQUlaLDJCQUEyQmU7SUFDNUUsTUFBTUUsU0FBUyxFQUFFO0lBQ2pCLEtBQUssTUFBTUMsZUFBZUYsYUFBYztRQUNwQyxNQUFNRyxjQUFjcEIsUUFBUSxDQUFDbUIsWUFBWTtRQUN6QyxJQUFJQyxhQUFhO1lBQ2IsSUFBSUEsWUFBWUMsV0FBVyxFQUFFO2dCQUN6QixPQUFPRCxZQUFZakIsT0FBTztZQUM5QixPQUNLLElBQUlpQixZQUFZRSxPQUFPLEVBQUU7Z0JBQzFCLFVBQVUsMkNBQTJDO1lBQ3pEO1lBQ0EsTUFBTUMsaUJBQWlCLENBQUMsQ0FBQ0gsWUFBWUksV0FBVztZQUNoRCxJQUFJO2dCQUNBLElBQUksQ0FBQ0QsZ0JBQWdCO29CQUNqQkgsWUFBWUksV0FBVyxHQUFHSixZQUFZakIsT0FBTyxDQUFDRSxJQUFJO2dCQUN0RDtnQkFDQSxNQUFNZSxZQUFZSSxXQUFXO2dCQUM3QkosWUFBWUMsV0FBVyxHQUFHO2dCQUMxQixPQUFPRCxZQUFZakIsT0FBTztZQUM5QixFQUNBLE9BQU9zQixHQUFHO2dCQUNOLElBQUksQ0FBQ0YsZ0JBQWdCO29CQUNqQkwsT0FBT0osSUFBSSxDQUFDO3dCQUFFWixNQUFNaUI7d0JBQWFPLEtBQUtEO29CQUFFO2dCQUM1QztnQkFDQUwsWUFBWUUsT0FBTyxHQUFHO1lBQzFCLFNBQ1E7Z0JBQ0osT0FBT0YsWUFBWUksV0FBVztZQUNsQztRQUNKO0lBQ0o7SUFDQSxNQUFNLElBQUlmLE1BQU0sQ0FBQyxpQ0FBaUMsRUFBRVMsT0FBT1MsR0FBRyxDQUFDRixDQUFBQSxJQUFLLENBQUMsQ0FBQyxFQUFFQSxFQUFFdkIsSUFBSSxDQUFDLEVBQUUsRUFBRXVCLEVBQUVDLEdBQUcsQ0FBQyxDQUFDLEVBQUVFLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDNUc7QUFDQWhDLHNCQUFzQixHQUFHRSxnQkFDekIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2JhY2tlbmQtaW1wbC5qcz83ZTEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlc29sdmVCYWNrZW5kID0gZXhwb3J0cy5yZWdpc3RlckJhY2tlbmQgPSB2b2lkIDA7XG5jb25zdCBiYWNrZW5kcyA9IHt9O1xuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5ID0gW107XG4vKipcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIGFzIGEga2V5IHRvIGxvb2t1cCBhcyBhbiBleGVjdXRpb24gcHJvdmlkZXIuXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cbiAqIEBwYXJhbSBwcmlvcml0eSAtIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGJhY2tlbmQuIEhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBpZiBwcmlvcml0eVxuICogPCAwLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSAnYmV0YScgdmVyc2lvbiBhbmQgd2lsbCBub3QgYmUgdXNlZCBhcyBhIGZhbGxiYWNrIGJhY2tlbmQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgcmVnaXN0ZXJCYWNrZW5kID0gKG5hbWUsIGJhY2tlbmQsIHByaW9yaXR5KSA9PiB7XG4gICAgaWYgKGJhY2tlbmQgJiYgdHlwZW9mIGJhY2tlbmQuaW5pdCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYmFja2VuZC5jcmVhdGVTZXNzaW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBjdXJyZW50QmFja2VuZCA9IGJhY2tlbmRzW25hbWVdO1xuICAgICAgICBpZiAoY3VycmVudEJhY2tlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmFja2VuZHNbbmFtZV0gPSB7IGJhY2tlbmQsIHByaW9yaXR5IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xuICAgICAgICAgICAgLy8gc2FtZSBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5LiBza2lwIHJlZ2lzdGVyYXRpb24uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPT09IHByaW9yaXR5KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEJhY2tlbmQuYmFja2VuZCAhPT0gYmFja2VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke25hbWV9XCIgdXNpbmcgcHJpb3JpdHkgJHtwcmlvcml0eX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5pbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2tlbmRzW2JhY2tlbmRzU29ydGVkQnlQcmlvcml0eVtpXV0ucHJpb3JpdHkgPD0gcHJpb3JpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAwLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgdmFsaWQgYmFja2VuZCcpO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJCYWNrZW5kID0gcmVnaXN0ZXJCYWNrZW5kO1xuLyoqXG4gKiBSZXNvbHZlIGJhY2tlbmQgYnkgc3BlY2lmaWVkIGhpbnRzLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kSGludHMgLSBhIGxpc3Qgb2YgZXhlY3V0aW9uIHByb3ZpZGVyIG5hbWVzIHRvIGxvb2t1cC4gSWYgb21pdHRlZCB1c2UgcmVnaXN0ZXJlZCBiYWNrZW5kcyBhcyBsaXN0LlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGJhY2tlbmQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IHJlc29sdmVCYWNrZW5kID0gYXN5bmMgKGJhY2tlbmRIaW50cykgPT4ge1xuICAgIGNvbnN0IGJhY2tlbmROYW1lcyA9IGJhY2tlbmRIaW50cy5sZW5ndGggPT09IDAgPyBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkgOiBiYWNrZW5kSGludHM7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICAgICAgY29uc3QgYmFja2VuZEluZm8gPSBiYWNrZW5kc1tiYWNrZW5kTmFtZV07XG4gICAgICAgIGlmIChiYWNrZW5kSW5mbykge1xuICAgICAgICAgICAgaWYgKGJhY2tlbmRJbmZvLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmJhY2tlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiYWNrZW5kSW5mby5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIGN1cnJlbnQgYmFja2VuZCBpcyB1bmF2YWlsYWJsZTsgdHJ5IG5leHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmJhY2tlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goeyBuYW1lOiBiYWNrZW5kTmFtZSwgZXJyOiBlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiYWNrZW5kSW5mby5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGF2YWlsYWJsZSBiYWNrZW5kIGZvdW5kLiBFUlI6ICR7ZXJyb3JzLm1hcChlID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG59O1xuZXhwb3J0cy5yZXNvbHZlQmFja2VuZCA9IHJlc29sdmVCYWNrZW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja2VuZC1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlc29sdmVCYWNrZW5kIiwicmVnaXN0ZXJCYWNrZW5kIiwiYmFja2VuZHMiLCJiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkiLCJuYW1lIiwiYmFja2VuZCIsInByaW9yaXR5IiwiaW5pdCIsImNyZWF0ZVNlc3Npb25IYW5kbGVyIiwiY3VycmVudEJhY2tlbmQiLCJ1bmRlZmluZWQiLCJFcnJvciIsImkiLCJpbmRleE9mIiwic3BsaWNlIiwibGVuZ3RoIiwicHVzaCIsIlR5cGVFcnJvciIsImJhY2tlbmRIaW50cyIsImJhY2tlbmROYW1lcyIsImVycm9ycyIsImJhY2tlbmROYW1lIiwiYmFja2VuZEluZm8iLCJpbml0aWFsaXplZCIsImFib3J0ZWQiLCJpc0luaXRpYWxpemluZyIsImluaXRQcm9taXNlIiwiZSIsImVyciIsIm1hcCIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/backend-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/backend.js":
/*!*************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/backend.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.registerBackend = void 0;\nvar backend_impl_js_1 = __webpack_require__(/*! ./backend-impl.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/backend-impl.js\");\nObject.defineProperty(exports, \"registerBackend\", ({\n    enumerable: true,\n    get: function() {\n        return backend_impl_js_1.registerBackend;\n    }\n})); //# sourceMappingURL=backend.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2JhY2tlbmQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixJQUFJRyxvQkFBb0JDLG1CQUFPQSxDQUFDLDJGQUFtQjtBQUNuRE4sbURBQWtEO0lBQUVPLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9ILGtCQUFrQkQsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDLEVBQ3ZJLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2Nqcy9iYWNrZW5kLmpzPzYyNzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnaXN0ZXJCYWNrZW5kID0gdm9pZCAwO1xudmFyIGJhY2tlbmRfaW1wbF9qc18xID0gcmVxdWlyZShcIi4vYmFja2VuZC1pbXBsLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJCYWNrZW5kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiYWNrZW5kX2ltcGxfanNfMS5yZWdpc3RlckJhY2tlbmQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrZW5kLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlZ2lzdGVyQmFja2VuZCIsImJhY2tlbmRfaW1wbF9qc18xIiwicmVxdWlyZSIsImVudW1lcmFibGUiLCJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/backend.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/env-impl.js":
/*!**************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/env-impl.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.env = void 0;\nconst version_js_1 = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/version.js\");\nlet logLevelValue = \"warning\";\nexports.env = {\n    wasm: {},\n    webgl: {},\n    webgpu: {},\n    versions: {\n        common: version_js_1.version\n    },\n    set logLevel (value){\n        if (value === undefined) {\n            return;\n        }\n        if (typeof value !== \"string\" || [\n            \"verbose\",\n            \"info\",\n            \"warning\",\n            \"error\",\n            \"fatal\"\n        ].indexOf(value) === -1) {\n            throw new Error(`Unsupported logging level: ${value}`);\n        }\n        logLevelValue = value;\n    },\n    get logLevel () {\n        return logLevelValue;\n    }\n};\n// set property 'logLevel' so that they can be correctly transferred to worker by `postMessage()`.\nObject.defineProperty(exports.env, \"logLevel\", {\n    enumerable: true\n}); //# sourceMappingURL=env-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2Vudi1pbXBsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNERBQTREO0FBQzVELGtDQUFrQztBQUNsQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELFdBQVcsR0FBRyxLQUFLO0FBQ25CLE1BQU1HLGVBQWVDLG1CQUFPQSxDQUFDLGlGQUFjO0FBQzNDLElBQUlDLGdCQUFnQjtBQUNwQkwsV0FBVyxHQUFHO0lBQ1ZNLE1BQU0sQ0FBQztJQUNQQyxPQUFPLENBQUM7SUFDUkMsUUFBUSxDQUFDO0lBQ1RDLFVBQVU7UUFBRUMsUUFBUVAsYUFBYVEsT0FBTztJQUFDO0lBQ3pDLElBQUlDLFVBQVNYLE1BQU87UUFDaEIsSUFBSUEsVUFBVVksV0FBVztZQUNyQjtRQUNKO1FBQ0EsSUFBSSxPQUFPWixVQUFVLFlBQVk7WUFBQztZQUFXO1lBQVE7WUFBVztZQUFTO1NBQVEsQ0FBQ2EsT0FBTyxDQUFDYixXQUFXLENBQUMsR0FBRztZQUNyRyxNQUFNLElBQUljLE1BQU0sQ0FBQywyQkFBMkIsRUFBRWQsTUFBTSxDQUFDO1FBQ3pEO1FBQ0FJLGdCQUFnQko7SUFDcEI7SUFDQSxJQUFJVyxZQUFXO1FBQ1gsT0FBT1A7SUFDWDtBQUNKO0FBQ0Esa0dBQWtHO0FBQ2xHUCxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLEdBQUcsRUFBRSxZQUFZO0lBQUVjLFlBQVk7QUFBSyxJQUNsRSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9janMvZW52LWltcGwuanM/MDEwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnYgPSB2b2lkIDA7XG5jb25zdCB2ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uLmpzXCIpO1xubGV0IGxvZ0xldmVsVmFsdWUgPSAnd2FybmluZyc7XG5leHBvcnRzLmVudiA9IHtcbiAgICB3YXNtOiB7fSxcbiAgICB3ZWJnbDoge30sXG4gICAgd2ViZ3B1OiB7fSxcbiAgICB2ZXJzaW9uczogeyBjb21tb246IHZlcnNpb25fanNfMS52ZXJzaW9uIH0sXG4gICAgc2V0IGxvZ0xldmVsKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvcicsICdmYXRhbCddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ0xldmVsVmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldCBsb2dMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIGxvZ0xldmVsVmFsdWU7XG4gICAgfSxcbn07XG4vLyBzZXQgcHJvcGVydHkgJ2xvZ0xldmVsJyBzbyB0aGF0IHRoZXkgY2FuIGJlIGNvcnJlY3RseSB0cmFuc2ZlcnJlZCB0byB3b3JrZXIgYnkgYHBvc3RNZXNzYWdlKClgLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZW52LCAnbG9nTGV2ZWwnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnYtaW1wbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnYiLCJ2ZXJzaW9uX2pzXzEiLCJyZXF1aXJlIiwibG9nTGV2ZWxWYWx1ZSIsIndhc20iLCJ3ZWJnbCIsIndlYmdwdSIsInZlcnNpb25zIiwiY29tbW9uIiwidmVyc2lvbiIsImxvZ0xldmVsIiwidW5kZWZpbmVkIiwiaW5kZXhPZiIsIkVycm9yIiwiZW51bWVyYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/env-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/env.js":
/*!*********************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/env.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.env = void 0;\nconst env_impl_js_1 = __webpack_require__(/*! ./env-impl.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/env-impl.js\");\n/**\n * Represent a set of flags as a global singleton.\n */ exports.env = env_impl_js_1.env; //# sourceMappingURL=env.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2Vudi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDREQUE0RDtBQUM1RCxrQ0FBa0M7QUFDbENBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUcsS0FBSztBQUNuQixNQUFNRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLG1GQUFlO0FBQzdDOztDQUVDLEdBQ0RKLFdBQVcsR0FBR0csY0FBY0QsR0FBRyxFQUMvQiwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9janMvZW52LmpzPzllOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW52ID0gdm9pZCAwO1xuY29uc3QgZW52X2ltcGxfanNfMSA9IHJlcXVpcmUoXCIuL2Vudi1pbXBsLmpzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzZXQgb2YgZmxhZ3MgYXMgYSBnbG9iYWwgc2luZ2xldG9uLlxuICovXG5leHBvcnRzLmVudiA9IGVudl9pbXBsX2pzXzEuZW52O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudiIsImVudl9pbXBsX2pzXzEiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * # ONNX Runtime JavaScript API\n *\n * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:\n *\n * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)\n * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)\n * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)\n *\n * See also:\n * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript.html)\n * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)\n *\n * @packageDocumentation\n */ __exportStar(__webpack_require__(/*! ./backend.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/backend.js\"), exports);\n__exportStar(__webpack_require__(/*! ./env.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/env.js\"), exports);\n__exportStar(__webpack_require__(/*! ./inference-session.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/inference-session.js\"), exports);\n__exportStar(__webpack_require__(/*! ./tensor.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./onnx-value.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/onnx-value.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNERBQTREO0FBQzVELGtDQUFrQztBQUNsQyxJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVNaLENBQUMsRUFBRWEsUUFBTztJQUNqRSxJQUFLLElBQUlDLEtBQUtkLEVBQUcsSUFBSWMsTUFBTSxhQUFhLENBQUNqQixPQUFPa0IsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osVUFBU0MsSUFBSWxCLGdCQUFnQmlCLFVBQVNiLEdBQUdjO0FBQzNIO0FBQ0FqQiw4Q0FBNkM7SUFBRXFCLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0Q7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRE4sYUFBYU8sbUJBQU9BLENBQUMsaUZBQWMsR0FBR047QUFDdENELGFBQWFPLG1CQUFPQSxDQUFDLHlFQUFVLEdBQUdOO0FBQ2xDRCxhQUFhTyxtQkFBT0EsQ0FBQyxxR0FBd0IsR0FBR047QUFDaERELGFBQWFPLG1CQUFPQSxDQUFDLCtFQUFhLEdBQUdOO0FBQ3JDRCxhQUFhTyxtQkFBT0EsQ0FBQyx1RkFBaUIsR0FBR04sVUFDekMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2luZGV4LmpzPzNmMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0Lmh0bWwpXG4gKiAtIFtJbmZlcmVuY2UgZXhhbXBsZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUtaW5mZXJlbmNlLWV4YW1wbGVzL3RyZWUvbWFpbi9qcylcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JhY2tlbmQuanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vudi5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5mZXJlbmNlLXNlc3Npb24uanNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RlbnNvci5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb25ueC12YWx1ZS5qc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnRTdGFyIiwiZXhwb3J0cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/inference-session-impl.js":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/inference-session-impl.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InferenceSession = void 0;\nconst backend_impl_js_1 = __webpack_require__(/*! ./backend-impl.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/backend-impl.js\");\nconst tensor_js_1 = __webpack_require__(/*! ./tensor.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor.js\");\nclass InferenceSession {\n    constructor(handler){\n        this.handler = handler;\n    }\n    async run(feeds, arg1, arg2) {\n        const fetches = {};\n        let options = {};\n        // check inputs\n        if (typeof feeds !== \"object\" || feeds === null || feeds instanceof tensor_js_1.Tensor || Array.isArray(feeds)) {\n            throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n        }\n        let isFetchesEmpty = true;\n        // determine which override is being used\n        if (typeof arg1 === \"object\") {\n            if (arg1 === null) {\n                throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n            }\n            if (arg1 instanceof tensor_js_1.Tensor) {\n                throw new TypeError(\"'fetches' cannot be a Tensor\");\n            }\n            if (Array.isArray(arg1)) {\n                if (arg1.length === 0) {\n                    throw new TypeError(\"'fetches' cannot be an empty array.\");\n                }\n                isFetchesEmpty = false;\n                // output names\n                for (const name of arg1){\n                    if (typeof name !== \"string\") {\n                        throw new TypeError(\"'fetches' must be a string array or an object.\");\n                    }\n                    if (this.outputNames.indexOf(name) === -1) {\n                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n                    }\n                    fetches[name] = null;\n                }\n                if (typeof arg2 === \"object\" && arg2 !== null) {\n                    options = arg2;\n                } else if (typeof arg2 !== \"undefined\") {\n                    throw new TypeError(\"'options' must be an object.\");\n                }\n            } else {\n                // decide whether arg1 is fetches or options\n                // if any output name is present and its value is valid OnnxValue, we consider it fetches\n                let isFetches = false;\n                const arg1Keys = Object.getOwnPropertyNames(arg1);\n                for (const name of this.outputNames){\n                    if (arg1Keys.indexOf(name) !== -1) {\n                        const v = arg1[name];\n                        if (v === null || v instanceof tensor_js_1.Tensor) {\n                            isFetches = true;\n                            isFetchesEmpty = false;\n                            fetches[name] = v;\n                        }\n                    }\n                }\n                if (isFetches) {\n                    if (typeof arg2 === \"object\" && arg2 !== null) {\n                        options = arg2;\n                    } else if (typeof arg2 !== \"undefined\") {\n                        throw new TypeError(\"'options' must be an object.\");\n                    }\n                } else {\n                    options = arg1;\n                }\n            }\n        } else if (typeof arg1 !== \"undefined\") {\n            throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n        }\n        // check if all inputs are in feed\n        for (const name of this.inputNames){\n            if (typeof feeds[name] === \"undefined\") {\n                throw new Error(`input '${name}' is missing in 'feeds'.`);\n            }\n        }\n        // if no fetches is specified, we use the full output names list\n        if (isFetchesEmpty) {\n            for (const name of this.outputNames){\n                fetches[name] = null;\n            }\n        }\n        // feeds, fetches and options are prepared\n        const results = await this.handler.run(feeds, fetches, options);\n        const returnValue = {};\n        for(const key in results){\n            if (Object.hasOwnProperty.call(results, key)) {\n                returnValue[key] = new tensor_js_1.Tensor(results[key].type, results[key].data, results[key].dims);\n            }\n        }\n        return returnValue;\n    }\n    async release() {\n        return this.handler.dispose();\n    }\n    static async create(arg0, arg1, arg2, arg3) {\n        // either load from a file or buffer\n        let filePathOrUint8Array;\n        let options = {};\n        if (typeof arg0 === \"string\") {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === \"object\" && arg1 !== null) {\n                options = arg1;\n            } else if (typeof arg1 !== \"undefined\") {\n                throw new TypeError(\"'options' must be an object.\");\n            }\n        } else if (arg0 instanceof Uint8Array) {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === \"object\" && arg1 !== null) {\n                options = arg1;\n            } else if (typeof arg1 !== \"undefined\") {\n                throw new TypeError(\"'options' must be an object.\");\n            }\n        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== \"undefined\" && arg0 instanceof SharedArrayBuffer) {\n            const buffer = arg0;\n            let byteOffset = 0;\n            let byteLength = arg0.byteLength;\n            if (typeof arg1 === \"object\" && arg1 !== null) {\n                options = arg1;\n            } else if (typeof arg1 === \"number\") {\n                byteOffset = arg1;\n                if (!Number.isSafeInteger(byteOffset)) {\n                    throw new RangeError(\"'byteOffset' must be an integer.\");\n                }\n                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n                }\n                byteLength = arg0.byteLength - byteOffset;\n                if (typeof arg2 === \"number\") {\n                    byteLength = arg2;\n                    if (!Number.isSafeInteger(byteLength)) {\n                        throw new RangeError(\"'byteLength' must be an integer.\");\n                    }\n                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n                    }\n                    if (typeof arg3 === \"object\" && arg3 !== null) {\n                        options = arg3;\n                    } else if (typeof arg3 !== \"undefined\") {\n                        throw new TypeError(\"'options' must be an object.\");\n                    }\n                } else if (typeof arg2 !== \"undefined\") {\n                    throw new TypeError(\"'byteLength' must be a number.\");\n                }\n            } else if (typeof arg1 !== \"undefined\") {\n                throw new TypeError(\"'options' must be an object.\");\n            }\n            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n        } else {\n            throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n        }\n        // get backend hints\n        const eps = options.executionProviders || [];\n        const backendHints = eps.map((i)=>typeof i === \"string\" ? i : i.name);\n        const backend = await (0, backend_impl_js_1.resolveBackend)(backendHints);\n        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\n        return new InferenceSession(handler);\n    }\n    startProfiling() {\n        this.handler.startProfiling();\n    }\n    endProfiling() {\n        this.handler.endProfiling();\n    }\n    get inputNames() {\n        return this.handler.inputNames;\n    }\n    get outputNames() {\n        return this.handler.outputNames;\n    }\n}\nexports.InferenceSession = InferenceSession; //# sourceMappingURL=inference-session-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxNQUFNRyxvQkFBb0JDLG1CQUFPQSxDQUFDLDJGQUFtQjtBQUNyRCxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQywrRUFBYTtBQUN6QyxNQUFNRjtJQUNGSSxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0EsTUFBTUMsSUFBSUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRTtRQUN6QixNQUFNQyxVQUFVLENBQUM7UUFDakIsSUFBSUMsVUFBVSxDQUFDO1FBQ2YsZUFBZTtRQUNmLElBQUksT0FBT0osVUFBVSxZQUFZQSxVQUFVLFFBQVFBLGlCQUFpQkosWUFBWVMsTUFBTSxJQUFJQyxNQUFNQyxPQUFPLENBQUNQLFFBQVE7WUFDNUcsTUFBTSxJQUFJUSxVQUFVO1FBQ3hCO1FBQ0EsSUFBSUMsaUJBQWlCO1FBQ3JCLHlDQUF5QztRQUN6QyxJQUFJLE9BQU9SLFNBQVMsVUFBVTtZQUMxQixJQUFJQSxTQUFTLE1BQU07Z0JBQ2YsTUFBTSxJQUFJTyxVQUFVO1lBQ3hCO1lBQ0EsSUFBSVAsZ0JBQWdCTCxZQUFZUyxNQUFNLEVBQUU7Z0JBQ3BDLE1BQU0sSUFBSUcsVUFBVTtZQUN4QjtZQUNBLElBQUlGLE1BQU1DLE9BQU8sQ0FBQ04sT0FBTztnQkFDckIsSUFBSUEsS0FBS1MsTUFBTSxLQUFLLEdBQUc7b0JBQ25CLE1BQU0sSUFBSUYsVUFBVTtnQkFDeEI7Z0JBQ0FDLGlCQUFpQjtnQkFDakIsZUFBZTtnQkFDZixLQUFLLE1BQU1FLFFBQVFWLEtBQU07b0JBQ3JCLElBQUksT0FB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bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2Nqcy9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzPzYyYzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5mZXJlbmNlU2Vzc2lvbiA9IHZvaWQgMDtcbmNvbnN0IGJhY2tlbmRfaW1wbF9qc18xID0gcmVxdWlyZShcIi4vYmFja2VuZC1pbXBsLmpzXCIpO1xuY29uc3QgdGVuc29yX2pzXzEgPSByZXF1aXJlKFwiLi90ZW5zb3IuanNcIik7XG5jbGFzcyBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIGFzeW5jIHJ1bihmZWVkcywgYXJnMSwgYXJnMikge1xuICAgICAgICBjb25zdCBmZXRjaGVzID0ge307XG4gICAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICAgIC8vIGNoZWNrIGlucHV0c1xuICAgICAgICBpZiAodHlwZW9mIGZlZWRzICE9PSAnb2JqZWN0JyB8fCBmZWVkcyA9PT0gbnVsbCB8fCBmZWVkcyBpbnN0YW5jZW9mIHRlbnNvcl9qc18xLlRlbnNvciB8fCBBcnJheS5pc0FycmF5KGZlZWRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnZmVlZHNcXCcgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChhcmcxID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIHRlbnNvcl9qc18xLlRlbnNvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgY2Fubm90IGJlIGEgVGVuc29yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmcxLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBvdXRwdXQgbmFtZXNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVjaWRlIHdoZXRoZXIgYXJnMSBpcyBmZXRjaGVzIG9yIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAvLyBpZiBhbnkgb3V0cHV0IG5hbWUgaXMgcHJlc2VudCBhbmQgaXRzIHZhbHVlIGlzIHZhbGlkIE9ubnhWYWx1ZSwgd2UgY29uc2lkZXIgaXQgZmV0Y2hlc1xuICAgICAgICAgICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcxS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyZzEpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcxS2V5cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IGFyZzFbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgdGVuc29yX2pzXzEuVGVuc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGZXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgXFwnZmV0Y2hlc1xcJyBvciBcXCdvcHRpb25zXFwnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIGFsbCBpbnB1dHMgYXJlIGluIGZlZWRcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuaW5wdXROYW1lcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke25hbWV9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm8gZmV0Y2hlcyBpcyBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgZnVsbCBvdXRwdXQgbmFtZXMgbGlzdFxuICAgICAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmVlZHMsIGZldGNoZXMgYW5kIG9wdGlvbnMgYXJlIHByZXBhcmVkXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gbmV3IHRlbnNvcl9qc18xLlRlbnNvcihyZXN1bHRzW2tleV0udHlwZSwgcmVzdWx0c1trZXldLmRhdGEsIHJlc3VsdHNba2V5XS5kaW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIGFzeW5jIHJlbGVhc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgLy8gZWl0aGVyIGxvYWQgZnJvbSBhIGZpbGUgb3IgYnVmZmVyXG4gICAgICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBhcmcwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0JyAmJiBhcmcxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhcmcwO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVPZmZzZXRcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYnl0ZU9mZnNldCA+PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtidWZmZXIuYnl0ZUxlbmd0aH0pLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVMZW5ndGggPSBhcmcyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdvYmplY3QnICYmIGFyZzMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlIFxcJ3BhdGhcXCcgb3IgXFwnYnVmZmVyXFwnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBiYWNrZW5kIGhpbnRzXG4gICAgICAgIGNvbnN0IGVwcyA9IG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzIHx8IFtdO1xuICAgICAgICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSk7XG4gICAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCAoMCwgYmFja2VuZF9pbXBsX2pzXzEucmVzb2x2ZUJhY2tlbmQpKGJhY2tlbmRIaW50cyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZVNlc3Npb25IYW5kbGVyKGZpbGVQYXRoT3JVaW50OEFycmF5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmZlcmVuY2VTZXNzaW9uKGhhbmRsZXIpO1xuICAgIH1cbiAgICBzdGFydFByb2ZpbGluZygpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyLnN0YXJ0UHJvZmlsaW5nKCk7XG4gICAgfVxuICAgIGVuZFByb2ZpbGluZygpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpO1xuICAgIH1cbiAgICBnZXQgaW5wdXROYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzO1xuICAgIH1cbiAgICBnZXQgb3V0cHV0TmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXM7XG4gICAgfVxufVxuZXhwb3J0cy5JbmZlcmVuY2VTZXNzaW9uID0gSW5mZXJlbmNlU2Vzc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmVyZW5jZS1zZXNzaW9uLWltcGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW5mZXJlbmNlU2Vzc2lvbiIsImJhY2tlbmRfaW1wbF9qc18xIiwicmVxdWlyZSIsInRlbnNvcl9qc18xIiwiY29uc3RydWN0b3IiLCJoYW5kbGVyIiwicnVuIiwiZmVlZHMiLCJhcmcxIiwiYXJnMiIsImZldGNoZXMiLCJvcHRpb25zIiwiVGVuc29yIiwiQXJyYXkiLCJpc0FycmF5IiwiVHlwZUVycm9yIiwiaXNGZXRjaGVzRW1wdHkiLCJsZW5ndGgiLCJuYW1lIiwib3V0cHV0TmFtZXMiLCJpbmRleE9mIiwiUmFuZ2VFcnJvciIsImlzRmV0Y2hlcyIsImFyZzFLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInYiLCJpbnB1dE5hbWVzIiwiRXJyb3IiLCJyZXN1bHRzIiwicmV0dXJuVmFsdWUiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ0eXBlIiwiZGF0YSIsImRpbXMiLCJyZWxlYXNlIiwiZGlzcG9zZSIsImNyZWF0ZSIsImFyZzAiLCJhcmczIiwiZmlsZVBhdGhPclVpbnQ4QXJyYXkiLCJVaW50OEFycmF5IiwiQXJyYXlCdWZmZXIiLCJTaGFyZWRBcnJheUJ1ZmZlciIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsImVwcyIsImV4ZWN1dGlvblByb3ZpZGVycyIsImJhY2tlbmRIaW50cyIsIm1hcCIsImkiLCJiYWNrZW5kIiwicmVzb2x2ZUJhY2tlbmQiLCJjcmVhdGVTZXNzaW9uSGFuZGxlciIsInN0YXJ0UHJvZmlsaW5nIiwiZW5kUHJvZmlsaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/inference-session-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/inference-session.js":
/*!***********************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/inference-session.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InferenceSession = void 0;\nconst inference_session_impl_js_1 = __webpack_require__(/*! ./inference-session-impl.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/inference-session-impl.js\");\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexports.InferenceSession = inference_session_impl_js_1.InferenceSession; //# sourceMappingURL=inference-session.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2luZmVyZW5jZS1zZXNzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNERBQTREO0FBQzVELGtDQUFrQztBQUNsQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHLEtBQUs7QUFDaEMsTUFBTUcsOEJBQThCQyxtQkFBT0EsQ0FBQywrR0FBNkI7QUFDekUsZ0VBQWdFO0FBQ2hFSix3QkFBd0IsR0FBR0csNEJBQTRCRCxnQkFBZ0IsRUFDdkUsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL2luZmVyZW5jZS1zZXNzaW9uLmpzP2NhYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5mZXJlbmNlU2Vzc2lvbiA9IHZvaWQgMDtcbmNvbnN0IGluZmVyZW5jZV9zZXNzaW9uX2ltcGxfanNfMSA9IHJlcXVpcmUoXCIuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnRzLkluZmVyZW5jZVNlc3Npb24gPSBpbmZlcmVuY2Vfc2Vzc2lvbl9pbXBsX2pzXzEuSW5mZXJlbmNlU2Vzc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmVyZW5jZS1zZXNzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkluZmVyZW5jZVNlc3Npb24iLCJpbmZlcmVuY2Vfc2Vzc2lvbl9pbXBsX2pzXzEiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/inference-session.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/onnx-value.js":
/*!****************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/onnx-value.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n})); //# sourceMappingURL=onnx-value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL29ubngtdmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQyxFQUM3RCxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9janMvb25ueC12YWx1ZS5qcz9lODMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbm54LXZhbHVlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/onnx-value.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-conversion-impl.js":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/tensor-conversion-impl.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.tensorToImageData = exports.tensorToDataURL = void 0;\n/**\n * implementation of Tensor.toDataURL()\n */ const tensorToDataURL = (tensor, options)=>{\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = tensor.dims[3];\n    canvas.height = tensor.dims[2];\n    const pixels2DContext = canvas.getContext(\"2d\");\n    if (pixels2DContext != null) {\n        // Default values for height and width & format\n        let width;\n        let height;\n        if (options?.tensorLayout !== undefined && options.tensorLayout === \"NHWC\") {\n            width = tensor.dims[2];\n            height = tensor.dims[3];\n        } else {\n            width = tensor.dims[3];\n            height = tensor.dims[2];\n        }\n        const inputformat = options?.format !== undefined ? options.format : \"RGB\";\n        const norm = options?.norm;\n        let normMean;\n        let normBias;\n        if (norm === undefined || norm.mean === undefined) {\n            normMean = [\n                255,\n                255,\n                255,\n                255\n            ];\n        } else {\n            if (typeof norm.mean === \"number\") {\n                normMean = [\n                    norm.mean,\n                    norm.mean,\n                    norm.mean,\n                    norm.mean\n                ];\n            } else {\n                normMean = [\n                    norm.mean[0],\n                    norm.mean[1],\n                    norm.mean[2],\n                    0\n                ];\n                if (norm.mean[3] !== undefined) {\n                    normMean[3] = norm.mean[3];\n                }\n            }\n        }\n        if (norm === undefined || norm.bias === undefined) {\n            normBias = [\n                0,\n                0,\n                0,\n                0\n            ];\n        } else {\n            if (typeof norm.bias === \"number\") {\n                normBias = [\n                    norm.bias,\n                    norm.bias,\n                    norm.bias,\n                    norm.bias\n                ];\n            } else {\n                normBias = [\n                    norm.bias[0],\n                    norm.bias[1],\n                    norm.bias[2],\n                    0\n                ];\n                if (norm.bias[3] !== undefined) {\n                    normBias[3] = norm.bias[3];\n                }\n            }\n        }\n        const stride = height * width;\n        // Default pointer assignments\n        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n        // Updating the pointer assignments based on the input image format\n        if (inputformat === \"RGBA\") {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n            aTensorPointer = stride * 3;\n        } else if (inputformat === \"RGB\") {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n        } else if (inputformat === \"RBG\") {\n            rTensorPointer = 0;\n            bTensorPointer = stride;\n            gTensorPointer = stride * 2;\n        }\n        for(let i = 0; i < height; i++){\n            for(let j = 0; j < width; j++){\n                const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value\n                const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value\n                const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value\n                const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value\n                // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                pixels2DContext.fillStyle = \"rgba(\" + R + \",\" + G + \",\" + B + \",\" + A + \")\";\n                pixels2DContext.fillRect(j, i, 1, 1);\n            }\n        }\n        return canvas.toDataURL();\n    } else {\n        throw new Error(\"Can not access image data\");\n    }\n};\nexports.tensorToDataURL = tensorToDataURL;\n/**\n * implementation of Tensor.toImageData()\n */ const tensorToImageData = (tensor, options)=>{\n    const pixels2DContext = document.createElement(\"canvas\").getContext(\"2d\");\n    let image;\n    if (pixels2DContext != null) {\n        // Default values for height and width & format\n        let width;\n        let height;\n        let channels;\n        if (options?.tensorLayout !== undefined && options.tensorLayout === \"NHWC\") {\n            width = tensor.dims[2];\n            height = tensor.dims[1];\n            channels = tensor.dims[3];\n        } else {\n            width = tensor.dims[3];\n            height = tensor.dims[2];\n            channels = tensor.dims[1];\n        }\n        const inputformat = options !== undefined ? options.format !== undefined ? options.format : \"RGB\" : \"RGB\";\n        const norm = options?.norm;\n        let normMean;\n        let normBias;\n        if (norm === undefined || norm.mean === undefined) {\n            normMean = [\n                255,\n                255,\n                255,\n                255\n            ];\n        } else {\n            if (typeof norm.mean === \"number\") {\n                normMean = [\n                    norm.mean,\n                    norm.mean,\n                    norm.mean,\n                    norm.mean\n                ];\n            } else {\n                normMean = [\n                    norm.mean[0],\n                    norm.mean[1],\n                    norm.mean[2],\n                    255\n                ];\n                if (norm.mean[3] !== undefined) {\n                    normMean[3] = norm.mean[3];\n                }\n            }\n        }\n        if (norm === undefined || norm.bias === undefined) {\n            normBias = [\n                0,\n                0,\n                0,\n                0\n            ];\n        } else {\n            if (typeof norm.bias === \"number\") {\n                normBias = [\n                    norm.bias,\n                    norm.bias,\n                    norm.bias,\n                    norm.bias\n                ];\n            } else {\n                normBias = [\n                    norm.bias[0],\n                    norm.bias[1],\n                    norm.bias[2],\n                    0\n                ];\n                if (norm.bias[3] !== undefined) {\n                    normBias[3] = norm.bias[3];\n                }\n            }\n        }\n        const stride = height * width;\n        if (options !== undefined) {\n            if (options.format !== undefined && channels === 4 && options.format !== \"RGBA\" || channels === 3 && options.format !== \"RGB\" && options.format !== \"BGR\") {\n                throw new Error(\"Tensor format doesn't match input tensor dims\");\n            }\n        }\n        // Default pointer assignments\n        const step = 4;\n        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n        // Updating the pointer assignments based on the input image format\n        if (inputformat === \"RGBA\") {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n            aTensorPointer = stride * 3;\n        } else if (inputformat === \"RGB\") {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n        } else if (inputformat === \"RBG\") {\n            rTensorPointer = 0;\n            bTensorPointer = stride;\n            gTensorPointer = stride * 2;\n        }\n        image = pixels2DContext.createImageData(width, height);\n        for(let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++){\n            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value\n            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value\n            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value\n            image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value\n        }\n    } else {\n        throw new Error(\"Can not access image data\");\n    }\n    return image;\n};\nexports.tensorToImageData = tensorToImageData; //# sourceMappingURL=tensor-conversion-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL3RlbnNvci1jb252ZXJzaW9uLWltcGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDM0Q7O0NBRUMsR0FDRCxNQUFNRyxrQkFBa0IsQ0FBQ0MsUUFBUUM7SUFDN0IsTUFBTUMsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO0lBQ3RDRixPQUFPRyxLQUFLLEdBQUdMLE9BQU9NLElBQUksQ0FBQyxFQUFFO0lBQzdCSixPQUFPSyxNQUFNLEdBQUdQLE9BQU9NLElBQUksQ0FBQyxFQUFFO0lBQzlCLE1BQU1FLGtCQUFrQk4sT0FBT08sVUFBVSxDQUFDO0lBQzFDLElBQUlELG1CQUFtQixNQUFNO1FBQ3pCLCtDQUErQztRQUMvQyxJQUFJSDtRQUNKLElBQUlFO1FBQ0osSUFBSU4sU0FBU1MsaUJBQWlCQyxhQUFhVixRQUFRUyxZQUFZLEtBQUssUUFBUTtZQUN4RUwsUUFBUUwsT0FBT00sSUFBSSxDQUFDLEVBQUU7WUFDdEJDLFNBQVNQLE9BQU9NLElBQUksQ0FBQyxFQUFFO1FBQzNCLE9BQ0s7WUFDREQsUUFBUUwsT0FBT00sSUFBSSxDQUFDLEVBQUU7WUFDdEJDLFNBQVNQLE9BQU9NLElBQUksQ0FBQyxFQUFFO1FBQzNCO1FBQ0EsTUFBTU0sY0FBY1gsU0FBU1ksV0FBV0YsWUFBWVYsUUFBUVksTUFBTSxHQUFHO1FBQ3JFLE1BQU1DLE9BQU9iLFNBQVNhO1FBQ3RCLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJRixTQUFTSCxhQUFhRyxLQUFLRyxJQUFJLEtBQUtOLFdBQVc7WUFDL0NJLFdBQVc7Z0JBQUM7Z0JBQUs7Z0JBQUs7Z0JBQUs7YUFBSTtRQUNuQyxPQUNLO1lBQ0QsSUFBSSxPQUFRRCxLQUFLRyxJQUFJLEtBQU0sVUFBVTtnQkFDakNGLFdBQVc7b0JBQUNELEtBQUtHLElBQUk7b0JBQUVILEtBQUtHLElBQUk7b0JBQUVILEtBQUtHLElBQUk7b0JBQUVILEtBQUtHLElBQUk7aUJBQUM7WUFDM0QsT0FDSztnQkFDREYsV0FBVztvQkFBQ0QsS0FBS0csSUFBSSxDQUFDLEVBQUU7b0JBQUVILEtBQUtHLElBQUksQ0FBQyxFQUFFO29CQUFFSCxLQUFLRyxJQUFJLENBQUMsRUFBRTtvQkFBRTtpQkFBRTtnQkFDeEQsSUFBSUgsS0FBS0csSUFBSSxDQUFDLEVBQUUsS0FBS04sV0FBVztvQkFDNUJJLFFBQVEsQ0FBQyxFQUFFLEdBQUdELEtBQUtHLElBQUksQ0FBQyxFQUFFO2dCQUM5QjtZQUNKO1FBQ0o7UUFDQSxJQUFJSCxTQUFTSCxhQUFhRyxLQUFLSSxJQUFJLEtBQUtQLFdBQVc7WUFDL0NLLFdBQVc7Z0JBQUM7Z0JBQUc7Z0JBQUc7Z0JBQUc7YUFBRTtRQUMzQixPQUNLO1lBQ0QsSUFBSSxPQUFRRixLQUFLSSxJQUFJLEtBQU0sVUFBVTtnQkFDakNGLFdBQVc7b0JBQUNGLEtBQUtJLElBQUk7b0JBQUVKLEtBQUtJLElBQUk7b0JBQUVKLEtBQUtJLElBQUk7b0JBQUVKLEtBQUtJLElBQUk7aUJBQUM7WUFDM0QsT0FDSztnQkFDREYsV0FBVztvQkFBQ0YsS0FBS0ksSUFBSSxDQUFDLEVBQUU7b0JBQUVKLEtBQUtJLElBQUksQ0FBQyxFQUFFO29CQUFFSixLQUFLSSxJQUFJLENBQUMsRUFBRTtvQkFBRTtpQkFBRTtnQkFDeEQsSUFBSUosS0FBS0ksSUFBSSxDQUFDLEVBQUUsS0FBS1AsV0FBVztvQkFDNUJLLFFBQVEsQ0FBQyxFQUFFLEdBQUdGLEtBQUtJLElBQUksQ0FBQyxFQUFFO2dCQUM5QjtZQUNKO1FBQ0o7UUFDQSxNQUFNQyxTQUFTWixTQUFTRjtRQUN4Qiw4QkFBOEI7UUFDOUIsSUFBSWUsaUJBQWlCLEdBQUdDLGlCQUFpQkYsUUFBUUcsaUJBQWlCSCxTQUFTLEdBQUdJLGlCQUFpQixDQUFDO1FBQ2hHLG1FQUFtRTtRQUNuRSxJQUFJWCxnQkFBZ0IsUUFBUTtZQUN4QlEsaUJBQWlCO1lBQ2pCQyxpQkFBaUJGO1lBQ2pCRyxpQkFBaUJILFNBQVM7WUFDMUJJLGlCQUFpQkosU0FBUztRQUM5QixPQUNLLElBQUlQLGdCQUFnQixPQUFPO1lBQzVCUSxpQkFBaUI7WUFDakJDLGlCQUFpQkY7WUFDakJHLGlCQUFpQkgsU0FBUztRQUM5QixPQUNLLElBQUlQLGdCQUFnQixPQUFPO1lBQzVCUSxpQkFBaUI7WUFDakJFLGlCQUFpQkg7WUFDakJFLGlCQUFpQkYsU0FBUztRQUM5QjtRQUNBLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJakIsUUFBUWlCLElBQUs7WUFDN0IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlwQixPQUFPb0IsSUFBSztnQkFDNUIsTUFBTUMsSUFBSSxDQUFDMUIsT0FBTzJCLElBQUksQ0FBQ1AsaUJBQWlCLEdBQUdKLFFBQVEsQ0FBQyxFQUFFLElBQUlELFFBQVEsQ0FBQyxFQUFFLEVBQUUsVUFBVTtnQkFDakYsTUFBTWEsSUFBSSxDQUFDNUIsT0FBTzJCLElBQUksQ0FBQ04saUJBQWlCLEdBQUdMLFFBQVEsQ0FBQyxFQUFFLElBQUlELFFBQVEsQ0FBQyxFQUFFLEVBQUUsVUFBVTtnQkFDakYsTUFBTWMsSUFBSSxDQUFDN0IsT0FBTzJCLElBQUksQ0FBQ0wsaUJBQWlCLEdBQUdOLFFBQVEsQ0FBQyxFQUFFLElBQUlELFFBQVEsQ0FBQyxFQUFFLEVBQUUsVUFBVTtnQkFDakYsTUFBTWUsSUFBSVAsbUJBQW1CLENBQUMsSUFDMUIsTUFDQSxDQUFDdkIsT0FBTzJCLElBQUksQ0FBQ0osaUJBQWlCLEdBQUdQLFFBQVEsQ0FBQyxFQUFFLElBQUlELFFBQVEsQ0FBQyxFQUFFLEVBQUUsVUFBVTtnQkFDM0UscUVBQXFFO2dCQUNyRVAsZ0JBQWdCdUIsU0FBUyxHQUFHLFVBQVVMLElBQUksTUFBTUUsSUFBSSxNQUFNQyxJQUFJLE1BQU1DLElBQUk7Z0JBQ3hFdEIsZ0JBQWdCd0IsUUFBUSxDQUFDUCxHQUFHRCxHQUFHLEdBQUc7WUFDdEM7UUFDSjtRQUNBLE9BQU90QixPQUFPK0IsU0FBUztJQUMzQixPQUNLO1FBQ0QsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0FBQ0o7QUFDQXRDLHVCQUF1QixHQUFHRztBQUMxQjs7Q0FFQyxHQUNELE1BQU1ELG9CQUFvQixDQUFDRSxRQUFRQztJQUMvQixNQUFNTyxrQkFBa0JMLFNBQVNDLGFBQWEsQ0FBQyxVQUFVSyxVQUFVLENBQUM7SUFDcEUsSUFBSTBCO0lBQ0osSUFBSTNCLG1CQUFtQixNQUFNO1FBQ3pCLCtDQUErQztRQUMvQyxJQUFJSDtRQUNKLElBQUlFO1FBQ0osSUFBSTZCO1FBQ0osSUFBSW5DLFNBQVNTLGlCQUFpQkMsYUFBYVYsUUFBUVMsWUFBWSxLQUFLLFFBQVE7WUFDeEVMLFFBQVFMLE9BQU9NLElBQUksQ0FBQyxFQUFFO1lBQ3RCQyxTQUFTUCxPQUFPTSxJQUFJLENBQUMsRUFBRTtZQUN2QjhCLFdBQVdwQyxPQUFPTSxJQUFJLENBQUMsRUFBRTtRQUM3QixPQUNLO1lBQ0RELFFBQVFMLE9BQU9NLElBQUksQ0FBQyxFQUFFO1lBQ3RCQyxTQUFTUCxPQUFPTSxJQUFJLENBQUMsRUFBRTtZQUN2QjhCLFdBQVdwQyxPQUFPTSxJQUFJLENBQUMsRUFBRTtRQUM3QjtRQUNBLE1BQU1NLGNBQWNYLFlBQVlVLFlBQWFWLFFBQVFZLE1BQU0sS0FBS0YsWUFBWVYsUUFBUVksTUFBTSxHQUFHLFFBQVM7UUFDdEcsTUFBTUMsT0FBT2IsU0FBU2E7UUFDdEIsSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlGLFNBQVNILGFBQWFHLEtBQUtHLElBQUksS0FBS04sV0FBVztZQUMvQ0ksV0FBVztnQkFBQztnQkFBSztnQkFBSztnQkFBSzthQUFJO1FBQ25DLE9BQ0s7WUFDRCxJQUFJLE9BQVFELEtBQUtHLElBQUksS0FBTSxVQUFVO2dCQUNqQ0YsV0FBVztvQkFBQ0QsS0FBS0csSUFBSTtvQkFBRUgsS0FBS0csSUFBSTtvQkFBRUgsS0FBS0csSUFBSTtvQkFBRUgsS0FBS0csSUFBSTtpQkFBQztZQUMzRCxPQUNLO2dCQUNERixXQUFXO29CQUFDRCxLQUFLRyxJQUFJLENBQUMsRUFBRTtvQkFBRUgsS0FBS0csSUFBSSxDQUFDLEVBQUU7b0JBQUVILEtBQUtHLElBQUksQ0FBQyxFQUFFO29CQUFFO2lCQUFJO2dCQUMxRCxJQUFJSCxLQUFLRyxJQUFJLENBQUMsRUFBRSxLQUFLTixXQUFXO29CQUM1QkksUUFBUSxDQUFDLEVBQUUsR0FBR0QsS0FBS0csSUFBSSxDQUFDLEVBQUU7Z0JBQzlCO1lBQ0o7UUFDSjtRQUNBLElBQUlILFNBQVNILGFBQWFHLEtBQUtJLElBQUksS0FBS1AsV0FBVztZQUMvQ0ssV0FBVztnQkFBQztnQkFBRztnQkFBRztnQkFBRzthQUFFO1FBQzNCLE9BQ0s7WUFDRCxJQUFJLE9BQVFGLEtBQUtJLElBQUksS0FBTSxVQUFVO2dCQUNqQ0YsV0FBVztvQkFBQ0YsS0FBS0ksSUFBSTtvQkFBRUosS0FBS0ksSUFBSTtvQkFBRUosS0FBS0ksSUFBSTtvQkFBRUosS0FBS0ksSUFBSTtpQkFBQztZQUMzRCxPQUNLO2dCQUNERixXQUFXO29CQUFDRixLQUFLSSxJQUFJLENBQUMsRUFBRTtvQkFBRUosS0FBS0ksSUFBSSxDQUFDLEVBQUU7b0JBQUVKLEtBQUtJLElBQUksQ0FBQyxFQUFFO29CQUFFO2lCQUFFO2dCQUN4RCxJQUFJSixLQUFLSSxJQUFJLENBQUMsRUFBRSxLQUFLUCxXQUFXO29CQUM1QkssUUFBUSxDQUFDLEVBQUUsR0FBR0YsS0FBS0ksSUFBSSxDQUFDLEVBQUU7Z0JBQzlCO1lBQ0o7UUFDSjtRQUNBLE1BQU1DLFNBQVNaLFNBQVNGO1FBQ3hCLElBQUlKLFlBQVlVLFdBQVc7WUFDdkIsSUFBSVYsUUFBUVksTUFBTSxLQUFLRixhQUFjeUIsYUFBYSxLQUFLbkMsUUFBUVksTUFBTSxLQUFLLFVBQ3JFdUIsYUFBYSxLQUFNbkMsUUFBUVksTUFBTSxLQUFLLFNBQVNaLFFBQVFZLE1BQU0sS0FBSyxPQUFTO2dCQUM1RSxNQUFNLElBQUlxQixNQUFNO1lBQ3BCO1FBQ0o7UUFDQSw4QkFBOEI7UUFDOUIsTUFBTUcsT0FBTztRQUNiLElBQUlDLGdCQUFnQixHQUFHQyxnQkFBZ0IsR0FBR0MsZ0JBQWdCLEdBQUdDLGdCQUFnQjtRQUM3RSxJQUFJckIsaUJBQWlCLEdBQUdDLGlCQUFpQkYsUUFBUUcsaUJBQWlCSCxTQUFTLEdBQUdJLGlCQUFpQixDQUFDO1FBQ2hHLG1FQUFtRTtRQUNuRSxJQUFJWCxnQkFBZ0IsUUFBUTtZQUN4QlEsaUJBQWlCO1lBQ2pCQyxpQkFBaUJGO1lBQ2pCRyxpQkFBaUJILFNBQVM7WUFDMUJJLGlCQUFpQkosU0FBUztRQUM5QixPQUNLLElBQUlQLGdCQUFnQixPQUFPO1lBQzVCUSxpQkFBaUI7WUFDakJDLGlCQUFpQkY7WUFDakJHLGlCQUFpQkgsU0FBUztRQUM5QixPQUNLLElBQUlQLGdCQUFnQixPQUFPO1lBQzVCUSxpQkFBaUI7WUFDakJFLGlCQUFpQkg7WUFDakJFLGlCQUFpQkYsU0FBUztRQUM5QjtRQUNBZ0IsUUFBUTNCLGdCQUFnQmtDLGVBQWUsQ0FBQ3JDLE9BQU9FO1FBQy9DLElBQUssSUFBSWlCLElBQUksR0FBR0EsSUFBSWpCLFNBQVNGLE9BQU9pQyxpQkFBaUJELE1BQU1FLGlCQUFpQkYsTUFBTUcsaUJBQWlCSCxNQUFNSSxpQkFBaUJKLE1BQU1iLElBQUs7WUFDaklXLE1BQU1SLElBQUksQ0FBQ1csY0FBYyxHQUFHLENBQUN0QyxPQUFPMkIsSUFBSSxDQUFDUCxpQkFBaUIsR0FBR0osUUFBUSxDQUFDLEVBQUUsSUFBSUQsUUFBUSxDQUFDLEVBQUUsRUFBRSxVQUFVO1lBQ25Hb0IsTUFBTVIsSUFBSSxDQUFDWSxjQUFjLEdBQUcsQ0FBQ3ZDLE9BQU8yQixJQUFJLENBQUNOLGlCQUFpQixHQUFHTCxRQUFRLENBQUMsRUFBRSxJQUFJRCxRQUFRLENBQUMsRUFBRSxFQUFFLFVBQVU7WUFDbkdvQixNQUFNUixJQUFJLENBQUNhLGNBQWMsR0FBRyxDQUFDeEMsT0FBTzJCLElBQUksQ0FBQ0wsaUJBQWlCLEdBQUdOLFFBQVEsQ0FBQyxFQUFFLElBQUlELFFBQVEsQ0FBQyxFQUFFLEVBQUUsVUFBVTtZQUNuR29CLE1BQU1SLElBQUksQ0FBQ2MsY0FBYyxHQUFHbEIsbUJBQW1CLENBQUMsSUFDNUMsTUFDQSxDQUFDdkIsT0FBTzJCLElBQUksQ0FBQ0osaUJBQWlCLEdBQUdQLFFBQVEsQ0FBQyxFQUFFLElBQUlELFFBQVEsQ0FBQyxFQUFFLEVBQUUsVUFBVTtRQUMvRTtJQUNKLE9BQ0s7UUFDRCxNQUFNLElBQUltQixNQUFNO0lBQ3BCO0lBQ0EsT0FBT0M7QUFDWDtBQUNBdkMseUJBQXlCLEdBQUdFLG1CQUM1QixrREFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9janMvdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcz81ZTg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRlbnNvclRvSW1hZ2VEYXRhID0gZXhwb3J0cy50ZW5zb3JUb0RhdGFVUkwgPSB2b2lkIDA7XG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0RhdGFVUkwoKVxuICovXG5jb25zdCB0ZW5zb3JUb0RhdGFVUkwgPSAodGVuc29yLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gdGVuc29yLmRpbXNbM107XG4gICAgY2FudmFzLmhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgICAgICBsZXQgd2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbM107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIERlZmF1bHQgbGF5b3V0IGlzIE5DV0hcbiAgICAgICAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbM107XG4gICAgICAgICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJztcbiAgICAgICAgY29uc3Qgbm9ybSA9IG9wdGlvbnM/Lm5vcm07XG4gICAgICAgIGxldCBub3JtTWVhbjtcbiAgICAgICAgbGV0IG5vcm1CaWFzO1xuICAgICAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAobm9ybS5tZWFuKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuWzBdLCBub3JtLm1lYW5bMV0sIG5vcm0ubWVhblsyXSwgMF07XG4gICAgICAgICAgICAgICAgaWYgKG5vcm0ubWVhblszXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1NZWFuWzNdID0gbm9ybS5tZWFuWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBub3JtQmlhcyA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5vcm0uYmlhcykgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhc1swXSwgbm9ybS5iaWFzWzFdLCBub3JtLmJpYXNbMl0sIDBdO1xuICAgICAgICAgICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtQmlhc1szXSA9IG5vcm0uYmlhc1szXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgICAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLCBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSwgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLCBhVGVuc29yUG9pbnRlciA9IC0xO1xuICAgICAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gICAgICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgICAgICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgUiA9ICh0ZW5zb3IuZGF0YVtyVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgRyA9ICh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgQiA9ICh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAvLyBCIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/XG4gICAgICAgICAgICAgICAgICAgIDI1NSA6XG4gICAgICAgICAgICAgICAgICAgICh0ZW5zb3IuZGF0YVthVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXG4gICAgICAgICAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBSICsgJywnICsgRyArICcsJyArIEIgKyAnLCcgKyBBICsgJyknO1xuICAgICAgICAgICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxufTtcbmV4cG9ydHMudGVuc29yVG9EYXRhVVJMID0gdGVuc29yVG9EYXRhVVJMO1xuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9JbWFnZURhdGEoKVxuICovXG5jb25zdCB0ZW5zb3JUb0ltYWdlRGF0YSA9ICh0ZW5zb3IsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGxldCBpbWFnZTtcbiAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZXMgZm9yIGhlaWdodCBhbmQgd2lkdGggJiBmb3JtYXRcbiAgICAgICAgbGV0IHdpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0O1xuICAgICAgICBsZXQgY2hhbm5lbHM7XG4gICAgICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMV07XG4gICAgICAgICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICAgICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgICAgICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InKSA6ICdSR0InO1xuICAgICAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICAgICAgbGV0IG5vcm1NZWFuO1xuICAgICAgICBsZXQgbm9ybUJpYXM7XG4gICAgICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5tZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1NZWFuID0gWzI1NSwgMjU1LCAyNTUsIDI1NV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChub3JtLm1lYW4pID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAyNTVdO1xuICAgICAgICAgICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtTWVhblszXSA9IG5vcm0ubWVhblszXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybUJpYXMgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChub3JtLmJpYXMpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybS5iaWFzWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCAmJiAoY2hhbm5lbHMgPT09IDQgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0JBJykgfHxcbiAgICAgICAgICAgICAgICAoY2hhbm5lbHMgPT09IDMgJiYgKG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCJyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ0JHUicpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGVuc29yIGZvcm1hdCBkb2VzblxcJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICAgICAgY29uc3Qgc3RlcCA9IDQ7XG4gICAgICAgIGxldCBySW1hZ2VQb2ludGVyID0gMCwgZ0ltYWdlUG9pbnRlciA9IDEsIGJJbWFnZVBvaW50ZXIgPSAyLCBhSW1hZ2VQb2ludGVyID0gMztcbiAgICAgICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcbiAgICAgICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgICAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICAgICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICAgICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlID0gcGl4ZWxzMkRDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQgKiB3aWR0aDsgckltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwLCBpKyspIHtcbiAgICAgICAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgLy8gUiB2YWx1ZVxuICAgICAgICAgICAgaW1hZ2UuZGF0YVtnSW1hZ2VQb2ludGVyXSA9ICh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXG4gICAgICAgICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKHRlbnNvci5kYXRhW2JUZW5zb3JQb2ludGVyKytdIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgICAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPSBhVGVuc29yUG9pbnRlciA9PT0gLTEgP1xuICAgICAgICAgICAgICAgIDI1NSA6XG4gICAgICAgICAgICAgICAgKHRlbnNvci5kYXRhW2FUZW5zb3JQb2ludGVyKytdIC0gbm9ybUJpYXNbM10pICogbm9ybU1lYW5bM107IC8vIEEgdmFsdWVcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbn07XG5leHBvcnRzLnRlbnNvclRvSW1hZ2VEYXRhID0gdGVuc29yVG9JbWFnZURhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW5zb3ItY29udmVyc2lvbi1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRlbnNvclRvSW1hZ2VEYXRhIiwidGVuc29yVG9EYXRhVVJMIiwidGVuc29yIiwib3B0aW9ucyIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpZHRoIiwiZGltcyIsImhlaWdodCIsInBpeGVsczJEQ29udGV4dCIsImdldENvbnRleHQiLCJ0ZW5zb3JMYXlvdXQiLCJ1bmRlZmluZWQiLCJpbnB1dGZvcm1hdCIsImZvcm1hdCIsIm5vcm0iLCJub3JtTWVhbiIsIm5vcm1CaWFzIiwibWVhbiIsImJpYXMiLCJzdHJpZGUiLCJyVGVuc29yUG9pbnRlciIsImdUZW5zb3JQb2ludGVyIiwiYlRlbnNvclBvaW50ZXIiLCJhVGVuc29yUG9pbnRlciIsImkiLCJqIiwiUiIsImRhdGEiLCJHIiwiQiIsIkEiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRvRGF0YVVSTCIsIkVycm9yIiwiaW1hZ2UiLCJjaGFubmVscyIsInN0ZXAiLCJySW1hZ2VQb2ludGVyIiwiZ0ltYWdlUG9pbnRlciIsImJJbWFnZVBvaW50ZXIiLCJhSW1hZ2VQb2ludGVyIiwiY3JlYXRlSW1hZ2VEYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-conversion-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-factory-impl.js":
/*!*************************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/tensor-factory-impl.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.tensorFromImage = exports.bufferToTensor = void 0;\nconst tensor_js_1 = __webpack_require__(/*! ./tensor.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor.js\");\n/**\n * Create a new tensor object from image object\n *\n * @param buffer - Extracted image buffer data - assuming RGBA format\n * @param imageFormat - input image configuration - required configurations height, width, format\n * @param tensorFormat - output tensor configuration - Default is RGB format\n */ const bufferToTensor = (buffer, options)=>{\n    if (buffer === undefined) {\n        throw new Error(\"Image buffer must be defined\");\n    }\n    if (options.height === undefined || options.width === undefined) {\n        throw new Error(\"Image height and width must be defined\");\n    }\n    if (options.tensorLayout === \"NHWC\") {\n        throw new Error(\"NHWC Tensor layout is not supported yet\");\n    }\n    const { height, width } = options;\n    const norm = options.norm ?? {\n        mean: 255,\n        bias: 0\n    };\n    let normMean;\n    let normBias;\n    if (typeof norm.mean === \"number\") {\n        normMean = [\n            norm.mean,\n            norm.mean,\n            norm.mean,\n            norm.mean\n        ];\n    } else {\n        normMean = [\n            norm.mean[0],\n            norm.mean[1],\n            norm.mean[2],\n            norm.mean[3] ?? 255\n        ];\n    }\n    if (typeof norm.bias === \"number\") {\n        normBias = [\n            norm.bias,\n            norm.bias,\n            norm.bias,\n            norm.bias\n        ];\n    } else {\n        normBias = [\n            norm.bias[0],\n            norm.bias[1],\n            norm.bias[2],\n            norm.bias[3] ?? 0\n        ];\n    }\n    const inputformat = options.format !== undefined ? options.format : \"RGBA\";\n    // default value is RGBA since imagedata and HTMLImageElement uses it\n    const outputformat = options.tensorFormat !== undefined ? options.tensorFormat !== undefined ? options.tensorFormat : \"RGB\" : \"RGB\";\n    const stride = height * width;\n    const float32Data = outputformat === \"RGBA\" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);\n    // Default pointer assignments\n    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n    let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === \"RGB\") {\n        step = 3;\n        rImagePointer = 0;\n        gImagePointer = 1;\n        bImagePointer = 2;\n        aImagePointer = -1;\n    }\n    // Updating the pointer assignments based on the output tensor format\n    if (outputformat === \"RGBA\") {\n        aTensorPointer = stride * 3;\n    } else if (outputformat === \"RBG\") {\n        rTensorPointer = 0;\n        bTensorPointer = stride;\n        gTensorPointer = stride * 2;\n    } else if (outputformat === \"BGR\") {\n        bTensorPointer = 0;\n        gTensorPointer = stride;\n        rTensorPointer = stride * 2;\n    }\n    for(let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step){\n        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];\n        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];\n        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];\n        if (aTensorPointer !== -1 && aImagePointer !== -1) {\n            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];\n        }\n    }\n    // Float32Array -> ort.Tensor\n    const outputTensor = outputformat === \"RGBA\" ? new tensor_js_1.Tensor(\"float32\", float32Data, [\n        1,\n        4,\n        height,\n        width\n    ]) : new tensor_js_1.Tensor(\"float32\", float32Data, [\n        1,\n        3,\n        height,\n        width\n    ]);\n    return outputTensor;\n};\nexports.bufferToTensor = bufferToTensor;\n/**\n * implementation of Tensor.fromImage().\n */ const tensorFromImage = async (image, options)=>{\n    // checking the type of image object\n    const isHTMLImageEle = typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement;\n    const isImageDataEle = typeof ImageData !== \"undefined\" && image instanceof ImageData;\n    const isImageBitmap = typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap;\n    const isString = typeof image === \"string\";\n    let data;\n    let bufferToTensorOptions = options ?? {};\n    // filling and checking image configuration options\n    if (isHTMLImageEle) {\n        // HTMLImageElement - image object - format is RGBA by default\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const pixels2DContext = canvas.getContext(\"2d\");\n        if (pixels2DContext != null) {\n            let height = image.height;\n            let width = image.width;\n            if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n                height = options.resizedHeight;\n                width = options.resizedWidth;\n            }\n            if (options !== undefined) {\n                bufferToTensorOptions = options;\n                if (options.tensorFormat !== undefined) {\n                    throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");\n                } else {\n                    bufferToTensorOptions.tensorFormat = \"RGBA\";\n                }\n                bufferToTensorOptions.height = height;\n                bufferToTensorOptions.width = width;\n            } else {\n                bufferToTensorOptions.tensorFormat = \"RGBA\";\n                bufferToTensorOptions.height = height;\n                bufferToTensorOptions.width = width;\n            }\n            pixels2DContext.drawImage(image, 0, 0);\n            data = pixels2DContext.getImageData(0, 0, width, height).data;\n        } else {\n            throw new Error(\"Can not access image data\");\n        }\n    } else if (isImageDataEle) {\n        let height;\n        let width;\n        if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n            height = options.resizedHeight;\n            width = options.resizedWidth;\n        } else {\n            height = image.height;\n            width = image.width;\n        }\n        if (options !== undefined) {\n            bufferToTensorOptions = options;\n        }\n        bufferToTensorOptions.format = \"RGBA\";\n        bufferToTensorOptions.height = height;\n        bufferToTensorOptions.width = width;\n        if (options !== undefined) {\n            const tempCanvas = document.createElement(\"canvas\");\n            tempCanvas.width = width;\n            tempCanvas.height = height;\n            const pixels2DContext = tempCanvas.getContext(\"2d\");\n            if (pixels2DContext != null) {\n                pixels2DContext.putImageData(image, 0, 0);\n                data = pixels2DContext.getImageData(0, 0, width, height).data;\n            } else {\n                throw new Error(\"Can not access image data\");\n            }\n        } else {\n            data = image.data;\n        }\n    } else if (isImageBitmap) {\n        // ImageBitmap - image object - format must be provided by user\n        if (options === undefined) {\n            throw new Error(\"Please provide image config with format for Imagebitmap\");\n        }\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const pixels2DContext = canvas.getContext(\"2d\");\n        if (pixels2DContext != null) {\n            const height = image.height;\n            const width = image.width;\n            pixels2DContext.drawImage(image, 0, 0, width, height);\n            data = pixels2DContext.getImageData(0, 0, width, height).data;\n            bufferToTensorOptions.height = height;\n            bufferToTensorOptions.width = width;\n            return (0, exports.bufferToTensor)(data, bufferToTensorOptions);\n        } else {\n            throw new Error(\"Can not access image data\");\n        }\n    } else if (isString) {\n        return new Promise((resolve, reject)=>{\n            const canvas = document.createElement(\"canvas\");\n            const context = canvas.getContext(\"2d\");\n            if (!image || !context) {\n                return reject();\n            }\n            const newImage = new Image();\n            newImage.crossOrigin = \"Anonymous\";\n            newImage.src = image;\n            newImage.onload = ()=>{\n                canvas.width = newImage.width;\n                canvas.height = newImage.height;\n                context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n                const img = context.getImageData(0, 0, canvas.width, canvas.height);\n                bufferToTensorOptions.height = canvas.height;\n                bufferToTensorOptions.width = canvas.width;\n                resolve((0, exports.bufferToTensor)(img.data, bufferToTensorOptions));\n            };\n        });\n    } else {\n        throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n    }\n    if (data !== undefined) {\n        return (0, exports.bufferToTensor)(data, bufferToTensorOptions);\n    } else {\n        throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n    }\n};\nexports.tensorFromImage = tensorFromImage; //# sourceMappingURL=tensor-factory-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL3RlbnNvci1mYWN0b3J5LWltcGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDeEQsTUFBTUksY0FBY0MsbUJBQU9BLENBQUMsK0VBQWE7QUFDekM7Ozs7OztDQU1DLEdBQ0QsTUFBTUYsaUJBQWlCLENBQUNHLFFBQVFDO0lBQzVCLElBQUlELFdBQVdFLFdBQVc7UUFDdEIsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0EsSUFBSUYsUUFBUUcsTUFBTSxLQUFLRixhQUFhRCxRQUFRSSxLQUFLLEtBQUtILFdBQVc7UUFDN0QsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBQ0EsSUFBSUYsUUFBUUssWUFBWSxLQUFLLFFBQVE7UUFDakMsTUFBTSxJQUFJSCxNQUFNO0lBQ3BCO0lBQ0EsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHSjtJQUMxQixNQUFNTSxPQUFPTixRQUFRTSxJQUFJLElBQUk7UUFBRUMsTUFBTTtRQUFLQyxNQUFNO0lBQUU7SUFDbEQsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUksT0FBUUosS0FBS0MsSUFBSSxLQUFNLFVBQVU7UUFDakNFLFdBQVc7WUFBQ0gsS0FBS0MsSUFBSTtZQUFFRCxLQUFLQyxJQUFJO1lBQUVELEtBQUtDLElBQUk7WUFBRUQsS0FBS0MsSUFBSTtTQUFDO0lBQzNELE9BQ0s7UUFDREUsV0FBVztZQUFDSCxLQUFLQyxJQUFJLENBQUMsRUFBRTtZQUFFRCxLQUFLQyxJQUFJLENBQUMsRUFBRTtZQUFFRCxLQUFLQyxJQUFJLENBQUMsRUFBRTtZQUFFRCxLQUFLQyxJQUFJLENBQUMsRUFBRSxJQUFJO1NBQUk7SUFDOUU7SUFDQSxJQUFJLE9BQVFE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Qm1ELFFBQVFQLFNBQVMsQ0FBQ1EsVUFBVSxHQUFHLEdBQUdmLE9BQU9wQyxLQUFLLEVBQUVvQyxPQUFPckMsTUFBTTtnQkFDN0QsTUFBTXlELE1BQU1OLFFBQVFOLFlBQVksQ0FBQyxHQUFHLEdBQUdSLE9BQU9wQyxLQUFLLEVBQUVvQyxPQUFPckMsTUFBTTtnQkFDbEVvQyxzQkFBc0JwQyxNQUFNLEdBQUdxQyxPQUFPckMsTUFBTTtnQkFDNUNvQyxzQkFBc0JuQyxLQUFLLEdBQUdvQyxPQUFPcEMsS0FBSztnQkFDMUNnRCxRQUFRLENBQUMsR0FBRzNELFFBQVFHLGNBQWMsRUFBRWdFLElBQUl0QixJQUFJLEVBQUVDO1lBQ2xEO1FBQ0o7SUFDSixPQUNLO1FBQ0QsTUFBTSxJQUFJckMsTUFBTTtJQUNwQjtJQUNBLElBQUlvQyxTQUFTckMsV0FBVztRQUNwQixPQUFPLENBQUMsR0FBR1IsUUFBUUcsY0FBYyxFQUFFMEMsTUFBTUM7SUFDN0MsT0FDSztRQUNELE1BQU0sSUFBSXJDLE1BQU07SUFDcEI7QUFDSjtBQUNBVCx1QkFBdUIsR0FBR0UsaUJBQzFCLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2Nqcy90ZW5zb3ItZmFjdG9yeS1pbXBsLmpzP2E2ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGVuc29yRnJvbUltYWdlID0gZXhwb3J0cy5idWZmZXJUb1RlbnNvciA9IHZvaWQgMDtcbmNvbnN0IHRlbnNvcl9qc18xID0gcmVxdWlyZShcIi4vdGVuc29yLmpzXCIpO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIGltYWdlIG9iamVjdFxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBFeHRyYWN0ZWQgaW1hZ2UgYnVmZmVyIGRhdGEgLSBhc3N1bWluZyBSR0JBIGZvcm1hdFxuICogQHBhcmFtIGltYWdlRm9ybWF0IC0gaW5wdXQgaW1hZ2UgY29uZmlndXJhdGlvbiAtIHJlcXVpcmVkIGNvbmZpZ3VyYXRpb25zIGhlaWdodCwgd2lkdGgsIGZvcm1hdFxuICogQHBhcmFtIHRlbnNvckZvcm1hdCAtIG91dHB1dCB0ZW5zb3IgY29uZmlndXJhdGlvbiAtIERlZmF1bHQgaXMgUkdCIGZvcm1hdFxuICovXG5jb25zdCBidWZmZXJUb1RlbnNvciA9IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhlaWdodCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMud2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTkhXQyBUZW5zb3IgbGF5b3V0IGlzIG5vdCBzdXBwb3J0ZWQgeWV0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBub3JtID0gb3B0aW9ucy5ub3JtID8/IHsgbWVhbjogMjU1LCBiaWFzOiAwIH07XG4gICAgbGV0IG5vcm1NZWFuO1xuICAgIGxldCBub3JtQmlhcztcbiAgICBpZiAodHlwZW9mIChub3JtLm1lYW4pID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuWzBdLCBub3JtLm1lYW5bMV0sIG5vcm0ubWVhblsyXSwgbm9ybS5tZWFuWzNdID8/IDI1NV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKG5vcm0uYmlhcykgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCBub3JtLmJpYXNbM10gPz8gMF07XG4gICAgfVxuICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQkEnO1xuICAgIC8vIGRlZmF1bHQgdmFsdWUgaXMgUkdCQSBzaW5jZSBpbWFnZWRhdGEgYW5kIEhUTUxJbWFnZUVsZW1lbnQgdXNlcyBpdFxuICAgIGNvbnN0IG91dHB1dGZvcm1hdCA9IG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDpcbiAgICAgICAgJ1JHQic7XG4gICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgY29uc3QgZmxvYXQzMkRhdGEgPSBvdXRwdXRmb3JtYXQgPT09ICdSR0JBJyA/IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogNCkgOiBuZXcgRmxvYXQzMkFycmF5KHN0cmlkZSAqIDMpO1xuICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgIGxldCBzdGVwID0gNCwgckltYWdlUG9pbnRlciA9IDAsIGdJbWFnZVBvaW50ZXIgPSAxLCBiSW1hZ2VQb2ludGVyID0gMiwgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcbiAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCJykge1xuICAgICAgICBzdGVwID0gMztcbiAgICAgICAgckltYWdlUG9pbnRlciA9IDA7XG4gICAgICAgIGdJbWFnZVBvaW50ZXIgPSAxO1xuICAgICAgICBiSW1hZ2VQb2ludGVyID0gMjtcbiAgICAgICAgYUltYWdlUG9pbnRlciA9IC0xO1xuICAgIH1cbiAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcbiAgICBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICAgICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRwdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnQkdSJykge1xuICAgICAgICBiVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgICByVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyBpKyssIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcCkge1xuICAgICAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1swXSkgLyBub3JtTWVhblswXTtcbiAgICAgICAgZmxvYXQzMkRhdGFbZ1RlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2dJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMV0pIC8gbm9ybU1lYW5bMV07XG4gICAgICAgIGZsb2F0MzJEYXRhW2JUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltiSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzJdKSAvIG5vcm1NZWFuWzJdO1xuICAgICAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XG4gICAgICAgICAgICBmbG9hdDMyRGF0YVthVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYUltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1szXSkgLyBub3JtTWVhblszXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGbG9hdDMyQXJyYXkgLT4gb3J0LlRlbnNvclxuICAgIGNvbnN0IG91dHB1dFRlbnNvciA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IHRlbnNvcl9qc18xLlRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgNCwgaGVpZ2h0LCB3aWR0aF0pIDpcbiAgICAgICAgbmV3IHRlbnNvcl9qc18xLlRlbnNvcignZmxvYXQzMicsIGZsb2F0MzJEYXRhLCBbMSwgMywgaGVpZ2h0LCB3aWR0aF0pO1xuICAgIHJldHVybiBvdXRwdXRUZW5zb3I7XG59O1xuZXhwb3J0cy5idWZmZXJUb1RlbnNvciA9IGJ1ZmZlclRvVGVuc29yO1xuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUltYWdlKCkuXG4gKi9cbmNvbnN0IHRlbnNvckZyb21JbWFnZSA9IGFzeW5jIChpbWFnZSwgb3B0aW9ucykgPT4ge1xuICAgIC8vIGNoZWNraW5nIHRoZSB0eXBlIG9mIGltYWdlIG9iamVjdFxuICAgIGNvbnN0IGlzSFRNTEltYWdlRWxlID0gdHlwZW9mIChIVE1MSW1hZ2VFbGVtZW50KSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICAgIGNvbnN0IGlzSW1hZ2VEYXRhRWxlID0gdHlwZW9mIChJbWFnZURhdGEpICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YTtcbiAgICBjb25zdCBpc0ltYWdlQml0bWFwID0gdHlwZW9mIChJbWFnZUJpdG1hcCkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA7XG4gICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnO1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xuICAgIC8vIGZpbGxpbmcgYW5kIGNoZWNraW5nIGltYWdlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgIGlmIChpc0hUTUxJbWFnZUVsZSkge1xuICAgICAgICAvLyBIVE1MSW1hZ2VFbGVtZW50IC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IGlzIFJHQkEgYnkgZGVmYXVsdFxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBpbnB1dCBjb25maWcgZm9ybWF0IG11c3QgYmUgUkdCQSBmb3IgSFRNTEltYWdlRWxlbWVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XG4gICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgIGxldCB3aWR0aDtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5mb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBpeGVsczJEQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgLy8gSW1hZ2VCaXRtYXAgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgbXVzdCBiZSBwcm92aWRlZCBieSB1c2VyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5idWZmZXJUb1RlbnNvcikoZGF0YSwgYnVmZmVyVG9UZW5zb3JPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIGlmICghaW1hZ2UgfHwgIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgbmV3SW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgICAgICAgIG5ld0ltYWdlLnNyYyA9IGltYWdlO1xuICAgICAgICAgICAgbmV3SW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdJbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UobmV3SW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgoMCwgZXhwb3J0cy5idWZmZXJUb1RlbnNvcikoaW1nLmRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmJ1ZmZlclRvVGVuc29yKShkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICAgIH1cbn07XG5leHBvcnRzLnRlbnNvckZyb21JbWFnZSA9IHRlbnNvckZyb21JbWFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci1mYWN0b3J5LWltcGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidGVuc29yRnJvbUltYWdlIiwiYnVmZmVyVG9UZW5zb3IiLCJ0ZW5zb3JfanNfMSIsInJlcXVpcmUiLCJidWZmZXIiLCJvcHRpb25zIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJoZWlnaHQiLCJ3aWR0aCIsInRlbnNvckxheW91dCIsIm5vcm0iLCJtZWFuIiwiYmlhcyIsIm5vcm1NZWFuIiwibm9ybUJpYXMiLCJpbnB1dGZvcm1hdCIsImZvcm1hdCIsIm91dHB1dGZvcm1hdCIsInRlbnNvckZvcm1hdCIsInN0cmlkZSIsImZsb2F0MzJEYXRhIiwiRmxvYXQzMkFycmF5Iiwic3RlcCIsInJJbWFnZVBvaW50ZXIiLCJnSW1hZ2VQb2ludGVyIiwiYkltYWdlUG9pbnRlciIsImFJbWFnZVBvaW50ZXIiLCJyVGVuc29yUG9pbnRlciIsImdUZW5zb3JQb2ludGVyIiwiYlRlbnNvclBvaW50ZXIiLCJhVGVuc29yUG9pbnRlciIsImkiLCJvdXRwdXRUZW5zb3IiLCJUZW5zb3IiLCJpbWFnZSIsImlzSFRNTEltYWdlRWxlIiwiSFRNTEltYWdlRWxlbWVudCIsImlzSW1hZ2VEYXRhRWxlIiwiSW1hZ2VEYXRhIiwiaXNJbWFnZUJpdG1hcCIsIkltYWdlQml0bWFwIiwiaXNTdHJpbmciLCJkYXRhIiwiYnVmZmVyVG9UZW5zb3JPcHRpb25zIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwicGl4ZWxzMkRDb250ZXh0IiwiZ2V0Q29udGV4dCIsInJlc2l6ZWRIZWlnaHQiLCJyZXNpemVkV2lkdGgiLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJ0ZW1wQ2FudmFzIiwicHV0SW1hZ2VEYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjb250ZXh0IiwibmV3SW1hZ2UiLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwic3JjIiwib25sb2FkIiwiaW1nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-factory-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-impl.js":
/*!*****************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/tensor-impl.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Tensor = void 0;\nconst tensor_conversion_impl_js_1 = __webpack_require__(/*! ./tensor-conversion-impl.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-conversion-impl.js\");\nconst tensor_factory_impl_js_1 = __webpack_require__(/*! ./tensor-factory-impl.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-factory-impl.js\");\nconst tensor_utils_impl_js_1 = __webpack_require__(/*! ./tensor-utils-impl.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-utils-impl.js\");\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([\n    [\n        \"float32\",\n        Float32Array\n    ],\n    [\n        \"uint8\",\n        Uint8Array\n    ],\n    [\n        \"int8\",\n        Int8Array\n    ],\n    [\n        \"uint16\",\n        Uint16Array\n    ],\n    [\n        \"float16\",\n        Uint16Array\n    ],\n    [\n        \"int16\",\n        Int16Array\n    ],\n    [\n        \"int32\",\n        Int32Array\n    ],\n    [\n        \"bool\",\n        Uint8Array\n    ],\n    [\n        \"float64\",\n        Float64Array\n    ],\n    [\n        \"uint32\",\n        Uint32Array\n    ]\n]);\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([\n    [\n        Float32Array,\n        \"float32\"\n    ],\n    [\n        Uint8Array,\n        \"uint8\"\n    ],\n    [\n        Int8Array,\n        \"int8\"\n    ],\n    [\n        Uint16Array,\n        \"uint16\"\n    ],\n    [\n        Int16Array,\n        \"int16\"\n    ],\n    [\n        Int32Array,\n        \"int32\"\n    ],\n    [\n        Float64Array,\n        \"float64\"\n    ],\n    [\n        Uint32Array,\n        \"uint32\"\n    ]\n]);\n// the following code allows delaying execution of BigInt checking. This allows lazy initialization for\n// NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP and NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, which allows BigInt polyfill\n// if available.\nlet isBigIntChecked = false;\nconst checkBigInt = ()=>{\n    if (!isBigIntChecked) {\n        isBigIntChecked = true;\n        const isBigInt64ArrayAvailable = typeof BigInt64Array !== \"undefined\" && typeof BigInt64Array.from === \"function\";\n        const isBigUint64ArrayAvailable = typeof BigUint64Array !== \"undefined\" && typeof BigUint64Array.from === \"function\";\n        if (isBigInt64ArrayAvailable) {\n            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set(\"int64\", BigInt64Array);\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, \"int64\");\n        }\n        if (isBigUint64ArrayAvailable) {\n            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set(\"uint64\", BigUint64Array);\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, \"uint64\");\n        }\n    }\n};\nclass Tensor {\n    constructor(arg0, arg1, arg2){\n        checkBigInt();\n        let type;\n        let data;\n        let dims;\n        // check whether arg0 is type or data\n        if (typeof arg0 === \"string\") {\n            //\n            // Override: constructor(type, data, ...)\n            //\n            type = arg0;\n            dims = arg2;\n            if (arg0 === \"string\") {\n                // string tensor\n                if (!Array.isArray(arg1)) {\n                    throw new TypeError(\"A string tensor's data must be a string array.\");\n                }\n                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n                // error will be populated at inference\n                data = arg1;\n            } else {\n                // numeric tensor\n                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n                if (typedArrayConstructor === undefined) {\n                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n                }\n                if (Array.isArray(arg1)) {\n                    if (arg0 === \"float16\") {\n                        // Throw error here because when user try to use number array as data,\n                        // e.g. new Tensor('float16', [1, 2, 3, 4], dims)), it will actually call\n                        // Uint16Array.from(arg1) which generates wrong data.\n                        throw new TypeError(\"Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.\");\n                    } else if (arg0 === \"uint64\" || arg0 === \"int64\") {\n                        // use 'as any' here because:\n                        // 1. TypeScript's check on type of 'Array.isArray()' does not work with readonly arrays.\n                        // see https://github.com/microsoft/TypeScript/issues/17002\n                        // 2. TypeScript's check on union type of '(BigInt64ArrayConstructor|BigUint64ArrayConstructor).from()' does\n                        // not accept parameter mapFn.\n                        // 3. parameters of 'SupportedTypedArrayConstructors.from()' does not match the requirement of the union\n                        // type.\n                        // assume 'arg1' is of type \"readonly number[]|readonly bigint[]\" here.\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        data = typedArrayConstructor.from(arg1, BigInt);\n                    } else {\n                        // assume 'arg1' is of type \"readonly number[]\" here.\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        data = typedArrayConstructor.from(arg1);\n                    }\n                } else if (arg1 instanceof typedArrayConstructor) {\n                    data = arg1;\n                } else {\n                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n                }\n            }\n        } else {\n            //\n            // Override: constructor(data, ...)\n            //\n            dims = arg1;\n            if (Array.isArray(arg0)) {\n                // only boolean[] and string[] is supported\n                if (arg0.length === 0) {\n                    throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");\n                }\n                const firstElementType = typeof arg0[0];\n                if (firstElementType === \"string\") {\n                    type = \"string\";\n                    data = arg0;\n                } else if (firstElementType === \"boolean\") {\n                    type = \"bool\";\n                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n                    // wrong type. We use 'as any' to make it happy.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    data = Uint8Array.from(arg0);\n                } else {\n                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n                }\n            } else {\n                // get tensor type from TypedArray\n                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);\n                if (mappedType === undefined) {\n                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n                }\n                type = mappedType;\n                data = arg0;\n            }\n        }\n        // type and data is processed, now processing dims\n        if (dims === undefined) {\n            // assume 1-D tensor if dims omitted\n            dims = [\n                data.length\n            ];\n        } else if (!Array.isArray(dims)) {\n            throw new TypeError(\"A tensor's dims must be a number array\");\n        }\n        // perform check\n        const size = (0, tensor_utils_impl_js_1.calculateSize)(dims);\n        if (size !== data.length) {\n            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\n        }\n        this.dims = dims;\n        this.type = type;\n        this.data = data;\n        this.size = size;\n    }\n    static async fromImage(image, options) {\n        return (0, tensor_factory_impl_js_1.tensorFromImage)(image, options);\n    }\n    // #endregion\n    // #region conversions\n    toDataURL(options) {\n        return (0, tensor_conversion_impl_js_1.tensorToDataURL)(this, options);\n    }\n    toImageData(options) {\n        return (0, tensor_conversion_impl_js_1.tensorToImageData)(this, options);\n    }\n    // #endregion\n    // #region tensor utilities\n    reshape(dims) {\n        return (0, tensor_utils_impl_js_1.tensorReshape)(this, dims);\n    }\n}\nexports.Tensor = Tensor; //# sourceMappingURL=tensor-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL3RlbnNvci1pbXBsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNERBQTREO0FBQzVELGtDQUFrQztBQUNsQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLE1BQU1HLDhCQUE4QkMsbUJBQU9BLENBQUMsK0dBQTZCO0FBQ3pFLE1BQU1DLDJCQUEyQkQsbUJBQU9BLENBQUMseUdBQTBCO0FBQ25FLE1BQU1FLHlCQUF5QkYsbUJBQU9BLENBQUMscUdBQXdCO0FBQy9ELGtHQUFrRztBQUNsRyxNQUFNRyx3Q0FBd0MsSUFBSUMsSUFBSTtJQUNsRDtRQUFDO1FBQVdDO0tBQWE7SUFDekI7UUFBQztRQUFTQztLQUFXO0lBQ3JCO1FBQUM7UUFBUUM7S0FBVTtJQUNuQjtRQUFDO1FBQVVDO0tBQVk7SUFDdkI7UUFBQztRQUFXQTtLQUFZO0lBQ3hCO1FBQUM7UUFBU0M7S0FBVztJQUNyQjtRQUFDO1FBQVNDO0tBQVc7SUFDckI7UUFBQztRQUFRSjtLQUFXO0lBQ3BCO1FBQUM7UUFBV0s7S0FBYTtJQUN6QjtRQUFDO1FBQVVDO0tBQVk7Q0FDMUI7QUFDRCxrR0FBa0c7QUFDbEcsTUFBTUMsd0NBQXdDLElBQUlULElBQUk7SUFDbEQ7UUFBQ0M7UUFBYztLQUFVO0lBQ3pCO1FBQUNDO1FBQVk7S0FBUTtJQUNyQjtRQUFDQztRQUFXO0tBQU87SUFDbkI7UUFBQ0M7UUFBYTtLQUFTO0lBQ3ZCO1FBQUNDO1FBQVk7S0FBUTtJQUNyQjtRQUFDQztRQUFZO0tBQVE7SUFDckI7UUFBQ0M7UUFBYztLQUFVO0lBQ3pCO1FBQUNDO1FBQWE7S0FBUztDQUMxQjtBQUNELHVHQUF1RztBQUN2RyxnSEFBZ0g7QUFDaEgsZ0JBQWdCO0FBQ2hCLElBQUlFLGtCQUFrQjtBQUN0QixNQUFNQyxjQUFjO0lBQ2hCLElBQUksQ0FBQ0QsaUJBQWlCO1FBQ2xCQSxrQkFBa0I7UUFDbEIsTUFBTUUsMkJBQTJCLE9BQU9DLGtCQUFrQixlQUFlLE9BQU9BLGNBQWNDLElBQUksS0FBSztRQUN2RyxNQUFNQyw0QkFBNEIsT0FBT0MsbUJBQW1CLGVBQWUsT0FBT0EsZUFBZUYsSUFBSSxLQUFLO1FBQzFHLElBQUlGLDBCQUEwQjtZQUMxQmIsc0NBQXNDa0IsR0FBRyxDQUFDLFNBQVNKO1lBQ25ESixzQ0FBc0NRLEdBQUcsQ0FBQ0osZUFBZTtRQUM3RDtRQUNBLElBQUlFLDJCQUEyQjtZQUMzQmhCLHNDQUFzQ2tCLEdBQUcsQ0FBQyxVQUFVRDtZQUNwRFAsc0NBQXNDUSxHQUFHLENBQUNELGdCQUFnQjtRQUM5RDtJQUNKO0FBQ0o7QUFDQSxNQUFNdEI7SUFDRndCLFlBQVlDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxJQUFJLENBQUU7UUFDMUJWO1FBQ0EsSUFBSVc7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0oscUNBQXFDO1FBQ3JDLElBQUksT0FBT0wsU0FBUyxVQUFVO1lBQzFCLEVBQUU7WUFDRix5Q0FBeUM7WUFDekMsRUFBRTtZQUNGRyxPQUFPSDtZQUNQSyxPQUFPSDtZQUNQLElBQUlGLFNBQVMsVUFBVTtnQkFDbkIsZ0JBQWdCO2dCQUNoQixJQUFJLENBQUNNLE1BQU1DLE9BQU8sQ0FBQ04sT0FBTztvQkFDdEIsTUFBTSxJQUFJTyxVQUFVO2dCQUN4QjtnQkFDQSw0R0FBNEc7Z0JBQzVHLHVDQUF1QztnQkFDdkNKLE9BQU9IO1lBQ1gsT0FDSztnQkFDRCxpQkFBaUI7Z0JBQ2pCLE1BQU1RLHdCQUF3QjdCLHNDQUFzQzhCLEdBQUcsQ0FBQ1Y7Z0JBQ3hFLElBQUlTLDBCQUEwQkUsV0FBVztvQkFDckMsTUFBTSxJQUFJSCxVQUFVLENBQUMseUJBQXlCLEVBQUVSLEtBQUssQ0FBQyxDQUFDO2dCQUMzRDtnQkFDQSxJQUFJTSxNQUFNQyxPQUFPLENBQUNOLE9BQU87b0JBQ3JCLElBQUlELFNBQVMsV0FBVzt3QkFDcEIsc0VBQXNFO3dCQUN0RSx5RUFBeUU7d0JBQ3pFLHFEQUFxRDt3QkFDckQsTUFBTSxJQUFJUSxVQUFVO29CQUN4QixPQUNLLElBQUlSLFNBQVMsWUFBWUEsU0FBUyxTQUFTO3dCQUM1Qyw2QkFBNkI7d0JBQzdCLHlGQUF5Rjt3QkFDekYsMkRBQTJEO3dCQUMzRCw0R0FBNEc7d0JBQzVHLDhCQUE4Qjt3QkFDOUIsd0dBQXdHO3dCQUN4RyxRQUFRO3dCQUNSLHVFQUF1RTt3QkFDdkUsOERBQThEO3dCQUM5REksT0FBT0ssc0JBQXNCZCxJQUFJLENBQUNNLE1BQU1XO29CQUM1QyxPQUNLO3dCQUNELHFEQUFxRDt3QkFDckQsOERBQThEO3dCQUM5RFIsT0FBT0ssc0JBQXNCZCxJQUFJLENBQUNNO29CQUN0QztnQkFDSixPQUNLLElBQUlBLGdCQUFnQlEsdUJBQXVCO29CQUM1Q0wsT0FBT0g7Z0JBQ1gsT0FDSztvQkFDRCxNQUFNLElBQUlPLFVBQVUsQ0FBQyxFQUFFLEVBQUVMLEtBQUssK0JBQStCLEVBQUVNLHNCQUFzQixDQUFDO2dCQUMxRjtZQUNKO1FBQ0osT0FDSztZQUNELEVBQUU7WUFDRixtQ0FBbUM7WUFDbkMsRUFBRTtZQUNGSixPQUFPSjtZQUNQLElBQUlLLE1BQU1DLE9BQU8sQ0FBQ1AsT0FBTztnQkFDckIsMkNBQTJDO2dCQUMzQyxJQUFJQSxLQUFLYSxNQUFNLEtBQUssR0FBRztvQkFDbkIsTUFBTSxJQUFJTCxVQUFVO2dCQUN4QjtnQkFDQSxNQUFNTSxtQkFBbUIsT0FBT2QsSUFBSSxDQUFDLEVBQUU7Z0JBQ3ZDLElBQUljLHFCQUFxQixVQUFVO29CQUMvQlgsT0FBTztvQkFDUEMsT0FBT0o7Z0JBQ1gsT0FDSyxJQUFJYyxxQkFBcUIsV0FBVztvQkFDckNYLE9BQU87b0JBQ1AsMEdBQTBHO29CQUMxRyxnREFBZ0Q7b0JBQ2hELDhEQUE4RDtvQkFDOURDLE9BQU9yQixXQUFXWSxJQUFJLENBQUNLO2dCQUMzQixPQUNLO29CQUNELE1BQU0sSUFBSVEsVUFBVSxDQUFDLG9DQUFvQyxFQUFFTSxpQkFBaUIsQ0FBQyxDQUFDO2dCQUNsRjtZQUNKLE9BQ0s7Z0JBQ0Qsa0NBQWtDO2dCQUNsQyxNQUFNQyxhQUFhekIsc0NBQXNDb0IsR0FBRyxDQUFDVixLQUFLRCxXQUFXO2dCQUM3RSxJQUFJZ0IsZUFBZUosV0FBVztvQkFDMUIsTUFBTSxJQUFJSCxVQUFVLENBQUMsa0NBQWtDLEVBQUVSLEtBQUtELFdBQVcsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hGO2dCQUNBSSxPQUFPWTtnQkFDUFgsT0FBT0o7WUFDWDtRQUNKO1FBQ0Esa0RBQWtEO1FBQ2xELElBQUlLLFNBQVNNLFdBQVc7WUFDcEIsb0NBQW9DO1lBQ3BDTixPQUFPO2dCQUFDRCxLQUFLUyxNQUFNO2FBQUM7UUFDeEIsT0FDSyxJQUFJLENBQUNQLE1BQU1DLE9BQU8sQ0FBQ0YsT0FBTztZQUMzQixNQUFNLElBQUlHLFVBQVU7UUFDeEI7UUFDQSxnQkFBZ0I7UUFDaEIsTUFBTVEsT0FBTyxDQUFDLEdBQUdyQyx1QkFBdUJzQyxhQUFhLEVBQUVaO1FBQ3ZELElBQUlXLFNBQVNaLEtBQUtTLE1BQU0sRUFBRTtZQUN0QixNQUFNLElBQUlLLE1BQU0sQ0FBQyxjQUFjLEVBQUVGLEtBQUssNkJBQTZCLEVBQUVaLEtBQUtTLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDeEY7UUFDQSxJQUFJLENBQUNSLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNZLElBQUksR0FBR0E7SUFDaEI7SUFDQSxhQUFhRyxVQUFVQyxLQUFLLEVBQUVDLE9BQU8sRUFBRTtRQUNuQyxPQUFPLENBQUMsR0FBRzNDLHlCQUF5QjRDLGVBQWUsRUFBRUYsT0FBT0M7SUFDaEU7SUFDQSxhQUFhO0lBQ2Isc0JBQXNCO0lBQ3RCRSxVQUFVRixPQUFPLEVBQUU7UUFDZixPQUFPLENBQUMsR0FBRzdDLDRCQUE0QmdELGVBQWUsRUFBRSxJQUFJLEVBQUVIO0lBQ2xFO0lBQ0FJLFlBQVlKLE9BQU8sRUFBRTtRQUNqQixPQUFPLENBQUMsR0FBRzdDLDRCQUE0QmtELGlCQUFpQixFQUFFLElBQUksRUFBRUw7SUFDcEU7SUFDQSxhQUFhO0lBQ2IsMkJBQTJCO0lBQzNCTSxRQUFRdEIsSUFBSSxFQUFFO1FBQ1YsT0FBTyxDQUFDLEdBQUcxQix1QkFBdUJpRCxhQUFhLEVBQUUsSUFBSSxFQUFFdkI7SUFDM0Q7QUFDSjtBQUNBaEMsY0FBYyxHQUFHRSxRQUNqQix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qcy8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9janMvdGVuc29yLWltcGwuanM/Y2JmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZW5zb3IgPSB2b2lkIDA7XG5jb25zdCB0ZW5zb3JfY29udmVyc2lvbl9pbXBsX2pzXzEgPSByZXF1aXJlKFwiLi90ZW5zb3ItY29udmVyc2lvbi1pbXBsLmpzXCIpO1xuY29uc3QgdGVuc29yX2ZhY3RvcnlfaW1wbF9qc18xID0gcmVxdWlyZShcIi4vdGVuc29yLWZhY3RvcnktaW1wbC5qc1wiKTtcbmNvbnN0IHRlbnNvcl91dGlsc19pbXBsX2pzXzEgPSByZXF1aXJlKFwiLi90ZW5zb3ItdXRpbHMtaW1wbC5qc1wiKTtcbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5jb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQID0gbmV3IE1hcChbXG4gICAgWydmbG9hdDMyJywgRmxvYXQzMkFycmF5XSxcbiAgICBbJ3VpbnQ4JywgVWludDhBcnJheV0sXG4gICAgWydpbnQ4JywgSW50OEFycmF5XSxcbiAgICBbJ3VpbnQxNicsIFVpbnQxNkFycmF5XSxcbiAgICBbJ2Zsb2F0MTYnLCBVaW50MTZBcnJheV0sXG4gICAgWydpbnQxNicsIEludDE2QXJyYXldLFxuICAgIFsnaW50MzInLCBJbnQzMkFycmF5XSxcbiAgICBbJ2Jvb2wnLCBVaW50OEFycmF5XSxcbiAgICBbJ2Zsb2F0NjQnLCBGbG9hdDY0QXJyYXldLFxuICAgIFsndWludDMyJywgVWludDMyQXJyYXldLFxuXSk7XG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCA9IG5ldyBNYXAoW1xuICAgIFtGbG9hdDMyQXJyYXksICdmbG9hdDMyJ10sXG4gICAgW1VpbnQ4QXJyYXksICd1aW50OCddLFxuICAgIFtJbnQ4QXJyYXksICdpbnQ4J10sXG4gICAgW1VpbnQxNkFycmF5LCAndWludDE2J10sXG4gICAgW0ludDE2QXJyYXksICdpbnQxNiddLFxuICAgIFtJbnQzMkFycmF5LCAnaW50MzInXSxcbiAgICBbRmxvYXQ2NEFycmF5LCAnZmxvYXQ2NCddLFxuICAgIFtVaW50MzJBcnJheSwgJ3VpbnQzMiddLFxuXSk7XG4vLyB0aGUgZm9sbG93aW5nIGNvZGUgYWxsb3dzIGRlbGF5aW5nIGV4ZWN1dGlvbiBvZiBCaWdJbnQgY2hlY2tpbmcuIFRoaXMgYWxsb3dzIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yXG4vLyBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQIGFuZCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCB3aGljaCBhbGxvd3MgQmlnSW50IHBvbHlmaWxsXG4vLyBpZiBhdmFpbGFibGUuXG5sZXQgaXNCaWdJbnRDaGVja2VkID0gZmFsc2U7XG5jb25zdCBjaGVja0JpZ0ludCA9ICgpID0+IHtcbiAgICBpZiAoIWlzQmlnSW50Q2hlY2tlZCkge1xuICAgICAgICBpc0JpZ0ludENoZWNrZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEJpZ0ludDY0QXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgY29uc3QgaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEJpZ1VpbnQ2NEFycmF5LmZyb20gPT09ICdmdW5jdGlvbic7XG4gICAgICAgIGlmIChpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdpbnQ2NCcsIEJpZ0ludDY0QXJyYXkpO1xuICAgICAgICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnSW50NjRBcnJheSwgJ2ludDY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCd1aW50NjQnLCBCaWdVaW50NjRBcnJheSk7XG4gICAgICAgICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChCaWdVaW50NjRBcnJheSwgJ3VpbnQ2NCcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNsYXNzIFRlbnNvciB7XG4gICAgY29uc3RydWN0b3IoYXJnMCwgYXJnMSwgYXJnMikge1xuICAgICAgICBjaGVja0JpZ0ludCgpO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGxldCBkaW1zO1xuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIGFyZzAgaXMgdHlwZSBvciBkYXRhXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBPdmVycmlkZTogY29uc3RydWN0b3IodHlwZSwgZGF0YSwgLi4uKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHR5cGUgPSBhcmcwO1xuICAgICAgICAgICAgZGltcyA9IGFyZzI7XG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Egc3RyaW5nIHRlbnNvclxcJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcbiAgICAgICAgICAgICAgICAvLyBlcnJvciB3aWxsIGJlIHBvcHVsYXRlZCBhdCBpbmZlcmVuY2VcbiAgICAgICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG51bWVyaWMgdGVuc29yXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQoYXJnMCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke2FyZzB9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ2Zsb2F0MTYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBoZXJlIGJlY2F1c2Ugd2hlbiB1c2VyIHRyeSB0byB1c2UgbnVtYmVyIGFycmF5IGFzIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIG5ldyBUZW5zb3IoJ2Zsb2F0MTYnLCBbMSwgMiwgMywgNF0sIGRpbXMpKSwgaXQgd2lsbCBhY3R1YWxseSBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVaW50MTZBcnJheS5mcm9tKGFyZzEpIHdoaWNoIGdlbmVyYXRlcyB3cm9uZyBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ3JlYXRpbmcgYSBmbG9hdDE2IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIFVpbnQxNkFycmF5IGFzIGRhdGEuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnMCA9PT0gJ3VpbnQ2NCcgfHwgYXJnMCA9PT0gJ2ludDY0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlICdhcyBhbnknIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB0eXBlIG9mICdBcnJheS5pc0FycmF5KCknIGRvZXMgbm90IHdvcmsgd2l0aCByZWFkb25seSBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzAwMlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi4gVHlwZVNjcmlwdCdzIGNoZWNrIG9uIHVuaW9uIHR5cGUgb2YgJyhCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvcikuZnJvbSgpJyBkb2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3QgYWNjZXB0IHBhcmFtZXRlciBtYXBGbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMuIHBhcmFtZXRlcnMgb2YgJ1N1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMuZnJvbSgpJyBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZW1lbnQgb2YgdGhlIHVuaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgYmlnaW50W11cIiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZnJvbShhcmcxLCBCaWdJbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW11cIiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZnJvbShhcmcxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcxIGluc3RhbmNlb2YgdHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke3R5cGV9IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBPdmVycmlkZTogY29uc3RydWN0b3IoZGF0YSwgLi4uKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGRpbXMgPSBhcmcxO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGJvb2xlYW5bXSBhbmQgc3RyaW5nW10gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICAgICAgaWYgKGFyZzAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnRUeXBlID0gdHlwZW9mIGFyZzBbMF07XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGFyZzA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2Jvb2wnO1xuICAgICAgICAgICAgICAgICAgICAvLyAnYXJnMCcgaXMgb2YgdHlwZSAnYm9vbGVhbltdJy4gVWludDhBcnJheS5mcm9tKGJvb2xlYW5bXSkgYWN0dWFsbHkgd29ya3MsIGJ1dCB0eXBlc2NyaXB0IHRoaW5rcyB0aGlzIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyb25nIHR5cGUuIFdlIHVzZSAnYXMgYW55JyB0byBtYWtlIGl0IGhhcHB5LlxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHtmaXJzdEVsZW1lbnRUeXBlfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGVuc29yIHR5cGUgZnJvbSBUeXBlZEFycmF5XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkVHlwZSA9IE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuZ2V0KGFyZzAuY29uc3RydWN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGUgPSBtYXBwZWRUeXBlO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHR5cGUgYW5kIGRhdGEgaXMgcHJvY2Vzc2VkLCBub3cgcHJvY2Vzc2luZyBkaW1zXG4gICAgICAgIGlmIChkaW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGFzc3VtZSAxLUQgdGVuc29yIGlmIGRpbXMgb21pdHRlZFxuICAgICAgICAgICAgZGltcyA9IFtkYXRhLmxlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGltcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgdGVuc29yXFwncyBkaW1zIG11c3QgYmUgYSBudW1iZXIgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJmb3JtIGNoZWNrXG4gICAgICAgIGNvbnN0IHNpemUgPSAoMCwgdGVuc29yX3V0aWxzX2ltcGxfanNfMS5jYWxjdWxhdGVTaXplKShkaW1zKTtcbiAgICAgICAgaWYgKHNpemUgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHtkYXRhLmxlbmd0aH0pLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGltcyA9IGRpbXM7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBmcm9tSW1hZ2UoaW1hZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCB0ZW5zb3JfZmFjdG9yeV9pbXBsX2pzXzEudGVuc29yRnJvbUltYWdlKShpbWFnZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIGNvbnZlcnNpb25zXG4gICAgdG9EYXRhVVJMKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCB0ZW5zb3JfY29udmVyc2lvbl9pbXBsX2pzXzEudGVuc29yVG9EYXRhVVJMKSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdG9JbWFnZURhdGEob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIHRlbnNvcl9jb252ZXJzaW9uX2ltcGxfanNfMS50ZW5zb3JUb0ltYWdlRGF0YSkodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIHRlbnNvciB1dGlsaXRpZXNcbiAgICByZXNoYXBlKGRpbXMpIHtcbiAgICAgICAgcmV0dXJuICgwLCB0ZW5zb3JfdXRpbHNfaW1wbF9qc18xLnRlbnNvclJlc2hhcGUpKHRoaXMsIGRpbXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuVGVuc29yID0gVGVuc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yLWltcGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiVGVuc29yIiwidGVuc29yX2NvbnZlcnNpb25faW1wbF9qc18xIiwicmVxdWlyZSIsInRlbnNvcl9mYWN0b3J5X2ltcGxfanNfMSIsInRlbnNvcl91dGlsc19pbXBsX2pzXzEiLCJOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQIiwiTWFwIiwiRmxvYXQzMkFycmF5IiwiVWludDhBcnJheSIsIkludDhBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJVaW50MzJBcnJheSIsIk5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAiLCJpc0JpZ0ludENoZWNrZWQiLCJjaGVja0JpZ0ludCIsImlzQmlnSW50NjRBcnJheUF2YWlsYWJsZSIsIkJpZ0ludDY0QXJyYXkiLCJmcm9tIiwiaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSIsIkJpZ1VpbnQ2NEFycmF5Iiwic2V0IiwiY29uc3RydWN0b3IiLCJhcmcwIiwiYXJnMSIsImFyZzIiLCJ0eXBlIiwiZGF0YSIsImRpbXMiLCJBcnJheSIsImlzQXJyYXkiLCJUeXBlRXJyb3IiLCJ0eXBlZEFycmF5Q29uc3RydWN0b3IiLCJnZXQiLCJ1bmRlZmluZWQiLCJCaWdJbnQiLCJsZW5ndGgiLCJmaXJzdEVsZW1lbnRUeXBlIiwibWFwcGVkVHlwZSIsInNpemUiLCJjYWxjdWxhdGVTaXplIiwiRXJyb3IiLCJmcm9tSW1hZ2UiLCJpbWFnZSIsIm9wdGlvbnMiLCJ0ZW5zb3JGcm9tSW1hZ2UiLCJ0b0RhdGFVUkwiLCJ0ZW5zb3JUb0RhdGFVUkwiLCJ0b0ltYWdlRGF0YSIsInRlbnNvclRvSW1hZ2VEYXRhIiwicmVzaGFwZSIsInRlbnNvclJlc2hhcGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-utils-impl.js":
/*!***********************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/tensor-utils-impl.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.tensorReshape = exports.calculateSize = void 0;\nconst tensor_js_1 = __webpack_require__(/*! ./tensor.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor.js\");\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */ const calculateSize = (dims)=>{\n    let size = 1;\n    for(let i = 0; i < dims.length; i++){\n        const dim = dims[i];\n        if (typeof dim !== \"number\" || !Number.isSafeInteger(dim)) {\n            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n        }\n        if (dim < 0) {\n            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n        }\n        size *= dim;\n    }\n    return size;\n};\nexports.calculateSize = calculateSize;\n/**\n * implementation of Tensor.reshape()\n */ const tensorReshape = (tensor, dims)=>new tensor_js_1.Tensor(tensor.type, tensor.data, dims);\nexports.tensorReshape = tensorReshape; //# sourceMappingURL=tensor-utils-impl.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL3RlbnNvci11dGlscy1pbXBsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNERBQTREO0FBQzVELGtDQUFrQztBQUNsQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQ3JELE1BQU1JLGNBQWNDLG1CQUFPQSxDQUFDLCtFQUFhO0FBQ3pDOzs7O0NBSUMsR0FDRCxNQUFNRixnQkFBZ0IsQ0FBQ0c7SUFDbkIsSUFBSUMsT0FBTztJQUNYLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixLQUFLRyxNQUFNLEVBQUVELElBQUs7UUFDbEMsTUFBTUUsTUFBTUosSUFBSSxDQUFDRSxFQUFFO1FBQ25CLElBQUksT0FBT0UsUUFBUSxZQUFZLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsTUFBTTtZQUN2RCxNQUFNLElBQUlHLFVBQVUsQ0FBQyxLQUFLLEVBQUVMLEVBQUUsMkJBQTJCLEVBQUVFLElBQUksQ0FBQztRQUNwRTtRQUNBLElBQUlBLE1BQU0sR0FBRztZQUNULE1BQU0sSUFBSUksV0FBVyxDQUFDLEtBQUssRUFBRU4sRUFBRSx1Q0FBdUMsRUFBRUUsSUFBSSxDQUFDO1FBQ2pGO1FBQ0FILFFBQVFHO0lBQ1o7SUFDQSxPQUFPSDtBQUNYO0FBQ0FQLHFCQUFxQixHQUFHRztBQUN4Qjs7Q0FFQyxHQUNELE1BQU1ELGdCQUFnQixDQUFDYSxRQUFRVCxPQUFTLElBQUlGLFlBQVlZLE1BQU0sQ0FBQ0QsT0FBT0UsSUFBSSxFQUFFRixPQUFPRyxJQUFJLEVBQUVaO0FBQ3pGTixxQkFBcUIsR0FBR0UsZUFDeEIsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanMvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL3RlbnNvci11dGlscy1pbXBsLmpzP2ZiMjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGVuc29yUmVzaGFwZSA9IGV4cG9ydHMuY2FsY3VsYXRlU2l6ZSA9IHZvaWQgMDtcbmNvbnN0IHRlbnNvcl9qc18xID0gcmVxdWlyZShcIi4vdGVuc29yLmpzXCIpO1xuLyoqXG4gKiBjYWxjdWxhdGUgc2l6ZSBmcm9tIGRpbXMuXG4gKlxuICogQHBhcmFtIGRpbXMgdGhlIGRpbXMgYXJyYXkuIE1heSBiZSBhbiBpbGxlZ2FsIGlucHV0LlxuICovXG5jb25zdCBjYWxjdWxhdGVTaXplID0gKGRpbXMpID0+IHtcbiAgICBsZXQgc2l6ZSA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRpbSA9IGRpbXNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpbSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7aX1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke2RpbX1gKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplICo9IGRpbTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59O1xuZXhwb3J0cy5jYWxjdWxhdGVTaXplID0gY2FsY3VsYXRlU2l6ZTtcbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLnJlc2hhcGUoKVxuICovXG5jb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvciwgZGltcykgPT4gbmV3IHRlbnNvcl9qc18xLlRlbnNvcih0ZW5zb3IudHlwZSwgdGVuc29yLmRhdGEsIGRpbXMpO1xuZXhwb3J0cy50ZW5zb3JSZXNoYXBlID0gdGVuc29yUmVzaGFwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci11dGlscy1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRlbnNvclJlc2hhcGUiLCJjYWxjdWxhdGVTaXplIiwidGVuc29yX2pzXzEiLCJyZXF1aXJlIiwiZGltcyIsInNpemUiLCJpIiwibGVuZ3RoIiwiZGltIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIlR5cGVFcnJvciIsIlJhbmdlRXJyb3IiLCJ0ZW5zb3IiLCJUZW5zb3IiLCJ0eXBlIiwiZGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-utils-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor.js":
/*!************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/tensor.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Tensor = void 0;\nconst tensor_impl_js_1 = __webpack_require__(/*! ./tensor-impl.js */ \"(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor-impl.js\");\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexports.Tensor = tensor_impl_js_1.Tensor; //# sourceMappingURL=tensor.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL3RlbnNvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDREQUE0RDtBQUM1RCxrQ0FBa0M7QUFDbENBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxtQkFBbUJDLG1CQUFPQSxDQUFDLHlGQUFrQjtBQUNuRCxnRUFBZ0U7QUFDaEVKLGNBQWMsR0FBR0csaUJBQWlCRCxNQUFNLEVBQ3hDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2Nqcy90ZW5zb3IuanM/ZWUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZW5zb3IgPSB2b2lkIDA7XG5jb25zdCB0ZW5zb3JfaW1wbF9qc18xID0gcmVxdWlyZShcIi4vdGVuc29yLWltcGwuanNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnRzLlRlbnNvciA9IHRlbnNvcl9pbXBsX2pzXzEuVGVuc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlRlbnNvciIsInRlbnNvcl9pbXBsX2pzXzEiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/tensor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-common/dist/cjs/version.js":
/*!*************************************************************!*\
  !*** ./node_modules/onnxruntime-common/dist/cjs/version.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.version = void 0;\n// This file is generated by /js/scripts/update-version.ts\n// Do not modify file content manually.\nexports.version = \"1.16.3\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvY2pzL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0REFBNEQ7QUFDNUQsa0NBQWtDO0FBQ2xDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsMERBQTBEO0FBQzFELHVDQUF1QztBQUN2Q0EsZUFBZSxHQUFHLFVBQ2xCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2pzLy4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2Nqcy92ZXJzaW9uLmpzP2VjMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgL2pzL3NjcmlwdHMvdXBkYXRlLXZlcnNpb24udHNcbi8vIERvIG5vdCBtb2RpZnkgZmlsZSBjb250ZW50IG1hbnVhbGx5LlxuZXhwb3J0cy52ZXJzaW9uID0gJzEuMTYuMyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-common/dist/cjs/version.js\n");

/***/ })

};
;